import {
  __publicField
} from "./chunk-7U33LM2Z.js";

// node_modules/gojs/release/go-debug.mjs
(function() {
  const root = typeof globalThis == "object" && globalThis || typeof global == "object" && global.global === global && global || typeof self == "object" && self.self === self && self || {};
  root.requestAnimationFrame === void 0 && (root.setImmediate === void 0 ? root.requestAnimationFrame = (w) => root.setTimeout(w, 0) : root.requestAnimationFrame = root.setImmediate);
  const Debug = { boundsInfoEnabled: false, drawLocationsEnabled: false, drawClipEnabled: false, drawLinkpointsEnabled: false, nodeInspector: false, handleMessages: false, drawFrames: false, defaultDiagram: null, trace: function(w) {
    root.console && root.console.log(w);
  }, drawDiagramBounds(w, t, i, e) {
    w.strokeStyle = "red", w.fillStyle = "red", w.font = "8px sans-serif", w.beginPath(), w.moveTo(-10, 0), w.lineTo(10, 0), w.moveTo(0, -10), w.lineTo(0, 10), w.stroke(), w.setTransform(1, 0, 0, 1, 0, 0), w.scale(i, i), w.transform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy), w.lineWidth = 2, w.beginPath(), w.moveTo(e.left, e.top + 20), w.lineTo(e.left, e.top), w.lineTo(e.left + 20, e.top), w.moveTo(e.right, e.bottom - 20), w.lineTo(e.right, e.bottom), w.lineTo(e.right - 20, e.bottom), w.stroke(), w.fillText("DB: " + Math.round(e.x) + ", " + Math.round(e.y) + ", " + Math.round(e.width) + ", " + Math.round(e.height), e.left, e.top - 5);
  }, attachReadonlyWarnings: function(w) {
    for (const t in w) {
      if (t === "licenseKey")
        continue;
      const i = w[t];
      if (i.prototype === void 0)
        continue;
      const e = Object.getOwnPropertyNames(i.prototype);
      for (let s = 0; s < e.length; s++) {
        const n = Object.getOwnPropertyDescriptor(i.prototype, e[s]);
        n.get !== void 0 && n.set === void 0 && Object.defineProperty(i.prototype, e[s], { set: function(o) {
          throw new Error("Property " + e[s] + " of " + t + " is read-only.");
        } });
      }
    }
  } };
  const _Util = class _Util {
    static Rk(t, i, e) {
      let s = -1;
      return function() {
        const n = this, o = arguments;
        s !== -1 && _Util.Gg(s), s = _Util.Xh(() => {
          s = -1, e || t.apply(n, o);
        }, i), e && !s && t.apply(n, o);
      };
    }
    static Xh(t, i) {
      return root.setTimeout(t, i);
    }
    static Gg(t) {
      root.clearTimeout(t);
    }
    static hn(t) {
      return root.document.createElement(t);
    }
    static n(t) {
      throw new Error(t);
    }
    static O(t, i) {
      let e = "The object is frozen, so its properties cannot be set: " + t.toString();
      i !== void 0 && (e += "  to value: " + i), _Util.n(e);
    }
    static s(t, i, e, s) {
      if (!(t instanceof i)) {
        let n = _Util.hu(e);
        s !== void 0 && (n += "." + s), _Util.Bi(t, i, n);
      }
    }
    static t(t, i, e, s) {
      if (typeof t !== i) {
        let n = _Util.hu(e);
        s !== void 0 && (n += "." + s), _Util.Bi(t, i, n);
      }
    }
    static r(t, i, e) {
      if (typeof t != "number" || !isFinite(t)) {
        let s = _Util.hu(i);
        e !== void 0 && (s += "." + e), _Util.n(s + " must be a real number type, and not NaN or Infinity: " + t);
      }
    }
    static it(t, i, e) {
      t in i || _Util.n(`${t} is not a valid value in enumeration: ${e}`);
    }
    static Bi(t, i, e, s) {
      const n = " value is not an instance of " + _Util.hu(i) + ": ";
      let o = _Util.hu(e);
      s !== void 0 && (o += "." + s), typeof t == "string" && (t = '"' + t + '"'), _Util.n(o + n + t);
    }
    static G(t, i, e, s) {
      let n = _Util.hu(e);
      s !== void 0 && (n += "." + s), _Util.n(n + " is not in the range " + i + ": " + t);
    }
    static Ke(t) {
      _Util.n("Collection was modified during iteration: " + t.toString() + `
  Perhaps you should iterate over a copy of the collection,
  or you could collect items to be removed from the collection after the iteration.`);
    }
    static gr(t, i) {
      _Util.n("No property to set for this enum value: " + i + " on " + t.toString());
    }
    static ft(t) {
      root.console && root.console.log(t);
    }
    static Mt(t) {
      return typeof t == "object" && t !== null;
    }
    static Hg(t, i, e) {
      Array.isArray(t) || _Util.Bi(t, "Array", i, e);
    }
    static au(t, i, e) {
      Array.isArray(t) ? i >= t.length ? t.push(e) : t.splice(i, 0, e) : _Util.n("Cannot insert an object into an HTMLCollection or NodeList: " + e + " at " + i);
    }
    static rf(t, i) {
      Array.isArray(t) ? i >= t.length ? t.pop() : t.splice(i, 1) : _Util.n("Cannot remove an object from an HTMLCollection or NodeList at " + i);
    }
    static ct() {
      const t = _Util.Ik.pop();
      return t === void 0 ? [] : t;
    }
    static ot(t) {
      t.length = 0, _Util.Ik.push(t);
    }
    static hu(t) {
      return t === null ? "*" : typeof t == "string" ? t : typeof t == "function" ? t.name : "";
    }
    static an(t) {
      return typeof t == "function" ? t.className ? t.className : t.name : _Util.Mt(t) && t.constructor ? _Util.an(t.constructor) : typeof t;
    }
    static Yh(t, i) {
      return i == null || i === "" ? null : _Util.Mt(t) && i in t || t[i] ? t[i] : null;
    }
    static toString(t) {
      let i = t;
      return _Util.Mt(t) && (t.text ? i = t.text : t.name ? i = t.name : t.key !== void 0 ? i = t.key : t.id !== void 0 ? i = t.id : t.constructor === Object && (t.Text ? i = t.Text : t.Name ? i = t.Name : t.Key !== void 0 ? i = t.Key : t.Id !== void 0 ? i = t.Id : t.ID !== void 0 && (i = t.ID))), i === void 0 ? "undefined" : i === null ? "null" : i.toString();
    }
    static yw(t, i) {
      if (t.hasOwnProperty(i))
        return true;
      let e = Object.getPrototypeOf(t);
      for (; e && e !== Function; ) {
        if (e.hasOwnProperty(i))
          return true;
        const s = e.iE;
        if (s && s[i])
          return true;
        e = Object.getPrototypeOf(e);
      }
      return false;
    }
    static DD(t) {
      const i = [];
      let e = 0;
      for (e = 0; e < 256; e++)
        i[e] = e;
      let s = 0, n = 0;
      for (e = 0; e < 256; e++)
        s = (s + i[e] + 119) % 256, n = i[e], i[e] = i[s], i[s] = n;
      e = 0, s = 0;
      let o = "";
      for (let r = 0; r < t.length; r++)
        e = (e + 1) % 256, s = (s + i[e]) % 256, n = i[e], i[e] = i[s], i[s] = n, o += String.fromCharCode(t.charCodeAt(r) ^ i[(i[e] + i[s]) % 256]);
      return o;
    }
    static FD(t) {
      const i = "0123456789abcdef", e = [];
      for (let r = 0; r < 256; r++)
        e[i.charAt(r >> 4) + i.charAt(r & 15)] = String.fromCharCode(r);
      t.length % 2 && (t = "0" + t);
      const s = [];
      let n = 0;
      for (let r = 0; r < t.length; r += 2)
        s[n++] = e[t.substring(r, r + 2)];
      const o = s.join("");
      return o === "" ? "0" : o;
    }
    static Os(t) {
      return _Util.DD(_Util.FD(t));
    }
  };
  __publicField(_Util, "dr", root.navigator !== void 0 && root.navigator.platform !== void 0 && root.navigator.platform.match(/(iPhone|iPod|iPad|Mac)/i) !== null);
  __publicField(_Util, "Ik", []);
  __publicField(_Util, "tE", Object.freeze([]));
  __publicField(_Util, "color1", "@COLOR1");
  __publicField(_Util, "color2", "@COLOR2");
  __publicField(_Util, "ww", "32ab5ff3b26f42dc0ed90f21402913b5");
  let Util = _Util;
  Util.vfo = "29e646fdb1";
  class StringBuilder {
    constructor() {
      __publicField(this, "Ok");
      this.Ok = [];
    }
    toString() {
      return this.Ok.join("");
    }
    add(t) {
      t !== "" && this.Ok.push(t);
    }
  }
  class PropertyCollection {
  }
  const _EmptyIterator = class _EmptyIterator {
    constructor() {
      __publicField(this, "k");
      __publicField(this, "key");
      __publicField(this, "value");
      this.k = [];
    }
    [Symbol.iterator]() {
      return this.k.values();
    }
    get iterator() {
      return this;
    }
    reset() {
    }
    next() {
      return false;
    }
    hasNext() {
      return false;
    }
    first() {
      return null;
    }
    any() {
      return false;
    }
    all() {
      return true;
    }
    each() {
      return this;
    }
    map(t) {
      return this;
    }
    filter() {
      return this;
    }
    get count() {
      return 0;
    }
    kl() {
    }
    toString() {
      return "EmptyIterator";
    }
  };
  __publicField(_EmptyIterator, "instance", new _EmptyIterator());
  let EmptyIterator = _EmptyIterator;
  class SingletonIterator {
    constructor(t) {
      __publicField(this, "key");
      __publicField(this, "value");
      this.key = -1, this.value = t;
    }
    [Symbol.iterator]() {
      return [this.value].values();
    }
    get iterator() {
      return this;
    }
    reset() {
      this.key = -1;
    }
    next() {
      return this.key === -1 ? (this.key = 0, true) : false;
    }
    hasNext() {
      return this.next();
    }
    first() {
      return this.key = 0, this.value;
    }
    any(t) {
      return this.key = -1, t(this.value);
    }
    all(t) {
      return this.key = -1, t(this.value);
    }
    each(t) {
      return this.key = -1, t(this.value), this;
    }
    map(t) {
      return new SingletonIterator(t(this.value));
    }
    filter(t) {
      return t(this.value) ? new SingletonIterator(this.value) : EmptyIterator.instance;
    }
    get count() {
      return 1;
    }
    kl() {
      this.value = null;
    }
    toString() {
      return "SingletonIterator(" + this.value + ")";
    }
  }
  class ListIterator {
    constructor(t) {
      __publicField(this, "Qt");
      __publicField(this, "Es");
      __publicField(this, "jt");
      __publicField(this, "Vt");
      __publicField(this, "key");
      __publicField(this, "value");
      this.Qt = t, this.Es = null, t.mr = null, this.jt = t.mt, this.Vt = -1;
    }
    [Symbol.iterator]() {
      return this.Es === null ? this.Qt.h.values() : this.Qt.h.filter(this.Es).values();
    }
    get iterator() {
      return this;
    }
    get predicate() {
      return this.Es;
    }
    set predicate(t) {
      this.Es = t;
    }
    reset() {
      const t = this.Qt;
      t.mr = null, this.jt = t.mt, this.Vt = -1;
    }
    next() {
      const t = this.Qt;
      if (t.mt !== this.jt) {
        if (this.key < 0)
          return false;
        Util.Ke(t);
      }
      const i = t.h, e = i.length;
      let s = ++this.Vt;
      const n = this.Es;
      if (n !== null)
        for (; s < e; ) {
          const o = i[s];
          if (n(o))
            return this.Vt = s, this.key = s, this.value = o, true;
          s++;
        }
      else {
        if (s < e)
          return this.key = s, this.value = i[s], true;
        this.kl();
      }
      return false;
    }
    hasNext() {
      return this.next();
    }
    first() {
      const t = this.Qt;
      this.jt = t.mt, this.Vt = 0;
      const i = t.h, e = i.length, s = this.Es;
      if (s !== null) {
        let n = 0;
        for (; n < e; ) {
          const o = i[n];
          if (s(o))
            return this.Vt = n, this.key = n, this.value = o, o;
          n++;
        }
        return null;
      } else if (e > 0) {
        const n = i[0];
        return this.key = 0, this.value = n, n;
      } else
        return null;
    }
    any(t) {
      const i = this.Qt;
      i.mr = null;
      const e = i.mt;
      this.Vt = -1;
      const s = i.h, n = s.length, o = this.Es;
      for (let r = 0; r < n; r++) {
        const l = s[r];
        if (!(o !== null && !o(l))) {
          if (t(l))
            return true;
          i.mt !== e && Util.Ke(i);
        }
      }
      return false;
    }
    all(t) {
      const i = this.Qt;
      i.mr = null;
      const e = i.mt;
      this.Vt = -1;
      const s = i.h, n = s.length, o = this.Es;
      for (let r = 0; r < n; r++) {
        const l = s[r];
        if (!(o !== null && !o(l))) {
          if (!t(l))
            return false;
          i.mt !== e && Util.Ke(i);
        }
      }
      return true;
    }
    each(t) {
      const i = this.Qt;
      i.mr = null;
      const e = i.mt;
      this.Vt = -1;
      const s = i.h, n = s.length, o = this.Es;
      for (let r = 0; r < n; r++) {
        const l = s[r];
        o !== null && !o(l) || (t(l), i.mt !== e && Util.Ke(i));
      }
      return this;
    }
    map(t) {
      const i = this.Qt;
      i.mr = null;
      const e = i.mt;
      this.Vt = -1;
      const s = [], n = i.h, o = n.length, r = this.Es;
      for (let h = 0; h < o; h++) {
        const a = n[h];
        r !== null && !r(a) || (s.push(t(a)), i.mt !== e && Util.Ke(i));
      }
      const l = new List2();
      return l.h = s, l.Ue(), l.iterator;
    }
    filter(t) {
      const i = this.Qt;
      i.mr = null;
      const e = i.mt;
      this.Vt = -1;
      const s = [], n = i.h, o = n.length, r = this.Es;
      for (let h = 0; h < o; h++) {
        const a = n[h];
        r !== null && !r(a) || (t(a) && s.push(a), i.mt !== e && Util.Ke(i));
      }
      const l = new List2();
      return l.h = s, l.Ue(), l.iterator;
    }
    get count() {
      const t = this.Es;
      if (t !== null) {
        let i = 0;
        const e = this.Qt.h, s = e.length;
        for (let n = 0; n < s; n++)
          t(e[n]) && i++;
        return i;
      } else
        return this.Qt.h.length;
    }
    kl() {
      this.key = -1, this.value = null, this.jt = -1, this.Es = null, this.Qt.mr = this;
    }
    toString() {
      return "ListIterator@" + this.Vt + "/" + this.Qt.count;
    }
  }
  class ListIteratorBackwards {
    constructor(t) {
      __publicField(this, "Qt");
      __publicField(this, "jt");
      __publicField(this, "Vt");
      __publicField(this, "key");
      __publicField(this, "value");
      this.Qt = t, t.pr = null, this.jt = t.mt, this.Vt = t.h.length;
    }
    [Symbol.iterator]() {
      return this.Qt.h.reverse().values();
    }
    get iterator() {
      return this;
    }
    reset() {
      const t = this.Qt;
      t.pr = null, this.jt = t.mt, this.Vt = t.h.length;
    }
    next() {
      const t = this.Qt;
      if (t.mt !== this.jt) {
        if (this.key < 0)
          return false;
        Util.Ke(t);
      }
      const i = --this.Vt;
      return i >= 0 ? (this.key = i, this.value = t.h[i], true) : (this.kl(), false);
    }
    hasNext() {
      return this.next();
    }
    first() {
      const t = this.Qt;
      this.jt = t.mt;
      const i = t.h, e = i.length - 1;
      if (this.Vt = e, e >= 0) {
        const s = i[e];
        return this.key = e, this.value = s, s;
      } else
        return null;
    }
    any(t) {
      const i = this.Qt;
      i.pr = null;
      const e = i.mt, s = i.h, n = s.length;
      this.Vt = n;
      for (let o = n - 1; o >= 0; o--) {
        const r = s[o];
        if (t(r))
          return true;
        i.mt !== e && Util.Ke(i);
      }
      return false;
    }
    all(t) {
      const i = this.Qt;
      i.pr = null;
      const e = i.mt, s = i.h, n = s.length;
      this.Vt = n;
      for (let o = n - 1; o >= 0; o--) {
        const r = s[o];
        if (!t(r))
          return false;
        i.mt !== e && Util.Ke(i);
      }
      return true;
    }
    each(t) {
      const i = this.Qt;
      i.pr = null;
      const e = i.mt, s = i.h, n = s.length;
      this.Vt = n;
      for (let o = n - 1; o >= 0; o--) {
        const r = s[o];
        t(r), i.mt !== e && Util.Ke(i);
      }
      return this;
    }
    map(t) {
      const i = this.Qt;
      i.pr = null;
      const e = i.mt, s = [], n = i.h, o = n.length;
      this.Vt = o;
      for (let l = o - 1; l >= 0; l--) {
        const h = n[l];
        s.push(t(h)), i.mt !== e && Util.Ke(i);
      }
      const r = new List2();
      return r.h = s, r.Ue(), r.iterator;
    }
    filter(t) {
      const i = this.Qt;
      i.pr = null;
      const e = i.mt, s = [], n = i.h, o = n.length;
      this.Vt = o;
      for (let l = o - 1; l >= 0; l--) {
        const h = n[l];
        t(h) && s.push(h), i.mt !== e && Util.Ke(i);
      }
      const r = new List2();
      return r.h = s, r.Ue(), r.iterator;
    }
    get count() {
      return this.Qt.h.length;
    }
    kl() {
      this.key = -1, this.value = null, this.jt = -1, this.Qt.pr = this;
    }
    toString() {
      return "ListIteratorBackwards(" + this.Vt + "/" + this.Qt.count + ")";
    }
  }
  class List2 {
    constructor(t) {
      __publicField(this, "f");
      __publicField(this, "h");
      __publicField(this, "mt");
      __publicField(this, "mr");
      __publicField(this, "pr");
      GSet2.ji(this), this.f = false, this.h = [], this.mt = 0, this.mr = null, this.pr = null, t !== void 0 && this.addAll(t);
    }
    [Symbol.iterator]() {
      return this.h.values();
    }
    Ue() {
      let t = this.mt;
      t++, t > 999999999 && (t = 0), this.mt = t;
    }
    w() {
      return this.f = true, this;
    }
    ut() {
      return this.f = false, this;
    }
    toString() {
      return "List()#" + GSet2.ps(this);
    }
    add(t) {
      return this.f && Util.O(this, t), this.h.push(t), this.Ue(), this;
    }
    push(t) {
      this.add(t);
    }
    addAll(t) {
      if (t === null)
        return this;
      this.f && Util.O(this);
      const i = this.h;
      if (Array.isArray(t)) {
        const e = t.length;
        for (let s = 0; s < e; s++) {
          const n = t[s];
          i.push(n);
        }
      } else {
        const e = t.iterator;
        for (; e.next(); ) {
          const s = e.value;
          i.push(s);
        }
      }
      return this.Ue(), this;
    }
    clear() {
      this.f && Util.O(this), this.h.length = 0, this.Ue();
    }
    contains(t) {
      return t === null ? false : this.h.indexOf(t) !== -1;
    }
    has(t) {
      return this.contains(t);
    }
    indexOf(t) {
      return t === null ? -1 : this.h.indexOf(t);
    }
    elt(t) {
      Debug && Util.r(t, List2, "elt:i");
      const i = this.h;
      return (t < 0 || t >= i.length) && Util.G(t, "0 <= i < length", List2, "elt:i"), i[t];
    }
    get(t) {
      return this.elt(t);
    }
    setElt(t, i) {
      Debug && Util.r(t, List2, "setElt:i");
      const e = this.h;
      (t < 0 || t >= e.length) && Util.G(t, "0 <= i < length", List2, "setElt:i"), this.f && Util.O(this, t), e[t] = i;
    }
    set(t, i) {
      this.setElt(t, i);
    }
    first() {
      const t = this.h;
      return t.length === 0 ? null : t[0];
    }
    last() {
      const t = this.h, i = t.length;
      return i > 0 ? t[i - 1] : null;
    }
    pop() {
      this.f && Util.O(this);
      const t = this.h;
      return t.length > 0 ? t.pop() : null;
    }
    any(t) {
      const i = this.h, e = this.mt, s = i.length;
      for (let n = 0; n < s; n++) {
        if (t(i[n]))
          return true;
        this.mt !== e && Util.Ke(this);
      }
      return false;
    }
    all(t) {
      const i = this.h, e = this.mt, s = i.length;
      for (let n = 0; n < s; n++) {
        if (!t(i[n]))
          return false;
        this.mt !== e && Util.Ke(this);
      }
      return true;
    }
    each(t) {
      const i = this.h, e = this.mt, s = i.length;
      for (let n = 0; n < s; n++)
        t(i[n]), this.mt !== e && Util.Ke(this);
      return this;
    }
    map(t) {
      const i = new List2(), e = [], s = this.h, n = this.mt, o = s.length;
      for (let r = 0; r < o; r++)
        e.push(t(s[r])), this.mt !== n && Util.Ke(this);
      return i.h = e, i.Ue(), i;
    }
    filter(t) {
      const i = new List2(), e = [], s = this.h, n = this.mt, o = s.length;
      for (let r = 0; r < o; r++) {
        const l = s[r];
        t(l) && e.push(l), this.mt !== n && Util.Ke(this);
      }
      return i.h = e, i.Ue(), i;
    }
    insertAt(t, i) {
      Debug && Util.r(t, List2, "insertAt:i"), t < 0 && Util.G(t, ">= 0", List2, "insertAt:i"), this.f && Util.O(this, t);
      const e = this.h;
      t >= e.length ? e.push(i) : e.splice(t, 0, i), this.Ue();
    }
    remove(t) {
      if (t === null)
        return false;
      this.f && Util.O(this, t);
      const i = this.h, e = i.indexOf(t);
      return e === -1 ? false : (e === i.length - 1 ? i.pop() : i.splice(e, 1), this.Ue(), true);
    }
    delete(t) {
      return this.remove(t);
    }
    removeAt(t) {
      Debug && Util.r(t, List2, "removeAt:i");
      const i = this.h;
      (t < 0 || t >= i.length) && Util.G(t, "0 <= i < length", List2, "removeAt:i"), this.f && Util.O(this, t), t === i.length - 1 ? i.pop() : i.splice(t, 1), this.Ue();
    }
    removeRange(t, i) {
      Debug && (Util.r(t, List2, "removeRange:from"), Util.r(i, List2, "removeRange:to"));
      const e = this.h, s = e.length;
      if (t < 0)
        t = 0;
      else if (t >= s)
        return this;
      if (i < 0)
        return this;
      if (i >= s && (i = s - 1), t > i)
        return this;
      this.f && Util.O(this);
      let n = t, o = i + 1;
      for (; o < s; )
        e[n++] = e[o++];
      return e.length = s - (i - t + 1), this.Ue(), this;
    }
    copy() {
      const t = new List2(), i = this.h;
      return i.length > 0 && (t.h = Array.prototype.slice.call(i)), t;
    }
    toArray() {
      const t = this.h, i = this.count, e = new Array(i);
      for (let s = 0; s < i; s++)
        e[s] = t[s];
      return e;
    }
    get _N() {
      return this.h;
    }
    toSet() {
      const t = new GSet2(), i = this.h, e = this.count;
      for (let s = 0; s < e; s++)
        t.add(i[s]);
      return t;
    }
    sort(t) {
      return Debug && Util.t(t, "function", List2, "sort:sortfunc"), this.f && Util.O(this), this.h.sort(t), this.Ue(), this;
    }
    sortRange(t, i, e) {
      const s = this.h, n = s.length;
      i === void 0 && (i = 0), e === void 0 && (e = n), Debug && (Util.t(t, "function", List2, "sortRange:sortfunc"), Util.r(i, List2, "sortRange:from"), Util.r(e, List2, "sortRange:to")), this.f && Util.O(this);
      const o = e - i;
      if (o <= 1)
        return this;
      if ((i < 0 || i >= n - 1) && Util.G(i, "0 <= from < length", List2, "sortRange:from"), o === 2) {
        const r = s[i], l = s[i + 1];
        return t(r, l) > 0 && (s[i] = l, s[i + 1] = r, this.Ue()), this;
      }
      if (i === 0)
        if (e >= n)
          s.sort(t);
        else {
          const r = s.slice(0, e);
          r.sort(t);
          for (let l = 0; l < e; l++)
            s[l] = r[l];
        }
      else if (e >= n) {
        const r = s.slice(i);
        r.sort(t);
        for (let l = i; l < n; l++)
          s[l] = r[l - i];
      } else {
        const r = s.slice(i, e);
        r.sort(t);
        for (let l = i; l < e; l++)
          s[l] = r[l - i];
      }
      return this.Ue(), this;
    }
    reverse() {
      return this.f && Util.O(this), this.h.reverse(), this.Ue(), this;
    }
    get count() {
      return this.h.length;
    }
    get size() {
      return this.h.length;
    }
    get length() {
      return this.h.length;
    }
    get iterator() {
      if (this.h.length <= 0)
        return EmptyIterator.instance;
      const t = this.mr;
      return t !== null ? (t.reset(), t) : new ListIterator(this);
    }
    get iteratorBackwards() {
      if (this.h.length <= 0)
        return EmptyIterator.instance;
      const t = this.pr;
      return t !== null ? (t.reset(), t) : new ListIteratorBackwards(this);
    }
  }
  class SetIterator {
    constructor(t) {
      __publicField(this, "Lo");
      __publicField(this, "ri");
      __publicField(this, "key");
      __publicField(this, "value");
      this.Lo = t, this.ri = t.k.values();
    }
    [Symbol.iterator]() {
      return this.Lo.k.values();
    }
    get iterator() {
      return this;
    }
    reset() {
      const t = this.Lo;
      this.ri = t.k.values();
    }
    next() {
      const t = this.ri.next();
      return this.value = t.value, this.key = t.value, !t.done;
    }
    hasNext() {
      return this.next();
    }
    first() {
      return this.Lo.k.size === 0 ? null : (this.ri = this.Lo.k.values(), this.ri.next().value);
    }
    any(t) {
      return this.Lo.any(t);
    }
    all(t) {
      return this.Lo.all(t);
    }
    each(t) {
      return this.Lo.each(t), this;
    }
    map(t) {
      const i = new List2();
      return this.Lo.k.forEach((e) => i.add(t(e))), i.iterator;
    }
    filter(t) {
      const i = new List2();
      return this.Lo.k.forEach((e) => {
        t(e) && i.add(e);
      }), i.iterator;
    }
    get count() {
      return this.Lo.count;
    }
    kl() {
      this.key = null, this.value = null, this.ri = null;
    }
    toString() {
      return "SetIterator";
    }
  }
  const _GSet = class _GSet {
    constructor(t) {
      __publicField(this, "f");
      __publicField(this, "k");
      this.f = false, this.k = /* @__PURE__ */ new Set(), t !== void 0 && this.addAll(t);
    }
    [Symbol.iterator]() {
      return this.k.values();
    }
    values() {
      return this.k.values();
    }
    w() {
      return this.f = true, this;
    }
    ut() {
      return this.f = false, this;
    }
    toString() {
      return "Set()#" + _GSet.ps(this);
    }
    add(t) {
      return t === null ? this : (this.k.add(t), this);
    }
    addAll(t) {
      if (t === null)
        return this;
      if (Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++) {
          const s = t[e];
          s !== null && this.k.add(s);
        }
      } else {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          e !== null && this.k.add(e);
        }
      }
      return this;
    }
    has(t) {
      return this.k.has(t);
    }
    contains(t) {
      return this.has(t);
    }
    containsAll(t) {
      if (t === null)
        return true;
      const i = t.iterator;
      for (; i.next(); )
        if (!this.has(i.value))
          return false;
      return true;
    }
    containsAny(t) {
      if (t === null)
        return true;
      const i = t.iterator;
      for (; i.next(); )
        if (this.has(i.value))
          return true;
      return false;
    }
    first() {
      return this.k.size === 0 ? null : this.k.values().next().value;
    }
    any(t) {
      for (const i of this.k)
        if (t(i))
          return true;
      return false;
    }
    all(t) {
      for (const i of this.k)
        if (!t(i))
          return false;
      return true;
    }
    each(t) {
      for (const i of this.k)
        t(i);
      return this;
    }
    map(t) {
      const i = new _GSet();
      for (const e of this.k)
        i.add(t(e));
      return i;
    }
    filter(t) {
      const i = new _GSet();
      for (const e of this.k)
        t(e) && i.add(e);
      return i;
    }
    delete(t) {
      return this.f && Util.O(this), this.k.delete(t);
    }
    remove(t) {
      return this.delete(t);
    }
    removeAll(t) {
      if (t === null)
        return this;
      if (this.f && Util.O(this), Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++)
          this.delete(t[e]);
      } else {
        const i = t.iterator;
        for (; i.next(); )
          this.delete(i.value);
      }
      return this;
    }
    retainAll(t) {
      if (t === null)
        return this;
      if (this.count === 0)
        return this;
      this.f && Util.O(this);
      const i = new _GSet();
      i.addAll(t);
      const e = [], s = this.iterator;
      for (; s.next(); ) {
        const n = s.value;
        i.contains(n) || e.push(n);
      }
      return this.removeAll(e), this;
    }
    clear() {
      this.f && Util.O(this), this.k.clear();
    }
    copy() {
      const t = new _GSet();
      return this.k.forEach((i) => t.add(i)), t;
    }
    toArray() {
      return Array.from(this.k);
    }
    toList() {
      const t = new List2();
      return this.k.forEach((i) => t.add(i)), t;
    }
    get count() {
      return this.k.size;
    }
    get size() {
      return this.k.size;
    }
    get iterator() {
      return this.k.size <= 0 ? EmptyIterator.instance : new SetIterator(this);
    }
    entries() {
      return this.k.entries();
    }
    keys() {
      return this.k.keys();
    }
    forEach(t, i) {
      return this.k.forEach(t, i);
    }
    static ji(t) {
      t.__gohashid = _GSet.fu++;
    }
    static ps(t) {
      return t.__gohashid;
    }
  };
  __publicField(_GSet, "fu", 1);
  let GSet2 = _GSet;
  class MapKeySetIterator {
    constructor(t) {
      __publicField(this, "et");
      __publicField(this, "ri");
      __publicField(this, "key");
      __publicField(this, "value");
      this.et = t, this.ri = t.k.keys();
    }
    [Symbol.iterator]() {
      return this.et.k.keys();
    }
    get iterator() {
      return this;
    }
    reset() {
      const t = this.et;
      this.ri = t.k.keys();
    }
    next() {
      const t = this.ri.next();
      return this.value = t.value, this.key = t.value, !t.done;
    }
    hasNext() {
      return this.next();
    }
    first() {
      return this.et.k.size === 0 ? null : (this.ri = this.et.k.keys(), this.ri.next().value);
    }
    any(t) {
      for (const i of this.et.k)
        if (t(i[0]))
          return true;
      return false;
    }
    all(t) {
      for (const i of this.et.k)
        if (!t(i[0]))
          return false;
      return true;
    }
    each(t) {
      for (const i of this.et.k)
        t(i[0]);
      return this;
    }
    map(t) {
      const i = this.et, e = new List2();
      for (const s of i.k)
        e.add(t(s[0]));
      return e.iterator;
    }
    filter(t) {
      const i = this.et, e = new List2();
      for (const s of i.k) {
        const n = s[0];
        t(n) && e.add(n);
      }
      return e.iterator;
    }
    get count() {
      return this.et.size;
    }
    kl() {
      this.key = null, this.value = null, this.ri = null;
    }
    toString() {
      return "MapKeySetIterator";
    }
  }
  class MapKeySet extends GSet2 {
    constructor(t) {
      super();
      __publicField(this, "et");
      GSet2.ji(this), this.f = true, this.et = t;
    }
    [Symbol.iterator]() {
      return this.k.keys();
    }
    values() {
      return this.k.keys();
    }
    w() {
      return this;
    }
    ut() {
      return this;
    }
    toString() {
      return "MapKeySet(" + this.et.toString() + ")";
    }
    add(t) {
      Util.n("This Set is read-only: " + this.toString());
    }
    has(t) {
      return this.et.contains(t);
    }
    contains(t) {
      return this.has(t);
    }
    delete(t) {
      Util.n("This Set is read-only: " + this.toString());
    }
    remove(t) {
      return this.delete(t);
    }
    clear() {
      Util.n("This Set is read-only: " + this.toString());
    }
    first() {
      return this.et.k.size === 0 ? null : this.et.k.keys().next().value;
    }
    any(t) {
      for (const i of this.et.k)
        if (t(i[0]))
          return true;
      return false;
    }
    all(t) {
      for (const i of this.et.k)
        if (!t(i[0]))
          return false;
      return true;
    }
    each(t) {
      for (const i of this.et.k)
        t(i[0]);
      return this;
    }
    map(t) {
      const i = new GSet2();
      for (const e of this.et.k)
        i.add(t(e[0]));
      return i;
    }
    filter(t) {
      const i = new GSet2();
      for (const e of this.et.k) {
        const s = e[0];
        t(s) && i.add(s);
      }
      return i;
    }
    copy() {
      return new MapKeySet(this.et);
    }
    toSet() {
      const t = new GSet2(), i = this.et.k;
      for (const e of i)
        t.add(e[0]);
      return t;
    }
    toArray() {
      const t = this.et.k, i = new Array(t.size);
      let e = 0;
      for (const s of t)
        i[e] = s[0], e++;
      return i;
    }
    toList() {
      const t = new List2(), i = this.et.k;
      for (const e of i)
        t.add(e[0]);
      return t;
    }
    get count() {
      return this.et.size;
    }
    get size() {
      return this.et.size;
    }
    get iterator() {
      return this.et.size <= 0 ? EmptyIterator.instance : new MapKeySetIterator(this.et);
    }
  }
  class MapValueSetIterator {
    constructor(t) {
      __publicField(this, "et");
      __publicField(this, "ri");
      __publicField(this, "key");
      __publicField(this, "value");
      this.et = t, this.ri = t.k.values();
    }
    [Symbol.iterator]() {
      return this.et.k.values();
    }
    get iterator() {
      return this;
    }
    reset() {
      const t = this.et;
      this.ri = t.k.values();
    }
    next() {
      const t = this.ri.next();
      return this.value = t.value, this.key = t.value, !t.done;
    }
    hasNext() {
      return this.next();
    }
    first() {
      return this.et.k.size === 0 ? null : (this.ri = this.et.k.values(), this.ri.next().value);
    }
    any(t) {
      for (const i of this.et.k)
        if (t(i[1]))
          return true;
      return false;
    }
    all(t) {
      for (const i of this.et.k)
        if (!t(i[1]))
          return false;
      return true;
    }
    each(t) {
      for (const i of this.et.k)
        t(i[1]);
      return this;
    }
    map(t) {
      const i = this.et, e = new List2();
      for (const s of i.k)
        e.add(t(s[1]));
      return e.iterator;
    }
    filter(t) {
      const i = this.et, e = new List2();
      for (const s of i.k) {
        const n = s[1];
        t(n) && e.add(n);
      }
      return e.iterator;
    }
    get count() {
      return this.et.size;
    }
    kl() {
      this.key = null, this.value = null, this.ri = null;
    }
    toString() {
      return "MapValueSetIterator";
    }
  }
  class KeyValuePair {
    constructor(t, i) {
      __publicField(this, "key");
      __publicField(this, "value");
      this.key = t, this.value = i;
    }
    toString() {
      return "{" + this.key + ":" + this.value + "}";
    }
  }
  class MapIterator {
    constructor(t) {
      __publicField(this, "et");
      __publicField(this, "ri");
      __publicField(this, "key");
      __publicField(this, "value");
      this.et = t, this.ri = t.k.entries();
    }
    [Symbol.iterator]() {
      return this.et.k.entries();
    }
    get iterator() {
      return this;
    }
    reset() {
      const t = this.et;
      this.ri = t.k.entries();
    }
    next() {
      const t = this.ri.next();
      return t.done ? (this.key = null, this.value = null, false) : (this.key = t.value[0], this.value = t.value[1], true);
    }
    hasNext() {
      return this.next();
    }
    first() {
      if (this.et.k.size === 0)
        return null;
      this.ri = this.et.k.entries();
      const t = this.ri.next().value;
      return this.key = t[0], this.value = t[1], new KeyValuePair(t[0], t[1]);
    }
    any(t) {
      return this.et.any(t);
    }
    all(t) {
      return this.et.all(t);
    }
    each(t) {
      return this.et.each(t), this;
    }
    map(t) {
      const i = new List2();
      let e = null;
      return this.et.k.forEach((s, n) => {
        e === null ? e = new KeyValuePair(n, s) : (e.key = n, e.value = s), i.add(t(e));
      }), i.iterator;
    }
    filter(t) {
      const i = new List2();
      let e = null;
      return this.et.k.forEach((s, n) => {
        e === null ? e = new KeyValuePair(n, s) : (e.key = n, e.value = s), t(e) && (i.add(e), e = null);
      }), i.iterator;
    }
    get count() {
      return this.et.size;
    }
    kl() {
      this.key = null, this.value = null, this.ri = null;
    }
    toString() {
      return "MapIterator";
    }
  }
  class GMap2 {
    constructor(t) {
      __publicField(this, "f");
      __publicField(this, "k");
      GSet2.ji(this), this.f = false, this.k = /* @__PURE__ */ new Map(), t !== void 0 && this.addAll(t);
    }
    [Symbol.iterator]() {
      return this.k.entries();
    }
    entries() {
      return this.k.entries();
    }
    w() {
      return this.f = true, this;
    }
    ut() {
      return this.f = false, this;
    }
    toString() {
      return "Map()#" + GSet2.ps(this);
    }
    set(t, i) {
      return this.f && Util.O(this, t), this.k.set(t, i), this;
    }
    add(t, i) {
      return this.set(t, i);
    }
    addAll(t) {
      if (t === null)
        return this;
      if (this.f && Util.O(this), Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++) {
          const s = t[e];
          this.set(s.key, s.value);
        }
      } else if (t instanceof GMap2) {
        const i = t.iterator;
        for (; i.next(); )
          this.set(i.key, i.value);
      } else {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          this.set(e.key, e.value);
        }
      }
      return this;
    }
    first() {
      if (this.k.size === 0)
        return null;
      const t = this.k.entries().next().value;
      return new KeyValuePair(t[0], t[1]);
    }
    any(t) {
      let i = null;
      for (const [e, s] of this.k)
        if (i === null ? i = new KeyValuePair(e, s) : (i.key = e, i.value = s), t(i))
          return true;
      return false;
    }
    all(t) {
      let i = null;
      for (const [e, s] of this.k)
        if (i === null ? i = new KeyValuePair(e, s) : (i.key = e, i.value = s), !t(i))
          return false;
      return true;
    }
    each(t) {
      let i = null;
      for (const [e, s] of this.k)
        i === null ? i = new KeyValuePair(e, s) : (i.key = e, i.value = s), t(i);
      return this;
    }
    map(t) {
      const i = new GMap2();
      let e = null;
      for (const [s, n] of this.k)
        e === null ? e = new KeyValuePair(s, n) : (e.key = s, e.value = n), i.set(s, t(e));
      return i;
    }
    filter(t) {
      const i = new GMap2();
      let e = null;
      for (const [s, n] of this.k)
        e === null ? e = new KeyValuePair(s, n) : (e.key = s, e.value = n), t(e) && i.set(s, n);
      return i;
    }
    has(t) {
      return this.k.has(t);
    }
    contains(t) {
      return this.has(t);
    }
    get(t) {
      const i = this.k.get(t);
      return i === void 0 ? null : i;
    }
    getValue(t) {
      return this.get(t);
    }
    delete(t) {
      return t === null ? false : (this.f && Util.O(this, t), this.k.delete(t));
    }
    remove(t) {
      return this.delete(t);
    }
    clear() {
      this.f && Util.O(this), this.k.clear();
    }
    copy() {
      const t = new GMap2();
      return t.k = new Map(this.k), t;
    }
    toArray() {
      const t = this.k, i = new Array(t.size);
      let e = 0;
      for (const s of t)
        i[e] = new KeyValuePair(s[0], s[1]), e++;
      return i;
    }
    toKeySet() {
      return new MapKeySet(this);
    }
    get count() {
      return this.k.size;
    }
    get size() {
      return this.k.size;
    }
    get iterator() {
      return this.k.size <= 0 ? EmptyIterator.instance : new MapIterator(this);
    }
    get iteratorKeys() {
      return this.count <= 0 ? EmptyIterator.instance : new MapKeySetIterator(this);
    }
    keys() {
      return this.k.keys();
    }
    get iteratorValues() {
      return this.count <= 0 ? EmptyIterator.instance : new MapValueSetIterator(this);
    }
    values() {
      return this.k.values();
    }
    forEach(t, i) {
      return this.k.forEach(t, i);
    }
  }
  const _Point = class _Point {
    constructor(t, i) {
      __publicField(this, "S");
      __publicField(this, "P");
      __publicField(this, "f");
      t === void 0 ? (this.S = 0, this.P = 0) : typeof t == "number" && typeof i == "number" ? (this.S = t, this.P = i) : Util.n("Invalid arguments to Point constructor: " + t + ", " + i), this.f = false;
    }
    c(t) {
      return this.S = t.S, this.P = t.P, this;
    }
    e(t, i) {
      return this.S = t, this.P = i, this;
    }
    setTo(t, i) {
      return Debug && (Util.t(t, "number", _Point, "setTo:x"), Util.t(i, "number", _Point, "setTo:y"), this.st()), this.S = t, this.P = i, this;
    }
    set(t) {
      return Debug && (Util.s(t, _Point, _Point, "set:p"), this.st()), this.S = t.S, this.P = t.P, this;
    }
    copy() {
      const t = new _Point();
      return t.S = this.S, t.P = this.P, t;
    }
    rt() {
      return this.f = true, Object.freeze(this), this;
    }
    L() {
      return this.f || Object.isFrozen(this) ? this : this.copy().w();
    }
    w() {
      return this.f = true, this;
    }
    ut() {
      return Object.isFrozen(this) && Util.n("cannot thaw constant: " + this), this.f = false, this;
    }
    st(t) {
      if (Debug && this.f) {
        let i = "The Point is frozen, so its properties cannot be set: " + this.toString();
        t !== void 0 && (i += "  to value: " + t), Util.n(i);
      }
    }
    static parse(t) {
      if (typeof t == "string") {
        const i = t.split(" ");
        let e = 0, s = 0;
        for (; i[e] === ""; )
          e++;
        let n = i[e++];
        n && (s = parseFloat(n));
        let o = 0;
        for (; i[e] === ""; )
          e++;
        return n = i[e++], n && (o = parseFloat(n)), new _Point(s, o);
      } else
        return new _Point();
    }
    static stringify(t) {
      return Debug && Util.s(t, _Point), t.x.toString() + " " + t.y.toString();
    }
    static stringifyFixed(t) {
      return Util.t(t, "number", _Point, "stringifyFixed:digits"), (i) => i.x.toFixed(t) + " " + i.y.toFixed(t);
    }
    toString() {
      return "Point(" + this.x + "," + this.y + ")";
    }
    equals(t) {
      return t instanceof _Point ? this.S === t.x && this.P === t.y : false;
    }
    equalTo(t, i) {
      return this.S === t && this.P === i;
    }
    equalsApprox(t) {
      return Geo.p(this.S, t.x) && Geo.p(this.P, t.y);
    }
    add(t) {
      return Debug && (Util.s(t, _Point, _Point, "add:p"), this.st()), this.S += t.x, this.P += t.y, this;
    }
    subtract(t) {
      return Debug && (Util.s(t, _Point, _Point, "subtract:p"), this.st()), this.S -= t.x, this.P -= t.y, this;
    }
    offset(t, i) {
      return Debug && (Util.r(t, _Point, "offset:dx"), Util.r(i, _Point, "offset:dy"), this.st()), this.S += t, this.P += i, this;
    }
    rotate(t) {
      if (Debug && (Util.r(t, _Point, "rotate:angle"), this.st()), t === 0)
        return this;
      const i = this.S, e = this.P;
      if (i === 0 && e === 0)
        return this;
      let s = 0, n = 0;
      if (t >= 360 ? t -= 360 : t < 0 && (t += 360), t === 90)
        s = 0, n = 1;
      else if (t === 180)
        s = -1, n = 0;
      else if (t === 270)
        s = 0, n = -1;
      else {
        const o = t * Math.PI / 180;
        s = Math.cos(o), n = Math.sin(o);
      }
      return this.S = s * i - n * e, this.P = n * i + s * e, this;
    }
    scale(t, i) {
      return Debug && (Util.r(t, _Point, "scale:sx"), Util.r(i, _Point, "scale:sy"), this.st()), this.S *= t, this.P *= i, this;
    }
    distanceSquaredPoint(t) {
      Debug && Util.s(t, _Point, _Point, "distanceSquaredPoint:p");
      const i = t.x - this.S, e = t.y - this.P;
      return i * i + e * e;
    }
    distanceSquared(t, i) {
      Debug && (Util.r(t, _Point, "distanceSquared:px"), Util.r(i, _Point, "distanceSquared:py"));
      const e = t - this.S, s = i - this.P;
      return e * e + s * s;
    }
    normalize() {
      Debug && this.st();
      const t = this.S, i = this.P, e = Math.sqrt(t * t + i * i);
      return e > 0 && (this.S = t / e, this.P = i / e), this;
    }
    directionPoint(t) {
      return Debug && Util.s(t, _Point, _Point, "directionPoint:p"), this.tC(t.x - this.S, t.y - this.P);
    }
    direction(t, i) {
      return Debug && (Util.r(t, _Point, "direction:px"), Util.r(i, _Point, "direction:py")), this.tC(t - this.S, i - this.P);
    }
    tC(t, i) {
      if (t === 0)
        return i > 0 ? 90 : i < 0 ? 270 : 0;
      if (i === 0)
        return t > 0 ? 0 : 180;
      {
        if (isNaN(t) || isNaN(i))
          return 0;
        let e = Math.atan(Math.abs(i / t)) * 180 / Math.PI;
        return t < 0 ? i < 0 ? e += 180 : e = 180 - e : i < 0 && (e = 360 - e), e;
      }
    }
    static compareWithLineSegment(t, i, e, s, n, o) {
      return Debug && (Util.r(t, _Point, "compareWithLineSegment:a1x"), Util.r(i, _Point, "compareWithLineSegment:a1y"), Util.r(e, _Point, "compareWithLineSegment:a2x"), Util.r(s, _Point, "compareWithLineSegment:a2y"), Util.r(n, _Point, "compareWithLineSegment:b1x"), Util.r(o, _Point, "compareWithLineSegment:b1y")), Geo.cu(t, i, e, s, n, o);
    }
    compareWithLineSegmentPoint(t, i) {
      return Debug && (Util.s(t, _Point, _Point, "compareWithLineSegmentPoint:p"), Util.s(i, _Point, _Point, "compareWithLineSegmentPoint:q")), Geo.cu(t.x, t.y, i.x, i.y, this.x, this.y);
    }
    static intersectingLineSegments(t, i, e, s, n, o, r, l) {
      return Debug && (Util.r(t, _Point, "intersectingLineSegments:a1x"), Util.r(i, _Point, "intersectingLineSegments:a1y"), Util.r(e, _Point, "intersectingLineSegments:a2x"), Util.r(s, _Point, "intersectingLineSegments:a2y"), Util.r(n, _Point, "intersectingLineSegments:b1x"), Util.r(o, _Point, "intersectingLineSegments:b1y"), Util.r(r, _Point, "intersectingLineSegments:b2x"), Util.r(l, _Point, "intersectingLineSegments:b2y")), Geo.uu(t, i, e, s, n, o, r, l);
    }
    projectOntoLineSegment(t, i, e, s) {
      return Debug && (Util.r(t, _Point, "projectOntoLineSegment:px"), Util.r(i, _Point, "projectOntoLineSegment:py"), Util.r(e, _Point, "projectOntoLineSegment:qx"), Util.r(s, _Point, "projectOntoLineSegment:qy")), Geo.Sl(t, i, e, s, this.S, this.P, this), this;
    }
    projectOntoLineSegmentPoint(t, i) {
      return Debug && (Util.s(t, _Point, _Point, "projectOntoLineSegmentPoint:p"), Util.s(i, _Point, _Point, "projectOntoLineSegmentPoint:q")), Geo.Sl(t.x, t.y, i.x, i.y, this.S, this.P, this), this;
    }
    snapToGrid(t, i, e, s) {
      return Debug && (Util.r(t, _Point, "snapToGrid:originx"), Util.r(i, _Point, "snapToGrid:originy"), Util.r(e, _Point, "snapToGrid:cellwidth"), Util.r(s, _Point, "snapToGrid:cellheight")), Geo.vg(this.S, this.P, t, i, e, s, this), this;
    }
    snapToGridPoint(t, i) {
      return Debug && (Util.s(t, _Point, _Point, "snapToGridPoint:p"), Util.s(i, Size2, _Point, "snapToGridPoint:q")), Geo.vg(this.S, this.P, t.x, t.y, i.width, i.height, this), this;
    }
    setRectSpot(t, i) {
      return Debug && (Util.s(t, Rect2, _Point, "setRectSpot:r"), Util.s(i, Spot2, _Point, "setRectSpot:spot"), this.st()), this.S = t.x + i.x * t.width + i.offsetX, this.P = t.y + i.y * t.height + i.offsetY, this;
    }
    setSpot(t, i, e, s, n) {
      return Debug && (Util.r(t, _Point, "setSpot:x"), Util.r(i, _Point, "setSpot:y"), Util.r(e, _Point, "setSpot:w"), Util.r(s, _Point, "setSpot:h"), (e < 0 || s < 0) && Util.n("Point.setSpot:Width and height cannot be negative"), Util.s(n, Spot2, _Point, "setSpot:spot"), this.st()), this.S = t + n.x * e + n.offsetX, this.P = i + n.y * s + n.offsetY, this;
    }
    D(t) {
      return t.Pt(this), this;
    }
    Ge(t) {
      return t.rs(this), this;
    }
    static distanceLineSegmentSquared(t, i, e, s, n, o) {
      Debug && (Util.r(t, _Point, "distanceLineSegmentSquared:px"), Util.r(i, _Point, "distanceLineSegmentSquared:py"), Util.r(e, _Point, "distanceLineSegmentSquared:ax"), Util.r(s, _Point, "distanceLineSegmentSquared:ay"), Util.r(n, _Point, "distanceLineSegmentSquared:bx"), Util.r(o, _Point, "distanceLineSegmentSquared:by"));
      let r = n - e, l = o - s;
      const h = r * r + l * l, a = e - t, f = s - i, c = -a * r - f * l;
      if (c <= 0 || c >= h)
        return r = n - t, l = o - i, Math.min(a * a + f * f, r * r + l * l);
      {
        const u = r * f - l * a;
        return u * u / h;
      }
    }
    static distanceSquared(t, i, e, s) {
      Debug && (Util.r(t, _Point, "distanceSquared:px"), Util.r(i, _Point, "distanceSquared:py"), Util.r(e, _Point, "distanceSquared:qx"), Util.r(s, _Point, "distanceSquared:qy"));
      const n = e - t, o = s - i;
      return n * n + o * o;
    }
    static direction(t, i, e, s) {
      Debug && (Util.r(t, _Point, "direction:px"), Util.r(i, _Point, "direction:py"), Util.r(e, _Point, "direction:qx"), Util.r(s, _Point, "direction:qy"));
      const n = e - t, o = s - i;
      if (n === 0)
        return o > 0 ? 90 : o < 0 ? 270 : 0;
      if (o === 0)
        return n > 0 ? 0 : 180;
      {
        if (isNaN(n) || isNaN(o))
          return 0;
        let r = Math.atan(Math.abs(o / n)) * 180 / Math.PI;
        return n < 0 ? o < 0 ? r += 180 : r = 180 - r : o < 0 && (r = 360 - r), r;
      }
    }
    get x() {
      return this.S;
    }
    set x(t) {
      Debug && (Util.t(t, "number", _Point, "x"), this.st(t)), this.S = t;
    }
    get y() {
      return this.P;
    }
    set y(t) {
      Debug && (Util.t(t, "number", _Point, "y"), this.st(t)), this.P = t;
    }
    isReal() {
      return isFinite(this.x) && isFinite(this.y);
    }
    static a() {
      const t = _Point.Vk.pop();
      return t === void 0 ? new _Point() : t;
    }
    static H(t, i) {
      const e = _Point.Vk.pop();
      return e === void 0 ? new _Point(t, i) : (e.x = t, e.y = i, e);
    }
    static o(t) {
      _Point.Vk.push(t);
    }
  };
  __publicField(_Point, "To", new _Point(0, 0).rt());
  __publicField(_Point, "iC", new _Point(-1 / 0, -1 / 0).rt());
  __publicField(_Point, "eC", new _Point(1 / 0, 1 / 0).rt());
  __publicField(_Point, "sC", new _Point(6, 6).rt());
  __publicField(_Point, "Ek", new _Point(NaN, NaN).rt());
  __publicField(_Point, "Vk", []);
  let Point2 = _Point;
  const _Size = class _Size {
    constructor(t, i) {
      __publicField(this, "J");
      __publicField(this, "Z");
      __publicField(this, "f");
      t === void 0 ? (this.J = 0, this.Z = 0) : typeof t == "number" && (t >= 0 || isNaN(t)) && typeof i == "number" && (i >= 0 || isNaN(i)) ? (this.J = t, this.Z = i) : Util.n("Invalid arguments to Size constructor: " + t + ", " + i), this.f = false;
    }
    c(t) {
      return this.J = t.J, this.Z = t.Z, this;
    }
    e(t, i) {
      return this.J = t, this.Z = i, this;
    }
    setTo(t, i) {
      return Debug && (Util.t(t, "number", _Size, "setTo:w"), Util.t(i, "number", _Size, "setTo:h"), t < 0 && Util.G(t, ">= 0", _Size, "setTo:w"), i < 0 && Util.G(i, ">= 0", _Size, "setTo:h"), this.st()), this.J = t, this.Z = i, this;
    }
    set(t) {
      return Debug && (Util.s(t, _Size, _Size, "set:s"), this.st()), this.J = t.J, this.Z = t.Z, this;
    }
    copy() {
      const t = new _Size();
      return t.J = this.J, t.Z = this.Z, t;
    }
    rt() {
      return this.f = true, Object.freeze(this), this;
    }
    L() {
      return this.f || Object.isFrozen(this) ? this : this.copy().w();
    }
    w() {
      return this.f = true, this;
    }
    ut() {
      return Object.isFrozen(this) && Util.n("cannot thaw constant: " + this), this.f = false, this;
    }
    st(t) {
      if (Debug && this.f) {
        let i = "The Size is frozen, so its properties cannot be set: " + this.toString();
        t !== void 0 && (i += "  to value: " + t), Util.n(i);
      }
    }
    static parse(t) {
      if (typeof t == "string") {
        const i = t.split(" ");
        let e = 0, s = 0;
        for (; i[e] === ""; )
          e++;
        let n = i[e++];
        n && (s = parseFloat(n));
        let o = 0;
        for (; i[e] === ""; )
          e++;
        return n = i[e++], n && (o = parseFloat(n)), new _Size(s, o);
      } else
        return new _Size();
    }
    static stringify(t) {
      return Debug && Util.s(t, _Size), t.width.toString() + " " + t.height.toString();
    }
    static stringifyFixed(t) {
      return Util.t(t, "number", _Size, "stringifyFixed:digits"), (i) => i.width.toFixed(t) + " " + i.height.toFixed(t);
    }
    toString() {
      return "Size(" + this.width + "," + this.height + ")";
    }
    equals(t) {
      return t instanceof _Size ? this.J === t.width && this.Z === t.height : false;
    }
    equalTo(t, i) {
      return this.J === t && this.Z === i;
    }
    equalsApprox(t) {
      return Geo.p(this.J, t.width) && Geo.p(this.Z, t.height);
    }
    inflate(t, i) {
      Debug && (Util.r(t, _Size, "inflate:w"), Util.r(i, _Size, "inflate:h"));
      const e = this.width + t;
      this.J = e >= 0 ? e : 0;
      const s = this.height + i;
      return this.Z = s >= 0 ? s : 0, this;
    }
    get width() {
      return this.J;
    }
    set width(t) {
      Debug && (Util.t(t, "number", _Size, "width"), this.st(t)), t < 0 && Util.G(t, ">= 0", _Size, "width"), this.J = t;
    }
    get height() {
      return this.Z;
    }
    set height(t) {
      Debug && (Util.t(t, "number", _Size, "height"), this.st(t)), t < 0 && Util.G(t, ">= 0", _Size, "height"), this.Z = t;
    }
    isReal() {
      return isFinite(this.width) && isFinite(this.height);
    }
    static a() {
      const t = _Size.rC.pop();
      return t === void 0 ? new _Size() : t;
    }
    static o(t) {
      _Size.rC.push(t);
    }
  };
  __publicField(_Size, "lf", new _Size(0, 0).rt());
  __publicField(_Size, "Bk", new _Size(1, 1).rt());
  __publicField(_Size, "nC", new _Size(6, 6).rt());
  __publicField(_Size, "du", new _Size(8, 8).rt());
  __publicField(_Size, "oC", new _Size(10, 10).rt());
  __publicField(_Size, "zk", new _Size(1 / 0, 1 / 0).rt());
  __publicField(_Size, "xw", new _Size(NaN, NaN).rt());
  __publicField(_Size, "rC", []);
  let Size2 = _Size;
  const _Rect = class _Rect {
    constructor(t, i, e, s) {
      __publicField(this, "S");
      __publicField(this, "P");
      __publicField(this, "J");
      __publicField(this, "Z");
      __publicField(this, "f");
      if (t === void 0)
        this.S = 0, this.P = 0, this.J = 0, this.Z = 0;
      else if (typeof t == "number" && typeof i == "number" && typeof e == "number" && (e >= 0 || isNaN(e)) && typeof s == "number" && (s >= 0 || isNaN(s)))
        this.S = t, this.P = i, this.J = e, this.Z = s;
      else if (t instanceof Point2) {
        const n = t.x, o = t.y;
        if (i instanceof Point2) {
          const r = i.x, l = i.y;
          this.S = Math.min(n, r), this.P = Math.min(o, l), this.J = Math.abs(n - r), this.Z = Math.abs(o - l);
        } else
          i instanceof Size2 ? (this.S = n, this.P = o, this.J = i.width, this.Z = i.height) : Util.n("Incorrect second argument supplied to Rect constructor " + i);
      } else
        Util.n("Invalid arguments to Rect constructor: " + t + ", " + i + ", " + e + ", " + s);
      this.f = false;
    }
    c(t) {
      return this.S = t.S, this.P = t.P, this.J = t.J, this.Z = t.Z, this;
    }
    e(t, i, e, s) {
      return this.S = t, this.P = i, this.J = e, this.Z = s, this;
    }
    Do(t, i) {
      return this.J = t, this.Z = i, this;
    }
    setTo(t, i, e, s) {
      return Debug && (Util.t(t, "number", _Rect, "setTo:x"), Util.t(i, "number", _Rect, "setTo:y"), Util.t(e, "number", _Rect, "setTo:w"), Util.t(s, "number", _Rect, "setTo:h"), e < 0 && Util.G(e, ">= 0", _Rect, "setTo:w"), s < 0 && Util.G(s, ">= 0", _Rect, "setTo:h"), this.st()), this.S = t, this.P = i, this.J = e, this.Z = s, this;
    }
    set(t) {
      return Debug && (Util.s(t, _Rect, _Rect, "set:r"), this.st()), this.S = t.S, this.P = t.P, this.J = t.J, this.Z = t.Z, this;
    }
    setPoint(t) {
      return Debug && (Util.s(t, Point2, _Rect, "setPoint:p"), this.st()), this.S = t.x, this.P = t.y, this;
    }
    setSize(t) {
      return Debug && (Util.s(t, Size2, _Rect, "setSize:s"), this.st()), this.J = t.width, this.Z = t.height, this;
    }
    copy() {
      const t = new _Rect();
      return t.S = this.S, t.P = this.P, t.J = this.J, t.Z = this.Z, t;
    }
    rt() {
      return this.f = true, Object.freeze(this), this;
    }
    L() {
      return this.f || Object.isFrozen(this) ? this : this.copy().w();
    }
    w() {
      return this.f = true, this;
    }
    ut() {
      return Object.isFrozen(this) && Util.n("cannot thaw constant: " + this), this.f = false, this;
    }
    st(t) {
      if (Debug && this.f) {
        let i = "The Rect is frozen, so its properties cannot be set: " + this.toString();
        t !== void 0 && (i += "  to value: " + t), Util.n(i);
      }
    }
    static parse(t) {
      if (typeof t == "string") {
        const i = t.split(" ");
        let e = 0, s = 0;
        for (; i[e] === ""; )
          e++;
        let n = i[e++];
        n && (s = parseFloat(n));
        let o = 0;
        for (; i[e] === ""; )
          e++;
        n = i[e++], n && (o = parseFloat(n));
        let r = 0;
        for (; i[e] === ""; )
          e++;
        n = i[e++], n && (r = parseFloat(n));
        let l = 0;
        for (; i[e] === ""; )
          e++;
        return n = i[e++], n && (l = parseFloat(n)), new _Rect(s, o, r, l);
      } else
        return new _Rect();
    }
    static stringify(t) {
      return Debug && Util.s(t, _Rect), t.x.toString() + " " + t.y.toString() + " " + t.width.toString() + " " + t.height.toString();
    }
    static stringifyFixed(t) {
      return Util.t(t, "number", _Rect, "stringifyFixed:digits"), (i) => i.x.toFixed(t) + " " + i.y.toFixed(t) + " " + i.width.toFixed(t) + " " + i.height.toFixed(t);
    }
    toString() {
      return "Rect(" + this.x + "," + this.y + "," + this.width + "," + this.height + ")";
    }
    equals(t) {
      return t instanceof _Rect ? this.S === t.x && this.P === t.y && this.J === t.width && this.Z === t.height : false;
    }
    equalTo(t, i, e, s) {
      return this.S === t && this.P === i && this.J === e && this.Z === s;
    }
    equalsApprox(t) {
      return Geo.p(this.S, t.x) && Geo.p(this.P, t.y) && Geo.p(this.J, t.width) && Geo.p(this.Z, t.height);
    }
    equalsApproxTo(t, i, e, s) {
      return Geo.p(this.S, t) && Geo.p(this.P, i) && Geo.p(this.J, e) && Geo.p(this.Z, s);
    }
    equalsApproxClose(t) {
      return Geo.q(this.S, t.x) && Geo.q(this.P, t.y) && Geo.q(this.J, t.width) && Geo.q(this.Z, t.height);
    }
    containsPoint(t) {
      return Debug && Util.s(t, Point2, _Rect, "containsPoint:p"), this.S <= t.x && this.S + this.J >= t.x && this.P <= t.y && this.P + this.Z >= t.y;
    }
    containsRect(t) {
      return Debug && Util.s(t, _Rect, _Rect, "containsRect:r"), this.S <= t.x && t.x + t.width <= this.S + this.J && this.P <= t.y && t.y + t.height <= this.P + this.Z;
    }
    contains(t, i, e, s) {
      return Debug ? (Util.r(t, _Rect, "contains:x"), Util.r(i, _Rect, "contains:y"), e === void 0 ? e = 0 : Util.r(e, _Rect, "contains:w"), s === void 0 ? s = 0 : Util.r(s, _Rect, "contains:h"), (e < 0 || s < 0) && Util.n("Rect.contains:Width and height cannot be negative")) : (e === void 0 && (e = 0), s === void 0 && (s = 0)), this.S <= t && t + e <= this.S + this.J && this.P <= i && i + s <= this.P + this.Z;
    }
    offset(t, i) {
      return Debug && (Util.r(t, _Rect, "offset:dx"), Util.r(i, _Rect, "offset:dy"), this.st()), this.S += t, this.P += i, this;
    }
    inflate(t, i) {
      return Debug && (Util.r(t, _Rect, "inflate:w"), Util.r(i, _Rect, "inflate:h")), this.bw(i, t, i, t);
    }
    addMargin(t) {
      return Debug && Util.s(t, Margin2, _Rect, "addMargin:m"), this.bw(t.top, t.right, t.bottom, t.left);
    }
    subtractMargin(t) {
      return Debug && Util.s(t, Margin2, _Rect, "subtractMargin:m"), this.bw(-t.top, -t.right, -t.bottom, -t.left);
    }
    grow(t, i, e, s) {
      return Debug && (Util.r(t, _Rect, "grow:t"), Util.r(i, _Rect, "grow:r"), Util.r(e, _Rect, "grow:b"), Util.r(s, _Rect, "grow:l")), this.bw(t, i, e, s);
    }
    bw(t, i, e, s) {
      Debug && this.st();
      const n = this.J;
      i + s <= -n ? (this.S += n / 2, this.J = 0) : (this.S -= s, this.J += i + s);
      const o = this.Z;
      return t + e <= -o ? (this.P += o / 2, this.Z = 0) : (this.P -= t, this.Z += t + e), this;
    }
    intersectRect(t) {
      return Debug && Util.s(t, _Rect, _Rect, "intersectRect:r"), this.lC(t.x, t.y, t.width, t.height);
    }
    intersect(t, i, e, s) {
      return Debug && (Util.r(t, _Rect, "intersect:x"), Util.r(i, _Rect, "intersect:y"), Util.r(e, _Rect, "intersect:w"), Util.r(s, _Rect, "intersect:h"), (e < 0 || s < 0) && Util.n("Rect.intersect:Width and height cannot be negative")), this.lC(t, i, e, s);
    }
    lC(t, i, e, s) {
      Debug && this.st();
      const n = Math.max(this.S, t), o = Math.max(this.P, i), r = Math.min(this.S + this.J, t + e), l = Math.min(this.P + this.Z, i + s);
      return this.S = n, this.P = o, this.J = Math.max(0, r - n), this.Z = Math.max(0, l - o), this;
    }
    intersectsRect(t) {
      return Debug && Util.s(t, _Rect, _Rect, "intersectsRect:r"), this.intersects(t.x, t.y, t.width, t.height);
    }
    intersects(t, i, e, s) {
      Debug && (Util.r(t, _Rect, "intersects:x"), Util.r(i, _Rect, "intersects:y"), Util.r(t, _Rect, "intersects:w"), Util.r(i, _Rect, "intersects:h"), (e < 0 || s < 0) && Util.n("Rect.intersects:Width and height cannot be negative"));
      let n = this.J;
      const o = this.S;
      if (n !== 1 / 0 && e !== 1 / 0 && (n += o, e += t, isNaN(e) || isNaN(n) || o > e || t > n))
        return false;
      let r = this.Z;
      const l = this.P;
      return !(r !== 1 / 0 && s !== 1 / 0 && (r += l, s += i, isNaN(s) || isNaN(r) || l > s || i > r));
    }
    intersectsRectPlus(t, i) {
      let e = this.J, s = t.width + i + i;
      const n = this.S, o = t.x - i;
      if (e += n, s += o, n > s || o > e)
        return false;
      let r = this.Z, l = t.height + i + i;
      const h = this.P, a = t.y - i;
      return r += h, l += a, !(h > l || a > r);
    }
    unionPoint(t) {
      return Debug && Util.s(t, Point2, _Rect, "unionPoint:p"), this.unionNoCheck(t.x, t.y, 0, 0);
    }
    unionRect(t) {
      return Debug && Util.s(t, _Rect, _Rect, "unionRect:r"), this.unionNoCheck(t.S, t.P, t.J, t.Z);
    }
    union(t, i, e, s) {
      return Debug ? (Util.r(t, _Rect, "union:x"), Util.r(i, _Rect, "union:y"), e === void 0 ? e = 0 : Util.r(e, _Rect, "union:w"), s === void 0 ? s = 0 : Util.r(s, _Rect, "union:h"), (e < 0 || s < 0) && Util.n("Rect.union:Width and height cannot be negative"), this.st()) : (e === void 0 && (e = 0), s === void 0 && (s = 0)), this.unionNoCheck(t, i, e, s);
    }
    unionNoCheck(t, i, e, s) {
      const n = Math.min(this.S, t), o = Math.min(this.P, i), r = Math.max(this.S + this.J, t + e), l = Math.max(this.P + this.Z, i + s);
      return this.S = n, this.P = o, this.J = r - n, this.Z = l - o, this;
    }
    setSpot(t, i, e) {
      return Debug && (Util.r(t, _Rect, "setSpot:x"), Util.r(i, _Rect, "setSpot:y"), Util.s(e, Spot2, _Rect, "setSpot:spot"), this.st()), this.S = t - e.offsetX - e.x * this.J, this.P = i - e.offsetY - e.y * this.Z, this;
    }
    static contains(t, i, e, s, n, o, r, l) {
      return Debug ? (Util.r(t, _Rect, "contains:rx"), Util.r(i, _Rect, "contains:ry"), Util.r(e, _Rect, "contains:rw"), Util.r(s, _Rect, "contains:rh"), Util.r(n, _Rect, "contains:x"), Util.r(o, _Rect, "contains:y"), r === void 0 ? r = 0 : Util.r(r, _Rect, "contains:w"), l === void 0 ? l = 0 : Util.r(l, _Rect, "contains:h"), (e < 0 || s < 0 || r < 0 || l < 0) && Util.n("Rect.contains:Width and height cannot be negative")) : (r === void 0 && (r = 0), l === void 0 && (l = 0)), t <= n && n + r <= t + e && i <= o && o + l <= i + s;
    }
    static intersects(t, i, e, s, n, o, r, l) {
      Debug && (Util.r(t, _Rect, "intersects:rx"), Util.r(i, _Rect, "intersects:ry"), Util.r(e, _Rect, "intersects:rw"), Util.r(s, _Rect, "intersects:rh"), Util.r(n, _Rect, "intersects:x"), Util.r(o, _Rect, "intersects:y"), Util.r(r, _Rect, "intersects:w"), Util.r(l, _Rect, "intersects:h"), (e < 0 || s < 0 || r < 0 || l < 0) && Util.n("Rect.intersects:Width and height cannot be negative"));
      let h = e, a = r;
      const f = t, c = n;
      if (h += f, a += c, f > a || c > h)
        return false;
      let u = s, d = l;
      const m = i, g = o;
      return u += m, d += g, !(m > d || g > u);
    }
    static intersectsLineSegment(t, i, e, s, n, o, r, l) {
      return Debug && (Util.r(t, _Rect, "intersectsLineSegment:x"), Util.r(i, _Rect, "intersectsLineSegment:y"), Util.r(e, _Rect, "intersectsLineSegment:w"), Util.r(s, _Rect, "intersectsLineSegment:h"), Util.r(n, _Rect, "intersectsLineSegment:p1x"), Util.r(o, _Rect, "intersectsLineSegment:p1y"), Util.r(r, _Rect, "intersectsLineSegment:p2x"), Util.r(l, _Rect, "intersectsLineSegment:p2y"), (e < 0 || s < 0) && Util.n("Rect.intersectsLineSegment: width and height cannot be negative")), Geo.hC(t, i, e, s, n, o, r, l);
    }
    get x() {
      return this.S;
    }
    set x(t) {
      Debug && (Util.t(t, "number", _Rect, "x"), this.st(t)), this.S = t;
    }
    get y() {
      return this.P;
    }
    set y(t) {
      Debug && (Util.t(t, "number", _Rect, "y"), this.st(t)), this.P = t;
    }
    get width() {
      return this.J;
    }
    set width(t) {
      Debug && (Util.t(t, "number", _Rect, "width"), this.st(t)), t < 0 && Util.G(t, ">= 0", _Rect, "width"), this.J = t;
    }
    get height() {
      return this.Z;
    }
    set height(t) {
      Debug && (Util.t(t, "number", _Rect, "height"), this.st(t)), t < 0 && Util.G(t, ">= 0", _Rect, "height"), this.Z = t;
    }
    get left() {
      return this.S;
    }
    set left(t) {
      Debug && (Util.t(t, "number", _Rect, "left"), this.st(t)), this.S = t;
    }
    get top() {
      return this.P;
    }
    set top(t) {
      Debug && (Util.t(t, "number", _Rect, "top"), this.st(t)), this.P = t;
    }
    get right() {
      return this.S + this.J;
    }
    set right(t) {
      Debug && (Util.r(t, _Rect, "right"), this.st(t)), this.S += t - (this.S + this.J);
    }
    get bottom() {
      return this.P + this.Z;
    }
    set bottom(t) {
      Debug && (Util.r(t, _Rect, "top"), this.st(t)), this.P += t - (this.P + this.Z);
    }
    get position() {
      return new Point2(this.S, this.P);
    }
    set position(t) {
      Debug && (Util.s(t, Point2, _Rect, "position"), this.st(t)), this.S = t.x, this.P = t.y;
    }
    get size() {
      return new Size2(this.J, this.Z);
    }
    set size(t) {
      Debug && (Util.s(t, Size2, _Rect, "size"), this.st(t)), this.J = t.width, this.Z = t.height;
    }
    get center() {
      return new Point2(this.S + this.J / 2, this.P + this.Z / 2);
    }
    set center(t) {
      Debug && (Util.s(t, Point2, _Rect, "center"), this.st(t)), this.S = t.x - this.J / 2, this.P = t.y - this.Z / 2;
    }
    get centerX() {
      return this.S + this.J / 2;
    }
    set centerX(t) {
      Debug && (Util.r(t, _Rect, "centerX"), this.st(t)), this.S = t - this.J / 2;
    }
    get centerY() {
      return this.P + this.Z / 2;
    }
    set centerY(t) {
      Debug && (Util.r(t, _Rect, "centerY"), this.st(t)), this.P = t - this.Z / 2;
    }
    isReal() {
      return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
    }
    isEmpty() {
      return this.width === 0 && this.height === 0;
    }
    static a() {
      const t = _Rect.Yk.pop();
      return t === void 0 ? new _Rect() : t;
    }
    static H(t, i, e, s) {
      const n = _Rect.Yk.pop();
      return n === void 0 ? new _Rect(t, i, e, s) : n.e(t, i, e, s);
    }
    static o(t) {
      _Rect.Yk.push(t);
    }
  };
  __publicField(_Rect, "Xk", new _Rect(0, 0, 0, 0).rt());
  __publicField(_Rect, "RD", new _Rect(NaN, NaN, NaN, NaN).rt());
  __publicField(_Rect, "Yk", []);
  let Rect2 = _Rect;
  const _Margin = class _Margin {
    constructor(t, i, e, s) {
      __publicField(this, "fn");
      __publicField(this, "cn");
      __publicField(this, "un");
      __publicField(this, "dn");
      __publicField(this, "f");
      t === void 0 ? (this.fn = 0, this.cn = 0, this.un = 0, this.dn = 0) : i === void 0 ? (i = t, e = t, s = t, this.top = t, this.right = i, this.bottom = e, this.left = s) : e === void 0 ? (e = t, s = i, this.top = t, this.right = i, this.bottom = e, this.left = s) : s !== void 0 ? (this.top = t, this.right = i, this.bottom = e, this.left = s) : Util.n("Invalid arguments to Margin constructor: " + t + ", " + i + ", " + e + ", " + s), this.f = false;
    }
    c(t) {
      return this.fn = t.fn, this.cn = t.cn, this.un = t.un, this.dn = t.dn, this;
    }
    setTo(t, i, e, s) {
      return Debug && (Util.t(t, "number", _Margin, "setTo:t"), Util.t(i, "number", _Margin, "setTo:r"), Util.t(e, "number", _Margin, "setTo:b"), Util.t(s, "number", _Margin, "setTo:l"), this.st()), this.fn = t, this.cn = i, this.un = e, this.dn = s, this;
    }
    set(t) {
      return Debug && (Util.s(t, _Margin, _Margin, "assign:m"), this.st()), this.fn = t.fn, this.cn = t.cn, this.un = t.un, this.dn = t.dn, this;
    }
    copy() {
      const t = new _Margin();
      return t.fn = this.fn, t.cn = this.cn, t.un = this.un, t.dn = this.dn, t;
    }
    rt() {
      return this.f = true, Object.freeze(this), this;
    }
    L() {
      return this.f || Object.isFrozen(this) ? this : this.copy().w();
    }
    w() {
      return this.f = true, this;
    }
    ut() {
      return Object.isFrozen(this) && Util.n("cannot thaw constant: " + this), this.f = false, this;
    }
    st(t) {
      if (Debug && this.f) {
        let i = "The Margin is frozen, so its properties cannot be set: " + this.toString();
        t !== void 0 && (i += "  to value: " + t), Util.n(i);
      }
    }
    static parse(t) {
      if (typeof t == "string") {
        const i = t.split(" ");
        let e = 0, s = NaN;
        for (; i[e] === ""; )
          e++;
        let n = i[e++];
        if (n && (s = parseFloat(n)), isNaN(s))
          return new _Margin();
        let o = NaN;
        for (; i[e] === ""; )
          e++;
        if (n = i[e++], n && (o = parseFloat(n)), isNaN(o))
          return new _Margin(s);
        let r = NaN;
        for (; i[e] === ""; )
          e++;
        if (n = i[e++], n && (r = parseFloat(n)), isNaN(r))
          return new _Margin(s, o);
        let l = NaN;
        for (; i[e] === ""; )
          e++;
        return n = i[e++], n && (l = parseFloat(n)), isNaN(l) ? new _Margin(s, o) : new _Margin(s, o, r, l);
      } else
        return new _Margin();
    }
    static stringify(t) {
      return Debug && Util.s(t, _Margin), t.top.toString() + " " + t.right.toString() + " " + t.bottom.toString() + " " + t.left.toString();
    }
    static stringifyFixed(t) {
      return Util.t(t, "number", _Margin, "stringifyFixed:digits"), (i) => i.top.toFixed(t) + " " + i.right.toFixed(t) + " " + i.bottom.toFixed(t) + " " + i.left.toFixed(t);
    }
    toString() {
      return "Margin(" + this.top + "," + this.right + "," + this.bottom + "," + this.left + ")";
    }
    equals(t) {
      return t instanceof _Margin ? this.fn === t.top && this.cn === t.right && this.un === t.bottom && this.dn === t.left : false;
    }
    equalTo(t, i, e, s) {
      return this.fn === t && this.cn === i && this.un === e && this.dn === s;
    }
    equalsApprox(t) {
      return Geo.p(this.fn, t.top) && Geo.p(this.cn, t.right) && Geo.p(this.un, t.bottom) && Geo.p(this.dn, t.left);
    }
    get top() {
      return this.fn;
    }
    set top(t) {
      Debug && (Util.r(t, _Margin, "top"), this.st(t)), this.fn = t;
    }
    get right() {
      return this.cn;
    }
    set right(t) {
      Debug && (Util.r(t, _Margin, "right"), this.st(t)), this.cn = t;
    }
    get bottom() {
      return this.un;
    }
    set bottom(t) {
      Debug && (Util.r(t, _Margin, "bottom"), this.st(t)), this.un = t;
    }
    get left() {
      return this.dn;
    }
    set left(t) {
      Debug && (Util.r(t, _Margin, "left"), this.st(t)), this.dn = t;
    }
    isReal() {
      return isFinite(this.top) && isFinite(this.right) && isFinite(this.bottom) && isFinite(this.left);
    }
    static a() {
      const t = _Margin.fC.pop();
      return t === void 0 ? new _Margin() : t;
    }
    static o(t) {
      _Margin.fC.push(t);
    }
  };
  __publicField(_Margin, "qg", new _Margin(0, 0, 0, 0).rt());
  __publicField(_Margin, "aC", new _Margin(2, 2, 2, 2).rt());
  __publicField(_Margin, "fC", []);
  let Margin2 = _Margin;
  const _Spot = class _Spot {
    constructor(t, i, e, s) {
      __publicField(this, "S");
      __publicField(this, "P");
      __publicField(this, "Vs");
      __publicField(this, "Bs");
      __publicField(this, "f");
      t === void 0 ? (this.S = 0, this.P = 0, this.Vs = 0, this.Bs = 0) : (i === void 0 && (i = 0), e === void 0 && (e = 0), s === void 0 && (s = 0), this.x = t, this.y = i, this.offsetX = e, this.offsetY = s), this.f = false;
    }
    c(t) {
      return this.S = t.S, this.P = t.P, this.Vs = t.Vs, this.Bs = t.Bs, this;
    }
    setTo(t, i, e, s) {
      return Debug && (this.kw(t, "setTo:x"), this.kw(i, "setTo:y"), this.Sw(e, "setTo:offx"), this.Sw(s, "setTo:offy"), this.st()), this.S = t, this.P = i, this.Vs = e, this.Bs = s, this;
    }
    set(t) {
      return Debug && (Util.s(t, _Spot, _Spot, "set:s"), this.st()), this.S = t.S, this.P = t.P, this.Vs = t.Vs, this.Bs = t.Bs, this;
    }
    copy() {
      const t = new _Spot();
      return t.S = this.S, t.P = this.P, t.Vs = this.Vs, t.Bs = this.Bs, t;
    }
    rt() {
      return this.f = true, Object.freeze(this), this;
    }
    L() {
      return this.f || Object.isFrozen(this) ? this : this.copy().w();
    }
    w() {
      return this.f = true, this;
    }
    ut() {
      return Object.isFrozen(this) && Util.n("cannot thaw constant: " + this), this.f = false, this;
    }
    st(t) {
      if (Debug && this.f) {
        let i = "The Spot is frozen, so its properties cannot be set: " + this.toString();
        t !== void 0 && (i += "  to value: " + t), Util.n(i);
      }
    }
    He(t) {
      return this.S = NaN, this.P = NaN, this.Vs = t, this;
    }
    kw(t, i) {
      (isNaN(t) || t > 1 || t < 0) && Util.G(t, "0 <= " + i + " <= 1", _Spot, i);
    }
    Sw(t, i) {
      (isNaN(t) || t === 1 / 0 || t === -1 / 0) && Util.G(t, "real number, not NaN or Infinity", _Spot, i);
    }
    static parse(t) {
      if (typeof t == "string") {
        if (t = t.trim(), t === "None")
          return _Spot.None;
        if (t === "TopLeft")
          return _Spot.TopLeft;
        if (t === "Top" || t === "TopCenter" || t === "MiddleTop")
          return _Spot.TopCenter;
        if (t === "TopRight")
          return _Spot.TopRight;
        if (t === "Left" || t === "LeftCenter" || t === "MiddleLeft")
          return _Spot.LeftCenter;
        if (t === "Center")
          return _Spot.Center;
        if (t === "Right" || t === "RightCenter" || t === "MiddleRight")
          return _Spot.RightCenter;
        if (t === "BottomLeft")
          return _Spot.BottomLeft;
        if (t === "Bottom" || t === "BottomCenter" || t === "MiddleBottom")
          return _Spot.BottomCenter;
        if (t === "BottomRight")
          return _Spot.BottomRight;
        if (t === "TopSide")
          return _Spot.TopSide;
        if (t === "LeftSide")
          return _Spot.LeftSide;
        if (t === "RightSide")
          return _Spot.RightSide;
        if (t === "BottomSide")
          return _Spot.BottomSide;
        if (t === "TopBottomSides")
          return _Spot.TopBottomSides;
        if (t === "LeftRightSides")
          return _Spot.LeftRightSides;
        if (t === "TopLeftSides")
          return _Spot.TopLeftSides;
        if (t === "TopRightSides")
          return _Spot.TopRightSides;
        if (t === "BottomLeftSides")
          return _Spot.BottomLeftSides;
        if (t === "BottomRightSides")
          return _Spot.BottomRightSides;
        if (t === "NotTopSide")
          return _Spot.NotTopSide;
        if (t === "NotLeftSide")
          return _Spot.NotLeftSide;
        if (t === "NotRightSide")
          return _Spot.NotRightSide;
        if (t === "NotBottomSide")
          return _Spot.NotBottomSide;
        if (t === "AllSides")
          return _Spot.AllSides;
        if (t === "Default")
          return _Spot.Default;
        const i = t.split(" ");
        let e = 0, s = 0;
        for (; i[e] === ""; )
          e++;
        let n = i[e++];
        n !== void 0 && n.length > 0 && (s = parseFloat(n));
        let o = 0;
        for (; i[e] === ""; )
          e++;
        n = i[e++], n !== void 0 && n.length > 0 && (o = parseFloat(n));
        let r = 0;
        for (; i[e] === ""; )
          e++;
        n = i[e++], n !== void 0 && n.length > 0 && (r = parseFloat(n));
        let l = 0;
        for (; i[e] === ""; )
          e++;
        return n = i[e++], n !== void 0 && n.length > 0 && (l = parseFloat(n)), new _Spot(s, o, r, l);
      } else
        return new _Spot();
    }
    static stringify(t) {
      return Debug && Util.s(t, _Spot), t.isSpot() ? t.x.toString() + " " + t.y.toString() + " " + t.offsetX.toString() + " " + t.offsetY.toString() : t.toString();
    }
    static stringifyFixed(t) {
      return Util.t(t, "number", _Spot, "stringifyFixed:digits"), (i) => i.x.toFixed(t) + " " + i.y.toFixed(t) + " " + i.offsetX.toFixed(t) + " " + i.offsetY.toFixed(t);
    }
    toString() {
      return this.isSpot() ? this.Vs === 0 && this.Bs === 0 ? "Spot(" + this.x + "," + this.y + ")" : "Spot(" + this.x + "," + this.y + "," + this.offsetX + "," + this.offsetY + ")" : this.equals(_Spot.None) ? "None" : this.equals(_Spot.TopLeft) ? "TopLeft" : this.equals(_Spot.TopCenter) ? "Top" : this.equals(_Spot.TopRight) ? "TopRight" : this.equals(_Spot.LeftCenter) ? "Left" : this.equals(_Spot.Center) ? "Center" : this.equals(_Spot.RightCenter) ? "Right" : this.equals(_Spot.BottomLeft) ? "BottomLeft" : this.equals(_Spot.BottomCenter) ? "Bottom" : this.equals(_Spot.BottomRight) ? "BottomRight" : this.equals(_Spot.TopSide) ? "TopSide" : this.equals(_Spot.LeftSide) ? "LeftSide" : this.equals(_Spot.RightSide) ? "RightSide" : this.equals(_Spot.BottomSide) ? "BottomSide" : this.equals(_Spot.TopBottomSides) ? "TopBottomSides" : this.equals(_Spot.LeftRightSides) ? "LeftRightSides" : this.equals(_Spot.TopLeftSides) ? "TopLeftSides" : this.equals(_Spot.TopRightSides) ? "TopRightSides" : this.equals(_Spot.BottomLeftSides) ? "BottomLeftSides" : this.equals(_Spot.BottomRightSides) ? "BottomRightSides" : this.equals(_Spot.NotTopSide) ? "NotTopSide" : this.equals(_Spot.NotLeftSide) ? "NotLeftSide" : this.equals(_Spot.NotRightSide) ? "NotRightSide" : this.equals(_Spot.NotBottomSide) ? "NotBottomSide" : this.equals(_Spot.AllSides) ? "AllSides" : this.equals(_Spot.Default) ? "Default" : "None";
    }
    equals(t) {
      return t instanceof _Spot ? (this.S === t.x || isNaN(this.S) && isNaN(t.x)) && (this.P === t.y || isNaN(this.P) && isNaN(t.y)) && this.Vs === t.offsetX && this.Bs === t.offsetY : false;
    }
    opposite() {
      return new _Spot(0.5 - (this.S - 0.5), 0.5 - (this.P - 0.5), -this.Vs, -this.Bs);
    }
    includesSide(t) {
      if (!this.isSide())
        return false;
      if (!t.isSide())
        if (t.equals(_Spot.Left))
          t = _Spot.LeftSide;
        else if (t.equals(_Spot.Right))
          t = _Spot.RightSide;
        else if (t.equals(_Spot.Top))
          t = _Spot.TopSide;
        else if (t.equals(_Spot.Bottom))
          t = _Spot.BottomSide;
        else
          return false;
      const i = this.Bs, e = t.offsetY;
      return (i & e) === e;
    }
    get x() {
      return this.S;
    }
    set x(t) {
      Debug && (this.kw(t, "x"), this.st(t)), this.S = t;
    }
    get y() {
      return this.P;
    }
    set y(t) {
      Debug && (this.kw(t, "y"), this.st(t)), this.P = t;
    }
    get offsetX() {
      return this.Vs;
    }
    set offsetX(t) {
      Debug && (this.Sw(t, "offsetX"), this.st(t)), this.Vs = t;
    }
    get offsetY() {
      return this.Bs;
    }
    set offsetY(t) {
      Debug && (this.Sw(t, "offsetY"), this.st(t)), this.Bs = t;
    }
    isSpot() {
      return !isNaN(this.x) && !isNaN(this.y);
    }
    isNoSpot() {
      return isNaN(this.x) || isNaN(this.y);
    }
    isSide() {
      return isNaN(this.x) && isNaN(this.y) && this.offsetX === 1 && this.offsetY !== 0;
    }
    isNone() {
      return isNaN(this.x) && isNaN(this.y) && this.offsetX === 0 && this.offsetY === 0;
    }
    isDefault() {
      return isNaN(this.x) && isNaN(this.y) && this.offsetX === -1 && this.offsetY === 0;
    }
    static a() {
      const t = _Spot.cC.pop();
      return t === void 0 ? new _Spot() : t;
    }
    static o(t) {
      _Spot.cC.push(t);
    }
  };
  __publicField(_Spot, "None", new _Spot(0, 0, 0, 0).He(0).rt());
  __publicField(_Spot, "Default", new _Spot(0, 0, -1, 0).He(-1).rt());
  __publicField(_Spot, "TopLeft", new _Spot(0, 0, 0, 0).rt());
  __publicField(_Spot, "TopCenter", new _Spot(0.5, 0, 0, 0).rt());
  __publicField(_Spot, "TopRight", new _Spot(1, 0, 0, 0).rt());
  __publicField(_Spot, "LeftCenter", new _Spot(0, 0.5, 0, 0).rt());
  __publicField(_Spot, "Center", new _Spot(0.5, 0.5, 0, 0).rt());
  __publicField(_Spot, "RightCenter", new _Spot(1, 0.5, 0, 0).rt());
  __publicField(_Spot, "BottomLeft", new _Spot(0, 1, 0, 0).rt());
  __publicField(_Spot, "BottomCenter", new _Spot(0.5, 1, 0, 0).rt());
  __publicField(_Spot, "BottomRight", new _Spot(1, 1, 0, 0).rt());
  __publicField(_Spot, "MiddleTop", _Spot.TopCenter);
  __publicField(_Spot, "MiddleLeft", _Spot.LeftCenter);
  __publicField(_Spot, "MiddleRight", _Spot.RightCenter);
  __publicField(_Spot, "MiddleBottom", _Spot.BottomCenter);
  __publicField(_Spot, "Top", _Spot.TopCenter);
  __publicField(_Spot, "Left", _Spot.LeftCenter);
  __publicField(_Spot, "Right", _Spot.RightCenter);
  __publicField(_Spot, "Bottom", _Spot.BottomCenter);
  __publicField(_Spot, "TopSide", new _Spot(0, 0, 1, 1).He(1).rt());
  __publicField(_Spot, "LeftSide", new _Spot(0, 0, 1, 2).He(1).rt());
  __publicField(_Spot, "RightSide", new _Spot(0, 0, 1, 4).He(1).rt());
  __publicField(_Spot, "BottomSide", new _Spot(0, 0, 1, 8).He(1).rt());
  __publicField(_Spot, "TopBottomSides", new _Spot(0, 0, 1, 9).He(1).rt());
  __publicField(_Spot, "LeftRightSides", new _Spot(0, 0, 1, 6).He(1).rt());
  __publicField(_Spot, "TopLeftSides", new _Spot(0, 0, 1, 3).He(1).rt());
  __publicField(_Spot, "TopRightSides", new _Spot(0, 0, 1, 5).He(1).rt());
  __publicField(_Spot, "BottomLeftSides", new _Spot(0, 0, 1, 10).He(1).rt());
  __publicField(_Spot, "BottomRightSides", new _Spot(0, 0, 1, 12).He(1).rt());
  __publicField(_Spot, "NotTopSide", new _Spot(0, 0, 1, 14).He(1).rt());
  __publicField(_Spot, "NotLeftSide", new _Spot(0, 0, 1, 13).He(1).rt());
  __publicField(_Spot, "NotRightSide", new _Spot(0, 0, 1, 11).He(1).rt());
  __publicField(_Spot, "NotBottomSide", new _Spot(0, 0, 1, 7).He(1).rt());
  __publicField(_Spot, "AllSides", new _Spot(0, 0, 1, 15).He(1).rt());
  __publicField(_Spot, "Kk", new _Spot(0.156, 0.156).rt());
  __publicField(_Spot, "Uk", new _Spot(0.844, 0.844).rt());
  __publicField(_Spot, "cC", []);
  let Spot2 = _Spot;
  const _Transform = class _Transform {
    constructor() {
      __publicField(this, "m11");
      __publicField(this, "m12");
      __publicField(this, "m21");
      __publicField(this, "m22");
      __publicField(this, "dx");
      __publicField(this, "dy");
      this.m11 = 1, this.m12 = 0, this.m21 = 0, this.m22 = 1, this.dx = 0, this.dy = 0;
    }
    set(t) {
      return this.m11 = t.m11, this.m12 = t.m12, this.m21 = t.m21, this.m22 = t.m22, this.dx = t.dx, this.dy = t.dy, this;
    }
    setTo(t, i, e, s, n, o) {
      return this.m11 = t, this.m12 = i, this.m21 = e, this.m22 = s, this.dx = n, this.dy = o, this;
    }
    copy() {
      const t = new _Transform();
      return t.m11 = this.m11, t.m12 = this.m12, t.m21 = this.m21, t.m22 = this.m22, t.dx = this.dx, t.dy = this.dy, t;
    }
    toString() {
      return "Transform(" + this.m11 + "," + this.m12 + "," + this.m21 + "," + this.m22 + "," + this.dx + "," + this.dy + ")";
    }
    equals(t) {
      return this.m11 === t.m11 && this.m12 === t.m12 && this.m21 === t.m21 && this.m22 === t.m22 && this.dx === t.dx && this.dy === t.dy;
    }
    Gk() {
      return this.dx === 0 && this.dy === 0 && this.m11 === 1 && this.m12 === 0 && this.m21 === 0 && this.m22 === 1;
    }
    ti() {
      return this.m11 = 1, this.m12 = 0, this.m21 = 0, this.m22 = 1, this.dx = 0, this.dy = 0, this;
    }
    hf(t) {
      const i = this.m11 * t.m11 + this.m21 * t.m12, e = this.m12 * t.m11 + this.m22 * t.m12, s = this.m11 * t.m21 + this.m21 * t.m22, n = this.m12 * t.m21 + this.m22 * t.m22;
      return this.dx = this.m11 * t.dx + this.m21 * t.dy + this.dx, this.dy = this.m12 * t.dx + this.m22 * t.dy + this.dy, this.m11 = i, this.m12 = e, this.m21 = s, this.m22 = n, this;
    }
    uC(t) {
      const i = 1 / (t.m11 * t.m22 - t.m12 * t.m21), e = t.m22 * i, s = -t.m12 * i, n = -t.m21 * i, o = t.m11 * i, r = i * (t.m21 * t.dy - t.m22 * t.dx), l = i * (t.m12 * t.dx - t.m11 * t.dy), h = this.m11 * e + this.m21 * s, a = this.m12 * e + this.m22 * s, f = this.m11 * n + this.m21 * o, c = this.m12 * n + this.m22 * o;
      return this.dx = this.m11 * r + this.m21 * l + this.dx, this.dy = this.m12 * r + this.m22 * l + this.dy, this.m11 = h, this.m12 = a, this.m21 = f, this.m22 = c, this;
    }
    Mw() {
      const t = 1 / (this.m11 * this.m22 - this.m12 * this.m21), i = this.m22 * t, e = -this.m12 * t, s = -this.m21 * t, n = this.m11 * t, o = t * (this.m21 * this.dy - this.m22 * this.dx), r = t * (this.m12 * this.dx - this.m11 * this.dy);
      return this.m11 = i, this.m12 = e, this.m21 = s, this.m22 = n, this.dx = o, this.dy = r, this;
    }
    ys(t, i, e) {
      if (t >= 360 ? t -= 360 : t < 0 && (t += 360), t === 0)
        return this;
      this.se(i, e);
      let s = 0, n = 0;
      if (t === 90)
        s = 0, n = 1;
      else if (t === 180)
        s = -1, n = 0;
      else if (t === 270)
        s = 0, n = -1;
      else {
        const a = t * Math.PI / 180;
        s = Math.cos(a), n = Math.sin(a);
      }
      const o = this.m11 * s + this.m21 * n, r = this.m12 * s + this.m22 * n, l = this.m11 * -n + this.m21 * s, h = this.m12 * -n + this.m22 * s;
      return this.m11 = o, this.m12 = r, this.m21 = l, this.m22 = h, this.se(-i, -e), this;
    }
    se(t, i) {
      return this.dx += this.m11 * t + this.m21 * i, this.dy += this.m12 * t + this.m22 * i, this;
    }
    v(t, i) {
      return i === void 0 && (i = t), this.m11 *= t, this.m12 *= t, this.m21 *= i, this.m22 *= i, this;
    }
    ID() {
      if (this.m11 === 1 && this.m12 === 0)
        return 0;
      let t = Math.atan2(this.m12, this.m11) * 180 / Math.PI;
      return t < 0 && (t += 360), t;
    }
    Pt(t) {
      const i = t.x, e = t.y;
      return t.e(i * this.m11 + e * this.m21 + this.dx, i * this.m12 + e * this.m22 + this.dy);
    }
    rs(t) {
      const i = 1 / (this.m11 * this.m22 - this.m12 * this.m21), e = this.m22 * i, s = -this.m12 * i, n = -this.m21 * i, o = this.m11 * i, r = i * (this.m21 * this.dy - this.m22 * this.dx), l = i * (this.m12 * this.dx - this.m11 * this.dy), h = t.x, a = t.y;
      return t.e(h * e + a * n + r, h * s + a * o + l);
    }
    Pw(t) {
      const i = 1 / (this.m11 * this.m22 - this.m12 * this.m21), e = this.m22 * i, s = -this.m12 * i, n = -this.m21 * i, o = this.m11 * i, r = i * (this.m21 * this.dy - this.m22 * this.dx), l = i * (this.m12 * this.dx - this.m11 * this.dy), h = t.x * 1.25, a = t.y * 1.2;
      return t.e(h * e + a * n + r, h * s + a * o + l);
    }
    Nw(t) {
      const i = t.x, e = t.y, s = i + t.width, n = e + t.height, o = this.m11, r = this.m12, l = this.m21, h = this.m22, a = this.dx, f = this.dy, c = i * o + e * l + a, u = i * r + e * h + f, d = s * o + e * l + a, m = s * r + e * h + f, g = i * o + n * l + a, p = i * r + n * h + f, y = s * o + n * l + a, x = s * r + n * h + f;
      let b = c, k = c, S = u, M = u;
      return b = Math.min(b, d), k = Math.max(k, d), S = Math.min(S, m), M = Math.max(M, m), b = Math.min(b, g), k = Math.max(k, g), S = Math.min(S, p), M = Math.max(M, p), b = Math.min(b, y), k = Math.max(k, y), S = Math.min(S, x), M = Math.max(M, x), t.e(b, S, k - b, M - S), t;
    }
    static a() {
      const t = _Transform.dC.pop();
      return t === void 0 ? new _Transform() : t;
    }
    static o(t) {
      _Transform.dC.push(t);
    }
  };
  __publicField(_Transform, "dC", []);
  __publicField(_Transform, "Hk", "54a702f3e53909c447824c6706603faf4c");
  let Transform = _Transform;
  const Geo = { OD: "7da71ca0ad381e90", Gn: 4 * ((Math.sqrt(2) - 1) / 3), gC: null, Cw: (w) => {
    if (w <= 0)
      return 0;
    let t = Geo.gC;
    if (t === null) {
      t = [];
      for (let i = 0; i <= 2e3; i++)
        t[i] = Math.sqrt(i);
      Geo.gC = t;
    }
    if (w < 1) {
      const i = 1 / w;
      return i <= 2e3 ? 1 / t[i | 0] : Math.sqrt(w);
    } else
      return w <= 2e3 ? t[w | 0] : Math.sqrt(w);
  }, p: (w, t) => {
    const i = w - t;
    return i < 0.5 && i > -0.5;
  }, q: (w, t) => {
    const i = w - t;
    return i < 5e-8 && i > -5e-8;
  }, zi: (w, t, i, e, s, n, o) => {
    s <= 0 && (s = 1e-6);
    let r = 0, l = 0, h = 0, a = 0;
    if (w < i ? (l = w, r = i) : (l = i, r = w), t < e ? (a = t, h = e) : (a = e, h = t), w === i)
      return a <= o && o <= h && w - s <= n && n <= w + s;
    if (t === e)
      return l <= n && n <= r && t - s <= o && o <= t + s;
    const f = r + s, c = l - s;
    if (c <= n && n <= f) {
      const u = h + s, d = a - s;
      if (d <= o && o <= u)
        if (f - c > u - d)
          if (w - i > s || i - w > s) {
            const g = (e - t) / (i - w) * (n - w) + t;
            if (g - s <= o && o <= g + s)
              return true;
          } else
            return true;
        else if (t - e > s || e - t > s) {
          const g = (i - w) / (e - t) * (o - t) + w;
          if (g - s <= n && n <= g + s)
            return true;
        } else
          return true;
    }
    return false;
  }, Aw: (w, t, i, e, s, n, o, r, l, h, a, f) => {
    if (!Geo.zi(w, t, o, r, f, i, e) || !Geo.zi(w, t, o, r, f, s, n)) {
      const c = (w + i) / 2, u = (t + e) / 2, d = (i + s) / 2, m = (e + n) / 2, g = (s + o) / 2, p = (n + r) / 2, y = (c + d) / 2, x = (u + m) / 2, b = (d + g) / 2, k = (m + p) / 2, S = (y + b) / 2, M = (x + k) / 2;
      return Geo.Aw(w, t, c, u, y, x, S, M, l, h, a, f) || Geo.Aw(S, M, b, k, g, p, o, r, l, h, a, f);
    } else
      return Geo.zi(w, t, o, r, f, h, a);
  }, mC: (w, t, i, e, s, n, o, r, l) => {
    const h = (w + i) / 2, a = (t + e) / 2, f = (i + s) / 2, c = (e + n) / 2, u = (s + o) / 2, d = (n + r) / 2, m = (h + f) / 2, g = (a + c) / 2, p = (f + u) / 2, y = (c + d) / 2;
    return l.e((m + p) / 2, (g + y) / 2), l;
  }, ED: (w, t, i, e, s, n, o, r) => {
    const l = (w + i) / 2, h = (t + e) / 2, a = (i + s) / 2, f = (e + n) / 2, c = (s + o) / 2, u = (n + r) / 2, d = (l + a) / 2, m = (h + f) / 2, g = (a + c) / 2, p = (f + u) / 2;
    return Point2.direction(d, m, g, p);
  }, gu: (w, t, i, e, s, n, o, r, l, h) => {
    if (!Geo.zi(w, t, o, r, l, i, e) || !Geo.zi(w, t, o, r, l, s, n)) {
      const a = (w + i) / 2, f = (t + e) / 2, c = (i + s) / 2, u = (e + n) / 2, d = (s + o) / 2, m = (n + r) / 2, g = (a + c) / 2, p = (f + u) / 2, y = (c + d) / 2, x = (u + m) / 2, b = (g + y) / 2, k = (p + x) / 2;
      Geo.gu(w, t, a, f, g, p, b, k, l, h), Geo.gu(b, k, y, x, d, m, o, r, l, h);
    } else
      h.unionNoCheck(w, t, 0, 0), h.unionNoCheck(o, r, 0, 0);
    return h;
  }, Hn: (w, t, i, e, s, n, o, r, l, h) => {
    if (!Geo.zi(w, t, o, r, l, i, e) || !Geo.zi(w, t, o, r, l, s, n)) {
      const a = (w + i) / 2, f = (t + e) / 2, c = (i + s) / 2, u = (e + n) / 2, d = (s + o) / 2, m = (n + r) / 2, g = (a + c) / 2, p = (f + u) / 2, y = (c + d) / 2, x = (u + m) / 2, b = (g + y) / 2, k = (p + x) / 2;
      Geo.Hn(w, t, a, f, g, p, b, k, l, h), Geo.Hn(b, k, y, x, d, m, o, r, l, h);
    } else
      h.length === 0 && (h.push(w), h.push(t)), h.push(o), h.push(r);
    return h;
  }, vk: (w, t, i, e, s, n, o, r, l, h) => {
    if (Geo.zi(w, t, s, n, h, i, e))
      return Geo.zi(w, t, s, n, h, r, l);
    {
      const a = (w + i) / 2, f = (t + e) / 2, c = (i + s) / 2, u = (e + n) / 2, d = (a + c) / 2, m = (f + u) / 2;
      return Geo.vk(w, t, a, f, d, m, o, r, l, h) || Geo.vk(d, m, c, u, s, n, o, r, l, h);
    }
  }, eE: (w, t, i, e, s, n, o) => {
    const r = (w + i) / 2, l = (t + e) / 2, h = (i + s) / 2, a = (e + n) / 2;
    return o.e((r + h) / 2, (l + a) / 2), o;
  }, qk: (w, t, i, e, s, n, o, r) => {
    if (Geo.zi(w, t, s, n, o, i, e))
      r.unionNoCheck(w, t, 0, 0), r.unionNoCheck(s, n, 0, 0);
    else {
      const l = (w + i) / 2, h = (t + e) / 2, a = (i + s) / 2, f = (e + n) / 2, c = (l + a) / 2, u = (h + f) / 2;
      Geo.qk(w, t, l, h, c, u, o, r), Geo.qk(c, u, a, f, s, n, o, r);
    }
    return r;
  }, Wg: (w, t, i, e, s, n, o, r) => {
    if (Geo.zi(w, t, s, n, o, i, e))
      r.length === 0 && (r.push(w), r.push(t)), r.push(s), r.push(n);
    else {
      const l = (w + i) / 2, h = (t + e) / 2, a = (i + s) / 2, f = (e + n) / 2, c = (l + a) / 2, u = (h + f) / 2;
      Geo.Wg(w, t, l, h, c, u, o, r), Geo.Wg(c, u, a, f, s, n, o, r);
    }
    return r;
  }, jg: (w, t, i, e, s, n, o, r, l, h, a, f, c, u) => {
    if (!Geo.zi(w, t, o, r, c, i, e) || !Geo.zi(w, t, o, r, c, s, n)) {
      const d = (w + i) / 2, m = (t + e) / 2, g = (i + s) / 2, p = (e + n) / 2, y = (s + o) / 2, x = (n + r) / 2, b = (d + g) / 2, k = (m + p) / 2, S = (g + y) / 2, M = (p + x) / 2, A = (b + S) / 2, C = (k + M) / 2;
      let P = 1 / 0, N = false, T = 0, L = 0;
      if (Geo.jg(w, t, d, m, b, k, A, C, l, h, a, f, c, u)) {
        const D = (u.x - l) * (u.x - l) + (u.y - h) * (u.y - h);
        D < P && (P = D, N = true, T = u.x, L = u.y);
      }
      if (Geo.jg(A, C, S, M, y, x, o, r, l, h, a, f, c, u)) {
        const D = (u.x - l) * (u.x - l) + (u.y - h) * (u.y - h);
        D < P && (P = D, N = true, T = u.x, L = u.y);
      }
      return N && (u.x = T, u.y = L), N;
    } else {
      if (!Geo.uu(w, t, o, r, l, h, a, f))
        return false;
      const d = (w - o) * (h - f) - (t - r) * (l - a);
      if (d === 0)
        return false;
      const m = ((w * r - t * o) * (l - a) - (w - o) * (l * f - h * a)) / d, g = ((w * r - t * o) * (h - f) - (t - r) * (l * f - h * a)) / d;
      return u.e(m, g), true;
    }
  }, Jg: (w, t, i, e, s, n, o, r, l, h, a, f, c) => {
    let u = 0;
    if (!Geo.zi(w, t, o, r, c, i, e) || !Geo.zi(w, t, o, r, c, s, n)) {
      const d = (w + i) / 2, m = (t + e) / 2, g = (i + s) / 2, p = (e + n) / 2, y = (s + o) / 2, x = (n + r) / 2, b = (d + g) / 2, k = (m + p) / 2, S = (g + y) / 2, M = (p + x) / 2, A = (b + S) / 2, C = (k + M) / 2;
      u += Geo.Jg(w, t, d, m, b, k, A, C, l, h, a, f, c), u += Geo.Jg(A, C, S, M, y, x, o, r, l, h, a, f, c);
    } else {
      const d = (w - o) * (h - f) - (t - r) * (l - a);
      if (d === 0)
        return u;
      const m = ((w * r - t * o) * (l - a) - (w - o) * (l * f - h * a)) / d, g = ((w * r - t * o) * (h - f) - (t - r) * (l * f - h * a)) / d;
      if (m >= a)
        return u;
      let p = 0, y = 0;
      if ((l > a ? l - a : a - l) < (h > f ? h - f : f - h)) {
        if (t < r ? (p = t, y = r) : (p = r, y = t), g < p || g > y)
          return u;
      } else if (w < o ? (p = w, y = o) : (p = o, y = w), m < p || m > y)
        return u;
      d > 0 ? u++ : d < 0 && u--;
    }
    return u;
  }, Sl: (w, t, i, e, s, n, o) => {
    if (Geo.q(w, i)) {
      let r = 0, l = 0;
      t < e ? (r = t, l = e) : (r = e, l = t);
      const h = n;
      return h < r ? (o.e(w, r), false) : h > l ? (o.e(w, l), false) : (o.e(w, h), true);
    } else if (Geo.q(t, e)) {
      let r = 0, l = 0;
      w < i ? (r = w, l = i) : (r = i, l = w);
      const h = s;
      return h < r ? (o.e(r, t), false) : h > l ? (o.e(l, t), false) : (o.e(h, t), true);
    } else {
      const r = (i - w) * (i - w) + (e - t) * (e - t), l = ((w - s) * (w - i) + (t - n) * (t - e)) / r;
      if (l < -5e-6)
        return o.e(w, t), false;
      if (l > 1.000005)
        return o.e(i, e), false;
      {
        const h = w + l * (i - w), a = t + l * (e - t);
        return o.e(h, a), true;
      }
    }
  }, vn: (w, t, i, e, s, n, o, r, l) => {
    if (Geo.p(w, i) && Geo.p(t, e))
      return l.e(w, t), false;
    if (Geo.q(s, o)) {
      if (Geo.q(w, i))
        return Geo.Sl(w, t, i, e, s, n, l), false;
      {
        const a = (e - t) / (i - w) * (s - w) + t;
        return Geo.Sl(w, t, i, e, s, a, l);
      }
    } else {
      const h = (r - n) / (o - s);
      if (Geo.q(w, i)) {
        const a = h * (w - s) + n;
        let f = 0, c = 0;
        return t < e ? (f = t, c = e) : (f = e, c = t), a < f ? (l.e(w, f), false) : a > c ? (l.e(w, c), false) : (l.e(w, a), true);
      } else {
        const a = (e - t) / (i - w);
        if (Geo.q(h, a))
          return Geo.Sl(w, t, i, e, s, n, l), false;
        {
          const f = (a * w - h * s + n - t) / (a - h);
          if (Geo.q(a, 0)) {
            let c = 0, u = 0;
            return w < i ? (c = w, u = i) : (c = i, u = w), f < c ? (l.e(c, t), false) : f > u ? (l.e(u, t), false) : (l.e(f, t), true);
          } else {
            const c = a * (f - w) + t;
            return Geo.Sl(w, t, i, e, f, c, l);
          }
        }
      }
    }
  }, sE: (w, t, i, e, s) => Geo.vn(i.x, i.y, e.x, e.y, w.x, w.y, t.x, t.y, s), nE: (w, t, i, e, s, n, o, r, l, h) => {
    let a = 1 / 0;
    function f(S, M) {
      const A = (S - w) * (S - w) + (M - t) * (M - t);
      A < a && (a = A, l.e(S, M));
    }
    f(l.x, l.y);
    let c = 0, u = 0, d = 0, m = 0;
    s < o ? (c = s, u = o) : (c = o, u = s), n < r ? (d = s, m = o) : (d = o, m = s);
    const g = u - c, p = m - d, y = g / 2 + h, x = p / 2 + h, b = (s + o) / 2, k = (n + r) / 2;
    if (y === 0 || x === 0)
      return l;
    if ((i > w ? i - w : w - i) < 0.5) {
      const S = 1 - (i - b) * (i - b) / (y * y);
      if (S < 0)
        return l;
      const M = Math.sqrt(S), A = x * M + k, C = -x * M + k;
      f(i, A), f(i, C);
    } else {
      const S = (e - t) / (i - w), M = 1 / (y * y) + S * S / (x * x), A = 2 * S * (t - S * w) / (x * x) - 2 * S * k / (x * x) - 2 * b / (y * y), C = 2 * S * w * k / (x * x) - 2 * t * k / (x * x) + k * k / (x * x) + b * b / (y * y) - 1 + (t - S * w) * (t - S * w) / (x * x), P = A * A - 4 * M * C;
      if (P < 0)
        return l;
      const N = Math.sqrt(P), T = (-A + N) / (2 * M);
      f(T, S * T - S * w + t);
      const L = (-A - N) / (2 * M);
      f(L, S * L - S * w + t);
    }
    return l;
  }, Ml: (w, t, i, e, s, n, o, r, l) => {
    let h = 1e21, a = w, f = t;
    if (Geo.vn(w, t, w, e, s, n, o, r, l)) {
      const c = (l.x - s) * (l.x - s) + (l.y - n) * (l.y - n);
      c < h && (h = c, a = l.x, f = l.y);
    }
    if (Geo.vn(i, t, i, e, s, n, o, r, l)) {
      const c = (l.x - s) * (l.x - s) + (l.y - n) * (l.y - n);
      c < h && (h = c, a = l.x, f = l.y);
    }
    if (Geo.vn(w, t, i, t, s, n, o, r, l)) {
      const c = (l.x - s) * (l.x - s) + (l.y - n) * (l.y - n);
      c < h && (h = c, a = l.x, f = l.y);
    }
    if (Geo.vn(w, e, i, e, s, n, o, r, l)) {
      const c = (l.x - s) * (l.x - s) + (l.y - n) * (l.y - n);
      c < h && (h = c, a = l.x, f = l.y);
    }
    return l.e(a, f), h < 1e21;
  }, Lw: (w, t, i) => Geo.hC(w.x, w.y, w.width, w.height, t.x, t.y, i.x, i.y), hC: (w, t, i, e, s, n, o, r) => {
    const l = w, h = w + i, a = t, f = t + e;
    if (s === o) {
      let c = 0, u = 0;
      return n < r ? (c = n, u = r) : (c = r, u = n), l <= s && s <= h && c <= f && u >= a;
    }
    if (n === r) {
      let c = 0, u = 0;
      return s < o ? (c = s, u = o) : (c = o, u = s), a <= n && n <= f && c <= h && u >= l;
    }
    return !!(Rect2.contains(w, t, i, e, s, n) || Rect2.contains(w, t, i, e, o, r) || Geo.uu(l, a, h, a, s, n, o, r) || Geo.uu(h, a, h, f, s, n, o, r) || Geo.uu(h, f, l, f, s, n, o, r) || Geo.uu(l, f, l, a, s, n, o, r));
  }, uu: (w, t, i, e, s, n, o, r) => w === i && t === e && s === o && n === r ? w === s && t === n : Geo.cu(w, t, i, e, s, n) * Geo.cu(w, t, i, e, o, r) <= 0 && Geo.cu(s, n, o, r, w, t) * Geo.cu(s, n, o, r, i, e) <= 0, cu: (w, t, i, e, s, n) => {
    const o = i - w, r = e - t;
    let l = s - w, h = n - t, a = l * r - h * o;
    return a === 0 && (a = l * o + h * r, a > 0 && (l -= o, h -= r, a = l * o + h * r, a < 0 && (a = 0))), a;
  }, Zg: (w) => (w < 0 && (w += 360), w >= 360 && (w -= 360), w), pC: (w, t, i, e, s, n) => {
    const o = Math.PI;
    n || (e = e * (o / 180), s = s * (o / 180));
    const r = e > s ? -1 : 1, l = 1e-5, h = o * 2, a = [], f = o / 2;
    let c = e, u = Math.min(h, Math.abs(s - e));
    if (u < l) {
      const d = c + r * Math.min(u, f), m = w + i * Math.cos(c), g = t + i * Math.sin(c), p = w + i * Math.cos(d), y = t + i * Math.sin(d), x = (m + p) / 2, b = (g + y) / 2;
      return a.push([m, g, x, b, x, b, p, y]), a;
    }
    for (; u > l; ) {
      const d = c + r * Math.min(u, f);
      a.push(Geo.VD(i, c, d, w, t)), u -= Math.abs(d - c), c = d;
    }
    return a;
  }, VD: (w, t, i, e, s) => {
    const n = (i - t) / 2, o = w * Math.cos(n), r = w * Math.sin(n), l = o, h = -r, a = l * l + h * h, f = a + l * o + h * r, c = 4 / 3 * (Math.sqrt(2 * a * f) - f) / (l * r - h * o), u = l - c * h, d = h + c * l, m = u, g = -d, p = n + t, y = Math.cos(p), x = Math.sin(p);
    return [e + w * Math.cos(t), s + w * Math.sin(t), e + u * y - d * x, s + u * x + d * y, e + m * y - g * x, s + m * x + g * y, e + w * Math.cos(i), s + w * Math.sin(i)];
  }, vg: (w, t, i, e, s, n, o) => {
    const r = s, l = n, h = Math.floor((w - i) / r) * r + i, a = Math.floor((t - e) / l) * l + e;
    let f = h;
    h + r - w < r / 2 && (f = h + r);
    let c = a;
    return a + l - t < l / 2 && (c = a + l), o.e(f, c), o;
  }, yC: (w, t) => {
    let i = Math.max(w, t), e = Math.min(w, t), s = 1, n = 1;
    do
      s = i % e, n = e, i = e, e = s;
    while (s > 0);
    return n;
  }, BD: (w, t, i, e) => {
    const s = i < 0, n = e < 0;
    let o = 0, r = 0, l = 0;
    w < t ? (r = 1, l = 0) : (r = 0, l = 1);
    let h = 0, a = 0, f = 0, c = 0;
    return o = r, h = o === 0 ? w : t, f = o === 0 ? i : e, (o === 0 ? s : n) && (f = -f), o = l, a = o === 0 ? w : t, c = o === 0 ? i : e, (o === 0 ? s : n) && (c = -c), Geo.zD(h, a, f, c, 0, 0);
  }, zD: (w, t, i, e, s, n) => {
    let o = 0;
    if (e > 0)
      if (i > 0) {
        const r = w * w, l = t * t, h = w * i, a = t * e;
        let f = -l + a, c = -l + Math.sqrt(h * h + a * a), u = f;
        const d = 9999999999;
        for (let p = 0; p < d && (u = 0.5 * (f + c), !(u === f || u === c)); ++p) {
          const y = h / (u + r), x = a / (u + l), b = y * y + x * x - 1;
          if (b > 0)
            f = u;
          else if (b < 0)
            c = u;
          else
            break;
        }
        s = r * i / (u + r), n = l * e / (u + l);
        const m = s - i, g = n - e;
        o = Math.sqrt(m * m + g * g);
      } else
        s = 0, n = t, o = Math.abs(e - t);
    else {
      const r = w * w - t * t, l = w * i;
      if (l < r) {
        const h = l / r, a = h * h;
        s = w * h, n = t * Math.sqrt(Math.abs(1 - a));
        const f = s - i;
        o = Math.sqrt(f * f + n * n);
      } else
        s = w, n = 0, o = Math.abs(i - w);
    }
    return o;
  }, qn: new PropertyCollection(), $g: new PropertyCollection(), yr: new PropertyCollection(), wr: 0, Qg: 100 };
  Geo.za = Geo.OD;
  var GeometryType2 = ((w) => (w[w.Line = 1] = "Line", w[w.Rectangle = 2] = "Rectangle", w[w.Ellipse = 3] = "Ellipse", w[w.Path = 4] = "Path", w))(GeometryType2 || {}), GeometryStretch2 = ((w) => (w[w.None = 0] = "None", w[w.Default = 1] = "Default", w[w.Fill = 2] = "Fill", w[w.Uniform = 6] = "Uniform", w))(GeometryStretch2 || {});
  const _Geometry = class _Geometry {
    constructor(t) {
      __publicField(this, "l");
      __publicField(this, "_g");
      __publicField(this, "tm");
      __publicField(this, "af");
      __publicField(this, "mu");
      __publicField(this, "pu");
      __publicField(this, "Wn");
      __publicField(this, "jn");
      __publicField(this, "Jn");
      __publicField(this, "nt");
      __publicField(this, "Ae");
      __publicField(this, "Le");
      __publicField(this, "ne");
      __publicField(this, "oe");
      __publicField(this, "zs");
      __publicField(this, "ff");
      __publicField(this, "cf");
      Debug && arguments.length > 1 && Util.n("Geometry constructor can take at most one optional argument, the Geometry type."), GSet2.ji(this), this.l = 2, t === void 0 ? t = 4 : Debug && Util.it(t, GeometryType2, "GeometryType"), this.nt = t, this.Ae = 0, this.Le = 0, this.ne = 0, this.oe = 0, t === 4 ? this.zs = new List2() : this.zs = _Geometry.Tw, this._g = this.zs.mt, this.tm = new Rect2().w(), this.af = null, this.mu = null, this.pu = NaN, this.Wn = Spot2.TopLeft, this.jn = Spot2.BottomRight, this.ff = NaN, this.cf = NaN, this.Jn = 2;
    }
    copy() {
      const t = new _Geometry();
      if (t.l = this.l & -2, t.nt = this.nt, t.Ae = this.Ae, t.Le = this.Le, t.ne = this.ne, t.oe = this.oe, this.nt === 4) {
        const i = this.zs.h, e = t.zs;
        for (let s = 0; s < i.length; s++) {
          const n = i[s];
          e.add(n.copy());
        }
        t.zs = e;
      } else
        t.zs = this.zs;
      return t._g = this._g, t.tm.c(this.tm), t.af = this.af, t.mu = this.mu, t.pu = this.pu, t.Wn = this.Wn.L(), t.jn = this.jn.L(), t.ff = this.ff, t.cf = this.cf, t.Jn = this.Jn, t;
    }
    get f() {
      return (this.l & 1) !== 0;
    }
    set f(t) {
      t ? this.l |= 1 : this.l &= -2;
    }
    get Nt() {
      return (this.l & 2) !== 0;
    }
    set Nt(t) {
      t ? this.l |= 2 : this.l &= -3;
    }
    rt() {
      return this.w(), Object.freeze(this), this;
    }
    w() {
      if (this.f = true, this.type !== 4)
        return this;
      const t = this.figures;
      t.w();
      for (const i of t)
        i.w();
      return this;
    }
    ut() {
      if (Object.isFrozen(this) && Util.n("cannot thaw constant: " + this), this.f = false, this.type !== 4)
        return this;
      const t = this.figures;
      t.ut();
      for (const i of t)
        i.ut();
      return this;
    }
    equalsApprox(t) {
      if (!(t instanceof _Geometry))
        return false;
      if (this.type !== t.type)
        return this.type === 1 && t.type === 4 ? this.wC(t) : t.type === 1 && this.type === 4 ? t.wC(this) : false;
      if (this.type === 4) {
        const i = this.figures.h, e = t.figures.h, s = i.length;
        if (s !== e.length)
          return false;
        for (let n = 0; n < s; n++) {
          const o = i[n], r = e[n];
          if (!o.equalsApprox(r))
            return false;
        }
        return true;
      } else
        return Geo.p(this.startX, t.startX) && Geo.p(this.startY, t.startY) && Geo.p(this.endX, t.endX) && Geo.p(this.endY, t.endY);
    }
    wC(t) {
      if (this.type !== 1 || t.type !== 4)
        return false;
      if (t.figures.count === 1) {
        const i = t.figures.elt(0);
        if (i.segments.count === 1 && Geo.p(this.startX, i.startX) && Geo.p(this.startY, i.startY)) {
          const e = i.segments.elt(0);
          if (e.type === 2 && Geo.p(this.endX, e.endX) && Geo.p(this.endY, e.endY))
            return true;
        }
      }
      return false;
    }
    static stringify(t) {
      return t.toString();
    }
    static stringifyFixed(t) {
      return Util.t(t, "number", _Geometry, "stringifyFixed:digits"), (i) => i.toString(t);
    }
    ci(t) {
      t in GeometryType2 ? this.type = t : Util.gr(this, t);
    }
    toString(t) {
      t === void 0 && (t = -1);
      const i = (s) => s === 0 ? "0" : s.toFixed(t);
      let e;
      switch (this.type) {
        case 1:
          return t < 0 ? "M" + this.startX.toString() + " " + this.startY.toString() + "L" + this.endX.toString() + " " + this.endY.toString() : "M" + i(this.startX) + " " + i(this.startY) + "L" + i(this.endX) + " " + i(this.endY);
        case 2:
          return e = new Rect2(this.startX, this.startY, 0, 0), e.union(this.endX, this.endY, 0, 0), t < 0 ? "M" + e.x.toString() + " " + e.y.toString() + "H" + e.right.toString() + "V" + e.bottom.toString() + "H" + e.left.toString() + "z" : "M" + i(e.x) + " " + i(e.y) + "H" + i(e.right) + "V" + i(e.bottom) + "H" + i(e.left) + "z";
        case 3:
          if (e = new Rect2(this.startX, this.startY, 0, 0), e.union(this.endX, this.endY, 0, 0), t < 0) {
            const r = e.left.toString() + " " + (e.y + e.height / 2).toString(), l = e.right.toString() + " " + (e.y + e.height / 2).toString();
            return "M" + r + "A" + (e.width / 2).toString() + " " + (e.height / 2).toString() + " 0 0 1 " + l + "A" + (e.width / 2).toString() + " " + (e.height / 2).toString() + " 0 0 1 " + r;
          } else {
            const r = i(e.left) + " " + i(e.y + e.height / 2), l = i(e.right) + " " + i(e.y + e.height / 2);
            return "M" + r + "A" + i(e.width / 2) + " " + i(e.height / 2) + " 0 0 1 " + l + "A" + i(e.width / 2) + " " + i(e.height / 2) + " 0 0 1 " + r;
          }
        case 4:
          let s = "";
          const n = this.figures.h, o = n.length;
          for (let r = 0; r < o; r++) {
            const l = n[r];
            r > 0 && (s += " x "), l.isFilled && (s += "F "), s += l.toString(t);
          }
          return s;
        default:
          return GeometryType2[this.type];
      }
    }
    static fillPath(t) {
      typeof t != "string" && Util.Bi(t, "string", _Geometry, "fillPath:str");
      const i = t.split(/[Xx]/), e = i.length;
      let s = "";
      for (let n = 0; n < e; n++) {
        const o = i[n];
        if (o.match(/[Ff]/) !== null) {
          n === 0 ? s += o : s += "X" + (o[0] === " " ? "" : " ") + o;
          continue;
        }
        s += (n === 0 ? "" : "X ") + "F" + (o[0] === " " ? "" : " ") + o;
      }
      return s;
    }
    static parse(t, i) {
      i === void 0 && (i = false), typeof t != "string" && Util.Bi(t, "string", _Geometry, "parse:str");
      const e = new RegExp("([" + _Geometry.im + "])([" + _Geometry.im + "])", "gm"), s = new RegExp("([" + _Geometry.im + "])([^s])", "gm"), n = new RegExp("([^s])([" + _Geometry.im + "])", "gm");
      t = t.replace(/,/gm, " "), t = t.replace(e, "$1 $2"), t = t.replace(e, "$1 $2"), t = t.replace(s, "$1 $2"), t = t.replace(n, "$1 $2"), t = t.replace(/([0-9])([+\-])/gm, "$1 $2"), t = t.replace(/[\s\r\t\n]+/gm, " "), t = t.replace(/^\s+|\s+$/g, "");
      const o = t.split(" ");
      for (let L = 0; L < o.length; L++) {
        const D = o[L];
        if (D.match(/(\.[0-9]*)(\.)/gm) !== null) {
          const F = Util.ct();
          let R = "", I = false;
          for (let O = 0; O < D.length; O++) {
            const B = D[O];
            B === "." && !I ? (I = true, R += B) : B === "." ? (F.push(R), R = ".") : R += B;
          }
          F.push(R), o.splice(L, 1);
          for (let O = 0; O < F.length; O++)
            o.splice(L + O, 0, F[O]);
          L += F.length - 1, Util.ot(F);
        }
      }
      let r = -1, l = "", h = "";
      const a = new Point2(0, 0), f = new Point2(0, 0), c = new Point2(0, 0);
      let u = true;
      function d() {
        return r >= b - 1 || o[r + 1].match(N) !== null ? true : (u = false, false);
      }
      function m() {
        return r++, o[r];
      }
      function g(L) {
        let D = parseFloat(m()), F = parseFloat(m());
        l === l.toLowerCase() && (D = c.x + D, F = c.y + F), L.e(D, F);
      }
      function p() {
        return g(c), c;
      }
      function y() {
        return g(f), f;
      }
      function x() {
        const L = h.toLowerCase();
        return L === "c" || L === "s" || L === "q" || L === "t" ? new Point2(2 * c.x - f.x, 2 * c.y - f.y) : new Point2(c.x, c.y);
      }
      const b = o.length, k = GeoStream.xC(null);
      let S = false, M = false, A = false, C = true, P = null;
      const N = new RegExp("[" + _Geometry.im + "]");
      for (; !(r >= b - 1); ) {
        if (h = l, l = m(), l === "")
          continue;
        u = true;
        let L = false;
        switch (l.toUpperCase()) {
          case "X":
            C = true, S = false, M = false;
            break;
          case "M":
            for (P = p(), k.Ai === null || C === true ? (k.yu(P.x, P.y, S, false, !M, A), C = false) : k.XD(P.x, P.y), a.c(c); !d(); )
              P = p(), k.xr(P.x, P.y);
            break;
          case "L":
            for (; !d(); )
              P = p(), k.xr(P.x, P.y);
            u && (L = true);
            break;
          case "H":
            for (; !d(); )
              c.e((l === l.toLowerCase() ? c.x : 0) + parseFloat(m()), c.y), k.xr(c.x, c.y);
            break;
          case "V":
            for (; !d(); )
              c.e(c.x, (l === l.toLowerCase() ? c.y : 0) + parseFloat(m())), k.xr(c.x, c.y);
            u && (L = true);
            break;
          case "C":
            for (; !d(); ) {
              const D = new Point2();
              g(D);
              const F = y(), R = p();
              k.br(D.x, D.y, F.x, F.y, R.x, R.y);
            }
            u && (L = true);
            break;
          case "S":
            for (; !d(); ) {
              const D = x(), F = y(), R = p();
              k.br(D.x, D.y, F.x, F.y, R.x, R.y);
            }
            u && (L = true);
            break;
          case "Q":
            for (; !d(); ) {
              const D = y(), F = p();
              k.Dw(D.x, D.y, F.x, F.y);
            }
            u && (L = true);
            break;
          case "T":
            for (; !d(); ) {
              const D = x();
              f.c(D);
              const F = p();
              k.Dw(D.x, D.y, F.x, F.y), f.c(F);
            }
            u && (L = true);
            break;
          case "B":
            for (; !d(); ) {
              const D = parseFloat(m()), F = parseFloat(m());
              let R = parseFloat(m()), I = parseFloat(m());
              const O = parseFloat(m());
              let B = O, K = false;
              d() || (B = parseFloat(m()), d() || (K = parseFloat(m()) !== 0)), l === l.toLowerCase() && (R += c.x, I += c.y), k.YD(D, F, R, I, O, B, K);
            }
            u && (L = true);
            break;
          case "A":
            for (; !d(); ) {
              const D = Math.abs(parseFloat(m())), F = Math.abs(parseFloat(m())), R = parseFloat(m());
              let I = false, O = false, B = 0, K = 0;
              const V = m();
              V.length === 1 ? (I = !!parseFloat(V), O = !!parseFloat(m()), B = parseFloat(m()), K = parseFloat(m())) : V.length === 2 ? (I = !!parseFloat(V[0]), O = !!parseFloat(V[1]), B = parseFloat(m()), K = parseFloat(m())) : (I = !!parseFloat(V[0]), O = !!parseFloat(V[1]), B = parseFloat(V.slice(2)), K = parseFloat(m())), l === l.toLowerCase() && (B = c.x + B, K = c.y + K), c.e(B, K), k.KD(D, F, R, I, O, B, K);
            }
            u && (L = true);
            break;
          case "Z":
            k.UD(), c.c(a);
            break;
          case "F": {
            let D = "", F = 1;
            for (; o[r + F]; ) {
              if (o[r + F] === "0") {
                A = true, F++;
                continue;
              }
              if (o[r + F].match(/[Uu]/) !== null) {
                F++;
                continue;
              }
              if (o[r + F].match(N) === null) {
                F++;
                continue;
              }
              D = o[r + F];
              break;
            }
            D.match(/[Mm]/) ? S = true : k.GD();
            break;
          }
          case "U": {
            let D = "", F = 1;
            for (; o[r + F]; ) {
              if (o[r + F].match(/[Ff]/) !== null) {
                F++;
                continue;
              }
              if (o[r + F].match(N) === null) {
                F++;
                continue;
              }
              D = o[r + F];
              break;
            }
            D.match(/[Mm]/) ? M = true : k.HD(false);
            break;
          }
          default:
            if (l === "0" || l === "1")
              break;
            Util.ft("Unknown geometry command: " + l);
            break;
        }
        if (L) {
          Util.ft(`Bad geometry command: ${l}, next token: ${m()},
string: ${t}`);
          break;
        }
      }
      const T = k.em;
      if (GeoStream.bC(k), i) {
        const L = T.figures.iterator;
        for (; L.next(); ) {
          const D = L.value;
          D.isFilled = true;
        }
      }
      return T;
    }
    static kC(t, i) {
      const e = t.length, s = Point2.a();
      for (let n = 0; n < e; n++) {
        const o = t[n];
        s.x = o[0], s.y = o[1], i.Pt(s), o[0] = s.x, o[1] = s.y, s.x = o[2], s.y = o[3], i.Pt(s), o[2] = s.x, o[3] = s.y, s.x = o[4], s.y = o[5], i.Pt(s), o[4] = s.x, o[5] = s.y, s.x = o[6], s.y = o[7], i.Pt(s), o[6] = s.x, o[7] = s.y;
      }
      Point2.o(s);
    }
    Wk() {
      if (this.Nt)
        return true;
      if (this.type === 4) {
        const t = this.figures;
        if (this._g !== t.mt)
          return true;
        const i = this.figures.h, e = i.length;
        for (let s = 0; s < e; s++)
          if (i[s].Wk())
            return true;
      }
      return false;
    }
    Fw() {
      if (this.Nt = false, this.af = null, this.mu = null, this.pu = NaN, this.type === 4) {
        const i = this.figures;
        this._g = i.mt;
        const e = this.figures.h, s = e.length;
        for (let n = 0; n < s; n++)
          e[n].vD();
      }
      const t = this.tm;
      t.ut(), isNaN(this.ff) || isNaN(this.cf) ? t.e(0, 0, 0, 0) : t.e(0, 0, this.ff, this.cf), this.SC(t, false), t.unionNoCheck(0, 0, 0, 0), t.w();
    }
    computeBoundsWithoutOrigin() {
      const t = new Rect2();
      return this.SC(t, true), t;
    }
    SC(t, i) {
      switch (this.type) {
        case 1:
        case 2:
        case 3:
          i ? t.e(this.Ae, this.Le, 0, 0) : t.unionNoCheck(this.Ae, this.Le, 0, 0), t.unionNoCheck(this.ne, this.oe, 0, 0);
          break;
        case 4:
          const e = this.figures, s = e.h, n = e.length;
          for (let o = 0; o < n; o++) {
            const r = s[o];
            i && o === 0 ? t.e(r.startX, r.startY, 0, 0) : t.unionNoCheck(r.startX, r.startY, 0, 0);
            const h = r.segments.h, a = h.length;
            let f = r.startX, c = r.startY;
            for (let u = 0; u < a; u++) {
              const d = h[u];
              switch (d.type) {
                case 2:
                case 1:
                  f = d.endX, c = d.endY, t.unionNoCheck(f, c, 0, 0);
                  break;
                case 3:
                  Geo.gu(f, c, d.point1X, d.point1Y, d.point2X, d.point2Y, d.endX, d.endY, 0.5, t), f = d.endX, c = d.endY;
                  break;
                case 4:
                  Geo.qk(f, c, d.point1X, d.point1Y, d.endX, d.endY, 0.5, t), f = d.endX, c = d.endY;
                  break;
                case 5:
                case 6:
                  const m = d.type === 5 ? d.Fo(r) : d.Kh(r, f, c), g = m.length;
                  if (g === 0) {
                    f = d.type === 5 ? d.centerX : d.endX, c = d.type === 5 ? d.centerY : d.endY, t.unionNoCheck(f, c, 0, 0);
                    break;
                  }
                  let p = null;
                  for (let y = 0; y < g; y++)
                    p = m[y], Geo.gu(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], 0.5, t);
                  p !== null && (f = p[6], c = p[7]);
                  break;
                default:
                  Util.n("Unknown Segment type: " + d.type);
              }
            }
          }
          break;
        default:
          Util.n("Unknown Geometry type: " + this.type);
      }
    }
    qD(t, i) {
      const e = this.bounds;
      let s = t / e.width, n = i / e.height;
      return isFinite(s) || (s = 1), isFinite(n) || (n = 1), s === 1 && n === 1 ? this : this.copy().scale(s, n);
    }
    normalize() {
      this.f && Util.O(this);
      const t = this.computeBoundsWithoutOrigin();
      return this.offset(-t.x, -t.y), new Point2(-t.x, -t.y);
    }
    offset(t, i) {
      return this.f && Util.O(this), Debug && (Util.r(t, _Geometry, "offset"), Util.r(i, _Geometry, "offset")), this.D(1, 0, 0, 1, t, i), this;
    }
    scale(t, i) {
      return this.f && Util.O(this), Debug && (Util.r(t, _Geometry, "scale:x"), Util.r(i, _Geometry, "scale:y"), t === 0 && Util.G(t, "scale must be non-zero", _Geometry, "scale:x"), i === 0 && Util.G(i, "scale must be non-zero", _Geometry, "scale:y")), this.D(t, 0, 0, i, 0, 0), this;
    }
    rotate(t, i, e) {
      this.f && Util.O(this), i === void 0 && (i = 0), e === void 0 && (e = 0), Debug && (Util.r(t, _Geometry, "rotate:angle"), Util.r(i, _Geometry, "rotate:x"), Util.r(e, _Geometry, "rotate:y"));
      const s = Transform.a();
      return s.ti(), s.ys(t, i, e), this.D(s.m11, s.m12, s.m21, s.m22, s.dx, s.dy), Transform.o(s), this;
    }
    D(t, i, e, s, n, o) {
      let r = 0, l = 0;
      switch (this.type) {
        case 1:
        case 2:
        case 3:
          r = this.Ae, l = this.Le, this.Ae = r * t + l * e + n, this.Le = r * i + l * s + o, r = this.ne, l = this.oe, this.ne = r * t + l * e + n, this.oe = r * i + l * s + o;
          break;
        case 4:
          const a = this.figures.h, f = a.length;
          for (let c = 0; c < f; c++) {
            const u = a[c];
            r = u.startX, l = u.startY, u.startX = r * t + l * e + n, u.startY = r * i + l * s + o;
            const m = u.segments.h, g = m.length;
            for (let p = 0; p < g; p++) {
              const y = m[p];
              switch (y.type) {
                case 2:
                case 1:
                  r = y.endX, l = y.endY, y.endX = r * t + l * e + n, y.endY = r * i + l * s + o;
                  break;
                case 3:
                  r = y.point1X, l = y.point1Y, y.point1X = r * t + l * e + n, y.point1Y = r * i + l * s + o, r = y.point2X, l = y.point2Y, y.point2X = r * t + l * e + n, y.point2Y = r * i + l * s + o, r = y.endX, l = y.endY, y.endX = r * t + l * e + n, y.endY = r * i + l * s + o;
                  break;
                case 4:
                  r = y.point1X, l = y.point1Y, y.point1X = r * t + l * e + n, y.point1Y = r * i + l * s + o, r = y.endX, l = y.endY, y.endX = r * t + l * e + n, y.endY = r * i + l * s + o;
                  break;
                case 5:
                  if (r = y.centerX, l = y.centerY, y.centerX = r * t + l * e + n, y.centerY = r * i + l * s + o, i !== 0) {
                    let x = Math.atan2(i, t) * 180 / Math.PI;
                    x < 0 && (x += 360), y.startAngle += x;
                  }
                  t < 0 && (y.startAngle = 180 - y.startAngle, y.sweepAngle = -y.sweepAngle), s < 0 && (y.startAngle = -y.startAngle, y.sweepAngle = -y.sweepAngle), y.radiusX *= Math.sqrt(t * t + e * e), y.radiusY !== void 0 && (y.radiusY *= Math.sqrt(i * i + s * s));
                  break;
                case 6:
                  if (r = y.endX, l = y.endY, y.endX = r * t + l * e + n, y.endY = r * i + l * s + o, y.radiusX === 0 || y.radiusY === 0)
                    break;
                  if (i !== 0) {
                    let x = Math.atan2(i, t) * 180 / Math.PI;
                    x < 0 && (x += 360), y.xAxisRotation += x;
                  }
                  t < 0 && (y.xAxisRotation = 180 - y.xAxisRotation, y.isClockwiseArc = !y.isClockwiseArc), s < 0 && (y.xAxisRotation = -y.xAxisRotation, y.isClockwiseArc = !y.isClockwiseArc), y.radiusX *= Math.sqrt(t * t + e * e), y.radiusY *= Math.sqrt(i * i + s * s);
                  break;
                default:
                  Util.n("Unknown Segment type: " + y.type);
              }
            }
          }
          break;
      }
      return this.Nt = true, this;
    }
    containsPoint(t, i) {
      i === void 0 && (i = 0);
      const e = this.Ae, s = this.Le, n = this.ne, o = this.oe;
      switch (this.type) {
        case 1:
          return Geo.zi(e, s, n, o, i, t.x, t.y);
        case 2: {
          const r = Math.min(e, n) - i, l = Math.min(s, o) - i, h = Math.abs(n - e) + i * 2, a = Math.abs(o - s) + i * 2, f = Rect2.H(r, l, h, a), c = f.containsPoint(t);
          return Rect2.o(f), c;
        }
        case 3: {
          let r = Math.min(e, n) - i, l = Math.min(s, o) - i;
          const h = Math.abs(n - e) + i * 2, a = Math.abs(o - s) + i * 2, f = h / 2, c = a / 2;
          return f <= 0 || c <= 0 ? false : (r = t.x - (r + f), l = t.y - (l + c), r * r / (f * f) + l * l / (c * c) <= 1);
        }
        case 4:
          return this.jk(t, i, true, false);
        default:
          return false;
      }
    }
    jk(t, i, e, s) {
      const n = t.x, o = t.y, r = this.bounds.x - 20, l = o;
      let h = 0, a = 0, f = 0, c = 0, u = 0, d = 0;
      const m = this.figures.h, g = m.length;
      for (let p = 0; p < g; p++) {
        const y = m[p], x = !y.isEvenOdd;
        if (y.isFilled) {
          if (e && y.Jk(n, o, i))
            return true;
        } else {
          if (y.Jk(n, o, s ? i : i + 2))
            return true;
          continue;
        }
        const b = y.segments;
        a = y.startX, f = y.startY;
        let k = a, S = f;
        const M = b.h;
        for (let A = 0; A <= b.length; A++) {
          let C, P;
          switch (A !== b.length ? (C = M[A], P = C.type, u = C.endX, d = C.endY) : (P = 2, u = k, d = S), P) {
            case 1: {
              const N = this.Rw(n, o, r, l, a, f, k, S);
              if (isNaN(N))
                return true;
              h += N, k = u, S = d;
              break;
            }
            case 2: {
              const N = this.Rw(n, o, r, l, a, f, u, d);
              if (isNaN(N))
                return true;
              h += N;
              break;
            }
            case 3:
              c = Geo.Jg(a, f, C.point1X, C.point1Y, C.point2X, C.point2Y, u, d, r, l, n, o, 0.5), h += c;
              break;
            case 4: {
              const N = (a + 2 * C.point1X) / 3, T = (f + 2 * C.point1Y) / 3, L = (C.point1X * 2 + u) / 3, D = (C.point1Y * 2 + d) / 3;
              c = Geo.Jg(a, f, N, T, L, D, u, d, r, l, n, o, 0.5), h += c;
              break;
            }
            case 5:
            case 6: {
              const N = C.type === 5 ? C.Fo(y) : C.Kh(y, a, f), T = N.length;
              if (T === 0) {
                const D = this.Rw(n, o, r, l, a, f, C.type === 5 ? C.centerX : C.endX, C.type === 5 ? C.centerY : C.endY);
                if (isNaN(D))
                  return true;
                h += D;
                break;
              }
              let L = null;
              for (let D = 0; D < T; D++) {
                if (L = N[D], D === 0) {
                  const F = this.Rw(n, o, r, l, a, f, L[0], L[1]);
                  if (isNaN(F))
                    return true;
                  h += F;
                }
                c = Geo.Jg(L[0], L[1], L[2], L[3], L[4], L[5], L[6], L[7], r, l, n, o, 0.5), h += c;
              }
              L !== null && (u = L[6], d = L[7]);
              break;
            }
            default:
              Util.n("Unknown Segment type: " + C.type);
          }
          a = u, f = d;
        }
        if (x) {
          if (h !== 0)
            return true;
        } else if (h % 2 !== 0)
          return true;
        h = 0;
      }
      return false;
    }
    Rw(t, i, e, s, n, o, r, l) {
      if (Geo.zi(n, o, r, l, 0.05, t, i))
        return NaN;
      const h = (t - e) * (o - l);
      if (h === 0)
        return 0;
      const a = ((t * s - i * e) * (n - r) - (t - e) * (n * l - o * r)) / h, f = (t * s - i * e) * (o - l) / h;
      if (a >= t)
        return 0;
      if ((n > r ? n - r : r - n) < (o > l ? o - l : l - o)) {
        if (o < l) {
          if (f < o || f > l)
            return 0;
        } else if (f < l || f > o)
          return 0;
      } else if (n < r) {
        if (a < n || a > r)
          return 0;
      } else if (a < r || a > n)
        return 0;
      return h > 0 ? 1 : -1;
    }
    MC(t, i, e) {
      const s = this.figures.h, n = s.length;
      for (let o = 0; o < n; o++)
        if (s[o].Jk(t, i, e))
          return true;
      return false;
    }
    getPointAlongPath(t, i) {
      if (t < 0 ? t = 0 : t > 1 && (t = 1), i === void 0 && (i = new Point2()), this.type === 1)
        return i.e(this.startX + t * (this.endX - this.startX), this.startY + t * (this.endY - this.startY)), i;
      const e = this.flattenedSegments, s = this.flattenedLengths, n = this.flattenedTotalLength, o = e.length, r = n * t;
      let l = 0;
      for (let h = 0; h < o; h++) {
        const a = s[h], f = a.length;
        for (let c = 0; c < f; c++) {
          const u = a[c];
          if (l + u >= r) {
            const d = r - l, m = u === 0 ? 0 : d / u, g = e[h], p = g[c * 2], y = g[c * 2 + 1], x = g[c * 2 + 2], b = g[c * 2 + 3];
            return i.e(p + (x - p) * m, y + (b - y) * m), i;
          }
          l += u;
        }
      }
      return i;
    }
    getAngleAlongPath(t) {
      if (t < 0 ? t = 0 : t > 1 && (t = 1), this.type === 1)
        return Math.atan2(this.endY - this.startY, this.endX - this.startX) * 180 / Math.PI;
      const i = this.flattenedSegments, e = this.flattenedLengths, s = this.flattenedTotalLength, n = i.length, o = s * t;
      let r = 0;
      for (let l = 0; l < n; l++) {
        const h = e[l], a = h.length;
        for (let f = 0; f < a; f++) {
          const c = h[f];
          if (r + c >= o) {
            const u = i[l], d = u[f * 2], m = u[f * 2 + 1], g = u[f * 2 + 2], p = u[f * 2 + 3];
            return Math.abs(g - d) < 1 && Math.abs(p - m) < 1 ? 0 : Math.abs(g - d) < 1 ? p - m >= 0 ? 90 : 270 : Math.abs(p - m) < 1 ? g - d >= 0 ? 0 : 180 : Math.atan2(p - m, g - d) * 180 / Math.PI;
          }
          r += c;
        }
      }
      return NaN;
    }
    getPointAndAngleAlongPath(t, i) {
      if (t < 0 ? t = 0 : t > 1 && (t = 1), i === void 0 && (i = []), i.length = 3, this.type === 1)
        return i[0] = this.startX + t * (this.endX - this.startX), i[1] = this.startY + t * (this.endY - this.startY), i[2] = Math.atan2(this.endY - this.startY, this.endX - this.startX) * 180 / Math.PI, i;
      const e = this.flattenedSegments, s = this.flattenedLengths, n = this.flattenedTotalLength, o = e.length, r = n * t;
      let l = 0;
      for (let h = 0; h < o; h++) {
        const a = s[h], f = a.length;
        for (let c = 0; c < f; c++) {
          const u = a[c];
          if (l + u >= r) {
            const d = r - l, m = u === 0 ? 0 : d / u, g = e[h], p = g[c * 2], y = g[c * 2 + 1], x = g[c * 2 + 2], b = g[c * 2 + 3];
            i[0] = p + (x - p) * m, i[1] = y + (b - y) * m;
            let k;
            return Math.abs(x - p) < 1 && Math.abs(b - y) < 1 ? k = 0 : Math.abs(x - p) < 1 ? k = b - y >= 0 ? 90 : 270 : Math.abs(b - y) < 1 ? k = x - p >= 0 ? 0 : 180 : k = Math.atan2(b - y, x - p) * 180 / Math.PI, i[2] = k, i;
          }
          l += u;
        }
      }
      return i;
    }
    getFractionForPoint(t) {
      if (this.type === 1) {
        const i = this.startX, e = this.startY, s = this.endX, n = this.endY;
        if (i === s && e === n)
          return 0;
        {
          const o = t.x, r = t.y;
          let l = 0, h = 0;
          if (i === s)
            return e < n ? (l = e, h = n) : (l = n, h = e), r <= l ? l === e ? 0 : 1 : r >= h ? h === e ? 0 : 1 : Math.abs(r - e) / (h - l);
          if (e === n)
            return i < s ? (l = i, h = s) : (l = s, h = i), o <= l ? l === i ? 0 : 1 : o >= h ? h === i ? 0 : 1 : Math.abs(o - i) / (h - l);
          {
            const a = (s - i) * (s - i) + (n - e) * (n - e), f = Point2.a();
            Geo.Sl(i, e, s, n, o, r, f);
            const c = f.x, u = f.y;
            return Point2.o(f), Math.sqrt(((c - i) * (c - i) + (u - e) * (u - e)) / a);
          }
        }
      } else if (this.type === 2) {
        const i = this.startX, e = this.startY, s = this.endX, n = this.endY;
        if (i === s && e === n)
          return 0;
        {
          const o = s - i, r = n - e, l = o * 2 + r * 2;
          let h = t.x, a = t.y;
          h = Math.min(Math.max(h, i), s), a = Math.min(Math.max(a, e), n);
          const f = Math.abs(h - i), c = Math.abs(h - s), u = Math.abs(a - e), d = Math.abs(a - n), m = Math.min(f, c, u, d);
          if (m === u)
            return h / l;
          if (m === c)
            return (o + a) / l;
          if (m === d)
            return (o * 2 + r - h) / l;
          if (m === f)
            return (o * 2 + r * 2 - a) / l;
        }
      } else {
        const i = this.flattenedSegments, e = this.flattenedLengths, s = this.flattenedTotalLength, n = Point2.a();
        let o = 1 / 0, r = 0, l = 0;
        const h = i.length;
        let a = 0, f = 0;
        for (let u = 0; u < h; u++) {
          const d = i[u], m = e[u], g = d.length;
          for (let p = 0; p < g; p += 2) {
            const y = d[p], x = d[p + 1];
            if (p === 0) {
              a = y, f = x;
              continue;
            }
            Geo.Sl(a, f, y, x, t.x, t.y, n);
            const b = (n.x - t.x) * (n.x - t.x) + (n.y - t.y) * (n.y - t.y);
            b < o && (o = b, r = l, r += Math.sqrt((n.x - a) * (n.x - a) + (n.y - f) * (n.y - f))), l += m[(p - 2) / 2], a = y, f = x;
          }
        }
        Point2.o(n);
        const c = r / s;
        return c < 0 ? 0 : c > 1 ? 1 : c;
      }
      return 0;
    }
    get flattenedSegments() {
      return this.PC(), this.af;
    }
    PC() {
      if (this.af === null) {
        const t = this.af = [], i = this.mu = [];
        this.WD(t, i);
      }
    }
    get flattenedLengths() {
      return this.PC(), this.mu;
    }
    get flattenedTotalLength() {
      let t = this.pu;
      if (isNaN(t)) {
        if (this.type === 1) {
          const i = Math.abs(this.endX - this.startX), e = Math.abs(this.endY - this.startY);
          t = Math.sqrt(i * i + e * e);
        } else if (this.type === 2) {
          const i = Math.abs(this.endX - this.startX), e = Math.abs(this.endY - this.startY);
          t = i * 2 + e * 2;
        } else {
          const i = this.flattenedLengths, e = i.length;
          t = 0;
          for (let s = 0; s < e; s++) {
            const n = i[s], o = n.length;
            for (let r = 0; r < o; r++)
              t += n[r];
          }
        }
        this.pu = t;
      }
      return t;
    }
    Zk(t) {
      const i = [];
      let e = 0, s = 0;
      const n = t.length;
      for (let o = 0; o < n; o += 2) {
        const r = t[o], l = t[o + 1];
        if (o === 0) {
          e = r, s = l;
          continue;
        }
        const h = Math.sqrt(Point2.distanceSquared(e, s, r, l));
        i.push(h), e = r, s = l;
      }
      return i;
    }
    WD(t, i) {
      let e = [];
      const s = [];
      if (this.type === 1)
        e.push(this.startX), e.push(this.startY), e.push(this.endX), e.push(this.endY), t.push(e), s.push(Math.sqrt((this.startX - this.endX) * (this.startX - this.endX) + (this.startY - this.endY) * (this.startY - this.endY))), i.push(s);
      else if (this.type === 2)
        e.push(this.startX), e.push(this.startY), e.push(this.endX), e.push(this.startY), e.push(this.endX), e.push(this.endY), e.push(this.startX), e.push(this.endY), e.push(this.startX), e.push(this.startY), t.push(e), s.push(Math.abs(this.startX - this.endX)), s.push(Math.abs(this.startY - this.endY)), s.push(Math.abs(this.startX - this.endX)), s.push(Math.abs(this.startY - this.endY)), i.push(s);
      else if (this.type === 3) {
        const n = new PathFigure2();
        n.startX = this.endX, n.startY = (this.startY + this.endY) / 2;
        const o = new PathSegment2(5);
        o.startAngle = 0, o.sweepAngle = 360, o.centerX = (this.startX + this.endX) / 2, o.centerY = (this.startY + this.endY) / 2, o.radiusX = Math.abs(this.startX - this.endX) / 2, o.radiusY = Math.abs(this.startY - this.endY) / 2, n.add(o);
        const r = o.Fo(n), l = r.length;
        if (l === 0)
          e.push(o.centerX), e.push(o.centerY);
        else {
          let h = n.startX, a = n.startY;
          for (let f = 0; f < l; f++) {
            const c = r[f];
            Geo.Hn(h, a, c[2], c[3], c[4], c[5], c[6], c[7], 0.5, e), h = c[6], a = c[7];
          }
        }
        t.push(e), i.push(this.Zk(e));
      } else {
        const n = this.figures.iterator;
        for (; n.next(); ) {
          const o = n.value;
          e = [], e.push(o.startX), e.push(o.startY);
          let r = o.startX, l = o.startY, h = r, a = l;
          const f = o.segments.h, c = f.length;
          for (let u = 0; u < c; u++) {
            const d = f[u];
            switch (d.type) {
              case 1:
                e.length >= 4 && (t.push(e), i.push(this.Zk(e))), e = [], e.push(d.endX), e.push(d.endY), r = d.endX, l = d.endY, h = r, a = l;
                break;
              case 2:
                e.push(d.endX), e.push(d.endY), r = d.endX, l = d.endY;
                break;
              case 3:
                Geo.Hn(r, l, d.point1X, d.point1Y, d.point2X, d.point2Y, d.endX, d.endY, 0.5, e), r = d.endX, l = d.endY;
                break;
              case 4:
                Geo.Wg(r, l, d.point1X, d.point1Y, d.endX, d.endY, 0.5, e), r = d.endX, l = d.endY;
                break;
              case 5: {
                const m = d.Fo(o), g = m.length;
                if (g === 0) {
                  e.push(d.centerX), e.push(d.centerY), r = d.centerX, l = d.centerY;
                  break;
                }
                for (let p = 0; p < g; p++) {
                  const y = m[p];
                  Geo.Hn(r, l, y[2], y[3], y[4], y[5], y[6], y[7], 0.5, e), r = y[6], l = y[7];
                }
                break;
              }
              case 6: {
                const m = d.Kh(o, r, l), g = m.length, p = d.endX, y = d.endY;
                if (g === 0) {
                  e.push(p), e.push(y), r = p, l = y;
                  break;
                }
                for (let x = 0; x < g; x++) {
                  const b = m[x];
                  Geo.Hn(r, l, b[2], b[3], b[4], b[5], b[6], b[7], 0.5, e), r = b[6], l = b[7];
                }
                break;
              }
              default:
                Util.n("Segment not of valid type: " + d.type);
            }
            d.isClosed && (e.push(h), e.push(a));
          }
          e.length >= 4 && (t.push(e), i.push(this.Zk(e)));
        }
      }
    }
    get type() {
      return this.nt;
    }
    set type(t) {
      this.nt !== t && (Debug && Util.it(t, GeometryType2, "GeometryType"), this.f && Util.O(this, t), this.nt = t, t === 4 ? this.zs = new List2() : (_Geometry.Tw === null && (_Geometry.Tw = new List2().w()), this.zs = _Geometry.Tw), this.Nt = true);
    }
    get startX() {
      return this.Ae;
    }
    set startX(t) {
      this.Ae !== t && (Debug && Util.r(t, _Geometry, "startX"), this.f && Util.O(this, t), this.Ae = t, this.Nt = true);
    }
    get startY() {
      return this.Le;
    }
    set startY(t) {
      this.Le !== t && (Debug && Util.r(t, _Geometry, "startY"), this.f && Util.O(this, t), this.Le = t, this.Nt = true);
    }
    get endX() {
      return this.ne;
    }
    set endX(t) {
      this.ne !== t && (Debug && Util.r(t, _Geometry, "endX"), this.f && Util.O(this, t), this.ne = t, this.Nt = true);
    }
    get endY() {
      return this.oe;
    }
    set endY(t) {
      this.oe !== t && (Debug && Util.r(t, _Geometry, "endY"), this.f && Util.O(this, t), this.oe = t, this.Nt = true);
    }
    get figures() {
      return this.zs;
    }
    set figures(t) {
      this.zs !== t && (Debug && Util.s(t, List2, _Geometry, "figures"), this.f && Util.O(this, t), this.zs = t, this.Nt = true);
    }
    add(t) {
      return this.zs.add(t), this;
    }
    setSpots(t, i, e, s, n, o, r, l) {
      return this.f && Util.O(this), this.Wn = new Spot2(t, i, n, o).w(), this.jn = new Spot2(e, s, r, l).w(), this;
    }
    get spot1() {
      return this.Wn;
    }
    set spot1(t) {
      Debug && Util.s(t, Spot2, _Geometry, "spot1"), this.f && Util.O(this, t), this.Wn = t.L();
    }
    get spot2() {
      return this.jn;
    }
    set spot2(t) {
      Debug && Util.s(t, Spot2, _Geometry, "spot2"), this.f && Util.O(this, t), this.jn = t.L();
    }
    get defaultStretch() {
      return this.Jn;
    }
    set defaultStretch(t) {
      this.Jn = t;
    }
    get bounds() {
      return this.Wk() && this.Fw(), this.tm;
    }
  };
  __publicField(_Geometry, "Line", 1);
  __publicField(_Geometry, "Rectangle", 2);
  __publicField(_Geometry, "Ellipse", 3);
  __publicField(_Geometry, "Path", 4);
  __publicField(_Geometry, "Tw", new List2().w());
  __publicField(_Geometry, "im", "UuBbMmZzLlHhVvCcSsQqTtAaFfXx");
  let Geometry2 = _Geometry;
  Geometry2.stringify = Geometry2.stringify, Geometry2.stringifyFixed = Geometry2.stringifyFixed, Geometry2.fillPath = Geometry2.fillPath, Geometry2.parse = Geometry2.parse;
  class PathFigure2 {
    constructor(t, i, e, s, n) {
      __publicField(this, "l");
      __publicField(this, "Ae");
      __publicField(this, "Le");
      __publicField(this, "uf");
      __publicField(this, "sm");
      __publicField(this, "ve");
      e === void 0 && (e = true), s === void 0 && (s = true), n === void 0 && (n = false), this.l = 2 | (e ? 4 : 0) | (s ? 8 : 0) | (n ? 16 : 0), t !== void 0 ? (Debug && Util.r(t, PathFigure2, "sx"), this.Ae = t) : this.Ae = 0, i !== void 0 ? (Debug && Util.r(i, PathFigure2, "sy"), this.Le = i) : this.Le = 0, this.uf = new List2(), this.sm = this.uf.mt, this.ve = null;
    }
    copy() {
      const t = new PathFigure2();
      t.l = this.l & -2, t.Ae = this.Ae, t.Le = this.Le;
      const i = this.uf.h, e = i.length, s = t.uf;
      for (let n = 0; n < e; n++) {
        const r = i[n].copy();
        s.add(r);
      }
      return t.sm = this.sm, t.ve = this.ve, t;
    }
    equalsApprox(t) {
      if (!(t instanceof PathFigure2) || !Geo.p(this.startX, t.startX) || !Geo.p(this.startY, t.startY))
        return false;
      const i = this.segments.h, e = t.segments.h, s = i.length;
      if (s !== e.length)
        return false;
      for (let n = 0; n < s; n++) {
        const o = i[n], r = e[n];
        if (!o.equalsApprox(r))
          return false;
      }
      return true;
    }
    toString(t) {
      t === void 0 && (t = -1);
      let i = "";
      if (t < 0)
        i = "M" + this.startX.toString() + " " + this.startY.toString();
      else {
        const n = (o) => o === 0 ? "0" : o.toFixed(t);
        i = "M" + n(this.startX) + " " + n(this.startY);
      }
      const e = this.segments.h, s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n];
        i += " " + o.toString(t);
      }
      return i;
    }
    get f() {
      return (this.l & 1) !== 0;
    }
    set f(t) {
      t ? this.l |= 1 : this.l &= -2;
    }
    get Nt() {
      return (this.l & 2) !== 0;
    }
    set Nt(t) {
      t ? this.l |= 2 : this.l &= -3;
    }
    w() {
      this.f = true;
      const t = this.segments;
      t.w();
      const i = t.h, e = t.length;
      for (let s = 0; s < e; s++)
        i[s].w();
      return this;
    }
    ut() {
      this.f = false;
      const t = this.segments;
      t.ut();
      const i = t.h, e = i.length;
      for (let s = 0; s < e; s++)
        i[s].ut();
      return this;
    }
    Wk() {
      if (this.Nt)
        return true;
      const t = this.segments;
      if (this.sm !== t.mt)
        return true;
      for (const i of t)
        if (i.Nt)
          return true;
      return false;
    }
    vD() {
      this.Nt = false, this.ve = null;
      const t = this.segments;
      this.sm = t.mt;
      for (const i of t)
        i.Nt = false, i.Xs = null;
    }
    get isFilled() {
      return (this.l & 4) !== 0;
    }
    set isFilled(t) {
      Debug && Util.t(t, "boolean", PathFigure2, "isFilled"), this.f && Util.O(this, t), t ? this.l |= 4 : this.l &= -5;
    }
    get isShadowed() {
      return (this.l & 8) !== 0;
    }
    set isShadowed(t) {
      Debug && Util.t(t, "boolean", PathFigure2, "isShadowed"), this.f && Util.O(this, t), t ? this.l |= 8 : this.l &= -9;
    }
    get isEvenOdd() {
      return (this.l & 16) !== 0;
    }
    set isEvenOdd(t) {
      Debug && Util.t(t, "boolean", PathFigure2, "isEvenOdd"), this.f && Util.O(this, t), t ? this.l |= 16 : this.l &= -17;
    }
    get startX() {
      return this.Ae;
    }
    set startX(t) {
      Debug && Util.r(t, PathFigure2, "startX"), this.f && Util.O(this, t), this.Ae = t, this.ve = null, this.Nt = true;
    }
    get startY() {
      return this.Le;
    }
    set startY(t) {
      Debug && Util.r(t, PathFigure2, "startY"), this.f && Util.O(this, t), this.Le = t, this.ve = null, this.Nt = true;
    }
    get segments() {
      return this.uf;
    }
    set segments(t) {
      Debug && Util.s(t, List2, PathFigure2, "segments"), this.f && Util.O(this, t), this.uf = t, this.ve = null, this.Nt = true;
    }
    add(t) {
      return this.uf.add(t), this.ve = null, this;
    }
    Jk(t, i, e) {
      const s = this;
      let n = s.startX, o = s.startY, r = n, l = o;
      const h = s.segments.h, a = h.length;
      for (let f = 0; f < a; f++) {
        const c = h[f];
        switch (c.type) {
          case 1:
            r = c.endX, l = c.endY, n = c.endX, o = c.endY;
            break;
          case 2:
            if (Geo.zi(n, o, c.endX, c.endY, e, t, i))
              return true;
            n = c.endX, o = c.endY;
            break;
          case 3:
            if (Geo.Aw(n, o, c.point1X, c.point1Y, c.point2X, c.point2Y, c.endX, c.endY, 0.5, t, i, e))
              return true;
            n = c.endX, o = c.endY;
            break;
          case 4:
            if (Geo.vk(n, o, c.point1X, c.point1Y, c.endX, c.endY, 0.5, t, i, e))
              return true;
            n = c.endX, o = c.endY;
            break;
          case 5:
          case 6:
            const u = c.type === 5 ? c.Fo(s) : c.Kh(s, n, o), d = u.length, m = c.type === 5 ? c.centerX : c.endX, g = c.type === 5 ? c.centerY : c.endY;
            if (d === 0) {
              if (Geo.zi(n, o, m, g, e, t, i))
                return true;
              n = m, o = g;
              break;
            }
            let p = null;
            for (let y = 0; y < d; y++)
              if (p = u[y], y === 0 && Geo.zi(n, o, p[0], p[1], e, t, i) || Geo.Aw(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], 0.5, t, i, e))
                return true;
            p !== null && (n = p[6], o = p[7]);
            break;
          default:
            Util.n("Unknown Segment type: " + c.type);
        }
        if (c.isClosed && (n !== r || o !== l) && Geo.zi(n, o, r, l, e, t, i))
          return true;
      }
      return false;
    }
  }
  var SegmentType2 = ((w) => (w[w.Move = 1] = "Move", w[w.Line = 2] = "Line", w[w.Bezier = 3] = "Bezier", w[w.QuadraticBezier = 4] = "QuadraticBezier", w[w.Arc = 5] = "Arc", w[w.SvgArc = 6] = "SvgArc", w))(SegmentType2 || {});
  const _PathSegment = class _PathSegment {
    constructor(t, i, e, s, n, o, r, l) {
      __publicField(this, "nt");
      __publicField(this, "l");
      __publicField(this, "ne");
      __publicField(this, "oe");
      __publicField(this, "gn");
      __publicField(this, "Pl");
      __publicField(this, "Nl");
      __publicField(this, "kr");
      __publicField(this, "Xs");
      if (GSet2.ji(this), t === void 0 ? t = 2 : Debug && Util.it(t, SegmentType2, "SegmentType"), this.nt = t, this.l = 2, i !== void 0 ? (Debug && Util.r(i, _PathSegment, "ex"), this.ne = i) : this.ne = 0, e !== void 0 ? (Debug && Util.r(e, _PathSegment, "ey"), this.oe = e) : this.oe = 0, s === void 0 && (s = 0), n === void 0 && (n = 0), o === void 0 && (o = 0), r === void 0 && (r = 0), t === 6) {
        let h = o;
        h = h % 360, h < 0 && (h += 360), this.gn = h, this.Pl = 0, Debug && Util.r(s, _PathSegment, "x1"), this.Nl = Math.max(s, 0), Debug && Util.r(n, _PathSegment, "y1"), this.kr = Math.max(n, 0), typeof r == "boolean" ? r && (this.isLargeArc = true) : typeof r == "number" && r && (this.isLargeArc = true), l && (this.isClockwiseArc = true);
      } else
        Debug && Util.r(s, _PathSegment, "x1"), this.gn = s, Debug && Util.r(n, _PathSegment, "y1"), this.Pl = n, Debug && Util.r(o, _PathSegment, "x2"), t === 5 && (o = Math.max(o, 0)), this.Nl = o, typeof r == "number" ? (t === 5 && (r = Math.max(r, 0)), this.kr = r) : this.kr = 0;
      this.Xs = null;
    }
    copy() {
      const t = new _PathSegment();
      return t.nt = this.nt, t.l = this.l & -2, t.ne = this.ne, t.oe = this.oe, t.gn = this.gn, t.Pl = this.Pl, t.Nl = this.Nl, t.kr = this.kr, t;
    }
    equalsApprox(t) {
      if (!(t instanceof _PathSegment) || this.type !== t.type || this.isClosed !== t.isClosed)
        return false;
      switch (this.type) {
        case 1:
        case 2:
          return Geo.p(this.endX, t.endX) && Geo.p(this.endY, t.endY);
        case 3:
          return Geo.p(this.endX, t.endX) && Geo.p(this.endY, t.endY) && Geo.p(this.point1X, t.point1X) && Geo.p(this.point1Y, t.point1Y) && Geo.p(this.point2X, t.point2X) && Geo.p(this.point2Y, t.point2Y);
        case 4:
          return Geo.p(this.endX, t.endX) && Geo.p(this.endY, t.endY) && Geo.p(this.point1X, t.point1X) && Geo.p(this.point1Y, t.point1Y);
        case 5:
          return Geo.p(this.startAngle, t.startAngle) && Geo.p(this.sweepAngle, t.sweepAngle) && Geo.p(this.centerX, t.centerX) && Geo.p(this.centerY, t.centerY) && Geo.p(this.radiusX, t.radiusX) && Geo.p(this.radiusY, t.radiusY);
        case 6:
          return this.isClockwiseArc === t.isClockwiseArc && this.isLargeArc === t.isLargeArc && Geo.p(this.xAxisRotation, t.xAxisRotation) && Geo.p(this.endX, t.endX) && Geo.p(this.endY, t.endY) && Geo.p(this.radiusX, t.radiusX) && Geo.p(this.radiusY, t.radiusY);
        default:
          return false;
      }
    }
    ci(t) {
      t in SegmentType2 ? this.type = t : Util.gr(this, t);
    }
    toString(t) {
      t === void 0 && (t = -1);
      const i = (s) => s === 0 ? "0" : s.toFixed(t);
      let e = "";
      switch (this.type) {
        case 1:
          t < 0 ? e = "M" + this.endX.toString() + " " + this.endY.toString() : e = "M" + i(this.endX) + " " + i(this.endY);
          break;
        case 2:
          t < 0 ? e = "L" + this.endX.toString() + " " + this.endY.toString() : e = "L" + i(this.endX) + " " + i(this.endY);
          break;
        case 3:
          t < 0 ? e = "C" + this.point1X.toString() + " " + this.point1Y.toString() + " " + this.point2X.toString() + " " + this.point2Y.toString() + " " + this.endX.toString() + " " + this.endY.toString() : e = "C" + i(this.point1X) + " " + i(this.point1Y) + " " + i(this.point2X) + " " + i(this.point2Y) + " " + i(this.endX) + " " + i(this.endY);
          break;
        case 4:
          t < 0 ? e = "Q" + this.point1X.toString() + " " + this.point1Y.toString() + " " + this.endX.toString() + " " + this.endY.toString() : e = "Q" + i(this.point1X) + " " + i(this.point1Y) + " " + i(this.endX) + " " + i(this.endY);
          break;
        case 5:
          t < 0 ? e = "B" + this.startAngle.toString() + " " + this.sweepAngle.toString() + " " + this.centerX.toString() + " " + this.centerY.toString() + " " + this.radiusX.toString() + " " + this.radiusY.toString() : e = "B" + i(this.startAngle) + " " + i(this.sweepAngle) + " " + i(this.centerX) + " " + i(this.centerY) + " " + i(this.radiusX) + " " + i(this.radiusY);
          break;
        case 6:
          t < 0 ? e = "A" + this.radiusX.toString() + " " + this.radiusY.toString() + " " + this.xAxisRotation.toString() + " " + (this.isLargeArc ? 1 : 0) + " " + (this.isClockwiseArc ? 1 : 0) + " " + this.endX.toString() + " " + this.endY.toString() : e = "A" + i(this.radiusX) + " " + i(this.radiusY) + " " + i(this.xAxisRotation) + " " + (this.isLargeArc ? 1 : 0) + " " + (this.isClockwiseArc ? 1 : 0) + " " + i(this.endX) + " " + i(this.endY);
          break;
        default:
          e = SegmentType2[this.type];
      }
      return e + (this.isClosed ? "z" : "");
    }
    get f() {
      return (this.l & 1) !== 0;
    }
    set f(t) {
      t ? this.l |= 1 : this.l &= -2;
    }
    get Nt() {
      return (this.l & 2) !== 0;
    }
    set Nt(t) {
      t ? this.l |= 2 : this.l &= -3;
    }
    w() {
      return this.f = true, this;
    }
    ut() {
      return this.f = false, this;
    }
    close() {
      return this.isClosed = true, this;
    }
    Fo(t) {
      if (this.Xs !== null && t.Nt === false)
        return this.Xs;
      const i = this.radiusX;
      let e = this.radiusY;
      if (e === void 0 && (e = i), i === 0 || e === 0)
        return this.Xs = [], this.Xs;
      const s = this.gn, n = this.Pl, o = Geo.pC(0, 0, i < e ? i : e, this.startAngle, this.startAngle + this.sweepAngle, false);
      if (i !== e) {
        const l = Transform.a();
        l.ti(), i < e ? l.v(1, e / i) : l.v(i / e, 1), Geometry2.kC(o, l), Transform.o(l);
      }
      const r = o.length;
      for (let l = 0; l < r; l++) {
        const h = o[l];
        h[0] += s, h[1] += n, h[2] += s, h[3] += n, h[4] += s, h[5] += n, h[6] += s, h[7] += n;
      }
      return this.Xs = o, this.Xs;
    }
    Kh(t, i, e) {
      if (this.Xs !== null && t.Nt === false)
        return this.Xs;
      if (this.radiusX === 0 || this.radiusY === 0)
        return this.Xs = [], this.Xs;
      const s = i, n = e;
      let o = this.Nl, r = this.kr;
      o === 0 && (o = 1e-4), r === 0 && (r = 1e-4);
      const l = this.gn * (Math.PI / 180), h = this.isLargeArc, a = this.isClockwiseArc, f = this.ne, c = this.oe, u = Math.cos(l), d = Math.sin(l), m = u * (s - f) / 2 + d * (n - c) / 2, g = -d * (s - f) / 2 + u * (n - c) / 2, p = m * m / (o * o) + g * g / (r * r);
      p > 1 && (o *= Math.sqrt(p), r *= Math.sqrt(p));
      let y = (h === a ? -1 : 1) * Math.sqrt((o * o * r * r - o * o * g * g - r * r * m * m) / (o * o * g * g + r * r * m * m));
      isNaN(y) && (y = 0);
      let x = y * o * g / r, b = y * -r * m / o;
      isNaN(x) && (x = 0), isNaN(b) && (b = 0);
      const k = (s + f) / 2 + u * x - d * b, S = (n + c) / 2 + d * x + u * b, M = (X, z) => Math.sqrt(X * X + z * z), A = (X, z, G, v) => (X * G + z * v) / (M(X, z) * M(G, v)), C = (X, z, G, v) => (X * v < z * G ? -1 : 1) * Math.acos(A(X, z, G, v)), P = C(1, 0, (m - x) / o, (g - b) / r), N = (m - x) / o, T = (g - b) / r, L = (-m - x) / o, D = (-g - b) / r;
      let F = C(N, T, L, D);
      const R = A(N, T, L, D);
      R <= -1 ? F = Math.PI : R >= 1 && (F = 0), !a && F > 0 && (F = F - 2 * Math.PI), a && F < 0 && (F = F + 2 * Math.PI);
      const I = o > r ? o : r, O = o > r ? 1 : o / r, B = o > r ? r / o : 1, K = Geo.pC(0, 0, I, P, P + F, true), V = Transform.a();
      return V.ti(), V.se(k, S), V.ys(this.gn, 0, 0), V.v(O, B), Geometry2.kC(K, V), Transform.o(V), this.Xs = K, this.Xs;
    }
    get isClosed() {
      return (this.l & 8) !== 0;
    }
    set isClosed(t) {
      this.isClosed !== t && (t ? this.l |= 8 : this.l &= -9, this.Nt = true);
    }
    get type() {
      return this.nt;
    }
    set type(t) {
      Debug && Util.it(t, SegmentType2, "SegmentType"), this.f && Util.O(this, t), this.nt = t, this.Nt = true;
    }
    get endX() {
      return this.ne;
    }
    set endX(t) {
      Debug && Util.r(t, _PathSegment, "endX"), this.f && Util.O(this, t), this.ne = t, this.Nt = true;
    }
    get endY() {
      return this.oe;
    }
    set endY(t) {
      Debug && Util.r(t, _PathSegment, "endY"), this.f && Util.O(this, t), this.oe = t, this.Nt = true;
    }
    get point1X() {
      return this.gn;
    }
    set point1X(t) {
      Debug && Util.r(t, _PathSegment, "point1X"), this.f && Util.O(this, t), this.gn = t, this.Nt = true;
    }
    get point1Y() {
      return this.Pl;
    }
    set point1Y(t) {
      Debug && Util.r(t, _PathSegment, "point1Y"), this.f && Util.O(this, t), this.Pl = t, this.Nt = true;
    }
    get point2X() {
      return this.Nl;
    }
    set point2X(t) {
      Debug && Util.r(t, _PathSegment, "point2X"), this.f && Util.O(this, t), this.Nl = t, this.Nt = true;
    }
    get point2Y() {
      return this.kr;
    }
    set point2Y(t) {
      Debug && Util.r(t, _PathSegment, "point2Y"), this.f && Util.O(this, t), this.kr = t, this.Nt = true;
    }
    get centerX() {
      return this.gn;
    }
    set centerX(t) {
      Debug && Util.r(t, _PathSegment, "centerX"), this.f && Util.O(this, t), this.gn = t, this.Nt = true;
    }
    get centerY() {
      return this.Pl;
    }
    set centerY(t) {
      Debug && Util.r(t, _PathSegment, "centerY"), this.f && Util.O(this, t), this.Pl = t, this.Nt = true;
    }
    get radiusX() {
      return this.Nl;
    }
    set radiusX(t) {
      Debug && Util.r(t, _PathSegment, "radiusX"), t < 0 && Util.G(t, ">= zero", _PathSegment, "radiusX"), this.f && Util.O(this, t), this.Nl = t, this.Nt = true;
    }
    get radiusY() {
      return this.kr;
    }
    set radiusY(t) {
      Debug && Util.r(t, _PathSegment, "radiusY"), t < 0 && Util.G(t, ">= zero", _PathSegment, "radiusY"), this.f && Util.O(this, t), this.kr = t, this.Nt = true;
    }
    get startAngle() {
      return this.ne;
    }
    set startAngle(t) {
      Debug && Util.r(t, _PathSegment, "startAngle"), this.f && Util.O(this, t), t = t % 360, t < 0 && (t += 360), this.ne = t, this.Nt = true;
    }
    get sweepAngle() {
      return this.oe;
    }
    set sweepAngle(t) {
      Debug && Util.r(t, _PathSegment, "sweepAngle"), this.f && Util.O(this, t), t > 360 && (t = 360), t < -360 && (t = -360), this.oe = t, this.Nt = true;
    }
    get isClockwiseArc() {
      return (this.l & 4) !== 0;
    }
    set isClockwiseArc(t) {
      this.f && Util.O(this, t), t ? this.l |= 4 : this.l &= -5, this.Nt = true;
    }
    get isLargeArc() {
      return (this.l & 16) !== 0;
    }
    set isLargeArc(t) {
      this.f && Util.O(this, t), t ? this.l |= 16 : this.l &= -17, this.Nt = true;
    }
    get xAxisRotation() {
      return this.gn;
    }
    set xAxisRotation(t) {
      Debug && Util.r(t, _PathSegment, "xAxisRotation"), this.f && Util.O(this, t), t = t % 360, t < 0 && (t += 360), this.gn = t, this.Nt = true;
    }
  };
  __publicField(_PathSegment, "Move", 1);
  __publicField(_PathSegment, "Line", 2);
  __publicField(_PathSegment, "Bezier", 3);
  __publicField(_PathSegment, "QuadraticBezier", 4);
  __publicField(_PathSegment, "Arc", 5);
  __publicField(_PathSegment, "SvgArc", 6);
  let PathSegment2 = _PathSegment;
  class InputEvent2 {
    constructor() {
      __publicField(this, "b");
      __publicField(this, "Iw");
      __publicField(this, "Ow");
      __publicField(this, "nm");
      __publicField(this, "om");
      __publicField(this, "rm");
      __publicField(this, "lm");
      __publicField(this, "hm");
      __publicField(this, "am");
      __publicField(this, "fm");
      __publicField(this, "cm");
      __publicField(this, "um");
      __publicField(this, "dm");
      __publicField(this, "gm");
      __publicField(this, "Ro");
      __publicField(this, "mm");
      __publicField(this, "pm");
      __publicField(this, "ym");
      __publicField(this, "Te");
      this.b = null, this.Iw = new Point2(0, 0).w(), this.Ow = new Point2(0, 0).w(), this.nm = 0, this.om = 0, this.rm = 1, this.lm = "", this.hm = "", this.am = false, this.fm = false, this.cm = 0, this.um = 0, this.dm = false, this.gm = false, this.Ro = false, this.mm = null, this.pm = 0, this.ym = null, this.Te = null;
    }
    copy() {
      const t = new InputEvent2();
      return this.clone(t);
    }
    clone(t) {
      return t.b = this.b, t.Iw.c(this.viewPoint), t.Ow.c(this.documentPoint), t.nm = this.nm, t.om = this.om, t.rm = this.rm, t.lm = this.lm, t.hm = this.hm, t.am = this.am, t.fm = this.fm, t.cm = this.cm, t.um = this.um, t.dm = this.dm, t.gm = this.gm, t.Ro = this.Ro, t.mm = this.mm, t.pm = this.pm, t.ym = this.ym, t.Te = this.Te, t;
    }
    toString() {
      let t = "^";
      return this.modifiers !== 0 && (t += "M:" + this.modifiers), this.button !== 0 && (t += "B:" + this.button), this.key !== "" && (t += "K:" + this.key), this.clickCount !== 0 && (t += "C:" + this.clickCount), this.delta !== 0 && (t += "D:" + this.delta), this.handled && (t += "h"), this.bubbles && (t += "b"), this.documentPoint !== null && (t += "@" + this.documentPoint.toString()), t;
    }
    get diagram() {
      return this.b;
    }
    set diagram(t) {
      this.b = t;
    }
    get viewPoint() {
      return this.Iw;
    }
    set viewPoint(t) {
      Util.s(t, Point2, InputEvent2, "viewPoint"), this.Iw.c(t);
    }
    get documentPoint() {
      return this.Ow;
    }
    set documentPoint(t) {
      Util.s(t, Point2, InputEvent2, "documentPoint"), this.Ow.c(t);
    }
    getMultiTouchViewPoint(t, i) {
      const e = this.diagram;
      return e === null || e.NC(this.event, t, i), i;
    }
    getMultiTouchDocumentPoint(t, i) {
      const e = this.diagram;
      return e === null || (e.NC(this.event, t, i), i.c(e.transformViewToDoc(i))), i;
    }
    get modifiers() {
      return this.nm;
    }
    set modifiers(t) {
      this.nm = t;
    }
    get button() {
      return this.om;
    }
    set button(t) {
      if (this.om = t, this.event === null)
        switch (t) {
          case 0:
            this.buttons = 1;
            return;
          case 1:
            this.buttons = 4;
            return;
          case 2:
            this.buttons = 2;
            return;
        }
    }
    get buttons() {
      return this.rm;
    }
    set buttons(t) {
      this.rm = t;
    }
    get key() {
      return this.lm;
    }
    set key(t) {
      this.lm = t;
    }
    get code() {
      return this.hm;
    }
    set code(t) {
      this.hm = t;
    }
    get down() {
      return this.am;
    }
    set down(t) {
      this.am = t;
    }
    get up() {
      return this.fm;
    }
    set up(t) {
      this.fm = t;
    }
    get clickCount() {
      return this.cm;
    }
    set clickCount(t) {
      this.cm = t;
    }
    get delta() {
      return this.um;
    }
    set delta(t) {
      this.um = t;
    }
    get isMultiTouch() {
      return this.dm;
    }
    set isMultiTouch(t) {
      this.dm = t;
    }
    get handled() {
      return this.gm;
    }
    set handled(t) {
      this.gm = t;
    }
    get bubbles() {
      return this.Ro;
    }
    set bubbles(t) {
      this.Ro = t;
    }
    get event() {
      return this.mm;
    }
    set event(t) {
      this.mm = t;
    }
    get isTouchEvent() {
      const t = this.event;
      return t === null ? false : t.pointerType === "touch" || t.pointerType === "pen";
    }
    get timestamp() {
      return this.pm;
    }
    set timestamp(t) {
      this.pm = t;
    }
    get targetDiagram() {
      return this.ym;
    }
    set targetDiagram(t) {
      this.ym = t;
    }
    get targetObject() {
      return this.Te;
    }
    set targetObject(t) {
      this.Te = t;
    }
    get control() {
      return (this.modifiers & 1) !== 0;
    }
    set control(t) {
      this.modifiers = t ? this.modifiers | 1 : this.modifiers & -2;
    }
    get shift() {
      return (this.modifiers & 4) !== 0;
    }
    set shift(t) {
      this.modifiers = t ? this.modifiers | 4 : this.modifiers & -5;
    }
    get alt() {
      return (this.modifiers & 2) !== 0;
    }
    set alt(t) {
      this.modifiers = t ? this.modifiers | 2 : this.modifiers & -3;
    }
    get meta() {
      return (this.modifiers & 8) !== 0;
    }
    set meta(t) {
      this.modifiers = t ? this.modifiers | 8 : this.modifiers & -9;
    }
    get left() {
      const t = this.event;
      return t !== null && (t.type === "mousedown" || t.type === "mouseup" || t.type === "pointerdown" || t.type === "pointerup") ? this.button === 0 : (this.buttons & 1) !== 0;
    }
    set left(t) {
      t ? this.buttons |= 1 : this.buttons &= -2;
    }
    get right() {
      const t = this.event;
      return t !== null && (t.type === "mousedown" || t.type === "mouseup" || t.type === "pointerdown" || t.type === "pointerup") ? this.button === 2 : (this.buttons & 2) !== 0;
    }
    set right(t) {
      t ? this.buttons |= 2 : this.buttons &= -3;
    }
    get middle() {
      const t = this.event;
      return t !== null && (t.type === "mousedown" || t.type === "mouseup" || t.type === "pointerdown" || t.type === "pointerup") ? this.button === 1 : (this.buttons & 4) !== 0;
    }
    set middle(t) {
      t ? this.buttons |= 4 : this.buttons &= -5;
    }
  }
  class DiagramEvent2 {
    constructor() {
      __publicField(this, "b");
      __publicField(this, "Tt");
      __publicField(this, "wm");
      __publicField(this, "xm");
      this.b = null, this.Tt = "", this.wm = null, this.xm = null;
    }
    copy() {
      const t = new DiagramEvent2();
      return t.b = this.b, t.Tt = this.Tt, t.wm = this.wm, t.xm = this.xm, t;
    }
    toString() {
      let t = "*" + this.name;
      return this.subject !== null && (t += ":" + this.subject.toString()), this.parameter !== null && (t += "(" + this.parameter.toString() + ")"), t;
    }
    get diagram() {
      return this.b;
    }
    set diagram(t) {
      this.b = t;
    }
    get name() {
      return this.Tt;
    }
    set name(t) {
      this.Tt = t;
    }
    get subject() {
      return this.wm;
    }
    set subject(t) {
      this.wm = t;
    }
    get parameter() {
      return this.xm;
    }
    set parameter(t) {
      this.xm = t;
    }
  }
  var ChangeType2 = ((w) => (w[w.Transaction = 1] = "Transaction", w[w.Property = 2] = "Property", w[w.Insert = 3] = "Insert", w[w.Remove = 4] = "Remove", w))(ChangeType2 || {});
  const _ChangedEvent = class _ChangedEvent {
    constructor() {
      __publicField(this, "wu");
      __publicField(this, "bm");
      __publicField(this, "mn");
      __publicField(this, "Li");
      __publicField(this, "b");
      __publicField(this, "xu");
      __publicField(this, "df");
      __publicField(this, "gf");
      __publicField(this, "mf");
      __publicField(this, "pf");
      this.wu = 2, this.bm = "", this.mn = "", this.Li = null, this.b = null, this.xu = null, this.df = null, this.gf = null, this.mf = null, this.pf = null;
    }
    clear() {
      this.Li = null, this.b = null, this.xu = null, this.df = null, this.gf = null, this.mf = null, this.pf = null;
    }
    copy() {
      const t = new _ChangedEvent();
      t.wu = this.wu, t.bm = this.bm, t.mn = this.mn, t.Li = this.Li, t.b = this.b, t.xu = this.xu;
      let i = this.df;
      return Util.Mt(i) && typeof i.copyFrozen == "function" ? t.df = i.copyFrozen() : t.df = i, i = this.gf, Util.Mt(i) && typeof i.copyFrozen == "function" ? t.gf = i.copyFrozen() : t.gf = i, i = this.mf, Util.Mt(i) && typeof i.copyFrozen == "function" ? t.mf = i.copyFrozen() : t.mf = i, i = this.pf, Util.Mt(i) && typeof i.copyFrozen == "function" ? t.pf = i.copyFrozen() : t.pf = i, t;
    }
    ci(t) {
      t in ChangeType2 ? this.change = t : Util.gr(this, t);
    }
    toString() {
      let t = "";
      return this.change === 1 ? t += "* " : this.change === 2 ? t += this.model !== null ? "!m" : "!d" : t += (this.model !== null ? "!m" : "!d") + this.change, this.propertyName && typeof this.propertyName == "string" && (t += " " + this.propertyName), this.modelChange && this.modelChange !== this.propertyName && (t += " " + this.modelChange), t += ": ", this.change === 1 ? this.oldValue !== null && (t += " " + this.oldValue) : (this.object !== null && (t += Util.toString(this.object)), this.oldValue !== null && (t += "  old: " + Util.toString(this.oldValue)), this.oldParam !== null && (t += " " + this.oldParam), this.newValue !== null && (t += "  new: " + Util.toString(this.newValue)), this.newParam !== null && (t += " " + this.newParam)), t;
    }
    getValue(t) {
      return t ? this.oldValue : this.newValue;
    }
    getParam(t) {
      return t ? this.oldParam : this.newParam;
    }
    canUndo() {
      return this.model !== null || this.diagram !== null;
    }
    undo() {
      this.canUndo() && (this.model !== null ? this.model.changeState(this, true) : this.diagram !== null && this.diagram.CC(this, true));
    }
    canRedo() {
      return this.model !== null || this.diagram !== null;
    }
    redo() {
      this.canRedo() && (this.model !== null ? this.model.changeState(this, false) : this.diagram !== null && this.diagram.CC(this, false));
    }
    get model() {
      return this.Li;
    }
    set model(t) {
      this.Li = t;
    }
    get diagram() {
      return this.b;
    }
    set diagram(t) {
      this.b = t;
    }
    get change() {
      return this.wu;
    }
    set change(t) {
      this.wu = t;
    }
    get modelChange() {
      return this.bm;
    }
    set modelChange(t) {
      Debug && Util.t(t, "string", _ChangedEvent, "modelChange"), this.bm = t;
    }
    get propertyName() {
      return this.mn;
    }
    set propertyName(t) {
      Debug && typeof t != "string" && Util.t(t, "function", _ChangedEvent, "propertyName"), this.mn = t;
    }
    get isTransactionFinished() {
      return this.wu === 1 && (this.mn === "CommittedTransaction" || this.mn === "FinishedUndo" || this.mn === "FinishedRedo");
    }
    get object() {
      return this.xu;
    }
    set object(t) {
      this.xu = t;
    }
    get oldValue() {
      return this.df;
    }
    set oldValue(t) {
      this.df = t;
    }
    get oldParam() {
      return this.gf;
    }
    set oldParam(t) {
      this.gf = t;
    }
    get newValue() {
      return this.mf;
    }
    set newValue(t) {
      this.mf = t;
    }
    get newParam() {
      return this.pf;
    }
    set newParam(t) {
      this.pf = t;
    }
  };
  __publicField(_ChangedEvent, "Transaction", 1);
  __publicField(_ChangedEvent, "Property", 2);
  __publicField(_ChangedEvent, "Insert", 3);
  __publicField(_ChangedEvent, "Remove", 4);
  let ChangedEvent2 = _ChangedEvent;
  class Transaction2 {
    constructor() {
      __publicField(this, "AC");
      __publicField(this, "Tt");
      __publicField(this, "$k");
      this.AC = new List2().w(), this.Tt = "", this.$k = false;
    }
    toString(t) {
      let i = "Transaction: " + this.name + " " + this.changes.count.toString() + (this.isComplete ? "" : ", incomplete");
      if (t !== void 0 && t > 0) {
        const e = this.changes.count;
        for (let s = 0; s < e; s++) {
          const n = this.changes.elt(s);
          n !== null && (i += `
  ` + n.toString());
        }
      }
      return i;
    }
    clear() {
      const t = this.changes;
      t.ut();
      for (let i = t.count - 1; i >= 0; i--) {
        const e = t.elt(i);
        e !== null && e.clear();
      }
      t.clear(), t.w();
    }
    canUndo() {
      return this.isComplete;
    }
    undo() {
      if (this.canUndo())
        for (let t = this.changes.count - 1; t >= 0; t--) {
          const i = this.changes.elt(t);
          i !== null && i.undo();
        }
    }
    canRedo() {
      return this.isComplete;
    }
    redo() {
      if (!this.canRedo())
        return;
      const t = this.changes.count;
      for (let i = 0; i < t; i++) {
        const e = this.changes.elt(i);
        e !== null && e.redo();
      }
    }
    jD(t) {
      const i = this.changes;
      for (let e = i.count - 1; e >= t; e--) {
        const s = i.elt(e);
        s !== null && s.undo(), i.ut(), i.removeAt(e);
      }
      i.w();
    }
    optimize() {
      if (!this.isComplete)
        return;
      const t = this.changes;
      t.ut();
      const i = new GMap2();
      for (let s = 0; s < t.count; s++) {
        const n = t.elt(s);
        if (n === null || n.change !== 2 || !n.object)
          continue;
        let o = i.get(n.object);
        o || (o = new GMap2(), i.set(n.object, o));
        const r = o.get(n.propertyName);
        r === null ? o.set(n.propertyName, -1) : (r > 0 && t.setElt(r, null), o.set(n.propertyName, s));
      }
      let e = 0;
      for (let s = 0; s < t.count; s++) {
        const n = t.elt(s);
        n !== null && (s > e && t.setElt(e, n), e++);
      }
      for (; t.length > e; )
        t.pop();
      t.w();
    }
    get changes() {
      return this.AC;
    }
    get name() {
      return this.Tt;
    }
    set name(t) {
      this.Tt = t;
    }
    get isComplete() {
      return this.$k;
    }
    set isComplete(t) {
      this.$k = t;
    }
  }
  class UndoManager2 {
    constructor(t) {
      __publicField(this, "Ew");
      __publicField(this, "Xi");
      __publicField(this, "LC");
      __publicField(this, "Ys");
      __publicField(this, "Qk");
      __publicField(this, "km");
      __publicField(this, "Zn");
      __publicField(this, "Vw");
      __publicField(this, "_k");
      __publicField(this, "pn");
      __publicField(this, "yf");
      __publicField(this, "Bw");
      __publicField(this, "Ks");
      __publicField(this, "zw");
      __publicField(this, "Xw");
      __publicField(this, "Sm");
      __publicField(this, "Yw");
      this.Ew = new GSet2(), this.Xi = false, this.LC = new List2().w(), this.Ys = -1, this.Qk = 999, this.Ks = false, this.km = null, this.Zn = 0, this.Vw = false, Debug && (this.Vw = true), this._k = 23, this.pn = new List2().w(), this.yf = new List2(), this.Bw = true, this.zw = false, this.Xw = false, this.Sm = false, this.Yw = false, t && Object.assign(this, t);
    }
    toString(t) {
      let i = "UndoManager " + this.historyIndex + "<" + this.history.count + "<=" + this.maxHistoryLength;
      i += "[";
      let e = this.nestedTransactionNames.count;
      for (let s = 0; s < e; s++)
        s > 0 && (i += " "), i += this.nestedTransactionNames.elt(s);
      if (i += "]", t !== void 0 && t > 0) {
        e = this.history.count;
        for (let s = 0; s < e; s++)
          i += `
 ` + this.history.elt(s).toString(t - 1);
      }
      return i;
    }
    clear() {
      const t = this.history;
      t.ut();
      for (let i = t.count - 1; i >= 0; i--) {
        const e = t.elt(i);
        e !== null && e.clear();
      }
      t.clear(), this.Ys = -1, t.w(), this.Ks = false, this.km = null, this.Zn = 0, this.pn.ut(), this.pn.clear(), this.pn.w(), this.yf.clear(), this.zw = false, this.Xw = false, this.Sm = false, this.Yw = false;
    }
    copyProperties(t) {
      this.isEnabled = t.isEnabled, this.maxHistoryLength = t.maxHistoryLength, this.bu = t.bu;
    }
    addModel(t) {
      this.Ew.add(t);
    }
    removeModel(t) {
      this.Ew.remove(t);
    }
    startTransaction(t) {
      if (t === void 0 && (t = ""), t === null && (t = ""), this.isUndoingRedoing)
        return false;
      this.Bw === true && (this.Bw = false, this.Zn++, this.Cl || this.i("StartingFirstTransaction", t, this.currentTransaction), this.Zn > 0 && this.Zn--), this.isEnabled && (this.pn.ut(), this.pn.add(t), this.pn.w(), this.currentTransaction === null ? this.yf.add(0) : this.yf.add(this.currentTransaction.changes.count)), this.Zn++;
      const i = this.transactionLevel === 1;
      return i && (this.Cl || this.i("StartedTransaction", t, this.currentTransaction)), i;
    }
    commitTransaction(t) {
      return t === void 0 && (t = ""), this.TC(true, t);
    }
    rollbackTransaction() {
      return this.TC(false, "");
    }
    TC(t, i) {
      if (this.isUndoingRedoing)
        return false;
      this.bu && this.transactionLevel < 1 && Util.ft("Ending transaction without having started a transaction: " + i);
      const e = this.transactionLevel === 1;
      let s = this.currentTransaction;
      e && t && (this.Cl || this.i("CommittingTransaction", i, s));
      let n = 0;
      if (this.transactionLevel > 0 && (this.Zn--, this.isEnabled)) {
        const o = this.pn.count;
        o > 0 && (i === "" && (i = this.pn.elt(0)), this.pn.ut(), this.pn.removeAt(o - 1), this.pn.w());
        const r = this.yf.count;
        r > 0 && (n = this.yf.elt(r - 1), this.yf.removeAt(r - 1));
      }
      if (e) {
        if (t) {
          if (this.Sm = false, s === null && i !== "" && (s = this.currentTransaction), this.isEnabled && s !== null) {
            const o = s;
            o.isComplete || (o.isComplete = true, o.name = i), this.discardHistoryAfterIndex();
            const r = this.history;
            r.ut();
            const l = this.maxHistoryLength;
            if (l >= 0) {
              if (l === 0)
                r.clear();
              else if (r.count >= l) {
                const h = r.elt(0);
                h !== null && h.clear(), r.removeAt(0), this.Ys--;
              }
            }
            l !== 0 && (r.count === 0 || r.get(r.count - 1) !== o) && (r.add(o), this.Ys++), r.w(), s = o;
          }
          this.Cl || this.i("CommittedTransaction", i, s);
        } else {
          this.Ks = true;
          try {
            this.isEnabled && s !== null && (s.isComplete = true, s.undo());
          } finally {
            this.Cl || this.i("RolledBackTransaction", i, s), this.Ks = false;
          }
          s !== null && s.clear();
        }
        return this.km = null, this.Kw && this.clear(), this.Kw = false, this.Uw = false, true;
      } else
        return this.isEnabled && !t && s !== null && s.jD(n), false;
    }
    discardHistoryAfterIndex() {
      if (this.isUndoingRedoing || !this.canRedo())
        return;
      const t = this.history;
      t.ut();
      for (let i = t.count - 1; i > this.historyIndex; i--) {
        const e = t.elt(i);
        e !== null && e.clear(), t.removeAt(i), this.Sm = true;
      }
      t.w();
    }
    oE(t) {
      this.Zn += t, this.Zn < 0 && (this.Zn = 0);
    }
    canUndo() {
      if (!this.isEnabled || this.transactionLevel > 0)
        return false;
      const t = this.transactionToUndo;
      return !!(t !== null && t.canUndo());
    }
    undo() {
      if (!this.canUndo())
        return;
      const t = this.transactionToUndo;
      try {
        this.Ks = true, this.i("StartingUndo", "Undo", t), this.Ys--, t.undo();
      } catch (i) {
        Util.ft("undo error: " + i.toString());
      } finally {
        this.i("FinishedUndo", "Undo", t), this.Ks = false;
      }
    }
    canRedo() {
      if (!this.isEnabled || this.transactionLevel > 0)
        return false;
      const t = this.transactionToRedo;
      return !!(t !== null && t.canRedo());
    }
    redo() {
      if (!this.canRedo())
        return;
      const t = this.transactionToRedo;
      try {
        this.Ks = true, this.i("StartingRedo", "Redo", t), this.Ys++, t.redo();
      } catch (i) {
        Util.ft("redo error: " + i.toString());
      } finally {
        this.i("FinishedRedo", "Redo", t), this.Ks = false;
      }
    }
    i(t, i, e) {
      e === void 0 && (e = null);
      const s = new ChangedEvent2();
      s.change = 1, s.propertyName = t, s.object = e, s.oldValue = i;
      const n = this.models;
      for (; n.next(); ) {
        const o = n.value;
        s.model = o, o.Gw(s);
      }
    }
    handleChanged(t) {
      if (this.isEnabled && !this.isUndoingRedoing && !this.skipsEvent(t)) {
        let i = this.currentTransaction;
        i === null && (i = new Transaction2(), this.km = i);
        const e = t.copy(), s = i.changes;
        if (s.ut(), s.add(e), s.w(), this.bu && this._k > 0 && this.transactionLevel <= 0 && !this.Bw) {
          const n = t.diagram;
          if (n !== null && n.Uh === false)
            return;
          Util.ft("Change not within a transaction: " + e.toString()), this._k--;
        }
      }
    }
    skipsEvent(t) {
      if (t === null || t.change === 1)
        return true;
      const i = t.object;
      if (i === null)
        return false;
      if (i.layer !== void 0) {
        const e = i.layer;
        if (e !== null && e.isTemporary)
          return true;
      } else if (i.isTemporary)
        return true;
      return false;
    }
    get models() {
      return this.Ew.iterator;
    }
    get isEnabled() {
      return this.Xi;
    }
    set isEnabled(t) {
      this.Xi = t;
    }
    get transactionToUndo() {
      return this.historyIndex >= 0 && this.historyIndex <= this.history.count - 1 ? this.history.elt(this.historyIndex) : null;
    }
    get transactionToRedo() {
      return this.historyIndex < this.history.count - 1 ? this.history.elt(this.historyIndex + 1) : null;
    }
    get isUndoingRedoing() {
      return this.Ks;
    }
    get history() {
      return this.LC;
    }
    get maxHistoryLength() {
      return this.Qk;
    }
    set maxHistoryLength(t) {
      this.Qk = t;
    }
    get historyIndex() {
      return this.Ys;
    }
    get currentTransaction() {
      return this.km;
    }
    get transactionLevel() {
      return this.Zn;
    }
    get isInTransaction() {
      return this.Zn > 0;
    }
    get bu() {
      return this.Vw;
    }
    set bu(t) {
      this.Vw = t;
    }
    get nestedTransactionNames() {
      return this.pn;
    }
    get Kw() {
      return this.zw;
    }
    set Kw(t) {
      this.zw = t;
    }
    get Uw() {
      return this.Xw;
    }
    set Uw(t) {
      this.Xw = t;
    }
    get Cl() {
      return this.Yw;
    }
    set Cl(t) {
      this.Yw = t;
    }
    get isJustDiscarded() {
      return this.Sm;
    }
  }
  class Tool2 {
    constructor() {
      __publicField(this, "b");
      __publicField(this, "Tt");
      __publicField(this, "Xi");
      __publicField(this, "tS");
      __publicField(this, "iS");
      __publicField(this, "Mm");
      __publicField(this, "DC");
      GSet2.ji(this), this.b = Diagram2.Pm(), this.Tt = "", this.Xi = true, this.tS = false, this.iS = null, this.DC = new InputEvent2(), this.Mm = -1;
    }
    get diagram() {
      return this.b;
    }
    set diagram(t) {
      t instanceof Diagram2 && (this.b = t);
    }
    toString() {
      return this.name !== "" ? this.name + " Tool" : Util.an(this.constructor);
    }
    updateAdornments(t) {
    }
    canStart() {
      return this.isEnabled;
    }
    doStart() {
    }
    doActivate() {
      this.isActive = true;
    }
    doDeactivate() {
      this.isActive = false;
    }
    doStop() {
    }
    doCancel() {
      this.transactionResult = null, this.stopTool();
    }
    stopTool() {
      const t = this.diagram;
      t.currentTool === this && (t.currentTool = null, t.currentCursor = "");
    }
    doMouseDown() {
      !this.isActive && this.canStart() && this.doActivate();
    }
    doMouseMove() {
    }
    doMouseUp() {
      this.stopTool();
    }
    doMouseWheel() {
    }
    canStartMultiTouch() {
      return true;
    }
    standardPinchZoomStart() {
      const t = this.diagram, i = t.lastInput, e = i.getMultiTouchViewPoint(0, Point2.H(NaN, NaN)), s = i.getMultiTouchViewPoint(1, Point2.H(NaN, NaN));
      if (!e.isReal() || !s.isReal()) {
        Point2.o(e), Point2.o(s);
        return;
      }
      if (this.doCancel(), t.getInputOption("hasGestureZoom")) {
        t.eS = t.scale;
        const n = s.x - e.x, o = s.y - e.y, r = Math.sqrt(n * n + o * o);
        t.sS = r, i.bubbles = false;
      }
      Point2.o(e), Point2.o(s);
    }
    standardPinchZoomMove() {
      const t = this.diagram, i = t.lastInput, e = i.getMultiTouchViewPoint(0, Point2.H(NaN, NaN)), s = i.getMultiTouchViewPoint(1, Point2.H(NaN, NaN));
      if (!e.isReal() || !s.isReal()) {
        Point2.o(e), Point2.o(s);
        return;
      }
      if (this.doCancel(), t.getInputOption("hasGestureZoom")) {
        const n = s.x - e.x, o = s.y - e.y, l = Math.sqrt(n * n + o * o) / t.sS, h = new Point2((Math.min(s.x, e.x) + Math.max(s.x, e.x)) / 2, (Math.min(s.y, e.y) + Math.max(s.y, e.y)) / 2), a = t.eS * l, f = t.commandHandler;
        if (a !== t.scale && f.canResetZoom(a)) {
          const c = t.zoomPoint;
          t.zoomPoint = h, f.resetZoom(a), t.zoomPoint = c;
        }
        i.bubbles = false;
      }
      Point2.o(e), Point2.o(s);
    }
    doKeyDown() {
      this.diagram.lastInput.code === "Escape" && this.doCancel();
    }
    doKeyUp() {
    }
    startTransaction(t) {
      return t === void 0 && (t = this.name), this.transactionResult = null, this.diagram.startTransaction(t);
    }
    stopTransaction() {
      const t = this.diagram;
      return this.transactionResult === null ? t.rollbackTransaction() : t.commitTransaction(this.transactionResult);
    }
    standardMouseSelect() {
      const t = this.diagram;
      if (!t.allowSelect)
        return;
      const i = t.lastInput, e = t.findPartAt(i.documentPoint, false);
      if (e !== null) {
        if (Util.dr ? i.meta : i.control) {
          t.V("ChangingSelection", t.selection);
          let s = e;
          for (; s !== null && !s.canSelect(); )
            s = s.containingGroup;
          s !== null && (s.isSelected = !s.isSelected), t.V("ChangedSelection", t.selection);
        } else if (i.shift) {
          if (!e.isSelected) {
            t.V("ChangingSelection", t.selection);
            let s = e;
            for (; s !== null && !s.canSelect(); )
              s = s.containingGroup;
            s !== null && (s.isSelected = true), t.V("ChangedSelection", t.selection);
          }
        } else if (!e.isSelected) {
          let s = e;
          for (; s !== null && !s.canSelect(); )
            s = s.containingGroup;
          s !== null && t.select(s);
        }
      } else
        i.left && !(Util.dr ? i.meta : i.control) && !i.shift && t.clearSelection();
    }
    standardMouseClick(t, i) {
      t === void 0 && (t = null), i === void 0 && (i = (o) => !o.layer.isTemporary);
      const e = this.diagram, s = e.lastInput, n = e.findObjectAt(s.documentPoint, t, i);
      return s.targetObject = n, this.JD(n, s, e), s.handled;
    }
    JD(t, i, e) {
      if (i.handled = false, t !== null && !t.isEnabledObject())
        return;
      let s = 0;
      i.left ? i.clickCount === 1 ? s = 1 : i.clickCount === 2 ? s = 2 : s = 1 : i.right && i.clickCount === 1 && (s = 3);
      let n = "ObjectSingleClicked";
      if (t !== null) {
        switch (s) {
          case 1:
            n = "ObjectSingleClicked";
            break;
          case 2:
            n = "ObjectDoubleClicked";
            break;
          case 3:
            n = "ObjectContextClicked";
            break;
        }
        s !== 0 && e.V(n, t);
      } else {
        switch (s) {
          case 1:
            n = "BackgroundSingleClicked";
            break;
          case 2:
            n = "BackgroundDoubleClicked";
            break;
          case 3:
            n = "BackgroundContextClicked";
            break;
        }
        s !== 0 && e.V(n);
      }
      if (t !== null)
        for (; t !== null; ) {
          let o = null;
          switch (s) {
            case 1:
              o = t.click;
              break;
            case 2:
              o = t.doubleClick ? t.doubleClick : t.click;
              break;
            case 3:
              o = t.contextClick;
              break;
          }
          if (o !== null && (o(i, t), i.handled))
            break;
          t = t.panel;
        }
      else {
        let o = null;
        switch (s) {
          case 1:
            o = e.click;
            break;
          case 2:
            o = e.doubleClick ? e.doubleClick : e.click;
            break;
          case 3:
            o = e.contextClick;
            break;
        }
        o !== null && o(i);
      }
    }
    standardMouseOver() {
      const t = this.diagram, i = t.lastInput;
      if (t.animationManager.Mi === true)
        return;
      const e = t.skipsUndoManager;
      t.skipsUndoManager = true;
      let s = t.viewportBounds.containsPoint(i.documentPoint) ? t.findObjectAt(i.documentPoint, null, null) : null;
      i.event && (i.event.type === "pointercancel" || i.event.type === "pointerout") && (s = null), i.targetObject = s;
      let n = false;
      if (s !== t.wf) {
        let o = t.wf;
        const r = o;
        for (t.wf = s, this.doCurrentObjectChanged(o, s), i.handled = false; o !== null; ) {
          const l = o.mouseLeave;
          if (l !== null && (s === o || s !== null && s.isContainedBy(o) || (l(i, o, s), n = true, i.handled)))
            break;
          o = o.panel;
        }
        for (o = r, i.handled = false; s !== null; ) {
          const l = s.mouseEnter;
          if (l !== null && (o === s || o !== null && o.isContainedBy(s) || (l(i, s, o), n = true, i.handled)))
            break;
          s = s.panel;
        }
        s = t.wf;
      }
      if (s !== null) {
        let o = s, r = "";
        for (; o !== null && (r = o.cursor, r === ""); )
          o = o.panel;
        for (t.currentCursor = r, i.handled = false, o = s; o !== null; ) {
          const l = o.mouseOver;
          if (l !== null && (l(i, o), n = true, i.handled))
            break;
          o = o.panel;
        }
      } else {
        this.doUpdateCursor(null);
        const o = t.mouseOver;
        o !== null && (o(i), n = true);
      }
      n && t.requestUpdate(), t.skipsUndoManager = e;
    }
    doUpdateCursor(t) {
      const i = this.diagram;
      i && (i.currentCursor = "");
    }
    doCurrentObjectChanged(t, i) {
    }
    standardMouseWheel() {
      const t = this.diagram, i = t.lastInput;
      let e = i.delta;
      if (e === 0 || !t.documentBounds.isReal())
        return;
      const s = t.commandHandler, n = t.toolManager.mouseWheelBehavior;
      if (s !== null && (n === 2 && !i.shift || n === 1 && i.control)) {
        if (e > 0 ? s.canIncreaseZoom() : s.canDecreaseZoom()) {
          const o = t.zoomPoint;
          t.zoomPoint = i.viewPoint, e > 0 ? s.increaseZoom() : s.decreaseZoom(), t.zoomPoint = o;
        }
        i.bubbles = false;
      } else if (n === 2 && i.shift || n === 1 && !i.control) {
        const o = t.position.copy(), r = i.event, l = r.deltaMode;
        let h = r.deltaX, a = r.deltaY, f = "pixel";
        if ((h !== 0 || a !== 0) && !i.shift) {
          switch (l) {
            case 0:
              f = "pixel";
              break;
            case 1:
              f = "line";
              break;
            case 2:
              f = "page";
              break;
          }
          if (h !== 0 && t.allowHorizontalScroll) {
            const c = t.scrollHorizontalLineChange;
            h = h * (c / 16), t.scroll(f, h > 0 ? "right" : "left", Math.abs(h));
          }
          if (a !== 0 && t.allowVerticalScroll) {
            const c = t.scrollVerticalLineChange;
            a = a * (c / 16), t.scroll(f, a > 0 ? "down" : "up", Math.abs(a));
          }
        } else
          !i.shift && t.allowVerticalScroll ? (e = e * 3 * t.scrollVerticalLineChange, t.scroll(f, e > 0 ? "up" : "down", Math.abs(e))) : i.shift && t.allowHorizontalScroll && (e = e * 3 * t.scrollHorizontalLineChange, t.scroll(f, e > 0 ? "left" : "right", Math.abs(e)));
        this.doWheelChange(t, o, i);
      }
    }
    doWheelChange(t, i, e) {
      (!t.position.equals(i) || e.event.wheelDeltaX !== 0) && (e.bubbles = false);
    }
    standardWaitAfter(t, i) {
      Debug && Util.t(t, "number", Tool2, "standardWaitAfter:delay"), i === void 0 && (i = this.diagram.lastInput), this.cancelWaitAfter();
      const e = this, s = i.clone(this.DC);
      this.Mm = Util.Xh(() => e.doWaitAfter(s), t);
    }
    cancelWaitAfter() {
      this.Mm !== -1 && Util.Gg(this.Mm), this.Mm = -1;
    }
    doWaitAfter(t) {
    }
    findToolHandleAt(t, i) {
      const s = this.diagram.findObjectAt(t, (n) => {
        for (; n !== null && !(n.panel instanceof Adornment2); )
          n = n.panel;
        return n;
      });
      return s === null ? null : s.part.category === i ? s : null;
    }
    isBeyondDragSize(t, i) {
      const e = this.diagram;
      t === void 0 && (t = e.firstInput.viewPoint), i === void 0 && (i = e.lastInput.viewPoint);
      const s = e.toolManager.dragSize;
      let n = s.width, o = s.height;
      return e.firstInput.isTouchEvent && (n += 6, o += 6), Math.abs(i.x - t.x) > n || Math.abs(i.y - t.y) > o;
    }
    get name() {
      return this.Tt;
    }
    set name(t) {
      Util.t(t, "string", Tool2, "name"), this.Tt = t;
    }
    get isEnabled() {
      return this.Xi;
    }
    set isEnabled(t) {
      Util.t(t, "boolean", Tool2, "isEnabled"), this.Xi = t;
    }
    get isActive() {
      return this.tS;
    }
    set isActive(t) {
      Util.t(t, "boolean", Tool2, "isActive"), this.tS = t;
    }
    get transactionResult() {
      return this.iS;
    }
    set transactionResult(t) {
      t !== null && Util.t(t, "string", Tool2, "transactionResult"), this.iS = t;
    }
  }
  var WheelMode2 = ((w) => (w[w.Scroll = 1] = "Scroll", w[w.Zoom = 2] = "Zoom", w[w.None = 3] = "None", w))(WheelMode2 || {}), GestureMode2 = ((w) => (w[w.Zoom = 1] = "Zoom", w[w.Cancel = 2] = "Cancel", w[w.None = 3] = "None", w))(GestureMode2 || {});
  const _ToolManager = class _ToolManager extends Tool2 {
    constructor(t) {
      super();
      __publicField(this, "FC");
      __publicField(this, "RC");
      __publicField(this, "IC");
      __publicField(this, "nS");
      __publicField(this, "oS");
      __publicField(this, "rS");
      __publicField(this, "lS");
      __publicField(this, "hS");
      __publicField(this, "aS");
      __publicField(this, "fS");
      __publicField(this, "Nm");
      __publicField(this, "Gh");
      this.name = "ToolManager", this.FC = new List2(), this.RC = new List2(), this.IC = new List2(), this.nS = 850, this.oS = 850, this.rS = new Size2(2, 2).rt(), this.lS = 5e3, this.hS = 1, this.aS = 1, this.fS = null, this.Nm = null, this.Gh = -1, t && Object.assign(this, t);
    }
    get mouseWheelBehavior() {
      return this.hS;
    }
    set mouseWheelBehavior(t) {
      Util.it(t, WheelMode2, "WheelMode"), this.hS = t;
    }
    get gestureBehavior() {
      return this.aS;
    }
    set gestureBehavior(t) {
      Util.it(t, GestureMode2, "GestureMode"), this.aS = t;
    }
    initializeStandardTools() {
    }
    updateAdornments(t) {
      const i = this.currentToolTip;
      if (i instanceof Adornment2 && this.Nm === t) {
        const e = i.adornedObject;
        (t !== null ? e.part === t : e === null) ? this.showToolTip(i, e) : this.hideToolTip();
      }
    }
    doMouseDown() {
      const t = this.diagram, i = t.lastInput;
      if (i.isTouchEvent && this.gestureBehavior === 2 && (i.bubbles = false), i.isMultiTouch) {
        if (this.cancelWaitAfter(), this.gestureBehavior === 3) {
          i.bubbles = true;
          return;
        }
        if (this.gestureBehavior === 2)
          return;
        if (t.currentTool.canStartMultiTouch()) {
          t.currentTool.standardPinchZoomStart();
          return;
        }
      }
      const e = t.undoManager;
      Debug && e.bu && e.transactionLevel !== 0 && Util.ft("WARNING: In ToolManager.doMouseDown: UndoManager.transactionLevel is not zero");
      const s = this.mouseDownTools.length;
      for (let n = 0; n < s; n++) {
        const o = this.mouseDownTools.elt(n);
        if (o.diagram = this.diagram, o.canStart()) {
          t.doFocus(), t.currentTool = o, t.currentTool === o && (o.isActive || o.doActivate(), o.doMouseDown());
          return;
        }
      }
      t.lastInput.button === 1 && (this.mouseWheelBehavior === 1 ? this.mouseWheelBehavior = 2 : this.mouseWheelBehavior === 2 && (this.mouseWheelBehavior = 1)), this.doActivate(), this.standardWaitAfter(this.holdDelay, i);
    }
    doMouseMove() {
      const t = this.diagram, i = t.lastInput;
      if (i.isMultiTouch) {
        if (this.gestureBehavior === 3) {
          i.bubbles = true;
          return;
        }
        if (this.gestureBehavior === 2)
          return;
        if (t.currentTool.canStartMultiTouch()) {
          t.currentTool.standardPinchZoomMove();
          return;
        }
      }
      if (this.isActive) {
        const s = this.mouseMoveTools.length;
        for (let n = 0; n < s; n++) {
          const o = this.mouseMoveTools.elt(n);
          if (o.diagram = this.diagram, o.canStart()) {
            t.doFocus(), t.currentTool = o, t.currentTool === o && (o.isActive || o.doActivate(), o.doMouseMove());
            return;
          }
        }
      }
      this.standardMouseActivity(t);
      const e = i.event;
      e !== null && (e.type === "pointermove" || !e.cancelable) && (i.bubbles = true);
    }
    standardMouseActivity(t) {
      this.standardMouseOver(), this.isBeyondDragSize() && this.standardWaitAfter(this.isActive ? this.holdDelay : this.hoverDelay, t.lastInput);
    }
    doCurrentObjectChanged(t, i) {
      const e = this.currentToolTip;
      e !== null && (i !== null && e instanceof Adornment2 && (i === e || i.isContainedBy(e)) || this.hideToolTip());
    }
    doWaitAfter(t) {
      const i = this.diagram;
      if (i.ZD() && (this.doMouseHover(), this.isActive || this.doToolTip(), t.isTouchEvent && !i.lastInput.handled)) {
        const e = t.copy();
        e.button = 2, e.buttons = 2, i.lastInput = e, i.Hw = true, i.doMouseUp();
        return;
      }
    }
    doMouseHover() {
      const t = this.diagram, i = t.lastInput;
      i.targetObject === null && (i.targetObject = t.findObjectAt(i.documentPoint, null, null));
      let e = i.targetObject;
      if (e !== null)
        for (i.handled = false; e !== null; ) {
          const s = this.isActive ? e.mouseHold : e.mouseHover;
          if (s !== null && (s(i, e), i.handled))
            break;
          e = e.panel;
        }
      else {
        const s = this.isActive ? t.mouseHold : t.mouseHover;
        s !== null && s(i);
      }
    }
    doToolTip() {
      const t = this.diagram, i = t.lastInput;
      i.targetObject === null && (i.targetObject = t.findObjectAt(i.documentPoint, null, null));
      let e = i.targetObject;
      if (e !== null) {
        const s = this.currentToolTip;
        if (s instanceof Adornment2 && (e === s || e.isContainedBy(s)))
          return;
        for (; e !== null; ) {
          const n = e.toolTip;
          if (n !== null) {
            this.showToolTip(n, e);
            return;
          }
          e = e.panel;
        }
        this.hideToolTip();
      } else {
        const s = t.toolTip;
        s !== null ? this.showToolTip(s, null) : this.hideToolTip();
      }
    }
    showToolTip(t, i) {
      Debug && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && Util.n("showToolTip:tooltip must be an Adornment or HTMLInfo."), i !== null && Util.s(i, GraphObject2, _ToolManager, "showToolTip:obj");
      const e = this.diagram;
      if (t !== this.currentToolTip && this.hideToolTip(), t instanceof Adornment2) {
        t.layerName = "Tool", t.selectable = false, t.scale = 1 / e.scale, t.category = "ToolTip", t.hasPlaceholder() && (t.placeholder.scale = e.scale);
        const n = t.diagram;
        n !== null && n !== e && n.remove(t), e.add(t), i !== null ? t.adornedObject = i : t.data = e.model, t.ensureBounds(), this.positionToolTip(t, i);
      } else
        t instanceof HTMLInfo2 && t !== this.currentToolTip && t.show(i, e, this);
      this.currentToolTip = t, this.Gh !== -1 && (Util.Gg(this.Gh), this.Gh = -1);
      const s = this.toolTipDuration;
      if (s > 0 && s !== 1 / 0) {
        const n = this;
        this.Gh = Util.Xh(() => n.hideToolTip(), s);
      }
    }
    positionToolTip(t, i) {
      if (t.hasPlaceholder())
        return;
      const e = t, s = this.diagram, n = s.lastInput.documentPoint.copy(), o = e.measuredBounds, r = s.viewportBounds;
      s.lastInput.isTouchEvent && (n.x -= o.width), n.x + o.width > r.right && (n.x -= o.width + 5 / s.scale), n.x < r.x && (n.x = r.x), n.y + 20 / s.scale + o.height > r.bottom ? n.y -= o.height + 5 / s.scale : n.y += 20 / s.scale, n.y < r.y && (n.y = r.y), e.position = n;
    }
    hideToolTip() {
      this.Gh !== -1 && (Util.Gg(this.Gh), this.Gh = -1);
      const t = this.diagram, i = this.currentToolTip;
      i !== null && (i instanceof Adornment2 ? (t.remove(i), this.Nm !== null && this.Nm.removeAdornment(i.category), i.data = null, i.adornedObject = null) : i instanceof HTMLInfo2 && i.hide !== null && i.hide(t, this), this.currentToolTip = null);
    }
    get currentToolTip() {
      return this.fS;
    }
    set currentToolTip(t) {
      Debug && t !== null && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && Util.n("ToolManager.currentToolTip must be an Adornment or HTMLInfo."), this.fS = t, this.Nm = t !== null && t instanceof Adornment2 ? t.adornedPart : null;
    }
    doMouseUp() {
      this.cancelWaitAfter();
      const t = this.diagram;
      if (this.isActive) {
        const i = this.mouseUpTools.length;
        for (let e = 0; e < i; e++) {
          const s = this.mouseUpTools.elt(e);
          if (s.diagram = this.diagram, s.canStart()) {
            t.doFocus(), t.currentTool = s, t.currentTool === s && (s.isActive || s.doActivate(), s.doMouseUp());
            return;
          }
        }
      }
      t.doFocus(), this.doDeactivate();
    }
    doMouseWheel() {
      this.standardMouseWheel();
    }
    doKeyDown() {
      const t = this.diagram;
      t.commandHandler !== null && t.commandHandler.doKeyDown();
    }
    doKeyUp() {
      const t = this.diagram;
      t.commandHandler !== null && t.commandHandler.doKeyUp();
    }
    findTool(t) {
      Util.t(t, "string", _ToolManager, "findTool:name");
      let i = this.mouseDownTools.length;
      for (let e = 0; e < i; e++) {
        const s = this.mouseDownTools.elt(e);
        if (s.name === t)
          return s;
      }
      i = this.mouseMoveTools.length;
      for (let e = 0; e < i; e++) {
        const s = this.mouseMoveTools.elt(e);
        if (s.name === t)
          return s;
      }
      i = this.mouseUpTools.length;
      for (let e = 0; e < i; e++) {
        const s = this.mouseUpTools.elt(e);
        if (s.name === t)
          return s;
      }
      return null;
    }
    replaceTool(t, i) {
      Util.t(t, "string", _ToolManager, "replaceTool:name"), i !== null && (Util.s(i, Tool2, _ToolManager, "replaceTool:newtool"), i.diagram = this.diagram);
      let e = this.mouseDownTools.length;
      for (let s = 0; s < e; s++) {
        const n = this.mouseDownTools.elt(s);
        if (n.name === t)
          return i !== null ? this.mouseDownTools.setElt(s, i) : this.mouseDownTools.removeAt(s), n;
      }
      e = this.mouseMoveTools.length;
      for (let s = 0; s < e; s++) {
        const n = this.mouseMoveTools.elt(s);
        if (n.name === t)
          return i !== null ? this.mouseMoveTools.setElt(s, i) : this.mouseMoveTools.removeAt(s), n;
      }
      e = this.mouseUpTools.length;
      for (let s = 0; s < e; s++) {
        const n = this.mouseUpTools.elt(s);
        if (n.name === t)
          return i !== null ? this.mouseUpTools.setElt(s, i) : this.mouseUpTools.removeAt(s), n;
      }
      return null;
    }
    replaceStandardTool(t, i, e) {
      this.ii(t, i, e);
    }
    ii(t, i, e) {
      Util.t(t, "string", _ToolManager, "replaceStandardTool:name"), Util.s(e, List2, _ToolManager, "replaceStandardTool:list"), i !== null && (Util.s(i, Tool2, _ToolManager, "replaceStandardTool:newtool"), i.name = t, i.diagram = this.diagram), this.findTool(t) ? this.replaceTool(t, i) : i !== null && e.add(i);
    }
    get mouseDownTools() {
      return this.FC;
    }
    get mouseMoveTools() {
      return this.RC;
    }
    get mouseUpTools() {
      return this.IC;
    }
    get hoverDelay() {
      return this.nS;
    }
    set hoverDelay(t) {
      Util.t(t, "number", _ToolManager, "hoverDelay"), this.nS = t;
    }
    get holdDelay() {
      return this.oS;
    }
    set holdDelay(t) {
      Util.t(t, "number", _ToolManager, "holdDelay"), this.oS = t;
    }
    get dragSize() {
      return this.rS;
    }
    set dragSize(t) {
      Util.s(t, Size2, _ToolManager, "dragSize"), this.rS = t.L();
    }
    get toolTipDuration() {
      return this.lS;
    }
    set toolTipDuration(t) {
      Util.t(t, "number", _ToolManager, "toolTipDuration"), this.lS = t;
    }
    get actionTool() {
      return this.findTool("Action");
    }
    set actionTool(t) {
      this.ii("Action", t, this.mouseDownTools);
    }
    get relinkingTool() {
      return this.findTool("Relinking");
    }
    set relinkingTool(t) {
      this.ii("Relinking", t, this.mouseDownTools);
    }
    get linkReshapingTool() {
      return this.findTool("LinkReshaping");
    }
    set linkReshapingTool(t) {
      this.ii("LinkReshaping", t, this.mouseDownTools);
    }
    get resizingTool() {
      return this.findTool("Resizing");
    }
    set resizingTool(t) {
      this.ii("Resizing", t, this.mouseDownTools);
    }
    get rotatingTool() {
      return this.findTool("Rotating");
    }
    set rotatingTool(t) {
      this.ii("Rotating", t, this.mouseDownTools);
    }
    get linkingTool() {
      return this.findTool("Linking");
    }
    set linkingTool(t) {
      this.ii("Linking", t, this.mouseMoveTools);
    }
    get draggingTool() {
      return this.findTool("Dragging");
    }
    set draggingTool(t) {
      this.ii("Dragging", t, this.mouseMoveTools);
    }
    get dragSelectingTool() {
      return this.findTool("DragSelecting");
    }
    set dragSelectingTool(t) {
      this.ii("DragSelecting", t, this.mouseMoveTools);
    }
    get panningTool() {
      return this.findTool("Panning");
    }
    set panningTool(t) {
      this.ii("Panning", t, this.mouseMoveTools);
    }
    get contextMenuTool() {
      return this.findTool("ContextMenu");
    }
    set contextMenuTool(t) {
      this.ii("ContextMenu", t, this.mouseUpTools);
    }
    get textEditingTool() {
      return this.findTool("TextEditing");
    }
    set textEditingTool(t) {
      this.ii("TextEditing", t, this.mouseUpTools);
    }
    get clickCreatingTool() {
      return this.findTool("ClickCreating");
    }
    set clickCreatingTool(t) {
      this.ii("ClickCreating", t, this.mouseUpTools);
    }
    get clickSelectingTool() {
      return this.findTool("ClickSelecting");
    }
    set clickSelectingTool(t) {
      this.ii("ClickSelecting", t, this.mouseUpTools);
    }
  };
  __publicField(_ToolManager, "WheelScroll", 1);
  __publicField(_ToolManager, "WheelZoom", 2);
  __publicField(_ToolManager, "WheelNone", 3);
  __publicField(_ToolManager, "GestureZoom", 1);
  __publicField(_ToolManager, "GestureCancel", 2);
  __publicField(_ToolManager, "GestureNone", 3);
  let ToolManager2 = _ToolManager;
  const _DraggingTool = class _DraggingTool extends Tool2 {
    constructor(t) {
      super();
      __publicField(this, "cS");
      __publicField(this, "uS");
      __publicField(this, "yn");
      __publicField(this, "dS");
      __publicField(this, "gS");
      __publicField(this, "mS");
      __publicField(this, "pS");
      __publicField(this, "xf");
      __publicField(this, "Cm");
      __publicField(this, "yS");
      __publicField(this, "Hh");
      __publicField(this, "Sr");
      __publicField(this, "OC");
      __publicField(this, "wS");
      __publicField(this, "ku");
      __publicField(this, "Su");
      __publicField(this, "xS");
      __publicField(this, "bS");
      __publicField(this, "kS");
      __publicField(this, "SS");
      this.name = "Dragging", this.cS = true, this.SS = true, this.uS = true, this.yn = null, this.dS = null, this.gS = null, this.mS = null, this.pS = false, this.ku = false, this.xf = new Point2(NaN, NaN), this.Cm = new Point2(), this.yS = true, this.Hh = 100, this.Sr = [], this.OC = new GSet2().w(), this.wS = new DraggingOptions2(), this.Su = null, this.xS = "copy", this.bS = "", this.kS = "no-drop", t && Object.assign(this, t);
    }
    get isCopyEnabled() {
      return this.cS;
    }
    set isCopyEnabled(t) {
      Util.t(t, "boolean", _DraggingTool, "isCopyEnabled"), this.cS = t;
    }
    get copiesEffectiveCollection() {
      return this.uS;
    }
    set copiesEffectiveCollection(t) {
      Util.t(t, "boolean", _DraggingTool, "copiesEffectiveCollection"), this.uS = t;
    }
    get dragOptions() {
      return this.wS;
    }
    set dragOptions(t) {
      Util.s(t, DraggingOptions2, _DraggingTool, "dragOptions"), this.wS = t;
    }
    get isGridSnapEnabled() {
      return this.dragOptions.isGridSnapEnabled;
    }
    set isGridSnapEnabled(t) {
      Util.t(t, "boolean", _DraggingTool, "isGridSnapEnabled"), this.dragOptions.isGridSnapEnabled = t;
    }
    get isComplexRoutingRealtime() {
      return this.yS;
    }
    set isComplexRoutingRealtime(t) {
      this.yS = t;
      const i = this.diagram.findRouter("AvoidsLinks");
      i !== null && (i.isRealtime = t);
    }
    get isGridSnapRealtime() {
      return this.dragOptions.isGridSnapRealtime;
    }
    set isGridSnapRealtime(t) {
      Util.t(t, "boolean", _DraggingTool, "isGridSnapRealtime"), this.dragOptions.isGridSnapRealtime = t;
    }
    get gridSnapCellSize() {
      return this.dragOptions.gridSnapCellSize;
    }
    set gridSnapCellSize(t) {
      Util.s(t, Size2, _DraggingTool, "gridSnapCellSize"), this.dragOptions.gridSnapCellSize.equals(t) || (t = t.L(), this.dragOptions.gridSnapCellSize = t);
    }
    get gridSnapCellSpot() {
      return this.dragOptions.gridSnapCellSpot;
    }
    set gridSnapCellSpot(t) {
      Util.s(t, Spot2, _DraggingTool, "gridSnapCellSpot"), this.dragOptions.gridSnapCellSpot.equals(t) || (t = t.L(), this.dragOptions.gridSnapCellSpot = t);
    }
    get gridSnapOrigin() {
      return this.dragOptions.gridSnapOrigin;
    }
    set gridSnapOrigin(t) {
      Util.s(t, Point2, _DraggingTool, "gridSnapOrigin"), this.dragOptions.gridSnapOrigin.equals(t) || (t = t.L(), this.dragOptions.gridSnapOrigin = t);
    }
    get dragsLink() {
      return this.dragOptions.dragsLink;
    }
    set dragsLink(t) {
      Util.t(t, "boolean", _DraggingTool, "dragsLink"), this.dragOptions.dragsLink = t;
    }
    get dragsTree() {
      return this.dragOptions.dragsTree;
    }
    set dragsTree(t) {
      Util.t(t, "boolean", _DraggingTool, "dragsTree"), this.dragOptions.dragsTree = t;
    }
    get copyCursor() {
      return this.xS;
    }
    set copyCursor(t) {
      this.xS = t;
    }
    get moveCursor() {
      return this.bS;
    }
    set moveCursor(t) {
      this.bS = t;
    }
    get nodropCursor() {
      return this.kS;
    }
    set nodropCursor(t) {
      this.kS = t;
    }
    get currentPart() {
      return this.dS;
    }
    set currentPart(t) {
      t !== null && Util.s(t, Part2, _DraggingTool, "currentPart"), this.dS = t;
    }
    get copiedParts() {
      return this.mS;
    }
    set copiedParts(t) {
      this.mS = t;
    }
    get draggedParts() {
      return this.gS;
    }
    set draggedParts(t) {
      this.gS = t;
    }
    get draggingParts() {
      return this.copiedParts !== null ? this.copiedParts.toKeySet() : this.draggedParts !== null ? this.draggedParts.toKeySet() : this.OC;
    }
    get draggedLink() {
      return this.diagram.draggedLink;
    }
    set draggedLink(t) {
      t !== null && Util.s(t, Link2, _DraggingTool, "draggedLink"), this.diagram.draggedLink = t;
    }
    get isDragOutStarted() {
      return this.pS;
    }
    set isDragOutStarted(t) {
      this.pS = t;
    }
    get startPoint() {
      return this.Cm;
    }
    set startPoint(t) {
      Util.s(t, Point2, _DraggingTool, "startPoint"), this.Cm.equals(t) || this.Cm.c(t);
    }
    get delay() {
      return this.Hh;
    }
    set delay(t) {
      Util.t(t, "number", _DraggingTool, "delay"), this.Hh = t;
    }
    canStart() {
      if (!this.isEnabled)
        return false;
      const t = this.diagram;
      if (t.isReadOnly && !t.allowDragOut || !t.allowMove && !t.allowCopy && !t.allowDragOut || !t.allowSelect)
        return false;
      const i = t.lastInput;
      return !i.left || t.currentTool !== this && (!this.isBeyondDragSize() || i.isTouchEvent && i.timestamp - t.firstInput.timestamp < this.Hh) ? false : this.findDraggablePart() !== null;
    }
    findDraggablePart() {
      const t = this.diagram;
      let i = t.findPartAt(t.firstInput.documentPoint, false);
      if (i === null)
        return null;
      for (; i !== null && !i.canSelect(); )
        i = i.containingGroup;
      return i !== null && (i.canMove() || i.canCopy()) ? i : null;
    }
    standardMouseSelect() {
      const t = this.diagram;
      if (!t.allowSelect)
        return;
      let i = t.findPartAt(t.firstInput.documentPoint, false);
      if (i !== null) {
        for (; i !== null && !i.canSelect(); )
          i = i.containingGroup;
        if (this.currentPart = i, this.currentPart !== null && !this.currentPart.isSelected) {
          t.V("ChangingSelection", t.selection);
          const e = t.lastInput;
          !(Util.dr ? e.meta : e.control) && !e.shift && t.clearSelection(true), this.currentPart.isSelected = true, t.V("ChangedSelection", t.selection);
        }
      }
    }
    doActivate() {
      const t = this.diagram;
      this.Su = null, this.currentPart === null && this.standardMouseSelect();
      const i = this.currentPart;
      if (i === null || !i.canMove() && !i.canCopy())
        return;
      t.cacheGroupExternalLinks(true), _DraggingTool.St = null, this.isActive = true, this.xf.set(t.position), this.MS(t.selection), this.Sr.length = 0, t.animationManager.stopAnimation();
      const e = this.computeEffectiveCollection(t.selection, this.dragOptions);
      this.draggedParts = e, this.SS = this.diagram.layout.isRealtime, this.diagram.layout.isRealtime = false, t.Am = true, t.getRenderingHint("temporaryPixelRatio") === true && t.avgSpf > 30 && t.vw(), t.qw(this.draggedParts), t.Mu = true, this.startTransaction("Drag"), this.startPoint = t.firstInput.documentPoint, t.isMouseCaptured = true, t.allowDragOut && this.$D();
    }
    MS(t) {
      if (this.dragsLink) {
        const i = this.diagram;
        if (!i.allowRelink)
          return;
        i.model.bf() && t.count === 1 && t.first() instanceof Link2 ? (this.draggedLink = t.first(), this.draggedLink.canRelinkFrom() && this.draggedLink.canRelinkTo() && this.draggedLink.clearAdornments(), this.yn = i.toolManager.findTool("Relinking"), this.yn === null && (this.yn = new RelinkingTool2(), this.yn.diagram = i), this.yn.originalLink = this.draggedLink) : (this.draggedLink = null, this.yn = null);
      }
    }
    computeEffectiveCollection(t, i) {
      return this.diagram.commandHandler.computeEffectiveCollection(t, i);
    }
    Us(t) {
      return t === void 0 ? new DraggingInfo2(Point2.To) : this.isGridSnapEnabled ? new DraggingInfo2(new Point2(Math.round(t.x * 1e3) / 1e3, Math.round(t.y * 1e3) / 1e3)) : new DraggingInfo2(t.copy());
    }
    doDeactivate() {
      this.isActive = false;
      const t = this.diagram;
      this.diagram.layout.isRealtime = this.SS, t.Mu = false, t.Al = true, t.cacheGroupExternalLinks(false), t.stopAutoScroll(), this.PS(), t.Lm(this.draggedParts), this.Su = null, this.currentPart = null, this.draggedParts = null, this.isDragOutStarted = false, this.ku = false, _DraggingTool.QD(), this.EC(), this.xf.e(NaN, NaN), _DraggingTool.vh !== null && (_DraggingTool.vh.currentCursor = ""), _DraggingTool.vh = null, _DraggingTool.St = null, this.Ll(), t.isMouseCaptured = false, t.currentCursor = "", t.Am = false, this.stopTransaction(), t.NS(true);
    }
    stopTransaction() {
      const t = this.diagram, i = super.stopTransaction();
      return i && t.undoManager.transactionToUndo !== null && t.undoManager.transactionToUndo.optimize(), i;
    }
    PS() {
      const t = this.diagram, i = t.skipsUndoManager;
      t.skipsUndoManager = true;
      const e = t.lastInput;
      this.VC(e, null), t.skipsUndoManager = i, this.Sr.length = 0;
    }
    BC() {
      this.Ll(), this.CS();
      const t = this.diagram;
      this.xf.isReal() && (t.position = this.xf), t.stopAutoScroll();
    }
    doCancel() {
      this.Ll(), this.CS();
      const t = this.diagram;
      this.xf.isReal() && (t.position = this.xf), this.stopTool();
    }
    doKeyDown() {
      const t = this.diagram, i = t.lastInput;
      this.isActive && (i.code === "Escape" ? this.doCancel() : i.code !== t.previousInput.code && this.doMouseMove());
    }
    doKeyUp() {
      this.isActive && this.doMouseMove();
    }
    _D(t, i) {
      let e = 1 / 0, s = 1 / 0, n = -1 / 0, o = -1 / 0;
      const r = t.iterator;
      for (; r.next(); ) {
        const l = r.value;
        if (!l.isVisible())
          continue;
        const h = l.location, a = h.x, f = h.y;
        isNaN(a) || isNaN(f) || (a < e && (e = a), f < s && (s = f), a > n && (n = a), f > o && (o = f));
      }
      return e === 1 / 0 ? i.e(0, 0, 0, 0) : i.e(e, s, n - e, o - s), i;
    }
    AS(t) {
      if (this.copiedParts !== null)
        return;
      const i = this.diagram;
      if (t && (i.isReadOnly || i.isModelReadOnly) || this.draggedParts === null)
        return;
      const e = i.undoManager;
      e.isEnabled && e.isInTransaction ? e.currentTransaction !== null && e.currentTransaction.changes.count > 0 && (i.undoManager.rollbackTransaction(), i.startTransaction("Drag")) : this.CS(), i.skipsUndoManager = !t, i.partManager.addsToTemporaryLayer = !t, this.startPoint = i.firstInput.documentPoint;
      const s = this.copiesEffectiveCollection ? this.draggedParts.toKeySet() : i.selection, n = i.copyParts(s, i, true), o = new GMap2(), r = this.draggedParts.iterator;
      for (; r.next(); ) {
        const h = r.key;
        if (h.De() && h.canCopy()) {
          const a = n.getValue(h);
          if (a === null)
            continue;
          a.location = h.location, a.ensureBounds(), o.add(a, this.Us(a.location));
        }
      }
      const l = n.iterator;
      for (; l.next(); ) {
        const h = l.value;
        h instanceof Link2 && h.canCopy() && o.add(h, this.Us());
      }
      if (this.copiedParts = o, this.MS(o.toKeySet()), this.draggedLink !== null) {
        const h = this.draggedLink, a = h.routeBounds;
        h.Mr(this.startPoint.x - (a.x + a.width / 2), this.startPoint.y - (a.y + a.height / 2));
      }
      this.doUpdateCursor(null);
    }
    Ll() {
      const t = this.diagram;
      if (this.copiedParts !== null) {
        if (t.removeParts(this.copiedParts.toKeySet(), false), this.copiedParts = null, this.draggedParts !== null) {
          const i = this.draggedParts.iterator;
          for (; i.next(); )
            if (i.key instanceof Link2) {
              const s = i.value;
              s.point = new Point2(0, 0);
            }
        }
        this.doUpdateCursor(null);
      }
      t.skipsUndoManager = false, t.partManager.addsToTemporaryLayer = false, this.startPoint = t.firstInput.documentPoint;
    }
    EC() {
      this.draggedLink !== null && (this.dragsLink && this.yn !== null && (this.yn.stopDraggingMouseMove(), this.yn.originalLink = null), this.draggedLink = null, this.yn = null);
    }
    kf(t, i) {
      const e = this.diagram, s = this.startPoint, n = Point2.a();
      n.c(e.lastInput.documentPoint), this.moveParts(t, n.subtract(s), i), Point2.o(n), e.getRenderingHint("temporaryPixelRatio") === true && e.Tl === null && e.avgSpf > 30 && (e.vw(), e.Pu());
    }
    moveParts(t, i, e) {
      e === void 0 && (e = false);
      const s = this.diagram;
      s !== null && s.LS(t, i, this.dragOptions, e);
    }
    CS() {
      if (this.draggedParts === null)
        return;
      const t = this.diagram;
      let i = this.draggedParts.iterator;
      for (; i.next(); ) {
        const e = i.key;
        e.De() && (e.location = i.value.point);
      }
      for (i = this.draggedParts.iterator; i.next(); ) {
        const e = i.key;
        if (e instanceof Link2 && e.wn) {
          const s = i.value.point;
          this.draggedParts.add(e, this.Us()), e.Mr(-s.x, -s.y);
        }
      }
      t.maybeUpdate();
    }
    tF(t) {
      if (t === null)
        return true;
      const i = t.part;
      return !!(i === null || i instanceof Adornment2 || i.layer.isTemporary || this.draggedParts && this.draggedParts.contains(i) || this.copiedParts && this.copiedParts.contains(i));
    }
    TS(t) {
      const i = this.diagram;
      this.dragsLink && (this.draggedLink !== null && (this.draggedLink.fromNode = null, this.draggedLink.toNode = null), this.zC(false));
      const e = this.findDragOverObject(t), s = i.lastInput;
      s.targetObject = e, this.doUpdateCursor(e);
      const n = i.skipsUndoManager;
      let o = false;
      try {
        if (i.skipsUndoManager = true, o = this.VC(s, e), !this.isActive && _DraggingTool.St === null)
          return;
        const r = e !== null ? e.part : null;
        if (r === null || i.handlesDragDropForTopLevelParts && r.isTopLevel && !(r instanceof Group2)) {
          const l = i.mouseDragOver;
          l !== null && (l(s), o = true);
        }
        if (!this.isActive && _DraggingTool.St === null || (this.doDragOver(t, e), !this.isActive && _DraggingTool.St === null))
          return;
      } finally {
        i.skipsUndoManager = n, o && i.maybeUpdate();
      }
      this.Su = e, !i.isReadOnly && (i.allowMove || i.allowCopy) && (i.allowHorizontalScroll || i.allowVerticalScroll) && i.doAutoScroll(s.viewPoint);
    }
    findDragOverObject(t) {
      return this.diagram.DS(t, null, (i) => !this.tF(i));
    }
    doUpdateCursor(t) {
      const i = this.diagram;
      (t === null || this.Su !== t) && (!this.diagram.currentTool.isActive || this.mayCopy() ? i.currentCursor = this.copyCursor : this.mayMove() ? i.currentCursor = this.moveCursor : this.mayDragOut() && (i.currentCursor = this.nodropCursor));
    }
    VC(t, i) {
      let e = false, s = this.Sr.length;
      const n = s > 0 ? this.Sr[0] : null;
      if (i === n)
        return false;
      t.handled = false;
      for (let r = 0; r < s; r++) {
        const l = this.Sr[r], h = l.mouseDragLeave;
        if (h !== null && (h(t, l, i), e = true, t.handled))
          break;
      }
      if (this.Sr.length = 0, !this.isActive && _DraggingTool.St === null || i === null)
        return e;
      t.handled = false;
      let o = i;
      for (; o !== null; )
        this.Sr.push(o), o = this.XC(o);
      s = this.Sr.length;
      for (let r = 0; r < s; r++) {
        const l = this.Sr[r], h = l.mouseDragEnter;
        if (h !== null && (h(t, l, n), e = true, t.handled))
          break;
      }
      return e;
    }
    rE(t, i) {
      return t === null ? false : !!(t === i || t.isContainedBy(i) || i instanceof Group2 && !(t instanceof Group2) && i.handlesDragDropForMembers && t.part.isMemberOf(i));
    }
    XC(t) {
      const i = t.panel;
      if (i !== null)
        return i;
      if (t instanceof Part2 && !(t instanceof Group2)) {
        const e = t.containingGroup;
        if (e !== null && e.handlesDragDropForMembers)
          return e;
      }
      return null;
    }
    YC(t, i) {
      const e = this.diagram, s = this.yn;
      if (s === null)
        return null;
      const n = s.portGravity, o = e.findObjectsNear(t, n, (a) => s.findValidLinkablePort(a, i)), r = Point2.a();
      let l = 1 / 0, h = null;
      for (const a = o.iterator; a.next(); ) {
        const f = a.value;
        if (f.part === null)
          continue;
        const u = f.getDocumentPoint(Spot2.Center, r), d = t.distanceSquaredPoint(u);
        d < l && (h = f, l = d);
      }
      return Point2.o(r), h;
    }
    zC(t) {
      const i = this.draggedLink;
      if (i !== null) {
        if (i.pointsCount < 2)
          return;
        const e = this.diagram;
        if (e.isReadOnly)
          return;
        const s = this.yn;
        if (s === null)
          return;
        let n = null, o = null;
        i.fromNode === null && (n = this.YC(i.getPoint(0), false), n !== null && (o = n.part));
        let r = null, l = null;
        i.toNode === null && (r = this.YC(i.getPoint(i.pointsCount - 1), true), r !== null && (l = r.part)), s.isValidLink(o, n, l, r) ? t ? (i.defaultFromPoint = i.getPoint(0), i.defaultToPoint = i.getPoint(i.pointsCount - 1), i.wn = false, i.fromNode = o, n !== null && (i.fromPortId = n.portId), i.toNode = l, r !== null && (i.toPortId = r.portId), i.fromPort !== e.FS && e.V("LinkRelinked", i, e.FS), i.toPort !== e.RS && e.V("LinkRelinked", i, e.RS)) : s.doDraggingMouseMove(o, n, l, r) : s.doDraggingMouseMove(null, null, null, null);
      }
    }
    doDragOver(t, i) {
    }
    KC(t) {
      const i = this.diagram;
      this.dragsLink && this.zC(true), this.PS();
      const e = this.findDragOverObject(t), s = i.lastInput;
      if (s.targetObject = e, e !== null) {
        s.handled = false;
        let l = e;
        for (; l !== null; ) {
          const h = l.mouseDrop;
          if (h !== null && (h(s, l), s.handled))
            break;
          this.iF(s, l), l = this.XC(l);
        }
      } else {
        const l = i.mouseDrop;
        l !== null && l(s);
      }
      if (!this.isActive && _DraggingTool.St === null)
        return;
      const n = (this.copiedParts || this.draggedParts).iterator;
      for (; n.next(); ) {
        const l = n.key;
        l instanceof Node2 && l.linksConnected.each((h) => h.wn = false);
      }
      if (this.doDropOnto(t, e), !this.isActive && _DraggingTool.St === null)
        return;
      const o = Rect2.a(), r = i.selection.iterator;
      for (; r.next(); ) {
        const l = r.value;
        l instanceof Node2 && this.eF(i, l, o);
      }
      Rect2.o(o);
    }
    iF(t, i) {
      const e = this.diagram, s = i.part;
      if (e.handlesDragDropForTopLevelParts && s.isTopLevel && !(s instanceof Group2)) {
        const n = e.mouseDrop;
        n !== null && n(t);
      }
    }
    eF(t, i, e) {
      if (!i.canAvoid())
        return;
      let s = false;
      e = i.getAvoidableRect(e), t.viewportBounds.containsRect(e) && (s = true);
      const n = this.copiedParts || this.draggedParts, o = t.IS(e, (l) => l.part, (l) => l instanceof Link2, true, (l) => l instanceof Link2, s);
      if (o.count === 0)
        return;
      const r = o.iterator;
      for (; r.next(); ) {
        const l = r.value;
        n.contains(l) && n.contains(i) || !l.isMemberOf(i) && l.isAvoiding && l.invalidateRoute();
      }
    }
    doDropOnto(t, i) {
    }
    doMouseMove() {
      if (!this.isActive)
        return;
      const t = this.diagram, i = t.lastInput;
      if (this.simulatedMouseMove(i.event, i.documentPoint, i.targetDiagram))
        return;
      this.currentPart !== null && this.draggedParts !== null && (this.mayCopy() ? (this.AS(false), t.qw(this.copiedParts), this.kf(this.copiedParts, false), t.Lm(this.copiedParts)) : this.mayMove() ? (this.Ll(), this.kf(this.draggedParts, true)) : this.mayDragOut() ? (this.AS(false), this.kf(this.copiedParts, false)) : this.Ll(), this.TS(t.lastInput.documentPoint));
    }
    doMouseUp() {
      if (!this.isActive)
        return;
      const t = this.diagram, i = t.lastInput;
      if (this.simulatedMouseUp(i.event, i.documentPoint, i.targetDiagram))
        return;
      let e = false;
      const s = this.mayCopy();
      if (s && this.copiedParts !== null ? (this.Ll(), this.AS(true), t.qw(this.copiedParts), this.kf(this.copiedParts, false), t.Lm(this.copiedParts), this.copiedParts !== null && (t.V("ChangingSelection", t.selection), t.clearSelection(true), this.copiedParts.iteratorKeys.each((n) => {
        n.isSelected = true;
      }))) : (e = true, this.Ll(), this.mayMove() && (this.kf(this.draggedParts, true), this.TS(t.lastInput.documentPoint))), this.ku = true, this.KC(t.lastInput.documentPoint), this.isActive) {
        const n = s ? this.copiedParts.toKeySet() : this.draggedParts.toKeySet();
        this.copiedParts = null, e && this.sF(), t.invalidateDocumentBounds(), t.Lm(this.draggedParts), this.transactionResult = s ? "Copy" : "Move", t.V(s ? "SelectionCopied" : "SelectionMoved", n);
      }
      this.stopTool(), s && t.V("ChangedSelection", t.selection);
    }
    simulatedMouseMove(t, i, e) {
      if (_DraggingTool.St === null)
        return false;
      const s = _DraggingTool.St.diagram;
      e instanceof Diagram2 || (e = null);
      const n = _DraggingTool.vh;
      if (e !== n) {
        if (n !== null && n !== s) {
          n.stopAutoScroll(), _DraggingTool.St.isDragOutStarted = false;
          const r = n.toolManager.findTool("Dragging");
          r !== null && r.doSimulatedDragLeave();
        }
        if (_DraggingTool.vh = e, e !== null && e !== s) {
          _DraggingTool.St.BC();
          const r = e.toolManager.findTool("Dragging");
          r !== null && (r.UC(), r.doSimulatedDragEnter());
        }
        this.doUpdateCursor(null);
      }
      if (e === null || e === s || !e.allowDrop || e.isReadOnly || !e.allowInsert)
        return false;
      const o = e.toolManager.findTool("Dragging");
      if (o !== null) {
        let r = i;
        t !== null && (t.targetTouches !== void 0 && (t.targetTouches.length > 0 ? t = t.targetTouches[0] : t.changedTouches.length > 0 && (t = t.changedTouches[0])), r = e.getMouse(t)), e.lastInput.documentPoint = r, e.lastInput.viewPoint = e.transformDocToView(r), e.lastInput.down = false, e.lastInput.up = false, o.doSimulatedDragOver();
      }
      return true;
    }
    simulatedMouseUp(t, i, e) {
      if (_DraggingTool.St === null)
        return false;
      const s = _DraggingTool.vh, n = _DraggingTool.St.diagram;
      if (e === null)
        return _DraggingTool.St.doCancel(), true;
      if (e !== s) {
        const o = s.toolManager.findTool("Dragging");
        if (s !== null && s !== n && o !== null)
          return s.stopAutoScroll(), _DraggingTool.St.isDragOutStarted = false, o.doSimulatedDragLeave(), false;
        _DraggingTool.vh = e;
        const r = e.toolManager.findTool("Dragging");
        r !== null && (_DraggingTool.St.BC(), r.UC(), r.doSimulatedDragEnter());
      }
      if (e !== this.diagram) {
        let o = i;
        t !== null ? (t.targetTouches !== void 0 && (t.targetTouches.length > 0 ? t = t.targetTouches[0] : t.changedTouches.length > 0 && (t = t.changedTouches[0])), o = e.getMouse(t)) : o === null && (o = new Point2()), e.lastInput.documentPoint = o, e.lastInput.viewPoint = e.transformDocToView(o), e.lastInput.down = false, e.lastInput.up = true;
        const r = e.toolManager.findTool("Dragging");
        r !== null && r.doSimulatedDrop();
        const l = _DraggingTool.St;
        if (l !== null) {
          const h = l.mayCopy();
          l.transactionResult = h ? "Copy" : "Move", l.stopTool();
        }
        return true;
      }
      return false;
    }
    sF() {
      if (this.draggedParts === null)
        return;
      const t = this.draggedParts.iterator;
      for (; t.next(); ) {
        const i = t.key;
        if (i instanceof Node2) {
          const e = i.containingGroup;
          e !== null && e.hasPlaceholder() && !this.draggedParts.contains(e) && e.placeholder.u();
        }
      }
    }
    mayCopy() {
      if (!this.isCopyEnabled)
        return false;
      const t = this.diagram;
      if (t.isReadOnly || t.isModelReadOnly || !t.allowInsert || !t.allowCopy || !(Util.dr ? t.lastInput.alt : t.lastInput.control))
        return false;
      const i = t.selection.iterator;
      for (; i.next(); )
        if (i.value.canCopy())
          return true;
      return !!(this.draggedLink !== null && this.dragsLink && this.draggedLink.canCopy());
    }
    mayDragOut() {
      if (!this.isCopyEnabled)
        return false;
      const t = this.diagram;
      if (!t.allowDragOut || !t.allowCopy || t.allowMove)
        return false;
      const i = t.selection.iterator;
      for (; i.next(); )
        if (i.value.canCopy())
          return true;
      return !!(this.draggedLink !== null && this.dragsLink && this.draggedLink.canCopy());
    }
    mayMove() {
      const t = this.diagram;
      if (t.isReadOnly || !t.allowMove)
        return false;
      const i = t.selection.iterator;
      for (; i.next(); )
        if (i.value.canMove())
          return true;
      return !!(this.draggedLink !== null && this.dragsLink && this.draggedLink.canMove());
    }
    UC() {
      _DraggingTool.Ww.contains(this) || _DraggingTool.Ww.add(this);
    }
    static QD() {
      if (_DraggingTool.Ww.count > 0) {
        const t = _DraggingTool.Ww, i = t.length;
        for (let e = 0; e < i; e++) {
          const s = t.elt(e);
          s.EC(), s.Ll(), s.PS(), s.diagram.stopAutoScroll();
        }
        t.clear();
      }
    }
    computeBorder(t, i, e) {
      return !this.ku && this.draggedParts !== null && !this.draggedParts.contains(t) ? e.c(i) : null;
    }
    getDraggingSource() {
      return _DraggingTool.St;
    }
    mayDragIn() {
      const t = this.diagram;
      if (!t.allowDrop || t.isReadOnly || t.isModelReadOnly || !t.allowInsert)
        return false;
      const i = _DraggingTool.St;
      return !(i === null || i.diagram.model.dataFormat !== t.model.dataFormat);
    }
    doSimulatedDragEnter() {
      if (!this.mayDragIn())
        return;
      const t = this.diagram;
      t.animationManager.stopAnimation(), t.Pr(), t.animationManager.stopAnimation();
      const i = _DraggingTool.St;
      i !== null && (i.diagram.Am = false, t.lastInput.event === null && (t.lastInput.event = i.diagram.lastInput.event)), this.doUpdateCursor(null);
    }
    doSimulatedDragLeave() {
      const t = _DraggingTool.St;
      t !== null && t.doSimulatedDragOut(), this.doCancel();
    }
    doSimulatedDragOver() {
      const t = this.diagram;
      t.animationManager.Nu = true;
      const i = _DraggingTool.St;
      if (i !== null && i.draggedParts !== null) {
        if (!this.mayDragIn())
          return;
        this.GC(i.draggedParts.toKeySet(), false, t.firstInput), this.kf(this.copiedParts, false), this.TS(t.lastInput.documentPoint);
      }
      t.animationManager.Nu = false;
    }
    doSimulatedDrop() {
      const t = this.diagram, i = _DraggingTool.St;
      if (i !== null) {
        const e = i.diagram;
        if (i.ku = true, this.Ll(), !this.mayDragIn())
          return;
        t.animationManager.Nu = true, t.V("ChangingSelection", t.selection), this.startTransaction("Drop"), this.GC(i.draggedParts.toKeySet(), true, t.lastInput), this.kf(this.copiedParts, false);
        const s = new GSet2();
        this.copiedParts !== null && (t.clearSelection(true), this.copiedParts.iteratorKeys.each((n) => {
          n.isSelected = true, s.add(n);
        })), this.KC(t.lastInput.documentPoint), t.invalidateDocumentBounds(), this.copiedParts !== null && (this.transactionResult = "ExternalCopy"), this.copiedParts = null, t.doFocus(), t.V("ExternalObjectsDropped", s, e), this.stopTransaction(), t.V("ChangedSelection", t.selection);
      }
      t.animationManager.Nu = false;
    }
    GC(t, i, e) {
      if (this.copiedParts !== null)
        return;
      const s = this.diagram;
      if (s.isReadOnly || s.isModelReadOnly)
        return;
      s.skipsUndoManager = !i, s.partManager.addsToTemporaryLayer = !i, this.startPoint = e.documentPoint;
      const n = s.copyParts(t, s, true), o = Rect2.a();
      this._D(t, o);
      const r = o.x + o.width / 2, l = o.y + o.height / 2;
      Rect2.o(o);
      const h = this.Cm, a = new GMap2(), f = Point2.a(), c = t.iterator;
      for (; c.next(); ) {
        const d = c.value;
        if (d instanceof Link2 && d.canCopy()) {
          const m = n.getValue(d);
          if (m === null)
            continue;
          m.points = d.points, m.Mr(h.x - r, h.y - l), m.wn = true, a.add(m, this.Us());
        }
      }
      const u = t.iterator;
      for (; u.next(); ) {
        const d = u.value;
        if (d.De() && d.canCopy()) {
          const m = n.getValue(d);
          if (m === null)
            continue;
          const g = d.location;
          f.e(h.x - (r - g.x), h.y - (l - g.y)), m.location = f, m.ensureBounds(), a.add(m, this.Us(f));
        }
      }
      if (Point2.o(f), this.copiedParts = a, this.MS(a.toKeySet()), this.draggedLink !== null) {
        const d = this.draggedLink, m = d.routeBounds;
        d.Mr(this.startPoint.x - (m.x + m.width / 2), this.startPoint.y - (m.y + m.height / 2));
      }
      this.doUpdateCursor(null);
    }
    $D() {
      this.isDragOutStarted = true, this.ku = false, _DraggingTool.St = this, _DraggingTool.vh = this.diagram, this.doSimulatedDragOut();
    }
    doSimulatedDragOut() {
      const t = this.diagram;
      t.Am = false, !this.mayCopy() && !this.mayMove() ? t.currentCursor = this.nodropCursor : t.currentCursor = "", this.Su = null;
    }
    computeMove(t, i, e, s) {
      const n = this.diagram;
      return n !== null ? n.computeMove(t, i, this.dragOptions, s) : new Point2();
    }
  };
  __publicField(_DraggingTool, "Ww", new List2());
  __publicField(_DraggingTool, "St", null);
  __publicField(_DraggingTool, "vh", null);
  let DraggingTool2 = _DraggingTool;
  ToolManager2.prototype.doCancel = function() {
    DraggingTool2.St !== null && DraggingTool2.St.doCancel(), Tool2.prototype.doCancel.call(this);
  };
  class LinkingBaseTool2 extends Tool2 {
    constructor() {
      super();
      __publicField(this, "OS");
      __publicField(this, "ES");
      __publicField(this, "Dl");
      __publicField(this, "VS");
      __publicField(this, "BS");
      __publicField(this, "qh");
      __publicField(this, "zS");
      __publicField(this, "Wh");
      __publicField(this, "XS");
      __publicField(this, "YS");
      __publicField(this, "KS");
      __publicField(this, "US");
      __publicField(this, "GS");
      __publicField(this, "HS");
      __publicField(this, "HC");
      __publicField(this, "vS");
      __publicField(this, "Fl");
      __publicField(this, "qS");
      this.OS = 100, this.ES = false, this.Dl = "pointer", this.VS = new Link2({ layerName: "Tool" }).add(new Shape2({ isPanelMain: true, stroke: "blue" }).theme("stroke", "tempLink"), new Shape2({ toArrow: "Standard", fill: "blue", stroke: "blue" }).theme("fill", "tempLink").theme("stroke", "tempLink")).ui(), this.qh = new Shape2("Rectangle", { portId: "", fill: null, stroke: "magenta", strokeWidth: 2, desiredSize: Size2.Bk }).theme("stroke", "tempPort"), this.BS = new Node2({ selectable: false, layerName: "Tool" }).add(this.qh).ui(), this.Wh = new Shape2("Rectangle", { portId: "", fill: null, stroke: "magenta", strokeWidth: 2, desiredSize: Size2.Bk }).theme("stroke", "tempPort"), this.zS = new Node2({ selectable: false, layerName: "Tool" }).add(this.Wh).ui(), this.XS = null, this.YS = null, this.KS = null, this.US = null, this.GS = null, this.HS = true, this.HC = new GMap2(), this.vS = null, this.Fl = null, this.qS = null;
    }
    doStop() {
      this.diagram.stopAutoScroll(), this.originalLink = null, this.originalFromNode = null, this.originalFromPort = null, this.originalToNode = null, this.originalToPort = null, this.validPortsCache.clear(), this.targetPort = null;
    }
    get portGravity() {
      return this.OS;
    }
    set portGravity(t) {
      Util.t(t, "number", LinkingBaseTool2, "portGravity"), t >= 0 && (this.OS = t);
    }
    get isUnconnectedLinkValid() {
      return this.ES;
    }
    set isUnconnectedLinkValid(t) {
      Util.t(t, "boolean", LinkingBaseTool2, "isUnconnectedLinkValid"), this.ES = t;
    }
    get linkingCursor() {
      return this.Dl;
    }
    set linkingCursor(t) {
      this.Dl = t;
    }
    get temporaryLink() {
      return this.VS;
    }
    set temporaryLink(t) {
      Util.s(t, Link2, LinkingBaseTool2, "temporaryLink"), t.ui(), this.VS = t;
    }
    get temporaryFromNode() {
      return this.BS;
    }
    set temporaryFromNode(t) {
      Util.s(t, Node2, LinkingBaseTool2, "temporaryFromNode"), t.ui(), this.BS = t, t && (this.qh = t.port);
    }
    get temporaryFromPort() {
      return this.qh;
    }
    set temporaryFromPort(t) {
      if (Util.s(t, GraphObject2, LinkingBaseTool2, "temporaryFromPort"), this.qh !== null) {
        const i = this.qh.panel;
        if (i !== null) {
          const e = i.F.indexOf(this.qh);
          i.removeAt(e), i.insertAt(e, t);
        }
      }
      this.qh = t;
    }
    get temporaryToNode() {
      return this.zS;
    }
    set temporaryToNode(t) {
      Util.s(t, Node2, LinkingBaseTool2, "temporaryToNode"), t.ui(), this.zS = t, t && (this.Wh = t.port);
    }
    get temporaryToPort() {
      return this.Wh;
    }
    set temporaryToPort(t) {
      if (Util.s(t, GraphObject2, LinkingBaseTool2, "temporaryToPort"), this.Wh !== null) {
        const i = this.Wh.panel;
        if (i !== null) {
          const e = i.F.indexOf(this.Wh);
          i.removeAt(e), i.insertAt(e, t);
        }
      }
      this.Wh = t;
    }
    get originalLink() {
      return this.XS;
    }
    set originalLink(t) {
      t !== null && Util.s(t, Link2, LinkingBaseTool2, "originalLink"), this.XS = t;
    }
    get originalFromNode() {
      return this.YS;
    }
    set originalFromNode(t) {
      t !== null && Util.s(t, Node2, LinkingBaseTool2, "originalFromNode"), this.YS = t;
    }
    get originalFromPort() {
      return this.KS;
    }
    set originalFromPort(t) {
      t !== null && Util.s(t, GraphObject2, LinkingBaseTool2, "originalFromPort"), this.KS = t;
    }
    get originalToNode() {
      return this.US;
    }
    set originalToNode(t) {
      t !== null && Util.s(t, Node2, LinkingBaseTool2, "originalToNode"), this.US = t;
    }
    get originalToPort() {
      return this.GS;
    }
    set originalToPort(t) {
      t !== null && Util.s(t, GraphObject2, LinkingBaseTool2, "originalToPort"), this.GS = t;
    }
    get isForwards() {
      return this.HS;
    }
    set isForwards(t) {
      this.HS = t;
    }
    get validPortsCache() {
      return this.HC;
    }
    get targetPort() {
      return this.vS;
    }
    set targetPort(t) {
      t !== null && Util.s(t, GraphObject2, LinkingBaseTool2, "targetPort"), this.vS = t;
    }
    copyPortProperties(t, i, e, s, n) {
      if (t === null || i === null || e === null || s === null)
        return;
      const o = i.getDocumentScale(), r = Size2.a();
      r.width = i.naturalBounds.width * o, r.height = i.naturalBounds.height * o, s.desiredSize = r, Size2.o(r), n ? (s.toSpot = i.toSpot, s.toEndSegmentLength = i.toEndSegmentLength) : (s.fromSpot = i.fromSpot, s.fromEndSegmentLength = i.fromEndSegmentLength), e.locationSpot = Spot2.Center;
      const l = Point2.a();
      e.location = i.getDocumentPoint(Spot2.Center, l), Point2.o(l), s.angle = i.getDocumentAngle(), this.portTargeted !== null && this.portTargeted(t, i, e, s, n);
    }
    setNoTargetPortProperties(t, i, e) {
      i !== null && (i.desiredSize = Size2.Bk, i.fromSpot = Spot2.None, i.toSpot = Spot2.None), t !== null && (t.location = this.diagram.lastInput.documentPoint), this.portTargeted !== null && this.portTargeted(null, null, t, i, e);
    }
    doMouseDown() {
      this.isActive && this.doMouseMove();
    }
    doMouseMove() {
      if (this.isActive) {
        const t = this.diagram;
        if (this.targetPort = this.findTargetPort(this.isForwards), this.targetPort !== null && this.targetPort.part instanceof Node2) {
          const i = this.targetPort.part;
          this.isForwards ? this.copyPortProperties(i, this.targetPort, this.temporaryToNode, this.temporaryToPort, true) : this.copyPortProperties(i, this.targetPort, this.temporaryFromNode, this.temporaryFromPort, false);
        } else
          this.isForwards ? this.setNoTargetPortProperties(this.temporaryToNode, this.temporaryToPort, true) : this.setNoTargetPortProperties(this.temporaryFromNode, this.temporaryFromPort, false);
        (t.allowHorizontalScroll || t.allowVerticalScroll) && t.doAutoScroll(t.lastInput.viewPoint);
      }
    }
    findValidLinkablePort(t, i) {
      if (t === null)
        return null;
      const e = t.part;
      if (!(e instanceof Node2))
        return null;
      for (; t !== null; ) {
        const s = i ? t.toLinkable : t.fromLinkable;
        if (s === true && (t.portId !== null || t instanceof Node2) && (i ? this.isValidTo(e, t) : this.isValidFrom(e, t)))
          return t;
        if (s === false)
          return null;
        t = t.panel;
      }
      return null;
    }
    findTargetPort(t) {
      const i = this.diagram, e = i.lastInput.documentPoint;
      let s = this.portGravity;
      s <= 0 && (s = 0.1);
      const n = this, o = i.findObjectsNear(e, s, (a) => n.findValidLinkablePort(a, t), null, true);
      let r = 1 / 0, l = null;
      const h = o.iterator;
      for (; h.next(); ) {
        const a = h.value, f = a.part;
        if (!(f instanceof Node2))
          continue;
        const c = a.getDocumentPoint(Spot2.Center, Point2.a()), u = e.x - c.x, d = e.y - c.y;
        Point2.o(c);
        const m = u * u + d * d;
        if (m < r) {
          const g = this.validPortsCache.getValue(a);
          g !== null ? g && (l = a, r = m) : t && this.isValidLink(this.originalFromNode, this.originalFromPort, f, a) || !t && this.isValidLink(f, a, this.originalToNode, this.originalToPort) ? (this.validPortsCache.add(a, true), l = a, r = m) : this.validPortsCache.add(a, false);
        }
      }
      if (l !== null) {
        const a = l.part;
        if (a instanceof Node2 && (a.layer === null || a.layer.allowLink))
          return l;
      }
      return null;
    }
    isValidFrom(t, i) {
      if (t === null || i === null)
        return this.isUnconnectedLinkValid;
      if (this.diagram.currentTool === this && (t.layer !== null && !t.layer.allowLink || i.fromLinkable !== true))
        return false;
      const e = i.fromMaxLinks;
      if (e < 1 / 0) {
        if (this.originalLink !== null && t === this.originalFromNode && i === this.originalFromPort)
          return true;
        let s = i.portId;
        if (s === null && (s = ""), t.findLinksOutOf(s).count >= e)
          return false;
      }
      return true;
    }
    isValidTo(t, i) {
      if (t === null || i === null)
        return this.isUnconnectedLinkValid;
      if (this.diagram.currentTool === this && (t.layer !== null && !t.layer.allowLink || i.toLinkable !== true))
        return false;
      const e = i.toMaxLinks;
      if (e < 1 / 0) {
        if (this.originalLink !== null && t === this.originalToNode && i === this.originalToPort)
          return true;
        let s = i.portId;
        if (s === null && (s = ""), t.findLinksInto(s).count >= e)
          return false;
      }
      return true;
    }
    isInSameNode(t, i) {
      if (t === null || i === null)
        return false;
      if (t === i)
        return true;
      const e = t.part, s = i.part;
      return e !== null && e === s;
    }
    isLinked(t, i) {
      if (t === null || i === null)
        return false;
      const e = t.part;
      if (!(e instanceof Node2))
        return false;
      let s = t.portId;
      s === null && (s = "");
      const n = i.part;
      if (!(n instanceof Node2))
        return false;
      let o = i.portId;
      o === null && (o = "");
      const r = n.findLinksInto(o);
      for (; r.next(); ) {
        const l = r.value;
        if (l.fromNode === e && l.fromPortId === s)
          return true;
      }
      return false;
    }
    isValidLink(t, i, e, s) {
      if (!this.isValidFrom(t, i) || !this.isValidTo(e, s) || i !== null && s !== null && (!(i.fromLinkableSelfNode && s.toLinkableSelfNode) && this.isInSameNode(i, s) || !(i.fromLinkableDuplicates && s.toLinkableDuplicates) && this.isLinked(i, s)) || this.originalLink !== null && (t !== null && this.isLabelDependentOnLink(t, this.originalLink) || e !== null && this.isLabelDependentOnLink(e, this.originalLink)) || t !== null && e !== null && (t.data === null && e.data !== null || t.data !== null && e.data === null) || !this.isValidCycle(t, e, this.originalLink))
        return false;
      let n;
      return t !== null && (n = t.linkValidation, n !== null && !n(t, i, e, s, this.originalLink)) || e !== null && (n = e.linkValidation, n !== null && !n(t, i, e, s, this.originalLink)) ? false : (n = this.linkValidation, n !== null ? n(t, i, e, s, this.originalLink) : true);
    }
    isLabelDependentOnLink(t, i) {
      if (t === null)
        return false;
      const e = t.labeledLink;
      if (e === null)
        return false;
      if (e === i)
        return true;
      const s = new GSet2();
      return s.add(t), this.WS(e, i, s);
    }
    WS(t, i, e) {
      if (t === i)
        return true;
      const s = t.fromNode;
      if (s !== null && s.isLinkLabel && (e.add(s), this.WS(s.labeledLink, i, e)))
        return true;
      const n = t.toNode;
      return !!(n !== null && n.isLinkLabel && (e.add(n), this.WS(n.labeledLink, i, e)));
    }
    isValidCycle(t, i, e) {
      if (e === void 0 && (e = null), t === null || i === null)
        return this.isUnconnectedLinkValid;
      const s = this.diagram.validCycle;
      if (s === 1)
        return true;
      if (s === 5) {
        const n = e || this.temporaryLink;
        if (n !== null && !n.isTreeLink)
          return true;
        const o = i.linksConnected;
        for (; o.next(); ) {
          const r = o.value;
          if (r !== e && r.isTreeLink && r.toNode === i)
            return false;
        }
        return !this.Cu(t, i, e, true);
      } else if (s === 6) {
        const n = e || this.temporaryLink;
        if (n !== null && !n.isTreeLink)
          return true;
        const o = t.linksConnected;
        for (; o.next(); ) {
          const r = o.value;
          if (r !== e && r.isTreeLink && r.fromNode === t)
            return false;
        }
        return !this.Cu(t, i, e, true);
      } else {
        if (s === 2)
          return !this.nF(t, i, e);
        if (s === 3)
          return !this.Cu(t, i, e, false);
        if (s === 4)
          return !this.oF(t, i, e);
      }
      return true;
    }
    Cu(t, i, e, s) {
      if (t === i)
        return true;
      if (t === null || i === null)
        return false;
      const n = t.linksConnected;
      for (; n.next(); ) {
        const o = n.value;
        if (o === e || s && !o.isTreeLink || o.toNode !== t)
          continue;
        const r = o.fromNode;
        if (r !== t && this.Cu(r, i, e, s))
          return true;
      }
      return false;
    }
    nF(t, i, e) {
      if (t === i)
        return true;
      const s = new GSet2();
      return s.add(i), this.vC(s, t, i, e);
    }
    vC(t, i, e, s) {
      if (i === e)
        return true;
      if (i === null || e === null || t.contains(i))
        return false;
      t.add(i);
      const n = i.linksConnected;
      for (; n.next(); ) {
        const o = n.value;
        if (o === s || o.toNode !== i)
          continue;
        const r = o.fromNode;
        if (r !== i && this.vC(t, r, e, s))
          return true;
      }
      return false;
    }
    oF(t, i, e) {
      if (t === i)
        return true;
      const s = new GSet2();
      return s.add(i), this.qC(s, t, i, e);
    }
    qC(t, i, e, s) {
      if (i === e)
        return true;
      if (i === null || e === null || t.contains(i))
        return false;
      t.add(i);
      const n = i.linksConnected;
      for (; n.next(); ) {
        const o = n.value;
        if (o === s)
          continue;
        const r = o.fromNode, l = o.toNode, h = r === i ? l : r;
        if (h !== i && this.qC(t, h, e, s))
          return true;
      }
      return false;
    }
    get linkValidation() {
      return this.Fl;
    }
    set linkValidation(t) {
      t !== null && Util.t(t, "function", LinkingBaseTool2, "linkValidation"), this.Fl = t;
    }
    get portTargeted() {
      return this.qS;
    }
    set portTargeted(t) {
      t !== null && Util.t(t, "function", LinkingBaseTool2, "portTargeted"), this.qS = t;
    }
  }
  var LinkingDirection2 = ((w) => (w[w.Either = 1] = "Either", w[w.ForwardsOnly = 2] = "ForwardsOnly", w[w.BackwardsOnly = 3] = "BackwardsOnly", w))(LinkingDirection2 || {});
  const _LinkingTool = class _LinkingTool extends LinkingBaseTool2 {
    constructor(t) {
      super();
      __publicField(this, "jS");
      __publicField(this, "JS");
      __publicField(this, "C");
      __publicField(this, "ZS");
      this.name = "Linking", this.jS = {}, this.JS = null, this.C = 1, this.ZS = null, t && Object.assign(this, t);
    }
    get archetypeLinkData() {
      return this.jS;
    }
    set archetypeLinkData(t) {
      t !== null && Util.t(t, "object", _LinkingTool, "archetypeLinkData"), t instanceof GraphObject2 && Util.s(t, Link2, _LinkingTool, "archetypeLinkData"), this.jS = t;
    }
    get archetypeLabelNodeData() {
      return this.JS;
    }
    set archetypeLabelNodeData(t) {
      t !== null && Util.t(t, "object", _LinkingTool, "archetypeLabelNodeData"), t instanceof GraphObject2 && Util.s(t, Node2, _LinkingTool, "archetypeLabelNodeData"), this.JS = t;
    }
    get direction() {
      return this.C;
    }
    set direction(t) {
      Util.it(t, LinkingDirection2, "LinkingDirection"), this.C = t;
    }
    get startObject() {
      return this.ZS;
    }
    set startObject(t) {
      t !== null && Util.s(t, GraphObject2, _LinkingTool, "startObject"), this.ZS = t;
    }
    canStart() {
      if (!this.isEnabled)
        return false;
      const t = this.diagram;
      return t.isReadOnly || t.isModelReadOnly || !t.allowLink || !t.model.jw() || !t.lastInput.left || t.currentTool !== this && !this.isBeyondDragSize() ? false : this.findLinkablePort() !== null;
    }
    findLinkablePort() {
      const t = this.diagram;
      let i = this.startObject;
      if (i === null && (i = t.findObjectAt(t.firstInput.documentPoint, null, null)), i === null)
        return null;
      const e = i.part;
      if (!(e instanceof Node2))
        return null;
      const s = this.direction;
      if (s === 1 || s === 2) {
        const n = this.findValidLinkablePort(i, false);
        if (n !== null)
          return this.isForwards = true, n;
        if (this.startObject === e) {
          const o = e.port;
          if (this.findValidLinkablePort(o, false))
            return this.isForwards = true, o;
        }
      }
      if (s === 1 || s === 3) {
        const n = this.findValidLinkablePort(i, true);
        if (n !== null)
          return this.isForwards = false, n;
        if (this.startObject === e) {
          const o = e.port;
          if (this.findValidLinkablePort(o, true))
            return this.isForwards = false, o;
        }
      }
      return null;
    }
    doActivate() {
      const t = this.diagram, i = this.findLinkablePort();
      if (i === null) {
        this.stopTool();
        return;
      }
      if (this.startTransaction(this.name), t.isMouseCaptured = true, t.currentCursor = this.linkingCursor, this.isForwards) {
        this.temporaryToNode !== null && (this.temporaryToNode.location = t.lastInput.documentPoint), this.originalFromPort = i;
        const e = this.originalFromPort.part;
        e instanceof Node2 && (this.originalFromNode = e), this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, false);
      } else {
        this.temporaryFromNode !== null && (this.temporaryFromNode.location = t.lastInput.documentPoint), this.originalToPort = i;
        const e = this.originalToPort.part;
        e instanceof Node2 && (this.originalToNode = e), this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, true);
      }
      t.add(this.temporaryFromNode), this.temporaryFromNode && this.temporaryFromNode.ensureBounds(), t.add(this.temporaryToNode), this.temporaryToNode && this.temporaryToNode.ensureBounds(), this.temporaryLink !== null && (this.temporaryFromNode !== null && (this.temporaryLink.fromNode = this.temporaryFromNode), this.temporaryToNode !== null && (this.temporaryLink.toNode = this.temporaryToNode), this.temporaryLink.isTreeLink = this.isNewTreeLink(), this.temporaryLink.invalidateRoute(), t.add(this.temporaryLink)), this.isActive = true;
    }
    doDeactivate() {
      this.isActive = false;
      const t = this.diagram;
      t.remove(this.temporaryLink), t.remove(this.temporaryFromNode), t.remove(this.temporaryToNode), t.isMouseCaptured = false, t.currentCursor = "", this.stopTransaction();
    }
    doStop() {
      super.doStop(), this.startObject = null;
    }
    doMouseUp() {
      if (this.isActive) {
        const t = this.diagram;
        this.transactionResult = null;
        let i = null, e = null, s = null, n = null, o = null;
        try {
          this.targetPort = this.findTargetPort(this.isForwards);
          const r = this.targetPort;
          if (r !== null) {
            const l = r.part;
            l instanceof Node2 && (this.isForwards ? (this.originalFromNode !== null && (i = this.originalFromNode, e = this.originalFromPort), s = l, n = r) : (i = l, e = r, this.originalToNode !== null && (s = this.originalToNode, n = this.originalToPort)));
          } else
            this.isForwards ? this.originalFromNode !== null && this.isUnconnectedLinkValid && (i = this.originalFromNode, e = this.originalFromPort) : this.originalToNode !== null && this.isUnconnectedLinkValid && (s = this.originalToNode, n = this.originalToPort);
          i !== null || s !== null ? (o = this.insertLink(i, e, s, n), o !== null ? (r === null && (this.isForwards ? o.defaultToPoint = t.lastInput.documentPoint : o.defaultFromPoint = t.lastInput.documentPoint), t.allowSelect && (t.V("ChangingSelection", t.selection), t.clearSelection(true), o.isSelected = true), this.transactionResult = this.name, t.V("LinkDrawn", o)) : this.doNoLink(i, e, s, n)) : this.isForwards ? this.doNoLink(this.originalFromNode, this.originalFromPort, null, null) : this.doNoLink(null, null, this.originalToNode, this.originalToPort);
        } finally {
          this.stopTool(), o && t.allowSelect && t.V("ChangedSelection", t.selection);
        }
      }
    }
    isNewTreeLink() {
      const t = this.archetypeLinkData;
      if (t === null)
        return true;
      if (t instanceof Link2)
        return t.isTreeLink;
      const i = this.diagram;
      if (i === null)
        return true;
      const e = i.partManager.getLinkCategoryForData(t), s = i.partManager.findLinkTemplateForCategory(e);
      return s !== null ? s.isTreeLink : true;
    }
    insertLink(t, i, e, s) {
      return this.diagram.partManager.insertLink(t, i, e, s);
    }
    doNoLink(t, i, e, s) {
    }
  };
  __publicField(_LinkingTool, "Either", 1);
  __publicField(_LinkingTool, "ForwardsOnly", 2);
  __publicField(_LinkingTool, "BackwardsOnly", 3);
  let LinkingTool2 = _LinkingTool;
  class RelinkingTool2 extends LinkingBaseTool2 {
    constructor(t) {
      super();
      __publicField(this, "$S");
      __publicField(this, "QS");
      __publicField(this, "ws");
      __publicField(this, "_S");
      this.name = "Relinking", this.$S = new Shape2("Diamond", { desiredSize: Size2.du, fill: "lightblue", stroke: "dodgerblue", cursor: this.linkingCursor, segmentIndex: 0 }).theme("fill", "adornmentFill").theme("stroke", "adornmentStroke"), this.QS = new Shape2("Diamond", { desiredSize: Size2.du, fill: "lightblue", stroke: "dodgerblue", cursor: this.linkingCursor, segmentIndex: -1 }).theme("fill", "adornmentFill").theme("stroke", "adornmentStroke"), this.ws = null, this._S = new Rect2(), t && Object.assign(this, t);
    }
    updateAdornments(t) {
      if (t === null || !(t instanceof Link2))
        return;
      let i = "RelinkFrom", e = null;
      if (t.isSelected && !this.diagram.isReadOnly) {
        const s = t.selectionObject;
        s !== null && t.canRelinkFrom() && t.actualBounds.isReal() && t.isVisible() && s.actualBounds.isReal() && s.isVisibleObject() && (e = t.findAdornment(i), e === null && (e = this.makeAdornment(s, false), t.addAdornment(i, e)));
      }
      if (e === null && t.removeAdornment(i), i = "RelinkTo", e = null, t.isSelected && !this.diagram.isReadOnly) {
        const s = t.selectionObject;
        s !== null && t.canRelinkTo() && t.actualBounds.isReal() && t.isVisible() && s.actualBounds.isReal() && s.isVisibleObject() && (e = t.findAdornment(i), e === null ? (e = this.makeAdornment(s, true), t.addAdornment(i, e)) : e.u());
      }
      e === null && t.removeAdornment(i);
    }
    makeAdornment(t, i) {
      const e = new Adornment2();
      e.type = Panel2.Link;
      const s = i ? this.toHandleArchetype : this.fromHandleArchetype;
      return s !== null && e.add(s.copy().Tm()), e.adornedObject = t, e;
    }
    get fromHandleArchetype() {
      return this.$S;
    }
    set fromHandleArchetype(t) {
      t !== null && Util.s(t, GraphObject2, RelinkingTool2, "fromHandleArchetype"), this.$S = t;
    }
    get toHandleArchetype() {
      return this.QS;
    }
    set toHandleArchetype(t) {
      t !== null && Util.s(t, GraphObject2, RelinkingTool2, "toHandleArchetype"), this.QS = t;
    }
    get handle() {
      return this.ws;
    }
    set handle(t) {
      if (t !== null && (Util.s(t, GraphObject2, RelinkingTool2, "handle"), !(t.part instanceof Adornment2)))
        throw new Error("new handle is not in an Adornment: " + t);
      this.ws = t;
    }
    canStart() {
      if (!this.isEnabled)
        return false;
      const t = this.diagram;
      if (t.isReadOnly || t.isModelReadOnly || !t.allowRelink || !t.model.jw() || !t.lastInput.left)
        return false;
      let e = this.findToolHandleAt(t.firstInput.documentPoint, "RelinkFrom");
      return e === null && (e = this.findToolHandleAt(t.firstInput.documentPoint, "RelinkTo")), e !== null;
    }
    doActivate() {
      const t = this.diagram;
      if (this.originalLink === null) {
        let i = this.handle;
        if (i === null && (i = this.findToolHandleAt(t.firstInput.documentPoint, "RelinkFrom"), i === null && (i = this.findToolHandleAt(t.firstInput.documentPoint, "RelinkTo"))), i === null)
          return;
        const e = i.part;
        if (!(e instanceof Adornment2) || !(e.adornedPart instanceof Link2))
          return;
        this.handle = i, this.isForwards = e === null || e.category === "RelinkTo", this.originalLink = e.adornedPart;
      }
      this.startTransaction(this.name), t.isMouseCaptured = true, t.currentCursor = this.linkingCursor, this.originalFromPort = this.originalLink.fromPort, this.originalFromNode = this.originalLink.fromNode, this.originalToPort = this.originalLink.toPort, this.originalToNode = this.originalLink.toNode, this._S.set(this.originalLink.actualBounds), this.originalLink !== null && this.originalLink.pointsCount > 0 && (this.originalLink.fromNode === null && (this.temporaryFromPort !== null && (this.temporaryFromPort.desiredSize = Size2.lf), this.temporaryFromNode !== null && (this.temporaryFromNode.location = this.originalLink.getPoint(0))), this.originalLink.toNode === null && (this.temporaryToPort !== null && (this.temporaryToPort.desiredSize = Size2.lf), this.temporaryToNode !== null && (this.temporaryToNode.location = this.originalLink.getPoint(this.originalLink.pointsCount - 1)))), this.copyPortProperties(this.originalFromNode, this.originalFromPort, this.temporaryFromNode, this.temporaryFromPort, false), this.copyPortProperties(this.originalToNode, this.originalToPort, this.temporaryToNode, this.temporaryToPort, true), t.add(this.temporaryFromNode), t.add(this.temporaryToNode), this.temporaryLink !== null && (this.temporaryFromNode !== null && (this.temporaryLink.fromNode = this.temporaryFromNode), this.temporaryToNode !== null && (this.temporaryLink.toNode = this.temporaryToNode), this.copyLinkProperties(this.originalLink, this.temporaryLink), this.temporaryLink.invalidateRoute(), t.add(this.temporaryLink)), this.isActive = true;
    }
    copyLinkProperties(t, i) {
      if (t === null || i === null)
        return;
      i.adjusting = t.adjusting, i.corner = t.corner;
      let e = t.curve;
      (e === 11 || e === 10) && (e = 0), i.curve = e, i.curviness = t.curviness, i.isTreeLink = t.isTreeLink, i.points = t.points, i.routing = t.routing, i.smoothness = t.smoothness, i.fromSpot = t.fromSpot, i.fromEndSegmentLength = t.fromEndSegmentLength, i.fromShortLength = t.fromShortLength, i.toSpot = t.toSpot, i.toEndSegmentLength = t.toEndSegmentLength, i.toShortLength = t.toShortLength;
    }
    doDeactivate() {
      this.isActive = false;
      const t = this.diagram;
      t.remove(this.temporaryLink), t.remove(this.temporaryFromNode), t.remove(this.temporaryToNode), t.isMouseCaptured = false, t.currentCursor = "", this.stopTransaction();
    }
    doStop() {
      super.doStop(), this.handle = null;
    }
    doMouseUp() {
      if (this.isActive) {
        const t = this.diagram;
        this.transactionResult = null;
        let i = this.originalFromNode, e = this.originalFromPort, s = this.originalToNode, n = this.originalToPort, o = this.originalLink;
        try {
          if (this.targetPort = this.findTargetPort(this.isForwards), this.targetPort !== null) {
            const r = this.targetPort.part;
            r instanceof Node2 && (this.isForwards ? (s = r, n = this.targetPort) : (i = r, e = this.targetPort));
          } else
            this.isUnconnectedLinkValid ? this.isForwards ? (s = null, n = null) : (i = null, e = null) : o = null;
          o !== null ? (this.reconnectLink(o, this.isForwards ? s : i, this.isForwards ? n : e, this.isForwards), this.targetPort === null && (this.isForwards ? o.defaultToPoint = t.lastInput.documentPoint : o.defaultFromPoint = t.lastInput.documentPoint, o.invalidateRoute()), this.transactionResult = this.name, t.V("LinkRelinked", o, this.isForwards ? this.originalToPort : this.originalFromPort)) : this.doNoRelink(this.originalLink, this.isForwards), this.originalLink.invalidateOtherJumpOvers(this._S);
        } finally {
          this.stopTool();
        }
      }
    }
    reconnectLink(t, i, e, s) {
      const n = e !== null && e.portId !== null ? e.portId : "";
      return s ? (t.toNode = i, t.toPortId = n) : (t.fromNode = i, t.fromPortId = n), true;
    }
    doNoRelink(t, i) {
    }
    doDraggingMouseMove(t, i, e, s) {
      t !== null ? (this.copyPortProperties(t, i, this.temporaryFromNode, this.temporaryFromPort, false), this.diagram.add(this.temporaryFromNode)) : this.diagram.remove(this.temporaryFromNode), e !== null ? (this.copyPortProperties(e, s, this.temporaryToNode, this.temporaryToPort, true), this.diagram.add(this.temporaryToNode)) : this.diagram.remove(this.temporaryToNode);
    }
    stopDraggingMouseMove() {
      this.diagram.remove(this.temporaryFromNode), this.diagram.remove(this.temporaryToNode);
    }
  }
  var ReshapingBehavior2 = ((w) => (w[w.None = 0] = "None", w[w.Horizontal = 1] = "Horizontal", w[w.Vertical = 2] = "Vertical", w[w.All = 3] = "All", w))(ReshapingBehavior2 || {});
  const _LinkReshapingTool = class _LinkReshapingTool extends Tool2 {
    constructor(t) {
      super();
      __publicField(this, "Io");
      __publicField(this, "tM");
      __publicField(this, "iM");
      __publicField(this, "ws");
      __publicField(this, "Jw");
      __publicField(this, "eM");
      __publicField(this, "Dm");
      this.name = "LinkReshaping", this.Io = new Shape2("Rectangle", { desiredSize: Size2.nC, fill: "lightblue", stroke: "dodgerblue" }).theme("fill", "adornmentFill").theme("stroke", "adornmentStroke"), this.tM = new Shape2("Diamond", { desiredSize: Size2.du, fill: "lightblue", stroke: "dodgerblue", cursor: "move" }).theme("fill", "adornmentFill").theme("stroke", "adornmentStroke"), this.iM = 3, this.ws = null, this.Jw = null, this.eM = new Point2(), this.Dm = new List2(), t && Object.assign(this, t);
    }
    getReshapingBehavior(t) {
      return t ? t.Nr : 0;
    }
    setReshapingBehavior(t, i) {
      t.Nr = i;
    }
    updateAdornments(t) {
      if (t === null || !(t instanceof Link2))
        return;
      let i = null;
      if (t.isSelected && !this.diagram.isReadOnly) {
        const e = t.path;
        e !== null && t.canReshape() && t.actualBounds.isReal() && t.isVisible() && e.actualBounds.isReal() && e.isVisibleObject() && (i = t.findAdornment(this.name), (i === null || i.sM !== t.pointsCount || i.nM !== t.resegmentable) && (i = this.makeAdornment(e), i !== null && (i.sM = t.pointsCount, i.nM = t.resegmentable, t.addAdornment(this.name, i))));
      }
      i === null && t.removeAdornment(this.name);
    }
    makeAdornment(t) {
      const i = t.part, e = i.points, s = i.pointsCount, n = i.isOrthogonal;
      let o = null;
      if (e !== null && s > 1) {
        o = new Adornment2(), o.type = Panel2.Link;
        const r = i.firstPickIndex, l = i.lastPickIndex, h = n ? 1 : 0;
        if (i.resegmentable && i.computeCurve() !== 9)
          for (let a = r + h; a < l - h; a++) {
            const f = this.makeResegmentHandle(t, a);
            f !== null && (f.segmentIndex = a, f.segmentFraction = 0.5, f.fromMaxLinks = 999, o.add(f));
          }
        for (let a = r + 1; a < l; a++) {
          const f = this.makeHandle(t, a);
          if (f !== null) {
            if (f.segmentIndex = a, a !== r)
              if (a === r + 1 && n) {
                const c = i.getPoint(r);
                let u = i.getPoint(r + 1);
                Geo.p(c.x, u.x) && Geo.p(c.y, u.y) ? (u = i.getPoint(r - 1), Geo.p(c.x, u.x) ? (this.setReshapingBehavior(f, 2), f.cursor = "n-resize") : Geo.p(c.y, u.y) && (this.setReshapingBehavior(f, 1), f.cursor = "w-resize")) : Geo.p(c.x, u.x) ? (this.setReshapingBehavior(f, 2), f.cursor = "n-resize") : Geo.p(c.y, u.y) && (this.setReshapingBehavior(f, 1), f.cursor = "w-resize");
              } else if (a === l - 1 && n) {
                let c = i.getPoint(l - 1);
                const u = i.getPoint(l);
                Geo.p(c.x, u.x) && Geo.p(c.y, u.y) ? (c = i.getPoint(l + 1), Geo.p(c.x, u.x) ? (this.setReshapingBehavior(f, 2), f.cursor = "n-resize") : Geo.p(c.y, u.y) && (this.setReshapingBehavior(f, 1), f.cursor = "w-resize")) : Geo.p(c.x, u.x) ? (this.setReshapingBehavior(f, 2), f.cursor = "n-resize") : Geo.p(c.y, u.y) && (this.setReshapingBehavior(f, 1), f.cursor = "w-resize");
              } else
                a === l || (this.setReshapingBehavior(f, 3), f.cursor = "move");
            o.add(f);
          }
        }
        o.adornedObject = t;
      }
      return o;
    }
    makeHandle(t, i) {
      const e = this.handleArchetype;
      return e === null ? null : e.copy().Tm();
    }
    get handleArchetype() {
      return this.Io;
    }
    set handleArchetype(t) {
      t !== null && Util.s(t, GraphObject2, _LinkReshapingTool, "handleArchetype"), this.Io = t;
    }
    makeResegmentHandle(t, i) {
      const e = this.midHandleArchetype;
      return e === null ? null : e.copy().Tm();
    }
    get midHandleArchetype() {
      return this.tM;
    }
    set midHandleArchetype(t) {
      t !== null && Util.s(t, GraphObject2, _LinkReshapingTool, "midHandleArchetype"), this.tM = t;
    }
    get handle() {
      return this.ws;
    }
    set handle(t) {
      if (t !== null && (Util.s(t, GraphObject2, _LinkReshapingTool, "handle"), !(t.part instanceof Adornment2)))
        throw new Error("new handle is not in an Adornment: " + t);
      this.ws = t;
    }
    get adornedLink() {
      return this.Jw;
    }
    canStart() {
      if (!this.isEnabled)
        return false;
      const t = this.diagram;
      return t.isReadOnly || !t.allowReshape || !t.lastInput.left ? false : this.findToolHandleAt(t.firstInput.documentPoint, this.name) !== null;
    }
    doActivate() {
      const t = this.diagram;
      if (this.handle === null && (this.handle = this.findToolHandleAt(t.firstInput.documentPoint, this.name)), this.handle === null)
        return;
      const i = this.handle.part.adornedPart;
      if (i instanceof Link2) {
        if (this.Jw = i, t.isMouseCaptured = true, this.startTransaction(this.name), i.resegmentable && this.handle.fromMaxLinks === 999) {
          const e = i.points.copy(), s = this.getResegmentingPoint();
          if (e.insertAt(this.handle.segmentIndex + 1, s), i.isOrthogonal && e.insertAt(this.handle.segmentIndex + 1, s), i.points = e, i.invalidateAdornments(), i.updateAdornments(), this.handle = this.findToolHandleAt(t.firstInput.documentPoint, this.name), this.handle === null) {
            this.doDeactivate();
            return;
          }
        }
        this.eM = i.getPoint(this.handle.segmentIndex), this.Dm = i.points.copy(), this.isActive = true;
      }
    }
    doDeactivate() {
      this.stopTransaction(), this.handle = null, this.Jw = null;
      const t = this.diagram;
      t.isMouseCaptured = false, this.isActive = false;
    }
    stopTransaction() {
      const t = this.diagram, i = super.stopTransaction();
      return i && t.undoManager.transactionToUndo !== null && t.undoManager.transactionToUndo.optimize(), i;
    }
    doCancel() {
      const t = this.adornedLink;
      t !== null && (t.points = this.Dm), this.stopTool();
    }
    getResegmentingPoint() {
      return this.handle.getDocumentPoint(Spot2.Center);
    }
    doMouseMove() {
      const t = this.diagram;
      if (this.isActive) {
        const i = this.computeReshape(t.lastInput.documentPoint);
        this.reshape(i);
      }
    }
    doMouseUp() {
      const t = this.diagram;
      if (this.isActive) {
        const i = this.computeReshape(t.lastInput.documentPoint);
        this.reshape(i);
        const e = this.adornedLink;
        if (e !== null && e.resegmentable) {
          const s = this.handle.segmentIndex, n = e.getPoint(s - 1), o = e.getPoint(s), r = e.getPoint(s + 1);
          if (e.isOrthogonal) {
            if (s > e.firstPickIndex + 1 && s < e.lastPickIndex - 1) {
              let l = e.getPoint(s - 2);
              if (this.isWithinResegmentingDistance(n, o) && (this.isInLineOrtho(l, n, o, r, true) || this.isInLineOrtho(l, n, o, r, false))) {
                const h = e.points.copy();
                this.isInLineOrtho(l, n, o, r, true) ? (h.setElt(s - 2, new Point2(l.x, (r.y + l.y) / 2)), h.setElt(s + 1, new Point2(r.x, (r.y + l.y) / 2))) : (h.setElt(s - 2, new Point2((r.x + l.x) / 2, l.y)), h.setElt(s + 1, new Point2((r.x + l.x) / 2, r.y))), h.removeAt(s), h.removeAt(s - 1), e.points = h, e.invalidateAdornments();
              } else if (l = e.getPoint(s + 2), this.isWithinResegmentingDistance(o, r) && (this.isInLineOrtho(n, o, r, l, true) || this.isInLineOrtho(n, o, r, l, false))) {
                const h = e.points.copy();
                this.isInLineOrtho(n, o, r, l, true) ? (h.setElt(s - 1, new Point2(n.x, (n.y + l.y) / 2)), h.setElt(s + 2, new Point2(l.x, (n.y + l.y) / 2))) : (h.setElt(s - 1, new Point2((n.x + l.x) / 2, n.y)), h.setElt(s + 2, new Point2((n.x + l.x) / 2, l.y))), h.removeAt(s + 1), h.removeAt(s), e.points = h, e.invalidateAdornments();
              }
            }
          } else {
            const l = Point2.a();
            if (Geo.Sl(n.x, n.y, r.x, r.y, o.x, o.y, l) && l.distanceSquaredPoint(o) < this.resegmentingDistance * this.resegmentingDistance) {
              const h = e.points.copy();
              h.removeAt(s), e.points = h, e.invalidateAdornments();
            }
            Point2.o(l);
          }
        }
        t.invalidateDocumentBounds(), this.transactionResult = this.name, t.V("LinkReshaped", this.adornedLink, this.Dm);
      }
      this.stopTool();
    }
    isWithinResegmentingDistance(t, i) {
      return Math.abs(t.x - i.x) < this.resegmentingDistance && Math.abs(t.y - i.y) < this.resegmentingDistance;
    }
    isInLineOrtho(t, i, e, s, n) {
      return n ? Math.abs(t.y - i.y) < this.resegmentingDistance && Math.abs(i.y - e.y) < this.resegmentingDistance && Math.abs(e.y - s.y) < this.resegmentingDistance : Math.abs(t.x - i.x) < this.resegmentingDistance && Math.abs(i.x - e.x) < this.resegmentingDistance && Math.abs(e.x - s.x) < this.resegmentingDistance;
    }
    get resegmentingDistance() {
      return this.iM;
    }
    set resegmentingDistance(t) {
      Util.t(t, "number", _LinkReshapingTool, "resegmentingDistance"), this.iM = t;
    }
    reshape(t) {
      const i = this.adornedLink;
      i.startRoute();
      let e = this.handle.segmentIndex;
      const s = this.getReshapingBehavior(this.handle);
      if (i.isOrthogonal)
        if (e === i.firstPickIndex + 1) {
          const n = i.firstPickIndex + 1;
          s === 2 ? (i.setPointAt(n, i.getPoint(n - 1).x, t.y), i.setPointAt(n + 1, i.getPoint(n + 2).x, t.y)) : s === 1 && (i.setPointAt(n, t.x, i.getPoint(n - 1).y), i.setPointAt(n + 1, t.x, i.getPoint(n + 2).y));
        } else if (e === i.lastPickIndex - 1) {
          const n = i.lastPickIndex - 1;
          s === 2 ? (i.setPointAt(n - 1, i.getPoint(n - 2).x, t.y), i.setPointAt(n, i.getPoint(n + 1).x, t.y)) : s === 1 && (i.setPointAt(n - 1, t.x, i.getPoint(n - 2).y), i.setPointAt(n, t.x, i.getPoint(n + 1).y));
        } else {
          let n = e;
          const o = i.getPoint(n), r = i.getPoint(n - 1), l = i.getPoint(n + 1);
          Geo.p(r.x, o.x) && Geo.p(o.y, l.y) ? (Geo.p(r.x, i.getPoint(n - 2).x) && !Geo.p(r.y, i.getPoint(n - 2).y) ? (i.insertPointAt(n, t.x, r.y), e++, n++) : i.setPointAt(n - 1, t.x, r.y), Geo.p(l.y, i.getPoint(n + 2).y) && !Geo.p(l.x, i.getPoint(n + 2).x) ? i.insertPointAt(n + 1, l.x, t.y) : i.setPointAt(n + 1, l.x, t.y)) : Geo.p(r.y, o.y) && Geo.p(o.x, l.x) ? (Geo.p(r.y, i.getPoint(n - 2).y) && !Geo.p(r.x, i.getPoint(n - 2).x) ? (i.insertPointAt(n, r.x, t.y), e++, n++) : i.setPointAt(n - 1, r.x, t.y), Geo.p(l.x, i.getPoint(n + 2).x) && !Geo.p(l.y, i.getPoint(n + 2).y) ? i.insertPointAt(n + 1, t.x, l.y) : i.setPointAt(n + 1, t.x, l.y)) : Geo.p(r.x, o.x) && Geo.p(o.x, l.x) ? (Geo.p(r.x, i.getPoint(n - 2).x) && !Geo.p(r.y, i.getPoint(n - 2).y) ? (i.insertPointAt(n, t.x, r.y), e++, n++) : i.setPointAt(n - 1, t.x, r.y), Geo.p(l.x, i.getPoint(n + 2).x) && !Geo.p(l.y, i.getPoint(n + 2).y) ? i.insertPointAt(n + 1, t.x, l.y) : i.setPointAt(n + 1, t.x, l.y)) : Geo.p(r.y, o.y) && Geo.p(o.y, l.y) && (Geo.p(r.y, i.getPoint(n - 2).y) && !Geo.p(r.x, i.getPoint(n - 2).x) ? (i.insertPointAt(n, r.x, t.y), e++, n++) : i.setPointAt(n - 1, r.x, t.y), Geo.p(l.y, i.getPoint(n + 2).y) && !Geo.p(l.x, i.getPoint(n + 2).x) ? i.insertPointAt(n + 1, l.x, t.y) : i.setPointAt(n + 1, l.x, t.y)), i.setPointAt(e, t.x, t.y);
        }
      else {
        i.setPointAt(e, t.x, t.y);
        let n = i.fromNode, o = i.fromPort;
        if (n !== null) {
          const h = n.findVisibleNode();
          h !== null && h !== n && (n = h, o = n.port);
        }
        if (e === 1 && i.computeSpot(true, o).isNoSpot()) {
          const h = o.getDocumentPoint(Spot2.Center, Point2.a()), a = i.getLinkPointFromPoint(n, o, h, t, true, Point2.a());
          i.setPointAt(0, a.x, a.y), Point2.o(h), Point2.o(a);
        }
        let r = i.toNode, l = i.toPort;
        if (r !== null) {
          const h = r.findVisibleNode();
          h !== null && h !== r && (r = h, l = r.port);
        }
        if (e === i.pointsCount - 2 && i.computeSpot(false, l).isNoSpot()) {
          const h = l.getDocumentPoint(Spot2.Center, Point2.a()), a = i.getLinkPointFromPoint(r, l, h, t, false, Point2.a());
          i.setPointAt(i.pointsCount - 1, a.x, a.y), Point2.o(h), Point2.o(a);
        }
      }
      i.commitRoute();
    }
    computeReshape(t) {
      const i = this.adornedLink, e = this.handle.segmentIndex;
      switch (this.getReshapingBehavior(this.handle)) {
        case 3:
          return t;
        case 2: {
          const s = i.getPoint(e);
          return new Point2(s.x, t.y);
        }
        case 1: {
          const s = i.getPoint(e);
          return new Point2(t.x, s.y);
        }
        default:
        case 0:
          return i.getPoint(e);
      }
    }
    get originalPoint() {
      return this.eM;
    }
    get originalPoints() {
      return this.Dm;
    }
  };
  __publicField(_LinkReshapingTool, "None", 0);
  __publicField(_LinkReshapingTool, "Horizontal", 1);
  __publicField(_LinkReshapingTool, "Vertical", 2);
  __publicField(_LinkReshapingTool, "All", 3);
  let LinkReshapingTool2 = _LinkReshapingTool;
  class ResizingTool2 extends Tool2 {
    constructor(t) {
      super();
      __publicField(this, "Cr");
      __publicField(this, "Ar");
      __publicField(this, "Oo");
      __publicField(this, "Sf");
      __publicField(this, "oM");
      __publicField(this, "xs");
      __publicField(this, "Io");
      __publicField(this, "ws");
      __publicField(this, "Fm");
      __publicField(this, "rM");
      __publicField(this, "Mf");
      __publicField(this, "Zw");
      __publicField(this, "$w");
      __publicField(this, "Qw");
      this.name = "Resizing", this.Cr = new Size2(1, 1).w(), this.Ar = new Size2(9999, 9999).w(), this.Oo = new Size2(NaN, NaN).w(), this.Sf = false, this.oM = true, this.xs = null, this.Io = new Shape2("Rectangle", { alignmentFocus: Spot2.Center, desiredSize: Size2.nC, fill: "lightblue", stroke: "dodgerblue", strokeWidth: 1, cursor: "pointer" }).theme("fill", "adornmentFill").theme("stroke", "adornmentStroke"), this.ws = null, this.Fm = new Point2(), this.rM = new Size2(), this.Mf = new Point2(), this.Zw = new Size2(0, 0), this.$w = new Size2(1 / 0, 1 / 0), this.Qw = new Size2(1, 1), t && Object.assign(this, t);
    }
    updateAdornments(t) {
      if (!(t === null || t instanceof Link2)) {
        if (t.isSelected && !this.diagram.isReadOnly) {
          const i = t.resizeObject;
          let e = t.findAdornment(this.name);
          if (i !== null && t.canResize() && t.actualBounds.isReal() && t.isVisible() && i.actualBounds.isReal() && i.isVisibleObject() && ((e === null || e.adornedObject !== i) && (e = this.makeAdornment(i)), e !== null)) {
            const s = i.getDocumentAngle();
            t.Rl() && this.updateResizeHandles(e, s), t.addAdornment(this.name, e);
            return;
          }
        }
        t.removeAdornment(this.name);
      }
    }
    makeAdornment(t) {
      let i = null;
      const e = t.part.resizeAdornmentTemplate;
      if (e === null) {
        i = new Adornment2(), i.type = Panel2.Spot, i.locationSpot = Spot2.Center;
        const s = new Placeholder2();
        s.isPanelMain = true, i.add(s), i.add(this.makeHandle(t, Spot2.TopLeft)), i.add(this.makeHandle(t, Spot2.TopRight)), i.add(this.makeHandle(t, Spot2.BottomRight)), i.add(this.makeHandle(t, Spot2.BottomLeft)), i.add(this.makeHandle(t, Spot2.MiddleTop)), i.add(this.makeHandle(t, Spot2.MiddleRight)), i.add(this.makeHandle(t, Spot2.MiddleBottom)), i.add(this.makeHandle(t, Spot2.MiddleLeft));
      } else if (e.ui(), i = e.copy(), i === null)
        return null;
      return i.adornedObject = t, i;
    }
    makeHandle(t, i) {
      const e = this.handleArchetype;
      if (e === null)
        return null;
      const s = e.copy().Tm();
      return s.alignment = i, s;
    }
    updateResizeHandles(t, i) {
      if (t !== null) {
        if (!t.alignment.isDefault() && (t.cursor === "pointer" || t.cursor.indexOf("resize") > 0))
          this.rF(t, i);
        else if (t instanceof Panel2) {
          const e = t.elements;
          for (; e.next(); ) {
            const s = e.value;
            this.updateResizeHandles(s, i);
          }
        }
      }
    }
    rF(t, i) {
      let e = t.alignment;
      e.isNoSpot() && (e = Spot2.Center);
      let s = i;
      if (e.x <= 0)
        e.y <= 0 ? s += 225 : e.y >= 1 ? s += 135 : s += 180;
      else if (e.x >= 1)
        e.y <= 0 ? s += 315 : e.y >= 1 && (s += 45);
      else if (e.y <= 0)
        s += 270;
      else if (e.y >= 1)
        s += 90;
      else
        return;
      s < 0 ? s += 360 : s >= 360 && (s -= 360), s < 22.5 ? t.cursor = "e-resize" : s < 67.5 ? t.cursor = "se-resize" : s < 112.5 ? t.cursor = "s-resize" : s < 157.5 ? t.cursor = "sw-resize" : s < 202.5 ? t.cursor = "w-resize" : s < 247.5 ? t.cursor = "nw-resize" : s < 292.5 ? t.cursor = "n-resize" : s < 337.5 ? t.cursor = "ne-resize" : t.cursor = "e-resize";
    }
    get handleArchetype() {
      return this.Io;
    }
    set handleArchetype(t) {
      t !== null && Util.s(t, GraphObject2, ResizingTool2, "handleArchetype"), this.Io = t;
    }
    get handle() {
      return this.ws;
    }
    set handle(t) {
      if (t !== null && (Util.s(t, GraphObject2, ResizingTool2, "handle"), !(t.part instanceof Adornment2)))
        throw new Error("new handle is not in an Adornment: " + t);
      this.ws = t;
    }
    get adornedObject() {
      return this.xs;
    }
    set adornedObject(t) {
      if (t !== null && (Util.s(t, GraphObject2, ResizingTool2, "handle"), t.part instanceof Adornment2))
        throw new Error("new handle must not be in an Adornment: " + t);
      this.xs = t;
    }
    canStart() {
      if (!this.isEnabled)
        return false;
      const t = this.diagram;
      return t.isReadOnly || !t.allowResize || !t.lastInput.left ? false : this.findToolHandleAt(t.firstInput.documentPoint, this.name) !== null;
    }
    doActivate() {
      const t = this.diagram;
      this.handle === null && (this.handle = this.findToolHandleAt(t.firstInput.documentPoint, this.name)), this.handle !== null && (this.adornedObject = this.handle.part.adornedObject, this.adornedObject !== null && (t.isMouseCaptured = true, t.animationManager.stopAnimation(), t.Mu = true, this.startTransaction(this.name), this.Fm.set(this.adornedObject.getDocumentPoint(this.handle.alignment.opposite())), this.Mf.set(this.adornedObject.part.location), this.rM.set(this.adornedObject.desiredSize), this.Qw = this.computeCellSize(), this.Zw = this.computeMinSize(), this.$w = this.computeMaxSize(), this.isActive = true));
    }
    doDeactivate() {
      const t = this.diagram;
      t.Mu = false, t.Al = true, this.stopTransaction(), this.handle = null, this.xs = null, t.isMouseCaptured = false, this.isActive = false;
    }
    stopTransaction() {
      const t = this.diagram, i = super.stopTransaction();
      return i && t.undoManager.transactionToUndo !== null && t.undoManager.transactionToUndo.optimize(), i;
    }
    doCancel() {
      this.adornedObject !== null && (this.adornedObject.desiredSize = this.originalDesiredSize, this.adornedObject.part.location = this.originalLocation), this.stopTool();
    }
    doMouseMove() {
      const t = this.diagram;
      if (!this.isActive)
        return;
      const i = this.Zw, e = this.$w, s = this.Qw, n = t.lastInput.documentPoint, o = this.adornedObject.getLocalPoint(n, Point2.a()), r = this.computeReshape(), l = this.computeResize(o, this.handle.alignment, i, e, s, r);
      this.resize(l), t.maybeUpdate(), Point2.o(o);
    }
    doMouseUp() {
      const t = this.diagram;
      if (this.isActive) {
        const i = this.Zw, e = this.$w, s = this.Qw, n = this.adornedObject.getLocalPoint(t.lastInput.documentPoint, Point2.a()), o = this.computeReshape(), r = this.computeResize(n, this.handle.alignment, i, e, s, o);
        this.resize(r), Point2.o(n), t.invalidateDocumentBounds(), this.transactionResult = this.name, t.V("PartResized", this.adornedObject, this.originalDesiredSize);
      }
      this.stopTool();
    }
    resize(t) {
      const i = this.diagram, e = this.adornedObject;
      if (e === null)
        return;
      e.desiredSize = t.size;
      const s = e.part;
      s.ensureBounds();
      const n = e.getDocumentPoint(this.handle.alignment.opposite());
      if (s instanceof Group2) {
        const o = new List2();
        o.add(s);
        let r;
        !this.dragsMembers && !s.hasPlaceholder() && (r = new DraggingOptions2(), r.dragsMembers = false), i.moveParts(o, this.oppositePoint.copy().subtract(n), true, r);
      } else
        s.location = s.location.copy().subtract(n).add(this.oppositePoint);
      i.maybeUpdate();
    }
    computeResize(t, i, e, s, n, o) {
      i.isNoSpot() && (i = Spot2.Center);
      const r = this.adornedObject.naturalBounds, l = r.x, h = r.y, a = r.x + r.width, f = r.y + r.height;
      let c = 1;
      if (!o) {
        let m = r.width, g = r.height;
        m <= 0 && (m = 1), g <= 0 && (g = 1), c = g / m;
      }
      const u = Point2.a();
      Geo.vg(t.x, t.y, l, h, n.width, n.height, u);
      const d = r.copy();
      return i.x <= 0 ? i.y <= 0 ? (d.x = Math.max(u.x, a - s.width), d.x = Math.min(d.x, a - e.width), d.width = Math.max(a - d.x, e.width), d.y = Math.max(u.y, f - s.height), d.y = Math.min(d.y, f - e.height), d.height = Math.max(f - d.y, e.height), o || (d.height / d.width >= 1 ? (d.height = Math.max(Math.min(c * d.width, s.height), e.height), d.width = d.height / c) : (d.width = Math.max(Math.min(d.height / c, s.width), e.width), d.height = c * d.width), d.x = a - d.width, d.y = f - d.height)) : i.y >= 1 ? (d.x = Math.max(u.x, a - s.width), d.x = Math.min(d.x, a - e.width), d.width = Math.max(a - d.x, e.width), d.height = Math.max(Math.min(u.y - h, s.height), e.height), o || (d.height / d.width >= 1 ? (d.height = Math.max(Math.min(c * d.width, s.height), e.height), d.width = d.height / c) : (d.width = Math.max(Math.min(d.height / c, s.width), e.width), d.height = c * d.width), d.x = a - d.width)) : (d.x = Math.max(u.x, a - s.width), d.x = Math.min(d.x, a - e.width), d.width = a - d.x, o || (d.height = Math.max(Math.min(c * d.width, s.height), e.height), d.width = d.height / c, d.y = h + 0.5 * (f - h - d.height))) : i.x >= 1 ? i.y <= 0 ? (d.width = Math.max(Math.min(u.x - l, s.width), e.width), d.y = Math.max(u.y, f - s.height), d.y = Math.min(d.y, f - e.height), d.height = Math.max(f - d.y, e.height), o || (d.height / d.width >= 1 ? (d.height = Math.max(Math.min(c * d.width, s.height), e.height), d.width = d.height / c) : (d.width = Math.max(Math.min(d.height / c, s.width), e.width), d.height = c * d.width), d.y = f - d.height)) : i.y >= 1 ? (d.width = Math.max(Math.min(u.x - l, s.width), e.width), d.height = Math.max(Math.min(u.y - h, s.height), e.height), o || (d.height / d.width >= 1 ? (d.height = Math.max(Math.min(c * d.width, s.height), e.height), d.width = d.height / c) : (d.width = Math.max(Math.min(d.height / c, s.width), e.width), d.height = c * d.width))) : (d.width = Math.max(Math.min(u.x - l, s.width), e.width), o || (d.height = Math.max(Math.min(c * d.width, s.height), e.height), d.width = d.height / c, d.y = h + 0.5 * (f - h - d.height))) : i.y <= 0 ? (d.y = Math.max(u.y, f - s.height), d.y = Math.min(d.y, f - e.height), d.height = f - d.y, o || (d.width = Math.max(Math.min(d.height / c, s.width), e.width), d.height = c * d.width, d.x = l + 0.5 * (a - l - d.width))) : i.y >= 1 && (d.height = Math.max(Math.min(u.y - h, s.height), e.height), o || (d.width = Math.max(Math.min(d.height / c, s.width), e.width), d.height = c * d.width, d.x = l + 0.5 * (a - l - d.width))), Point2.o(u), d;
    }
    computeReshape() {
      let t = 0;
      return this.adornedObject instanceof Shape2 && (t = this.adornedObject.lM()), !(t === 6 || this.diagram.lastInput.shift);
    }
    computeMinSize() {
      const t = this.adornedObject.minSize.copy(), i = this.minSize;
      return !isNaN(i.width) && i.width > t.width && (t.width = i.width), !isNaN(i.height) && i.height > t.height && (t.height = i.height), t;
    }
    computeMaxSize() {
      const t = this.adornedObject.maxSize.copy(), i = this.maxSize;
      return !isNaN(i.width) && i.width < t.width && (t.width = i.width), !isNaN(i.height) && i.height < t.height && (t.height = i.height), t;
    }
    computeCellSize() {
      const t = new Size2(NaN, NaN), i = this.adornedObject.part;
      if (i !== null) {
        const n = i.resizeCellSize;
        !isNaN(n.width) && n.width > 0 && (t.width = n.width), !isNaN(n.height) && n.height > 0 && (t.height = n.height);
      }
      let e = this.cellSize;
      isNaN(t.width) && !isNaN(e.width) && e.width > 0 && (t.width = e.width), isNaN(t.height) && !isNaN(e.height) && e.height > 0 && (t.height = e.height);
      const s = this.diagram;
      if ((isNaN(t.width) || isNaN(t.height)) && s) {
        const n = s.grid;
        n !== null && n.visible && this.isGridSnapEnabled && (e = n.gridCellSize, isNaN(t.width) && !isNaN(e.width) && e.width > 0 && (t.width = e.width), isNaN(t.height) && !isNaN(e.height) && e.height > 0 && (t.height = e.height));
      }
      return (isNaN(t.width) || t.width === 0 || t.width === 1 / 0) && (t.width = 1), (isNaN(t.height) || t.height === 0 || t.height === 1 / 0) && (t.height = 1), t;
    }
    get minSize() {
      return this.Cr;
    }
    set minSize(t) {
      if (Util.s(t, Size2, ResizingTool2, "minSize"), !this.Cr.equals(t)) {
        let e = t.width;
        isNaN(e) && (e = 0);
        let s = t.height;
        isNaN(s) && (s = 0), this.Cr.e(e, s);
      }
    }
    get maxSize() {
      return this.Ar;
    }
    set maxSize(t) {
      if (Util.s(t, Size2, ResizingTool2, "maxSize"), !this.Ar.equals(t)) {
        let e = t.width;
        isNaN(e) && (e = 1 / 0);
        let s = t.height;
        isNaN(s) && (s = 1 / 0), this.Ar.e(e, s);
      }
    }
    get cellSize() {
      return this.Oo;
    }
    set cellSize(t) {
      Util.s(t, Size2, ResizingTool2, "cellSize"), this.Oo.equals(t) || this.Oo.c(t);
    }
    get isGridSnapEnabled() {
      return this.Sf;
    }
    set isGridSnapEnabled(t) {
      Util.t(t, "boolean", ResizingTool2, "isGridSnapEnabled"), this.Sf = t;
    }
    get dragsMembers() {
      return this.oM;
    }
    set dragsMembers(t) {
      Util.t(t, "boolean", ResizingTool2, "dragsMembers"), this.oM = t;
    }
    get oppositePoint() {
      return this.Fm;
    }
    set oppositePoint(t) {
      Util.s(t, Point2, ResizingTool2, "oppositePoint"), this.Fm.equals(t) || this.Fm.c(t);
    }
    get originalDesiredSize() {
      return this.rM;
    }
    get originalLocation() {
      return this.Mf;
    }
  }
  class RotatingTool2 extends Tool2 {
    constructor(t) {
      super();
      __publicField(this, "hM");
      __publicField(this, "aM");
      __publicField(this, "xs");
      __publicField(this, "Io");
      __publicField(this, "ws");
      __publicField(this, "fM");
      __publicField(this, "Rm");
      __publicField(this, "Mf");
      __publicField(this, "cM");
      __publicField(this, "uM");
      this.name = "Rotating", this.hM = 45, this.aM = 2, this.Mf = new Point2(), this.xs = null, this.Io = new Shape2("Ellipse", { desiredSize: Size2.du, fill: "lightblue", stroke: "dodgerblue", strokeWidth: 1, cursor: "pointer" }).theme("fill", "adornmentFill").theme("stroke", "adornmentStroke"), this.ws = null, this.fM = 0, this.Rm = new Point2(NaN, NaN), this.cM = 0, this.uM = 50, t && Object.assign(this, t);
    }
    updateAdornments(t) {
      if (t !== null) {
        if (t.Il()) {
          const i = t.rotateObject;
          if (i === t || i === t.path || i.isPanelMain)
            return;
        }
        if (t.isSelected && !this.diagram.isReadOnly) {
          const i = t.rotateObject;
          if (i !== null && t.canRotate() && t.actualBounds.isReal() && t.isVisible() && i.actualBounds.isReal() && i.isVisibleObject()) {
            let e = t.findAdornment(this.name);
            if ((e === null || e.adornedObject !== i) && (e = this.makeAdornment(i)), e !== null) {
              e.angle = i.getDocumentAngle(), e.hasPlaceholder() || (e.location = this.computeAdornmentLocation(i)), t.addAdornment(this.name, e);
              return;
            }
          }
        }
        t.removeAdornment(this.name);
      }
    }
    makeAdornment(t) {
      let i = null;
      const e = t.part.rotateAdornmentTemplate;
      if (e === null) {
        i = new Adornment2(), i.type = Panel2.Position, i.locationSpot = Spot2.Center;
        const s = this.handleArchetype;
        s !== null && i.add(s.copy().Tm());
      } else if (e.ui(), i = e.copy(), i === null)
        return null;
      return i.adornedObject = t, i;
    }
    get handleArchetype() {
      return this.Io;
    }
    set handleArchetype(t) {
      t !== null && Util.s(t, GraphObject2, RotatingTool2, "handleArchetype"), this.Io = t;
    }
    get handle() {
      return this.ws;
    }
    set handle(t) {
      if (t !== null && (Util.s(t, GraphObject2, RotatingTool2, "handle"), !(t.part instanceof Adornment2)))
        throw new Error("new handle is not in an Adornment: " + t);
      this.ws = t;
    }
    get adornedObject() {
      return this.xs;
    }
    set adornedObject(t) {
      if (t !== null && (Util.s(t, GraphObject2, RotatingTool2, "handle"), t.part instanceof Adornment2))
        throw new Error("new handle must not be in an Adornment: " + t);
      this.xs = t;
    }
    canStart() {
      if (!this.isEnabled)
        return false;
      const t = this.diagram;
      return t.isReadOnly || !t.allowRotate || !t.lastInput.left ? false : this.findToolHandleAt(t.firstInput.documentPoint, this.name) !== null;
    }
    doActivate() {
      const t = this.diagram;
      if (this.adornedObject === null) {
        if (this.handle === null && (this.handle = this.findToolHandleAt(t.firstInput.documentPoint, this.name)), this.handle === null)
          return;
        this.adornedObject = this.handle.part.adornedObject;
      }
      this.adornedObject !== null && (t.isMouseCaptured = true, t.delaysLayout = true, this.startTransaction(this.name), this.fM = this.adornedObject.angle, this.Rm = this.computeRotationPoint(this.adornedObject), this.Mf = this.adornedObject.part.location.copy(), this.isActive = true);
    }
    computeRotationPoint(t) {
      const i = t.part, e = i.locationObject;
      return i.rotationSpot.isSpot() ? t.getDocumentPoint(i.rotationSpot) : t === i || t === e ? e.getDocumentPoint(i.locationSpot) : t.getDocumentPoint(Spot2.Center);
    }
    computeAdornmentLocation(t) {
      let i = this.rotationPoint;
      i.isReal() || (i = this.computeRotationPoint(t));
      const e = t.getLocalPoint(i);
      let s = this.handleAngle;
      s < 0 ? s += 360 : s >= 360 && (s -= 360), s = Math.round(Math.round(s / 45) * 45);
      const n = this.handleDistance;
      return s === 0 ? e.x = t.naturalBounds.width + n : s === 45 ? (e.x = t.naturalBounds.width + n, e.y = t.naturalBounds.height + n) : s === 90 ? e.y = t.naturalBounds.height + n : s === 135 ? (e.x = -n, e.y = t.naturalBounds.height + n) : s === 180 ? e.x = -n : s === 225 ? (e.x = -n, e.y = -n) : s === 270 ? e.y = -n : s === 315 && (e.x = t.naturalBounds.width + n, e.y = -n), t.getDocumentPoint(e);
    }
    doDeactivate() {
      const t = this.diagram;
      this.stopTransaction(), this.handle = null, this.xs = null, this.Rm = new Point2(NaN, NaN), t.isMouseCaptured = false, this.isActive = false;
    }
    stopTransaction() {
      const t = this.diagram, i = super.stopTransaction();
      return i && t.undoManager.transactionToUndo !== null && t.undoManager.transactionToUndo.optimize(), i;
    }
    doCancel() {
      const t = this.diagram;
      t.delaysLayout = false, this.rotate(this.originalAngle), this.stopTool();
    }
    doMouseMove() {
      const t = this.diagram;
      if (this.isActive) {
        const i = this.computeRotate(t.lastInput.documentPoint);
        this.rotate(i);
      }
    }
    doMouseUp() {
      const t = this.diagram;
      if (this.isActive) {
        t.delaysLayout = false;
        const i = this.computeRotate(t.lastInput.documentPoint);
        this.rotate(i), t.invalidateDocumentBounds(), this.transactionResult = this.name, t.V("PartRotated", this.adornedObject, this.originalAngle);
      }
      this.stopTool();
    }
    rotate(t) {
      Debug && Util.r(t, RotatingTool2, "rotate:newangle");
      const i = this.adornedObject;
      if (i === null)
        return;
      i.angle = t;
      const e = i.part;
      e.ensureBounds();
      const s = e.locationObject, n = e.rotateObject;
      if (s === n || s.isContainedBy(n)) {
        const o = this.Mf.copy();
        e.location = o.subtract(this.rotationPoint).rotate(t - this.originalAngle).add(this.rotationPoint);
      }
      this.diagram.maybeUpdate();
    }
    computeRotate(t) {
      let i = this.rotationPoint.directionPoint(t) - this.handleAngle;
      const e = this.adornedObject.panel;
      e !== null && (i -= e.getDocumentAngle()), i >= 360 ? i -= 360 : i < 0 && (i += 360);
      const s = Math.min(Math.abs(this.snapAngleMultiple), 180), n = Math.min(Math.abs(this.snapAngleEpsilon), s / 2);
      return !this.diagram.lastInput.shift && s > 0 && n > 0 && (i % s < n ? i = Math.floor(i / s) * s : i % s > s - n && (i = (Math.floor(i / s) + 1) * s)), i >= 360 ? i -= 360 : i < 0 && (i += 360), i;
    }
    get snapAngleMultiple() {
      return this.hM;
    }
    set snapAngleMultiple(t) {
      Util.t(t, "number", RotatingTool2, "snapAngleMultiple"), this.hM = t;
    }
    get snapAngleEpsilon() {
      return this.aM;
    }
    set snapAngleEpsilon(t) {
      Util.t(t, "number", RotatingTool2, "snapAngleEpsilon"), this.aM = t;
    }
    get originalAngle() {
      return this.fM;
    }
    get rotationPoint() {
      return this.Rm;
    }
    set rotationPoint(t) {
      this.Rm = t.copy();
    }
    get handleAngle() {
      return this.cM;
    }
    set handleAngle(t) {
      Util.t(t, "number", RotatingTool2, "handleAngle"), this.cM = t;
    }
    get handleDistance() {
      return this.uM;
    }
    set handleDistance(t) {
      Util.t(t, "number", RotatingTool2, "handleDistance"), this.uM = t;
    }
  }
  class ClickSelectingTool2 extends Tool2 {
    constructor(t) {
      super(), this.name = "ClickSelecting", t && Object.assign(this, t);
    }
    canStart() {
      return !(!this.isEnabled || this.isBeyondDragSize());
    }
    doMouseUp() {
      this.isActive && (this.standardMouseSelect(), this.standardMouseClick() || this.diagram.lastInput.isTouchEvent && this.diagram.toolManager.doToolTip()), this.stopTool();
    }
  }
  class ActionTool2 extends Tool2 {
    constructor(t) {
      super();
      __publicField(this, "Pf");
      this.name = "Action", this.Pf = null, t && Object.assign(this, t);
    }
    canStart() {
      if (!this.isEnabled)
        return false;
      const t = this.diagram, i = t.lastInput, e = t.findObjectAt(i.documentPoint, (s) => {
        for (; s.panel !== null; ) {
          if (s.isActionable)
            return s;
          s = s.panel;
        }
        return s;
      });
      return e !== null && e.isActionable ? (this.Pf = e, t.wf = t.findObjectAt(i.documentPoint, null, null), true) : false;
    }
    doMouseDown() {
      if (!this.isActive)
        this.canStart() && this.doActivate();
      else {
        const i = this.diagram.lastInput, e = this.Pf;
        if (e === null)
          return;
        i.targetObject = e, e.actionDown !== null && e.actionDown(i, e);
      }
    }
    doMouseMove() {
      if (this.isActive) {
        const i = this.diagram.lastInput, e = this.Pf;
        if (e === null)
          return;
        i.targetObject = e, e.actionMove !== null && e.actionMove(i, e);
      }
    }
    doMouseUp() {
      if (this.isActive) {
        const i = this.diagram.lastInput, e = this.Pf;
        if (e === null)
          return;
        i.targetObject = e, e.actionUp !== null && e.actionUp(i, e), this.standardMouseClick((s) => {
          for (; s.panel !== null; ) {
            if (s.isActionable && s === e)
              return s;
            s = s.panel;
          }
          return s;
        }, (s) => s === e);
      }
      this.stopTool();
    }
    doCancel() {
      const i = this.diagram.lastInput, e = this.Pf;
      e !== null && (i.targetObject = e, e.actionCancel !== null && e.actionCancel(i, e), this.stopTool());
    }
    doStop() {
      this.Pf = null;
    }
  }
  class ClickCreatingTool2 extends Tool2 {
    constructor(t) {
      super();
      __publicField(this, "Ol");
      __publicField(this, "dM");
      __publicField(this, "Sf");
      __publicField(this, "gM");
      this.name = "ClickCreating", this.Ol = null, this.dM = true, this.Sf = false, this.gM = new Point2(0, 0), t && Object.assign(this, t);
    }
    canStart() {
      if (!this.isEnabled || this.archetypeNodeData === null)
        return false;
      const t = this.diagram;
      if (t.isReadOnly || t.isModelReadOnly || !t.allowInsert || !t.lastInput.left || this.isBeyondDragSize())
        return false;
      if (this.isDoubleClick) {
        if (t.lastInput.clickCount === 1 && (this.gM = t.lastInput.viewPoint.copy()), t.lastInput.clickCount !== 2 || this.isBeyondDragSize(this.gM))
          return false;
      } else if (t.lastInput.clickCount !== 1)
        return false;
      return !(t.currentTool !== this && t.findPartAt(t.lastInput.documentPoint, true) !== null);
    }
    doMouseUp() {
      const t = this.diagram;
      this.isActive && this.insertPart(t.lastInput.documentPoint), this.stopTool();
    }
    insertPart(t) {
      const i = this.diagram, e = this.archetypeNodeData;
      if (e === null)
        return null;
      let s = null;
      try {
        if (i.V("ChangingSelection", i.selection), this.startTransaction(this.name), e instanceof Part2)
          e.De() && (e.ui(), s = e.copy(), s !== null && i.add(s));
        else if (e !== null) {
          const n = i.model.copyNodeData(e);
          Util.Mt(n) && (i.model.addNodeData(n), s = i.findPartForData(n));
        }
        if (s !== null) {
          const n = Point2.H(t.x, t.y);
          this.isGridSnapEnabled && this.diagram.mM(s, t, n), s.location = n, i.allowSelect && (i.clearSelection(true), s.isSelected = true), Point2.o(n);
        }
        i.invalidateDocumentBounds(), this.transactionResult = this.name, i.V("PartCreated", s);
      } finally {
        this.stopTransaction(), i.V("ChangedSelection", i.selection);
      }
      return s;
    }
    get archetypeNodeData() {
      return this.Ol;
    }
    set archetypeNodeData(t) {
      t !== null && Util.t(t, "object", ClickCreatingTool2, "archetypeNodeData"), this.Ol = t;
    }
    get isDoubleClick() {
      return this.dM;
    }
    set isDoubleClick(t) {
      Util.t(t, "boolean", ClickCreatingTool2, "isDoubleClick"), this.dM = t;
    }
    get isGridSnapEnabled() {
      return this.Sf;
    }
    set isGridSnapEnabled(t) {
      Util.t(t, "boolean", ClickCreatingTool2, "isGridSnapEnabled"), this.Sf = t;
    }
  }
  class DragSelectingTool2 extends Tool2 {
    constructor(t) {
      super();
      __publicField(this, "Hh");
      __publicField(this, "pM");
      __publicField(this, "El");
      this.name = "DragSelecting", this.Hh = 175, this.pM = false, this.El = new Part2({ layerName: "Tool", selectable: false }).add(new Shape2("Rectangle", { name: "SHAPE", fill: null, stroke: "magenta" }).theme("stroke", "dragSelect")).ui(), t && Object.assign(this, t);
    }
    canStart() {
      if (!this.isEnabled)
        return false;
      const t = this.diagram;
      if (!t.allowSelect)
        return false;
      const i = t.lastInput;
      return !(!i.left || t.currentTool !== this && (!this.isBeyondDragSize() || i.timestamp - t.firstInput.timestamp < this.delay || t.findPartAt(i.documentPoint, true) !== null));
    }
    doActivate() {
      const t = this.diagram;
      this.isActive = true, t.isMouseCaptured = true, t.skipsUndoManager = true, t.add(this.box), this.doMouseMove();
    }
    doDeactivate() {
      const t = this.diagram;
      t.stopAutoScroll(), t.remove(this.box), t.skipsUndoManager = false, t.isMouseCaptured = false, this.isActive = false;
    }
    doMouseMove() {
      const t = this.diagram;
      if (this.isActive && this.box !== null) {
        const i = this.computeBoxBounds();
        let e = this.box.findObject("SHAPE");
        e === null && (e = this.box.findMainElement());
        const s = Size2.a().e(i.width, i.height);
        e.desiredSize = s, this.box.Nf(i.x, i.y, false), Size2.o(s), (t.allowHorizontalScroll || t.allowVerticalScroll) && t.doAutoScroll(t.lastInput.viewPoint);
      }
    }
    doMouseUp() {
      if (this.isActive) {
        const t = this.diagram;
        t.remove(this.box);
        try {
          t.currentCursor = "wait", t.V("ChangingSelection", t.selection), this.selectInRect(this.computeBoxBounds()), t.V("ChangedSelection", t.selection);
        } finally {
          t.currentCursor = "";
        }
      }
      this.stopTool();
    }
    computeBoxBounds() {
      const t = this.diagram;
      return new Rect2(t.firstInput.documentPoint, t.lastInput.documentPoint);
    }
    selectInRect(t) {
      const i = this.diagram, e = i.lastInput, s = i.findPartsIn(t, this.isPartialInclusion);
      if (Util.dr ? e.meta : e.control)
        if (e.shift) {
          const n = s.iterator;
          for (; n.next(); ) {
            const o = n.value;
            o.isSelected && (o.isSelected = false);
          }
        } else {
          const n = s.iterator;
          for (; n.next(); ) {
            const o = n.value;
            o.isSelected = !o.isSelected;
          }
        }
      else if (e.shift) {
        const n = s.iterator;
        for (; n.next(); ) {
          const o = n.value;
          o.isSelected || (o.isSelected = true);
        }
      } else {
        const n = new List2(), o = i.selection.iterator;
        for (; o.next(); ) {
          const h = o.value;
          s.contains(h) || n.add(h);
        }
        const r = n.iterator;
        for (; r.next(); ) {
          const h = r.value;
          h.isSelected = false;
        }
        const l = s.iterator;
        for (; l.next(); ) {
          const h = l.value;
          h.isSelected || (h.isSelected = true);
        }
      }
    }
    get delay() {
      return this.Hh;
    }
    set delay(t) {
      Util.t(t, "number", DragSelectingTool2, "delay"), this.Hh = t;
    }
    get isPartialInclusion() {
      return this.pM;
    }
    set isPartialInclusion(t) {
      Util.t(t, "boolean", DragSelectingTool2, "isPartialInclusion"), this.pM = t;
    }
    get box() {
      return this.El;
    }
    set box(t) {
      t !== null && (Util.s(t, Part2, DragSelectingTool2, "box"), t.ui()), this.El = t;
    }
  }
  class PanningTool2 extends Tool2 {
    constructor(t) {
      super();
      __publicField(this, "_w");
      __publicField(this, "WC");
      __publicField(this, "Ro");
      __publicField(this, "yM");
      this.name = "Panning", this._w = new Point2(), this.WC = new Point2(), this.Ro = false;
      const i = this;
      this.yM = () => {
        const e = i.diagram;
        e !== null && e.Ti(root.document, "scroll", i.yM, false), i.stopTool();
      }, t && Object.assign(this, t);
    }
    canStart() {
      if (!this.isEnabled)
        return false;
      const t = this.diagram;
      return !(!t.allowHorizontalScroll && !t.allowVerticalScroll || !t.lastInput.left || t.currentTool !== this && !this.isBeyondDragSize());
    }
    doActivate() {
      const t = this.diagram;
      this.Ro ? (t.lastInput.bubbles = true, t.Ht(root.document, "scroll", this.yM, false)) : (t.currentCursor = "move", t.isMouseCaptured = true, this._w.c(t.position)), this.isActive = true;
    }
    doDeactivate() {
      const t = this.diagram;
      t.currentCursor = "", t.isMouseCaptured = false, this.isActive = false;
    }
    doCancel() {
      const t = this.diagram;
      t.position = this._w, t.isMouseCaptured = false, this.stopTool();
    }
    doMouseMove() {
      this.jC();
    }
    doMouseUp() {
      this.jC(), this.stopTool();
    }
    jC() {
      const t = this.diagram;
      if (this.isActive && t) {
        if (this.Ro) {
          t.lastInput.bubbles = true;
          return;
        }
        const i = t.position, e = t.firstInput.documentPoint, s = t.lastInput.documentPoint;
        let n = i.x + e.x - s.x, o = i.y + e.y - s.y;
        t.allowHorizontalScroll || (n = i.x), t.allowVerticalScroll || (o = i.y), t.position = this.WC.e(n, o);
      }
    }
    get bubbles() {
      return this.Ro;
    }
    set bubbles(t) {
      Util.t(t, "boolean", PanningTool2, "bubbles"), this.Ro = t;
    }
    get originalPosition() {
      return this._w;
    }
  }
  class HTMLInfo2 {
    constructor(t) {
      __publicField(this, "tx");
      __publicField(this, "ix");
      __publicField(this, "wM");
      __publicField(this, "xM");
      this.tx = null, this.ix = null, this.wM = null, this.xM = null, t && Object.assign(this, t);
    }
    get mainElement() {
      return this.wM;
    }
    set mainElement(t) {
      t !== null && Util.s(t, HTMLElement, HTMLInfo2, "mainElement"), this.wM = t;
    }
    get show() {
      return this.tx;
    }
    set show(t) {
      this.tx !== t && (t !== null && Util.t(t, "function", HTMLInfo2, "show"), this.tx = t);
    }
    get hide() {
      return this.ix;
    }
    set hide(t) {
      this.ix !== t && (t !== null && Util.t(t, "function", HTMLInfo2, "hide"), this.ix = t);
    }
    get valueFunction() {
      return this.xM;
    }
    set valueFunction(t) {
      this.xM = t;
    }
  }
  class ContextMenuButtonInfo {
    constructor(t, i, e) {
      __publicField(this, "di");
      __publicField(this, "Im");
      __publicField(this, "Cf");
      this.di = t, this.Im = i, this.Cf = e;
    }
  }
  const _ContextMenuTool = class _ContextMenuTool extends Tool2 {
    constructor(t) {
      super();
      __publicField(this, "bM");
      __publicField(this, "ex");
      __publicField(this, "kM");
      __publicField(this, "SM");
      __publicField(this, "sx");
      __publicField(this, "nx");
      __publicField(this, "ox");
      this.name = "ContextMenu", this.bM = null, this.ex = null, this.kM = null, this.SM = new Point2(), this.sx = null, this.ox = false;
      const i = this;
      this.nx = () => i.stopTool(), t && Object.assign(this, t);
    }
    lF() {
      const t = new HTMLInfo2();
      t.show = (r, l, h) => h.showDefaultContextMenu(), t.hide = (r, l) => l.hideDefaultContextMenu(), _ContextMenuTool.Au = t;
      const i = this;
      this.nx = () => i.stopTool();
      const e = Util.hn("div"), s = Util.hn("div");
      e.style.cssText = "top: 0px;z-index:10002;position: fixed;display: none;text-align: center;left: 25%;width: 50%;background-color: #F5F5F5;padding: 16px;border: 16px solid #444;border-radius: 10px;margin-top: 10px", s.style.cssText = "z-index:10001;position: fixed;display: none;top: 0;left: 0;width: 100%;height: 100%;background-color: black;opacity: 0.8;";
      const n = Util.hn("style");
      root.document.getElementsByTagName("head")[0].appendChild(n), n.sheet.insertRule(".goCXul { list-style: none; }", 0), n.sheet.insertRule(".goCXli {font:700 1.5em Helvetica, Arial, sans-serif;position: relative;min-width: 60px; }", 0), n.sheet.insertRule(".goCXa {color: #444;display: inline-block;padding: 4px;text-decoration: none;margin: 2px;border: 1px solid gray;border-radius: 10px; }", 0);
      const o = this.diagram;
      o !== null && (o.Ht(e, "contextmenu", _ContextMenuTool.jh, false), o.Ht(e, "selectstart", _ContextMenuTool.jh, false), o.Ht(s, "contextmenu", _ContextMenuTool.jh, false)), e.className = "goCXforeground", s.className = "goCXbackground", root.document.body && (root.document.body.appendChild(e), root.document.body.appendChild(s)), _ContextMenuTool.Om = e, _ContextMenuTool.Em = s, _ContextMenuTool.MM = true;
    }
    static jh(t) {
      return t.preventDefault(), false;
    }
    canStart() {
      if (!this.isEnabled)
        return false;
      const t = this.diagram;
      return this.isBeyondDragSize() || !t.lastInput.right || t.lastInput.clickCount > 1 ? false : !!(t.lastInput.isTouchEvent && this.defaultTouchContextMenu !== null || this.findObjectWithContextMenu() !== null);
    }
    doStart() {
      const t = this.diagram;
      this.SM.set(t.firstInput.documentPoint);
    }
    doStop() {
      this.hideContextMenu(), this.currentObject = null;
    }
    findObjectWithContextMenu(t) {
      t === void 0 && (t = null);
      const i = this.diagram, e = i.lastInput;
      let s = null;
      if (t instanceof Diagram2 || (t instanceof GraphObject2 ? s = t : s = i.findObjectAt(e.documentPoint, null, (n) => !n.layer.isTemporary)), s !== null) {
        let n = s;
        for (; n !== null; ) {
          if (n.contextMenu !== null)
            return n;
          n = n.panel;
        }
        if (i.lastInput.isTouchEvent && this.defaultTouchContextMenu)
          return s.part;
      } else if (i.contextMenu !== null)
        return i;
      return null;
    }
    doActivate() {
    }
    doMouseDown() {
      if (super.doMouseDown(), this.isActive && this.currentContextMenu instanceof Adornment2) {
        const t = this.diagram.toolManager.findTool("Action");
        t !== null && t.canStart() && (t.doActivate(), t.doMouseDown(), t.doDeactivate());
      }
      this.diagram.toolManager.mouseDownTools.contains(this) && this.doContextClick();
    }
    doMouseUp() {
      if (this.isActive && this.currentContextMenu instanceof Adornment2) {
        const t = this.diagram.toolManager.findTool("Action");
        t !== null && t.canStart() && (t.doActivate(), t.doCancel(), t.doDeactivate());
      }
      this.doContextClick();
    }
    doContextClick() {
      const t = this.diagram;
      if (!this.isActive)
        this.canStart() && (this.openMenu(true), this.isActive || this.stopTool());
      else {
        const i = this.currentContextMenu;
        if (i === null)
          return;
        let e = null;
        i instanceof HTMLInfo2 || (e = t.findObjectAt(t.lastInput.documentPoint, null, null), e !== null && e.isContainedBy(i) && this.standardMouseClick(null, null)), this.maybeStopTool(e);
      }
    }
    maybeStopTool(t) {
      this.stopTool(), this.canStart() && (this.diagram.currentTool = this, this.doMouseUp());
    }
    openMenu(t, i) {
      if (i === void 0 && (i = null), this.ox)
        return;
      this.ox = true, t && this.standardMouseSelect();
      const e = this.standardMouseClick();
      if (this.ox = false, !e) {
        this.isActive = true;
        const s = _ContextMenuTool.Au;
        if (i === null && (i = this.findObjectWithContextMenu()), i !== null) {
          const n = i.contextMenu;
          n !== null ? (this.currentObject = i instanceof GraphObject2 ? i : null, this.showContextMenu(n, this.currentObject)) : s !== null && this.showContextMenu(s, this.currentObject);
        } else
          s !== null && this.showContextMenu(s, null);
        this.currentContextMenu instanceof Adornment2 && !this.currentContextMenu.visible && this.stopTool();
      }
    }
    doMouseMove() {
      const t = this.diagram.toolManager.findTool("Action");
      t !== null && t.doMouseMove(), this.isActive && this.diagram.toolManager.doMouseMove();
    }
    showContextMenu(t, i) {
      Debug && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && Util.n("showContextMenu:contextMenu must be an Adornment or HTMLInfo."), i !== null && Util.s(i, GraphObject2, _ContextMenuTool, "showContextMenu:obj");
      const e = this.diagram;
      if (t !== this.currentContextMenu && this.hideContextMenu(), t instanceof Adornment2) {
        const s = t;
        s.layerName = "Tool", s.selectable = false, s.scale = 1 / e.scale, s.category = this.name, s.hasPlaceholder() && (s.placeholder.scale = e.scale);
        const n = s.diagram;
        n !== null && n !== e && n.remove(s), e.add(s), i !== null ? s.adornedObject = i : s.data = e.model, s.ensureBounds(), this.positionContextMenu(s, i);
      } else
        t instanceof HTMLInfo2 && t.show(i, e, this);
      this.currentContextMenu = t;
    }
    positionContextMenu(t, i) {
      if (t.hasPlaceholder())
        return;
      const e = t, s = this.diagram, n = s.lastInput.documentPoint.copy(), o = e.measuredBounds, r = s.viewportBounds;
      s.lastInput.isTouchEvent && (n.x -= o.width), n.x + o.width > r.right && (n.x -= o.width + 5 / s.scale), n.x < r.x && (n.x = r.x), n.y + o.height > r.bottom && (n.y -= o.height + 5 / s.scale), n.y < r.y && (n.y = r.y), e.position = n;
    }
    hideContextMenu() {
      const t = this.diagram, i = this.currentContextMenu;
      i !== null && (i instanceof Adornment2 ? (t.remove(i), this.ex !== null && this.ex.removeAdornment(i.category), i.data = null, i.adornedObject = null) : i instanceof HTMLInfo2 && (i.hide !== null ? i.hide(t, this) : i.mainElement !== null && (i.mainElement.style.display = "none")), this.currentContextMenu = null, this.standardMouseOver());
    }
    hF() {
      const t = this, i = new List2();
      return i.add(new ContextMenuButtonInfo("Copy", (e) => e.commandHandler.copySelection(), (e) => e.commandHandler.canCopySelection())), i.add(new ContextMenuButtonInfo("Cut", (e) => e.commandHandler.cutSelection(), (e) => e.commandHandler.canCutSelection())), i.add(new ContextMenuButtonInfo("Delete", (e) => e.commandHandler.deleteSelection(), (e) => e.commandHandler.canDeleteSelection())), i.add(new ContextMenuButtonInfo("Paste", (e) => e.commandHandler.pasteSelection(t.mouseDownPoint), (e) => e.commandHandler.canPasteSelection(t.mouseDownPoint))), i.add(new ContextMenuButtonInfo("Select All", (e) => e.commandHandler.selectAll(), (e) => e.commandHandler.canSelectAll())), i.add(new ContextMenuButtonInfo("Undo", (e) => e.commandHandler.undo(), (e) => e.commandHandler.canUndo())), i.add(new ContextMenuButtonInfo("Redo", (e) => e.commandHandler.redo(), (e) => e.commandHandler.canRedo())), i.add(new ContextMenuButtonInfo("Scroll To Part", (e) => e.commandHandler.scrollToPart(), (e) => e.commandHandler.canScrollToPart())), i.add(new ContextMenuButtonInfo("Zoom To Fit", (e) => e.commandHandler.zoomToFit(), (e) => e.commandHandler.canZoomToFit())), i.add(new ContextMenuButtonInfo("Reset Zoom", (e) => e.commandHandler.resetZoom(), (e) => e.commandHandler.canResetZoom())), i.add(new ContextMenuButtonInfo("Group Selection", (e) => e.commandHandler.groupSelection(), (e) => e.commandHandler.canGroupSelection())), i.add(new ContextMenuButtonInfo("Ungroup Selection", (e) => e.commandHandler.ungroupSelection(), (e) => e.commandHandler.canUngroupSelection())), i.add(new ContextMenuButtonInfo("Edit Text", (e) => e.commandHandler.editTextBlock(), (e) => e.commandHandler.canEditTextBlock())), i;
    }
    showDefaultContextMenu() {
      const t = this.diagram;
      this.sx === null && (this.sx = this.hF()), _ContextMenuTool.Om.innerHTML = "", _ContextMenuTool.Em.addEventListener("pointerdown", this.nx, false);
      const i = this, e = Util.hn("ul");
      e.className = "goCXul", _ContextMenuTool.Om.appendChild(e), e.innerHTML = "";
      const s = this.sx.iterator;
      for (; s.next(); ) {
        const n = s.value, o = n.Im, r = n.Cf;
        if (typeof o != "function" || typeof r == "function" && !r(t))
          continue;
        const l = Util.hn("li");
        l.className = "goCXli";
        const h = Util.hn("a");
        h.className = "goCXa", h.href = "#", h.Im = n.Im, h.addEventListener("pointerdown", function(a) {
          return this.Im(t), i.stopTool(), a.preventDefault(), false;
        }, false), h.textContent = n.di, l.appendChild(h), e.appendChild(l);
      }
      _ContextMenuTool.Om.style.display = "block", _ContextMenuTool.Em.style.display = "block";
    }
    hideDefaultContextMenu() {
      if (this.currentContextMenu === null || this.currentContextMenu !== _ContextMenuTool.Au)
        return;
      _ContextMenuTool.Om.style.display = "none", _ContextMenuTool.Em.style.display = "none";
      const t = this.diagram;
      t !== null && t.Ti(_ContextMenuTool.Em, "pointerdown", this.nx, false), this.currentContextMenu = null;
    }
    get currentContextMenu() {
      return this.bM;
    }
    set currentContextMenu(t) {
      Debug && t !== null && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && Util.n("ContextMenuTool.currentContextMenu must be an Adornment or HTMLInfo."), this.bM = t, this.ex = t instanceof Adornment2 ? t.adornedPart : null;
    }
    get defaultTouchContextMenu() {
      return _ContextMenuTool.MM === false && _ContextMenuTool.Au === null && Diagram2.isUsingDOM() && this.lF(), _ContextMenuTool.Au;
    }
    set defaultTouchContextMenu(t) {
      Debug && t !== null && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && Util.n("ContextMenuTool.defaultTouchContextMenu must be an Adornment or HTMLInfo."), t === null && (_ContextMenuTool.MM = true), _ContextMenuTool.Au = t;
    }
    get currentObject() {
      return this.kM;
    }
    set currentObject(t) {
      t !== null && Util.s(t, GraphObject2, _ContextMenuTool, "currentObject"), this.kM = t;
    }
    get mouseDownPoint() {
      return this.SM;
    }
  };
  __publicField(_ContextMenuTool, "Au", null);
  __publicField(_ContextMenuTool, "MM", false);
  __publicField(_ContextMenuTool, "Em", null);
  __publicField(_ContextMenuTool, "Om", null);
  let ContextMenuTool2 = _ContextMenuTool;
  var TextEditingAccept2 = ((w) => (w[w.LostFocus = 1] = "LostFocus", w[w.MouseDown = 2] = "MouseDown", w[w.Tab = 3] = "Tab", w[w.Enter = 4] = "Enter", w))(TextEditingAccept2 || {}), TextEditingStarting2 = ((w) => (w[w.SingleClick = 1] = "SingleClick", w[w.SingleClickSelected = 2] = "SingleClickSelected", w[w.DoubleClick = 3] = "DoubleClick", w))(TextEditingStarting2 || {}), TextEditingState2 = ((w) => (w[w.None = 1] = "None", w[w.Active = 2] = "Active", w[w.Editing = 3] = "Editing", w[w.Validating = 4] = "Validating", w[w.Invalid = 5] = "Invalid", w[w.Validated = 6] = "Validated", w))(TextEditingState2 || {});
  const _TextEditingTool = class _TextEditingTool extends Tool2 {
    constructor(t) {
      super();
      __publicField(this, "Fe");
      __publicField(this, "PM");
      __publicField(this, "NM");
      __publicField(this, "Vl");
      __publicField(this, "jt");
      __publicField(this, "CM");
      __publicField(this, "AM");
      __publicField(this, "LM");
      __publicField(this, "rx");
      __publicField(this, "lx");
      this.name = "TextEditing", this.Fe = new TextBlock2(), this.PM = null, this.NM = 2, this.Vl = null, this.jt = 1, this.CM = 1, this.AM = true, this.LM = null, this.rx = new HTMLInfo2(), this.lx = null, this.aF(this.rx), t && Object.assign(this, t);
    }
    aF(t) {
      if (!Diagram2.isUsingDOM())
        return;
      const i = Util.hn("textarea");
      this.lx = i;
      const e = this;
      i.addEventListener("input", function(s) {
        if (e.textBlock === null)
          return;
        const n = e.measureTemporaryTextBlock(this.value), o = this.textScale;
        this.style.width = 20 + Math.max(e.textBlock.measuredBounds.width, n.measuredBounds.width) * o + "px", this.rows = Math.max(e.textBlock.lineCount, n.lineCount);
      }, false), i.addEventListener("keydown", function(s) {
        if (s.isComposing || e.textBlock === null)
          return;
        const n = s.key;
        if (n === "Enter") {
          e.textBlock.isMultiline === false && s.preventDefault(), e.acceptText(4);
          return;
        } else if (n === "Tab") {
          e.acceptText(3), s.preventDefault();
          return;
        } else
          n === "Escape" && (e.doCancel(), e.diagram !== null && e.diagram.doFocus());
      }, false), i.addEventListener("focus", function(s) {
        e.fF(s);
      }, false), i.addEventListener("blur", function(s) {
        e.cF(s);
      }, false), t.valueFunction = () => i.value, t.mainElement = i, t.show = (s, n, o) => {
        if (!(s instanceof TextBlock2 && o instanceof _TextEditingTool))
          return;
        if (o.state === 5) {
          i.style.border = "3px solid red", i.focus();
          return;
        }
        const r = s.getDocumentPoint(Spot2.Center), l = n.position, h = n.scale;
        let a = s.getDocumentScale() * h;
        a < o.minimumEditorScale && (a = o.minimumEditorScale);
        const f = s.naturalBounds.width * a + 6, c = s.naturalBounds.height * a + 2, u = (r.x - l.x) * h, d = (r.y - l.y) * h, m = s.verticalAlignment, p = (s.lineHeight + s.spacingAbove + s.spacingBelow) * s.lineCount * a, y = 0.5 * c - 0.5 * p, x = m.y * c - m.y * p + m.offsetY - y - p / 2;
        i.value = s.text, n.div.style.font = s.font;
        const b = 1;
        i.style.position = "absolute", i.style.zIndex = "100", i.style.font = "inherit", i.style.fontSize = a * 100 + "%", i.style.lineHeight = "normal", i.style.width = f + "px", i.style.left = (u - f / 2 | 0) - b + "px", i.style.top = (d + x | 0) - b + "px", i.style.textAlign = s.textAlign, i.style.margin = "0", i.style.padding = b + "px", i.style.border = "0", i.style.outline = "none", i.style.whiteSpace = "pre-wrap", i.style.overflow = "hidden", i.rows = s.lineCount, i.textScale = a, i.className = "goTXarea", n.div.appendChild(i), i.focus(), o.selectsTextOnActivate && (i.select(), i.setSelectionRange(0, 9999));
      }, t.hide = (s, n) => {
        s.div.removeChild(i);
      };
    }
    get textBlock() {
      return this.PM;
    }
    set textBlock(t) {
      t !== null && Util.s(t, TextBlock2, _TextEditingTool, "textBlock"), this.PM = t;
    }
    get currentTextEditor() {
      return this.LM;
    }
    set currentTextEditor(t) {
      this.LM = t;
    }
    get defaultTextEditor() {
      return this.rx;
    }
    set defaultTextEditor(t) {
      Debug && !(t instanceof HTMLInfo2) && Util.n("TextEditingTool.defaultTextEditor must be an HTMLInfo."), this.rx = t;
    }
    get starting() {
      return this.NM;
    }
    set starting(t) {
      Util.it(t, TextEditingStarting2, "TextEditingStarting"), this.NM = t;
    }
    canStart() {
      if (!this.isEnabled)
        return false;
      const t = this.diagram;
      if (t === null || t.isReadOnly || _TextEditingTool.Af && _TextEditingTool.Af !== this && (_TextEditingTool.Af.acceptText(2), _TextEditingTool.Af && _TextEditingTool.Af !== this) || !t.lastInput.left || this.isBeyondDragSize())
        return false;
      const i = t.lastInput.documentPoint, e = t.findObjectAt(i);
      if (e === null || !(e instanceof TextBlock2) || !e.editable || !e.part.canEdit())
        return false;
      const s = e.part;
      return !(s === null || this.starting === 2 && !s.isSelected || this.starting === 3 && t.lastInput.clickCount < 2);
    }
    doStart() {
      _TextEditingTool.Af = this, this.textBlock !== null && this.doActivate();
    }
    doActivate() {
      if (this.isActive)
        return;
      const t = this.diagram;
      if (t === null)
        return;
      let i = this.textBlock;
      if (i === null && (i = t.findObjectAt(t.lastInput.documentPoint)), i === null || !(i instanceof TextBlock2) || (this.textBlock = i, i.part === null))
        return;
      t.animationManager.stopAnimation(), this.isActive = true, this.jt = 2;
      let s = this.defaultTextEditor;
      i.textEditor !== null && (s = i.textEditor), this.Fe = this.textBlock.copy();
      const n = new Rect2(this.textBlock.getDocumentPoint(Spot2.TopLeft), this.textBlock.getDocumentPoint(Spot2.BottomRight));
      t.scrollToRect(n), s.show(i, t, this), this.currentTextEditor = s;
    }
    doCancel() {
      this.stopTool();
    }
    doMouseUp() {
      this.canStart() && this.doActivate();
    }
    doMouseDown() {
      this.isActive && this.acceptText(2);
    }
    acceptText(t) {
      switch (t) {
        case 2:
          this.jt === 6 ? this.currentTextEditor instanceof HTMLElement && this.currentTextEditor.focus() : (this.jt === 2 || this.jt === 5 || this.jt === 3) && (this.jt = 4, this.JC());
          break;
        case 1:
        case 4:
        case 3:
          if (t === 4 && this.textBlock.isMultiline === true)
            return;
          (this.jt === 2 || this.jt === 5 || this.jt === 3) && (this.jt = 4, this.JC());
          break;
      }
    }
    JC() {
      const t = this.textBlock, i = this.diagram, e = this.currentTextEditor;
      if (t !== null && e !== null) {
        const s = t.text;
        let n = "";
        if (e.valueFunction !== null && (n = e.valueFunction()), !this.isValidText(t, s, n)) {
          this.jt = 5, this.doError(s, n);
          return;
        }
        this.startTransaction(this.name), this.jt = 6, this.transactionResult = this.name, t.text = n, this.doSuccess(s, n), i !== null && i.V("TextEdited", t, s), this.stopTransaction(), this.stopTool(), i !== null && i.doFocus();
      }
    }
    doError(t, i) {
      const e = this.textBlock;
      e.errorFunction !== null && e.errorFunction(this, t, i);
      const s = this.currentTextEditor;
      s && s.show(e, this.diagram, this);
    }
    doSuccess(t, i) {
      const e = this.textBlock;
      e.textEdited !== null && e.textEdited(e, t, i);
    }
    doDeactivate() {
      const t = this.diagram;
      t !== null && (this.jt = 1, this.currentTextEditor !== null && this.currentTextEditor.hide(t, this), this.textBlock = null, this.isActive = false);
    }
    doStop() {
      _TextEditingTool.Af = null;
    }
    fF(t) {
      if (this.currentTextEditor === null || this.state === 1)
        return;
      const i = this.lx;
      this.jt === 2 && (this.jt = 3), typeof i.select == "function" && this.selectsTextOnActivate && (i.select(), i.setSelectionRange(0, 9999));
    }
    cF(t) {
      if (this.currentTextEditor === null || this.state === 1)
        return;
      const i = this.lx;
      typeof i.focus == "function" && i.focus(), typeof i.select == "function" && this.selectsTextOnActivate && (i.select(), i.setSelectionRange(0, 9999));
    }
    isValidText(t, i, e) {
      Util.s(t, TextBlock2, _TextEditingTool, "isValidText:textblock");
      const s = this.textValidation;
      if (s !== null && !s(t, i, e))
        return false;
      const n = t.textValidation;
      return !(n !== null && !n(t, i, e));
    }
    get textValidation() {
      return this.Vl;
    }
    set textValidation(t) {
      t !== null && Util.t(t, "function", _TextEditingTool, "textValidation"), this.Vl = t;
    }
    get minimumEditorScale() {
      return this.CM;
    }
    set minimumEditorScale(t) {
      t !== null && Util.t(t, "number", _TextEditingTool, "minimumEditorScale"), this.CM = t;
    }
    get selectsTextOnActivate() {
      return this.AM;
    }
    set selectsTextOnActivate(t) {
      t !== null && Util.t(t, "boolean", _TextEditingTool, "selectsTextOnActivate"), this.AM = t;
    }
    get state() {
      return this.jt;
    }
    set state(t) {
      this.jt !== t && (Util.it(t, TextEditingState2, "TextEditingState"), this.jt = t);
    }
    measureTemporaryTextBlock(t) {
      const i = this.Fe;
      return i.text = t, i.wt(this.textBlock.Bl, 1 / 0), i;
    }
  };
  __publicField(_TextEditingTool, "LostFocus", 1);
  __publicField(_TextEditingTool, "MouseDown", 2);
  __publicField(_TextEditingTool, "Tab", 3);
  __publicField(_TextEditingTool, "Enter", 4);
  __publicField(_TextEditingTool, "SingleClick", 1);
  __publicField(_TextEditingTool, "SingleClickSelected", 2);
  __publicField(_TextEditingTool, "DoubleClick", 3);
  __publicField(_TextEditingTool, "StateNone", 1);
  __publicField(_TextEditingTool, "StateActive", 2);
  __publicField(_TextEditingTool, "StateEditing", 3);
  __publicField(_TextEditingTool, "StateValidating", 4);
  __publicField(_TextEditingTool, "StateInvalid", 5);
  __publicField(_TextEditingTool, "StateValidated", 6);
  __publicField(_TextEditingTool, "Af", null);
  let TextEditingTool2 = _TextEditingTool;
  var AnimationStyle2 = ((w) => (w[w.Default = 1] = "Default", w[w.AnimateLocations = 2] = "AnimateLocations", w[w.None = 3] = "None", w))(AnimationStyle2 || {});
  const _AnimationManager = class _AnimationManager {
    constructor(t) {
      __publicField(this, "b");
      __publicField(this, "Di");
      __publicField(this, "Xi");
      __publicField(this, "Lr");
      __publicField(this, "$n");
      __publicField(this, "Eo");
      __publicField(this, "TM");
      __publicField(this, "DM");
      __publicField(this, "Vm");
      __publicField(this, "Mi");
      __publicField(this, "Lf");
      __publicField(this, "xn");
      __publicField(this, "Bm");
      __publicField(this, "Jh");
      __publicField(this, "hx");
      __publicField(this, "zm");
      __publicField(this, "ax");
      __publicField(this, "Tf");
      __publicField(this, "Nu");
      __publicField(this, "Xm");
      this.b = Diagram2.Pm(), this.Di = false, this.Vm = false, this.Mi = false, this.Lf = false, this.ax = true, this.Tf = 1, this.Nu = false, this.Xi = true, this.Lr = true, this.Eo = 600, this.TM = false, this.DM = false, this.$n = new GSet2(), this.xn = new Animation2(), this.Bm = new Animation2(), this.xn.bs = this, this.Jh = new GSet2(), this.hx = new GSet2(), this.zm = new GSet2(), this.Xm = new GSet2(), t && Object.assign(this, t);
    }
    Vo(t) {
      this.b = t;
    }
    lE() {
      return this.b;
    }
    canStart(t) {
      return true;
    }
    zl(t) {
      return !this.Xi || !this.canStart(t) ? false : (this.$n.add(t), this.defaultAnimation.isAnimating && this.stopAnimation(), this.b.Fi(), this.Mi = true, true);
    }
    getBundleAnimation() {
      return this.Bm;
    }
    FM() {
      if (!this.Xi || (this.Bm.we.count > 0 && this.Bm.start(), !this.Mi))
        return;
      const t = this.xn, i = this.b, e = this.$n.contains("Model");
      if (e && (this.Lf = true, this.Tf === 1 ? (t.isViewportUnconstrained = true, t.we.clear(), t.add(i, "position", i.position.copy().offset(0, -200), i.position), t.add(i, "opacity", 0, 1)) : this.Tf === 3 && t.we.clear(), this.Tf === 2 && i.fx.equals(i.lt) ? this.ax = true : this.ax = false, i.V("InitialAnimationStarting", this)), e && !this.Lr || t.we.count === 0) {
        this.$n.clear(), this.Mi = false, t.we.clear(), t.cx(i), this.Lf = false, i.T();
        return;
      }
      this.$n.clear(), i.Tr = false;
      const s = t.we.get(i);
      i.autoScale !== 1 && s !== null && (delete s.li.scale, delete s.ks.scale);
      const n = this;
      root.requestAnimationFrame(() => {
        n.Mi === false || t.Di || (i.getRenderingHint("temporaryPixelRatio") && i.vw(), i.RM(), n.Mi = false, t.start(), t.Di && (n.Lu(), i.invalidateDocumentBounds(), t.ZC(0), i.Pr(true), n.Tu(), i.V("AnimationStarting", n)));
      });
    }
    IM() {
      return this.$n.contains("Trigger") && this.$n.count === 1;
    }
    $C(t, i, e, s) {
      this.isTicking || this.IM() || t instanceof Link2 && (t.fromNode !== null || t.toNode !== null) || this.xn.add(t, "position", i, e, s);
    }
    ux(t) {
      return this.xn.ux(t);
    }
    OM(t) {
      return this.xn.OM(t);
    }
    uF(t) {
      const i = this.Jh, e = this;
      function s() {
        if (e.zm.count > 0 && (i.addAll(e.zm), e.zm.clear(), e.Di = true), e.Di === false || i.count === 0)
          return;
        e.hx.addAll(i);
        const n = e.hx.iterator;
        for (; n.next(); ) {
          const o = n.value;
          o.Di !== false && (o.dF() ? o.QC(false) : o.Df = true);
        }
        if (e.hx.clear(), e.Di === false) {
          root.requestAnimationFrame(s);
          return;
        }
        e.Lu(), e.b.Pr(), e.Tu(), root.requestAnimationFrame(s);
      }
      this.Di ? this.gF(t) : (this.Di = true, i.add(t), root.requestAnimationFrame(() => s()));
    }
    gF(t) {
      this.zm.add(t);
    }
    mF() {
      const t = this.Jh.iterator;
      for (; t.next(); )
        t.value.Df = false;
    }
    Lu() {
      if (this.Vm)
        return;
      const t = this.b;
      this.TM = t.skipsUndoManager, this.DM = t.xe, t.skipsUndoManager = true, t.xe = true, this.Vm = true;
    }
    Tu() {
      const t = this.b;
      t.skipsUndoManager = this.TM, t.xe = this.DM, this.Vm = false;
    }
    stopAnimation(t) {
      const i = this.xn;
      if (this.Mi === true && (this.Mi = false, this.Lf = false, this.$n.clear(), i.pF() && this.b.requestUpdate()), !this.Di) {
        i.we.clear(), i.cx(this.b);
        return;
      }
      if (i.Du(true), i.cx(null), t === true) {
        const e = this.Jh.toArray();
        for (let s = 0; s < e.length; s++)
          e[s].Du(true);
      }
    }
    Du(t) {
      this.Jh.remove(t), this.Jh.count === 0 && (this.Di = false, this.b.requestUpdate()), t === this.defaultAnimation && this.b.V("AnimationFinished", this);
    }
    Ff(t, i) {
      this.Mi && (!this.$n.contains("Expand Tree") && !this.$n.contains("Expand SubGraph") || (this.xn.Ff(t, i), this._C(t)));
    }
    Rf(t, i) {
      this.Mi && (!this.$n.contains("Collapse Tree") && !this.$n.contains("Collapse SubGraph") || (this.xn.Rf(t, i), this.xn.EM(i, "position", i.position, i.position), this._C(t)));
    }
    tA(t, i) {
      !this.Mi || t.equals(i) || this.IM() || (this.b.Uh || (t = i.copy()), this.xn.EM(this.b, "position", t, i));
    }
    iA(t, i) {
      this.Mi && (this.IM() || this.xn.add(this.b, "scale", t, i));
    }
    VM(t, i) {
      t.Re && (t.Dr = i, this.Xm.add(t));
    }
    _C(t) {
      const i = t.findLinksConnected();
      for (; i.next(); ) {
        const e = i.value;
        e.Re && (e.Dr = e.points.copy(), this.Xm.add(e));
      }
    }
    get isEnabled() {
      return this.Xi;
    }
    set isEnabled(t) {
      Util.t(t, "boolean", _AnimationManager, "isEnabled"), this.Xi = t, t && this.Jh.each((i) => {
        !i.isAnimating && i.runCount === 1 / 0 && i.start();
      });
    }
    get duration() {
      return this.Eo;
    }
    set duration(t) {
      Util.t(t, "number", _AnimationManager, "duration"), t < 1 && Util.G(t, ">= 1", _AnimationManager, "duration"), this.Eo = t;
    }
    get isAnimating() {
      return this.Di;
    }
    get isTicking() {
      return this.Vm;
    }
    get isInitial() {
      return this.Lr;
    }
    set isInitial(t) {
      Util.t(t, "boolean", _AnimationManager, "isInitial"), this.Lr = t;
    }
    get defaultAnimation() {
      return this.xn;
    }
    get activeAnimations() {
      return this.Jh;
    }
    get initialAnimationStyle() {
      return this.Tf;
    }
    set initialAnimationStyle(t) {
      Debug && Util.it(t, AnimationStyle2, "AnimationStyle"), this.Tf = t;
    }
    static defineAnimationEffect(t, i) {
      _AnimationManager.gx.add(t, i);
    }
    static BM(t, i, e, s, n) {
      t === null && (t = [0, 0, 0, 0]), i === null && (i = [0, 0, 0, 0]);
      let o = t[0], r = t[1];
      const l = t[2], h = t[3];
      let a = i[0], f = i[1];
      const c = i[2], u = i[3];
      l === 0 || l === 100 ? (o = a, r = f) : (c === 0 || c === 100) && (a = o, f = r), Math.abs(a - o) > 180 && (a > o ? o += 360 : a += 360);
      const d = n(e, o, a - o, s) % 360, m = n(e, r, f - r, s), g = n(e, l, c - l, s), p = n(e, h, u - h, s);
      return "hsla(" + d + ", " + m + "%, " + g + "%, " + p + ")";
    }
  };
  __publicField(_AnimationManager, "gx", new GMap2());
  (() => {
    const t = _AnimationManager.gx, i = (e, s, n, o, r, l) => {
      e.position = new Point2(o(r, s.x, n.x - s.x, l), o(r, s.y, n.y - s.y, l));
    };
    t.add("position:diagram", i), t.add("position", i), t.add("position:part", (e, s, n, o, r, l) => {
      r < l ? e.Nf(o(r, s.x, n.x - s.x, l), o(r, s.y, n.y - s.y, l), false) : e.position = new Point2(o(r, s.x, n.x - s.x, l), o(r, s.y, n.y - s.y, l));
    }), t.add("location", (e, s, n, o, r, l) => {
      r < l ? e.Nf(o(r, s.x, n.x - s.x, l), o(r, s.y, n.y - s.y, l), true) : e.location = new Point2(o(r, s.x, n.x - s.x, l), o(r, s.y, n.y - s.y, l));
    }), t.add("position:placeholder", (e, s, n, o, r, l) => {
      r < l ? e.Nf(o(r, s.x, n.x - s.x, l), o(r, s.y, n.y - s.y, l), false) : e.position = new Point2(o(r, s.x, n.x - s.x, l), o(r, s.y, n.y - s.y, l));
    }), t.add("position:nodeCollapse", (e, s, n, o, r, l) => {
      const h = e.actualBounds, a = n.actualBounds, f = a.x + a.width / 2 - h.width / 2, c = a.y + a.height / 2 - h.height / 2;
      r < l ? e.Nf(o(r, s.x, f - s.x, l), o(r, s.y, c - s.y, l), false) : e.position = new Point2(o(r, s.x, f - s.x, l), o(r, s.y, c - s.y, l));
    }), t.add("desiredSize", (e, s, n, o, r, l) => {
      e.desiredSize = new Rect2(o(r, s.width, n.width - s.width, l), o(r, s.height, n.height - s.height, l));
    }), t.add("width", (e, s, n, o, r, l) => {
      e.width = o(r, s, n - s, l);
    }), t.add("height", (e, s, n, o, r, l) => {
      e.height = o(r, s, n - s, l);
    }), t.add("fill", (e, s, n, o, r, l) => {
      e.fill = _AnimationManager.BM(s, n, r, l, o);
    }), t.add("stroke", (e, s, n, o, r, l) => {
      e.stroke = _AnimationManager.BM(s, n, r, l, o);
    }), t.add("strokeWidth", (e, s, n, o, r, l) => {
      e.strokeWidth = o(r, s, n - s, l);
    }), t.add("strokeDashOffset", (e, s, n, o, r, l) => {
      e.strokeDashOffset = o(r, s, n - s, l);
    }), t.add("background", (e, s, n, o, r, l) => {
      e.background = _AnimationManager.BM(s, n, r, l, o);
    }), t.add("opacity", (e, s, n, o, r, l) => {
      e.opacity = o(r, s, n - s, l);
    }), t.add("scale", (e, s, n, o, r, l) => {
      e.scale = o(r, s, n - s, l);
    }), t.add("angle", (e, s, n, o, r, l) => {
      e.angle = o(r, s, n - s, l);
    });
  })();
  __publicField(_AnimationManager, "Default", 1);
  __publicField(_AnimationManager, "AnimateLocations", 2);
  __publicField(_AnimationManager, "None", 3);
  let AnimationManager2 = _AnimationManager;
  const _Animation = class _Animation {
    constructor(t) {
      __publicField(this, "mx");
      __publicField(this, "Ym");
      __publicField(this, "Di");
      __publicField(this, "Fu");
      __publicField(this, "Eo");
      __publicField(this, "Ss");
      __publicField(this, "eA");
      __publicField(this, "If");
      __publicField(this, "we");
      __publicField(this, "px");
      __publicField(this, "li");
      __publicField(this, "Qn");
      __publicField(this, "Ru");
      __publicField(this, "Of");
      __publicField(this, "yx");
      __publicField(this, "wx");
      __publicField(this, "Df");
      __publicField(this, "zM");
      __publicField(this, "xx");
      __publicField(this, "bs");
      __publicField(this, "b");
      __publicField(this, "XM");
      __publicField(this, "YM");
      __publicField(this, "KM");
      this.b = null, this.bs = null, this.zM = null, this.xx = null, this.XM = false, this.Di = false, this.Df = false, this.li = 0, this.Qn = 0, this.mx = _Animation.EaseInOutQuad, this.Ym = _Animation.EaseInOutQuad, this.Ru = false, this.Of = false, this.yx = 1, this.wx = 0, this.Eo = NaN, this.Ss = NaN, this.YM = 0, this.Fu = null, this.eA = Point2.To, this.we = new GMap2(), this.px = new GMap2(), this.If = new GSet2(), this.KM = 1, t && Object.assign(this, t);
    }
    suspend() {
      this.Df = true;
    }
    advanceTo(t, i) {
      i && (this.Df = false), this.Ru && t >= this.Ss && (this.Of = true, t = t - this.Ss), this.YM = t, this.QC(true), this.bs.Lu(), this.b.Pr(), this.bs.Tu(), this.b.redraw();
    }
    cx(t) {
      if (this.px.clear(), this.Of = false, this.wx = 0, this.Ss = NaN, this.If.count > 0 && this.If.clear(), t !== null) {
        const i = t.links;
        for (; i.next(); )
          i.value.Dr = null;
      }
    }
    pF() {
      return this.we.count > 0;
    }
    start() {
      if (this.we.count === 0)
        return this;
      if (this.Di)
        return this;
      let t = this.b;
      const i = this.we.iterator;
      for (; i.next(); ) {
        const s = i.key;
        t === null && (s instanceof Diagram2 ? t = s : s instanceof GraphObject2 && (t = s.diagram));
      }
      if (t !== null)
        this.b = t, this.bs = t.animationManager;
      else
        return this;
      const e = this.bs;
      return e.isEnabled === false ? this : (this.Ss = isNaN(this.Eo) ? e.duration : this.Eo, this.Ym = this.mx, e.Lf && e.Tf === 1 && this === e.defaultAnimation && (this.Ym = _Animation.EaseOutExpo, this.Ss = isNaN(this.Eo) ? e.duration === 600 ? 900 : e.duration : this.Eo), this.KM = t.scrollMode, this.isViewportUnconstrained && (t.Zh = 2), e.Lu(), this.If.each((s) => {
        s.data = null, t.add(s);
      }), e.Tu(), this.Di = true, this.li = +/* @__PURE__ */ new Date(), this.Qn = this.li + this.Ss, e.uF(this), this);
    }
    addTemporaryPart(t, i) {
      return t.De() ? (Debug && (i === void 0 && Util.n("addTemporaryPart: Required Diagram argument missing"), t.diagram === i && Util.n("addTemporaryPart: Part already in Diagram, did you mean to pass in a copy?"), this.b !== null && this.b !== i && Util.n("addTemporaryPart: A different Diagram is already associated with this Animation: " + this.b.toString())), this.If.add(t), this.b = i, this) : this;
    }
    add(t, i, e, s, n) {
      if (this.b === null && (t instanceof Diagram2 ? this.b = t : t instanceof GraphObject2 && t.diagram !== null && (this.b = t.diagram)), t instanceof Part2) {
        if (!t.isAnimated)
          return this;
        i === "position" && (i = "position:part");
      }
      return this.EM(t, i, e, s, n), this;
    }
    EM(t, i, e, s, n) {
      const o = this.we;
      let r, l, h;
      if (t instanceof Diagram2 && i === "position" && (i = "position:diagram"), (i === "fill" || i === "stroke" || i === "background") && (Brush2.Bo(e), Brush2.UM(), e = [Brush2.Yi.n0, Brush2.Yi.n1, Brush2.Yi.n2, Brush2.Yi.n3], Brush2.Bo(s), Brush2.UM(), s = [Brush2.Yi.n0, Brush2.Yi.n1, Brush2.Yi.n2, Brush2.Yi.n3]), o.contains(t))
        r = o.getValue(t), l = r.li, h = r.ks, l[i] === void 0 && (l[i] = this.Iu(e)), h[i] = this.Iu(s);
      else {
        if (i === "position" && e.equalsApprox(s))
          return;
        l = {}, h = {}, l[i] = this.Iu(e), h[i] = this.Iu(s), r = new AnimationState(l, h, n), o.add(t, r);
      }
      const a = l[i];
      a instanceof Point2 && !a.isReal() && a.c(this.eA), n && i.indexOf("position:") === 0 && t instanceof Part2 ? r.bx.location = this.Iu(t.location) : n && (r.bx[i] = this.Iu(e));
    }
    Iu(t) {
      return t instanceof Point2 || t instanceof Size2 ? t.copy() : t;
    }
    yF(t) {
      const i = this.we;
      if (i.contains(t)) {
        const e = i.getValue(t);
        e.kx = true;
      }
    }
    ux(t) {
      if (!this.Di)
        return false;
      const i = this.we.getValue(t);
      return i !== null && i.kx;
    }
    OM(t) {
      if (!this.Di)
        return false;
      const i = this.we.getValue(t);
      return i !== null && !!(i.li.position || i.li["position:part"] || i.li.location);
    }
    dF() {
      if (this.If.count > 0)
        return true;
      const t = this.we.iterator;
      for (; t.next(); ) {
        const i = t.key;
        if (i instanceof GraphObject2 && i.diagram !== null || i instanceof Diagram2)
          return true;
      }
      return false;
    }
    QC(t) {
      if (this.Df && !t)
        return;
      const i = this.bs;
      if (this.Di === false)
        return;
      const e = +/* @__PURE__ */ new Date();
      let s = e > this.Qn ? this.Ss : e - this.li;
      t && (s = this.YM, s < this.Ss ? (this.li = +/* @__PURE__ */ new Date() - s, this.Qn = this.li + this.Ss) : s = this.Ss), i.Lu(), this.ZC(s), this.b.Pr(true), i.Tu(), e > this.Qn && (this.Ru && !this.Of ? (this.li = +/* @__PURE__ */ new Date(), this.Qn = this.li + this.Ss, this.Of = true) : this.Du(false));
    }
    ZC(t) {
      const i = this.Ss, e = this.we.iterator, s = this.Of;
      for (; e.next(); ) {
        const n = e.key;
        if (n instanceof GraphObject2 && n.diagram === null)
          continue;
        const o = e.value, r = s ? o.ks : o.li, l = s ? o.li : o.ks, h = AnimationManager2.gx;
        for (const a in l)
          a === "position" && (l["position:placeholder"] || l["position:nodeCollapse"]) || h.get(a) !== null && h.get(a)(n, r[a], l[a], this.Ym, t, i, this);
      }
    }
    stop() {
      return this.Di ? (this.Du(true), this) : this;
    }
    Du(t) {
      if (this.xx !== null && this.xx.wF(this.zM), !this.Di)
        return;
      const i = this.b, e = this.bs;
      e.Lf = false, this.Di = false, this.Df = false, e.Lu();
      const s = this.we, n = this.If.iterator;
      for (; n.next(); )
        i.remove(n.value);
      const o = this.Ru, r = s.iterator, l = AnimationManager2.gx;
      for (; r.next(); ) {
        const a = r.key, f = r.value, c = o ? f.ks : f.li, u = o ? f.li : f.ks, d = f.bx;
        for (const m in u)
          if (l.get(m) !== null) {
            let g = m;
            f.Sx && (g === "position:nodeCollapse" || g === "position:placeholder") && (g = "position"), l.get(g)(a, c[m], d[m] !== void 0 ? d[m] : f.Sx ? c[m] : u[m], this.Ym, this.Ss, this.Ss, this);
          }
        f.Sx && d.location !== void 0 && a instanceof Part2 && (a.location = d.location), f.kx && a instanceof Part2 && a.Ki(false);
      }
      this.wx++;
      const h = !t && this.yx > this.wx;
      if (!h && (this === e.Bm || this === e.defaultAnimation) && this.we.clear(), i.Mx.clear(), i.NS(false), i.invalidateDocumentBounds(), i.T(), i.Pr(true), e.defaultAnimation === this) {
        const a = e.Xm.iterator;
        for (; a.next(); )
          a.value.xF();
        e.Xm.clear();
      }
      if (i.Pr(true), this.isViewportUnconstrained && (i.scrollMode = this.KM), e.Tu(), h) {
        this.Of = false, this.start();
        return;
      }
      this.cx(null), e.Du(this), this.Fu && this.Fu(this), i.requestUpdate();
    }
    Ff(t, i) {
      const e = i.actualBounds;
      let s = null;
      if (i instanceof Group2 && (s = i.placeholder), s !== null && s.visible) {
        const n = s.getDocumentPoint(Spot2.TopLeft), o = s.padding;
        n.x += o.left, n.y += o.top, this.add(t, "position", n, t.position, false);
      } else
        this.add(t, "position", new Point2(e.x + e.width / 2, e.y + e.height / 2), t.position, false);
      this.add(t, "scale", 0.01, t.scale, false), t instanceof Group2 && this.bF(t, i);
    }
    bF(t, i) {
      const e = t.memberParts;
      for (; e.next(); ) {
        const s = e.value;
        s instanceof Node2 && this.Ff(s, i);
      }
    }
    Rf(t, i) {
      if (!t.isVisible())
        return;
      let e = null;
      if (i instanceof Group2 && (e = i.placeholder), e !== null && e.visible) {
        const s = e.getDocumentPoint(Spot2.TopLeft), n = e.padding;
        s.x += n.left, s.y += n.top, this.add(t, "position:placeholder", t.position, s, true);
      } else
        this.add(t, "position:nodeCollapse", t.position, i, true);
      this.add(t, "scale", t.scale, 0.01, true), this.yF(t), t instanceof Group2 && this.kF(t, i);
    }
    kF(t, i) {
      const e = t.memberParts;
      for (; e.next(); ) {
        const s = e.value;
        s instanceof Node2 && this.Rf(s, i);
      }
    }
    get duration() {
      return this.Eo;
    }
    set duration(t) {
      Util.t(t, "number", _Animation, "duration"), t < 1 && Util.G(t, ">= 1", _Animation, "duration"), this.Eo = t;
    }
    get reversible() {
      return this.Ru;
    }
    set reversible(t) {
      this.Ru = t;
    }
    get runCount() {
      return this.yx;
    }
    set runCount(t) {
      t > 0 ? this.yx = t : Util.n("Animation.runCount value must be a positive integer.");
    }
    get finished() {
      return this.Fu;
    }
    set finished(t) {
      this.Fu !== t && (t !== null && Util.t(t, "function", _Animation, "finished"), this.Fu = t);
    }
    get easing() {
      return this.mx;
    }
    set easing(t) {
      this.mx = t;
    }
    get isViewportUnconstrained() {
      return this.XM;
    }
    set isViewportUnconstrained(t) {
      this.XM = t;
    }
    get isAnimating() {
      return this.Di;
    }
    getTemporaryState(t) {
      let i = this.px.get(t);
      return i === null && (i = {}, this.px.add(t, i)), i;
    }
  };
  __publicField(_Animation, "EaseLinear", (t, i, e, s) => e * t / s + i);
  __publicField(_Animation, "EaseInOutQuad", (t, i, e, s) => (t /= s / 2, t < 1 ? e / 2 * t * t + i : -e / 2 * (--t * (t - 2) - 1) + i));
  __publicField(_Animation, "EaseInQuad", (t, i, e, s) => e * (t /= s) * t + i);
  __publicField(_Animation, "EaseOutQuad", (t, i, e, s) => -e * (t /= s) * (t - 2) + i);
  __publicField(_Animation, "EaseInExpo", (t, i, e, s) => t === 0 ? i : e * Math.pow(2, 10 * (t / s - 1)) + i);
  __publicField(_Animation, "EaseOutExpo", (t, i, e, s) => t === s ? i + e : e * (-Math.pow(2, -10 * t / s) + 1) + i);
  let Animation2 = _Animation;
  class AnimationState {
    constructor(t, i, e) {
      __publicField(this, "li");
      __publicField(this, "ks");
      __publicField(this, "bx");
      __publicField(this, "Sx");
      __publicField(this, "kx");
      this.li = t, this.ks = i, this.bx = {}, this.Sx = e, this.kx = false;
    }
  }
  var TriggerStart2 = ((w) => (w[w.Default = 1] = "Default", w[w.Immediate = 2] = "Immediate", w[w.Bundled = 3] = "Bundled", w))(TriggerStart2 || {});
  const _AnimationTrigger = class _AnimationTrigger {
    constructor(t, i, e) {
      __publicField(this, "Te");
      __publicField(this, "mn");
      __publicField(this, "Ou");
      __publicField(this, "Ef");
      e && Debug && Util.it(e, TriggerStart2, "TriggerStart"), this.Te = null, this.mn = t, this.Ou = e || 1, this.Ef = null, i !== void 0 && (this.Ef = i, e === void 0 && (this.Ou = 2));
    }
    copy() {
      const t = new _AnimationTrigger(this.mn);
      t.Ou = this.Ou;
      const i = this.Ef;
      if (i !== null) {
        const e = {};
        i.duration !== void 0 && (e.duration = i.duration), i.finished !== void 0 && (e.finished = i.finished), i.easing !== void 0 && (e.easing = i.easing), t.Ef = e;
      }
      return t;
    }
    get propertyName() {
      return this.mn;
    }
    set propertyName(t) {
      this.mn = t;
    }
    get animationSettings() {
      return this.Ef;
    }
    set animationSettings(t) {
      this.Ef = t;
    }
    SF(t) {
      const i = this.Ef;
      i !== null && (i.duration && (t.duration = i.duration), i.finished && (t.finished = i.finished), i.easing && (t.easing = i.easing));
    }
    get startCondition() {
      return this.Ou;
    }
    set startCondition(t) {
      Debug && Util.it(t, TriggerStart2, "TriggerStart"), this.Ou = t;
    }
  };
  __publicField(_AnimationTrigger, "Default", 1);
  __publicField(_AnimationTrigger, "Immediate", 2);
  __publicField(_AnimationTrigger, "Bundled", 3);
  let AnimationTrigger2 = _AnimationTrigger;
  class Layer2 {
    constructor(t) {
      __publicField(this, "b");
      __publicField(this, "Tt");
      __publicField(this, "_t");
      __publicField(this, "Fr");
      __publicField(this, "Xl");
      __publicField(this, "Yl");
      __publicField(this, "Kl");
      __publicField(this, "Ul");
      __publicField(this, "Gl");
      __publicField(this, "Hl");
      __publicField(this, "vl");
      __publicField(this, "ql");
      __publicField(this, "Wl");
      __publicField(this, "jl");
      __publicField(this, "Jl");
      __publicField(this, "Zl");
      __publicField(this, "Cf");
      __publicField(this, "$l");
      __publicField(this, "Px");
      __publicField(this, "Km");
      __publicField(this, "Eu");
      __publicField(this, "It");
      GSet2.ji(this), this.b = null, this.It = new List2(), this.Tt = "", this._t = 1, this.Fr = false, this.Xl = true, this.Yl = true, this.Kl = true, this.Ul = true, this.Gl = true, this.Hl = true, this.vl = true, this.ql = true, this.Wl = true, this.jl = true, this.Jl = true, this.Zl = true, this.Cf = true, this.$l = true, this.Px = true, this.Km = false, this.Eu = [], t && Object.assign(this, t);
    }
    MF() {
      const t = this.It;
      for (let i = 0; i < t.length; i++)
        t.h[i].GM(null);
      t.clear(), this.Eu.length = 0;
    }
    Vo(t) {
      this.b = t;
    }
    toString(t) {
      t === void 0 && (t = 0);
      const i = 'Layer "' + this.name + '"';
      if (t <= 0)
        return i;
      let e = 0, s = 0, n = 0, o = 0, r = 0;
      const l = this.It.iterator;
      for (; l.next(); ) {
        const a = l.value;
        a instanceof Group2 ? n++ : a instanceof Node2 ? s++ : a instanceof Link2 ? o++ : a instanceof Adornment2 ? r++ : e++;
      }
      let h = "";
      if (e > 0 && (h += e + " Parts "), s > 0 && (h += s + " Nodes "), n > 0 && (h += n + " Groups "), o > 0 && (h += o + " Links "), r > 0 && (h += r + " Adornments "), t > 1) {
        const a = this.It.iterator;
        for (; a.next(); ) {
          const f = a.value;
          h += `
    ` + f.toString();
          const c = f.data;
          c !== null && GSet2.ps(c) && (h += " #" + GSet2.ps(c)), f instanceof Node2 ? h += " " + Util.toString(c) : f instanceof Link2 && (h += " " + Util.toString(f.fromNode) + " " + Util.toString(f.toNode));
        }
      }
      return i + " " + this.It.count + ": " + h;
    }
    findObjectAt(t, i, e) {
      if (i === void 0 && (i = null), e === void 0 && (e = null), this.$l === false)
        return null;
      Debug && !t.isReal() && Util.n("findObjectAt: Point must have a real value, not: " + t.toString());
      let s = false;
      this.diagram !== null && this.diagram.viewportBounds.containsPoint(t) && (s = true);
      const n = Point2.a(), o = this.It.h, r = o.length;
      for (let l = r; l--; ) {
        const h = o[l];
        if (s === true && h.Rl() === false || !h.isVisible())
          continue;
        n.c(t), n.Ge(h.Ms);
        let a = h.sA(n, i, e);
        if (a !== null && (i !== null && (a = i(a)), a !== null && (e === null || e(a))))
          return Point2.o(n), a;
      }
      return Point2.o(n), null;
    }
    findObjectsAt(t, i, e, s) {
      if (i === void 0 && (i = null), e === void 0 && (e = null), !(s instanceof List2) && !(s instanceof GSet2) && (s = new GSet2()), this.$l === false)
        return s;
      Debug && !t.isReal() && Util.n("findObjectsAt: Point must have a real value, not: " + t.toString());
      let n = false;
      this.diagram !== null && this.diagram.viewportBounds.containsPoint(t) && (n = true);
      const o = Point2.a(), r = this.It.h, l = r.length;
      for (let h = l; h--; ) {
        const a = r[h];
        if (n === true && a.Rl() === false || !a.isVisible())
          continue;
        o.c(t), o.Ge(a.Ms);
        let f = a;
        a.nA(o, i, e, s) && (i !== null && (f = i(f)), f !== null && (e === null || e(f)) && s.add(f));
      }
      return Point2.o(o), s;
    }
    findObjectsIn(t, i, e, s, n) {
      if (i === void 0 && (i = null), e === void 0 && (e = null), s === void 0 && (s = false), !(n instanceof List2) && !(n instanceof GSet2) && (n = new GSet2()), this.$l === false)
        return n;
      Debug && !t.isReal() && Util.n("findObjectsIn: Rect must have a real value, not: " + t.toString());
      let o = false;
      this.diagram !== null && this.diagram.viewportBounds.containsRect(t) && (o = true);
      const r = this.It.h, l = r.length;
      for (let h = l; h--; ) {
        const a = r[h];
        if (o === true && a.Rl() === false || !a.isVisible())
          continue;
        let f = a;
        a.Um(t, i, e, s, n) && (i !== null && (f = i(f)), f !== null && (e === null || e(f)) && n.add(f));
      }
      return n;
    }
    IS(t, i, e, s, n, o, r) {
      if (this.$l === false)
        return n;
      const l = this.It.h, h = l.length;
      for (let a = h; a--; ) {
        const f = l[a];
        if (r === true && f.Rl() === false || !o(f) || !f.isVisible())
          continue;
        let c = f;
        f.Um(t, i, e, s, n) && (i !== null && (c = i(c)), c !== null && (e === null || e(c)) && n.add(c));
      }
      return n;
    }
    findObjectsNear(t, i, e, s, n, o) {
      if (e === void 0 && (e = null), s === void 0 && (s = null), n === void 0 && (n = true), n !== false && n !== true && ((n instanceof List2 || n instanceof GSet2) && (o = n), n = true), !(o instanceof List2) && !(o instanceof GSet2) && (o = new GSet2()), this.$l === false)
        return o;
      Debug && !t.isReal() && Util.n("findObjectsNear: Point must have a real value, not: " + t.toString());
      let r = false;
      this.diagram !== null && this.diagram.viewportBounds.containsPoint(t) && (r = true);
      const l = Point2.a(), h = Point2.a(), a = this.It.h, f = a.length;
      for (let c = f; c--; ) {
        const u = a[c];
        if (r === true && u.Rl() === false || !u.isVisible())
          continue;
        l.c(t), l.Ge(u.Ms), h.e(t.x + i, t.y), h.Ge(u.Ms);
        let d = u;
        u.oA(l, h, e, s, n, o) && (e !== null && (d = e(d)), d !== null && (s === null || s(d)) && o.add(d));
      }
      return Point2.o(l), Point2.o(h), o;
    }
    HM() {
      return this.It.h;
    }
    Gs(t, i) {
      if (!this.visible)
        return;
      const e = this.It.h, s = e.length;
      if (s === 0)
        return;
      const n = Util.ct(), o = Util.ct();
      for (let r = 0; r < s; r++) {
        const l = e[r];
        if (l.vM = r, l instanceof Link2) {
          if (l.Re === false)
            continue;
        } else if (l instanceof Adornment2 && l.adornedPart !== null)
          continue;
        const h = l.actualBounds;
        l.isVisible() && h.intersectsRectPlus(i, 10) ? (l.Gs(true), n.push(l)) : (l.Gs(false), l.adornments !== null && l.adornments.count > 0 && o.push(l));
      }
      for (let r = 0; r < n.length; r++) {
        const l = n[r];
        l.qM();
        const h = l.adornments;
        for (; h.next(); ) {
          const a = h.value;
          a.wt(1 / 0, 1 / 0), a.vt(), a.Gs(true);
        }
      }
      for (let r = 0; r < o.length; r++)
        o[r].qM();
      Util.ot(n), Util.ot(o);
    }
    Vu(t) {
      let i = 1;
      return this._t !== 1 && (i = t.globalAlpha, t.globalAlpha = i * this._t), i;
    }
    rA(t, i) {
      for (let e = 0; e < i; e++)
        t[e].Bu();
    }
    Ji(t, i, e) {
      if (!this.visible || this._t === 0 || (e === void 0 && (e = true), !e && this.isTemporary))
        return;
      const s = this.It.h, n = s.length;
      if (n === 0)
        return;
      t.Fr && this.rA(s, n);
      const o = this.Vu(t), r = this.Eu;
      r.length = 0;
      const l = i.scale, h = Rect2.a();
      for (let a = 0; a < n; a++) {
        const f = s[a];
        this.Gm(t, f, i, r, l, h, true);
      }
      Rect2.o(h), t.Fr && this.rA(s, n), t.globalAlpha = o;
    }
    hE(t, i, e) {
      if (!this.visible || this._t === 0)
        return;
      const s = this.It.h, n = s.length;
      if (n === 0)
        return;
      const o = this.Vu(t), r = this.Eu;
      r.length = 0;
      const l = i.scale, h = Rect2.a();
      for (let a = 0; a < n; a++) {
        const f = s[a];
        e.contains(f) || this.Gm(t, f, i, r, l, h, true);
      }
      Rect2.o(h), t.globalAlpha = o;
    }
    PF(t, i, e, s) {
      if (!this.visible || this._t === 0 || !s && this.isTemporary)
        return;
      const n = this.It.h, o = n.length;
      if (o === 0)
        return;
      const r = this.Vu(t), l = this.Eu;
      l.length = 0;
      const h = i.scale, a = Rect2.a();
      for (let f = 0; f < o; f++) {
        const c = n[f];
        e.contains(c) && this.Gm(t, c, i, l, h, a, false);
      }
      Rect2.o(a), t.globalAlpha = r;
    }
    NF(t, i, e, s, n) {
      if (!this.visible || this.opacity === 0)
        return;
      const o = this.diagram.grid.part;
      if (!s && this.isTemporary) {
        if (n && o.layer === this) {
          const r = this.Vu(t);
          o.Ji(t, e), t.globalAlpha = r;
        }
      } else {
        const r = this.Vu(t), l = e.scale, h = Rect2.a(), a = this.It.h, f = a.length;
        for (let c = 0; c < f; c++) {
          const u = a[c];
          !n && u === o || this.Gm(t, u, e, null, l, h, false);
        }
        Rect2.o(h), t.globalAlpha = r;
      }
    }
    aE(t, i, e) {
      if (!this.visible || this._t === 0)
        return;
      const s = this.Vu(t), n = this.Eu;
      n.length = 0;
      const o = i.scale, r = Rect2.a(), l = this.It.h, h = l.length, a = e.length;
      for (let f = 0; f < h; f++) {
        const c = l[f], u = c.$h(c.actualBounds);
        this.CF(u, e, a, o) && this.Gm(t, c, i, n, o, r, true);
      }
      Rect2.o(r), t.globalAlpha = s;
    }
    Gm(t, i, e, s, n, o, r) {
      if (r && !i.Rl()) {
        t.removePartFromView(i);
        return;
      }
      if (s !== null && i instanceof Link2 && (i.isOrthogonal && s.push(i), i.Re === false)) {
        t.removePartFromView(i);
        return;
      }
      let l = false, h = i.containingGroup;
      for (; h !== null; )
        l ? h.hi !== null && o.intersectRect(h.hi) : h.hi !== null && (l = true, o.c(h.hi)), h = h.containingGroup;
      const a = i.actualBounds;
      let f = false;
      if (l && i.isVisible()) {
        if (!o.intersectsRect(a)) {
          t.removePartFromView(i);
          return;
        }
        f = !o.containsRect(a);
      }
      f && (t.save(), t instanceof SVGContext ? t.partClipRect = o.copy() : (t.beginPath(), t.rect(o.x, o.y, o.width, o.height), t.clip())), a.width * n > e.Hm || a.height * n > e.Hm ? i.Ji(t, e) : this.AF(t, i), f && (t.restore(), t.clearContextCache(true));
    }
    AF(t, i) {
      const e = i.actualBounds, s = i.naturalBounds;
      if (e.width === 0 || e.height === 0 || isNaN(e.x) || isNaN(e.y) || !i.isVisible())
        return;
      const n = i.D;
      if (i.background === null && (i.bn(t, "rgba(0,0,0,0.3)", true, false, s, e), t.fillRect(e.x, e.y, e.width, e.height)), i.background !== null && (t.transform(n.m11, n.m12, n.m21, n.m22, n.dx, n.dy), i.bn(t, i.background, true, false, s, e), t.fillRect(0, 0, s.width / 2, s.height / 2), !n.Gk())) {
        const o = 1 / (n.m11 * n.m22 - n.m12 * n.m21);
        t.transform(n.m22 * o, -n.m12 * o, -n.m21 * o, n.m11 * o, o * (n.m21 * n.dy - n.m22 * n.dx), o * (n.m12 * n.dx - n.m11 * n.dy));
      }
    }
    CF(t, i, e, s) {
      const n = 2 / s, o = 4 / s;
      for (let r = 0; r < e; r++) {
        const l = i[r];
        if (!(l.width === 0 || l.height === 0) && t.intersects(l.x - n, l.y - n, l.width + o, l.height + o))
          return true;
      }
      return false;
    }
    i(t, i, e, s, n) {
      const o = this.diagram;
      o !== null && o.raiseChangedEvent(2, t, this, i, e, s, n);
    }
    Qh(t, i, e) {
      const s = this.It;
      if (i.GM(this), t >= s.count)
        t = s.count;
      else if (s.elt(t) === i)
        return -1;
      s.insertAt(t, i), i.vm(e);
      const n = this.diagram;
      return n !== null && (e ? n.T() : n.Qh(i)), this.Nx(t, i), t;
    }
    re(t, i, e) {
      if (!e && i.layer !== this && i.layer !== null)
        return i.layer.re(t, i, e);
      const s = this.It;
      if (t < 0 || t >= s.length) {
        if (t = s.indexOf(i), t < 0)
          return -1;
      } else if (s.elt(t) !== i && (t = s.indexOf(i), t < 0))
        return -1;
      i.qm(e), s.removeAt(t);
      const n = this.diagram;
      return n !== null && (e ? n.T() : n.re(i)), i.GM(null), t;
    }
    Nx(t, i) {
      t = this.LF(t, i), i instanceof Group2 && this.TF(t, i), i.svg !== null && i.svg.remove();
    }
    LF(t, i) {
      const e = i.zOrder;
      if (isNaN(e))
        return t;
      const s = this.It, n = s.count;
      if (n <= 1)
        return t;
      if (t < 0 && (t = s.indexOf(i)), t < 0)
        return -1;
      let o = t - 1, r = NaN;
      for (; o >= 0 && (r = s.elt(o).zOrder, !!isNaN(r)); )
        o--;
      let l = t + 1, h = NaN;
      for (; l < n && (h = s.elt(l).zOrder, !!isNaN(h)); )
        l++;
      if (!isNaN(r) && r > e)
        for (; ; ) {
          if (o === -1 || r <= e)
            return o++, o === t ? t : (s.removeAt(t), s.insertAt(o, i), o);
          for (r = NaN; --o >= 0 && (r = s.elt(o).zOrder, !!isNaN(r)); )
            ;
        }
      else if (!isNaN(h) && h < e)
        for (; ; ) {
          if (l === n || h >= e)
            return l--, l === t ? t : (s.removeAt(t), s.insertAt(l, i), l);
          for (h = NaN; ++l < n && (h = s.elt(l).zOrder, !!isNaN(h)); )
            ;
        }
      return t;
    }
    TF(t, i) {
      if (i === null || !isNaN(i.zOrder))
        return;
      this.DF(t, i);
      const e = i.containingGroup;
      e !== null && this.Nx(-1, e);
    }
    DF(t, i) {
      if (i.memberParts.count === 0)
        return;
      let e = -1;
      const s = this.It.h, n = s.length;
      for (let o = 0; o < n; o++) {
        const r = s[o];
        if (r === i && (t = o, e >= 0) || e < 0 && r.containingGroup === i && (e = o, t >= 0))
          break;
      }
      if (!(e < 0) && e < t) {
        const o = this.It;
        o.removeAt(t), o.insertAt(e, i);
      }
    }
    get parts() {
      return this.It.iterator;
    }
    get partsBackwards() {
      return this.It.iteratorBackwards;
    }
    get diagram() {
      return this.b;
    }
    get name() {
      return this.Tt;
    }
    set name(t) {
      Util.t(t, "string", Layer2, "name");
      const i = this.Tt;
      if (i !== t) {
        const e = this.diagram;
        if (e !== null) {
          i === "" && Util.n("Cannot rename default Layer to: " + t);
          const n = e.layers;
          for (; n.next(); )
            n.value.name === t && Util.n("Layer.name is already present in this diagram: " + t);
        }
        this.Tt = t, this.i("name", i, t);
        const s = this.It.iterator;
        for (; s.next(); ) {
          const n = s.value;
          n.layerName = this.Tt;
        }
      }
    }
    get opacity() {
      return this._t;
    }
    set opacity(t) {
      const i = this._t;
      if (i !== t) {
        Util.t(t, "number", Layer2, "opacity"), (t < 0 || t > 1) && Util.G(t, "0 <= value <= 1", Layer2, "opacity"), this._t = t;
        const e = this.diagram;
        e !== null && e.T(), this.i("opacity", i, t);
      }
    }
    get isViewportAligned() {
      return this.Km;
    }
    set isViewportAligned(t) {
      const i = this.Km;
      i !== t && (this.Km = t, this.diagram && (this.lA(), this.diagram.T()), this.i("isViewportAligned", i, t), t && (this.isInDocumentBounds = false));
    }
    lA() {
      if (!this.Km)
        return;
      const t = this.diagram, i = this.It.h, e = i.length, s = t.Ct, n = t.At;
      for (let o = 0; o < e; o++) {
        const r = i[o], l = r.naturalBounds.width, h = r.naturalBounds.height;
        let a = r.alignment;
        (a.isDefault() || !a.isSpot()) && (a = Spot2.BottomRight);
        let f = r.alignmentFocus;
        f.isDefault() && (f = new Spot2(a.x, a.y));
        const c = a.x * s + a.offsetX - (f.x * l + f.offsetX), u = a.y * n + a.offsetY - (f.y * h + f.offsetY), d = Point2.H(c, u);
        t.FF(d), r.Nf(d.x, d.y, true), Point2.o(d), r.v = 1 / t.scale;
      }
    }
    get isTemporary() {
      return this.Fr;
    }
    set isTemporary(t) {
      const i = this.Fr;
      i !== t && (Util.t(t, "boolean", Layer2, "isTemporary"), this.Fr = t, this.i("isTemporary", i, t));
    }
    get visible() {
      return this.Cf;
    }
    set visible(t) {
      const i = this.Cf;
      if (i !== t) {
        Util.t(t, "boolean", Layer2, "visible"), this.Cf = t;
        const e = this.It.iterator;
        for (; e.next(); )
          e.value.Ki(t);
        const s = this.diagram;
        s !== null && s.T(), this.i("visible", i, t);
      }
    }
    get pickable() {
      return this.$l;
    }
    set pickable(t) {
      const i = this.$l;
      i !== t && (Util.t(t, "boolean", Layer2, "pickable"), this.$l = t, this.i("pickable", i, t));
    }
    get isInDocumentBounds() {
      return this.Px;
    }
    set isInDocumentBounds(t) {
      const i = this.Px;
      i !== t && (this.Px = t, this.diagram !== null && this.diagram.invalidateDocumentBounds(), this.i("isInDocumentBounds", i, t));
    }
    get allowCopy() {
      return this.Xl;
    }
    set allowCopy(t) {
      const i = this.Xl;
      i !== t && (Util.t(t, "boolean", Layer2, "allowCopy"), this.Xl = t, this.i("allowCopy", i, t));
    }
    get allowDelete() {
      return this.Yl;
    }
    set allowDelete(t) {
      const i = this.Yl;
      i !== t && (Util.t(t, "boolean", Layer2, "allowDelete"), this.Yl = t, this.i("allowDelete", i, t));
    }
    get allowTextEdit() {
      return this.Kl;
    }
    set allowTextEdit(t) {
      const i = this.Kl;
      i !== t && (Util.t(t, "boolean", Layer2, "allowTextEdit"), this.Kl = t, this.i("allowTextEdit", i, t));
    }
    get allowGroup() {
      return this.Ul;
    }
    set allowGroup(t) {
      const i = this.Ul;
      i !== t && (Util.t(t, "boolean", Layer2, "allowGroup"), this.Ul = t, this.i("allowGroup", i, t));
    }
    get allowUngroup() {
      return this.Gl;
    }
    set allowUngroup(t) {
      const i = this.Gl;
      i !== t && (Util.t(t, "boolean", Layer2, "allowUngroup"), this.Gl = t, this.i("allowUngroup", i, t));
    }
    get allowLink() {
      return this.Hl;
    }
    set allowLink(t) {
      const i = this.Hl;
      i !== t && (Util.t(t, "boolean", Layer2, "allowLink"), this.Hl = t, this.i("allowLink", i, t));
    }
    get allowRelink() {
      return this.vl;
    }
    set allowRelink(t) {
      const i = this.vl;
      i !== t && (Util.t(t, "boolean", Layer2, "allowRelink"), this.vl = t, this.i("allowRelink", i, t));
    }
    get allowMove() {
      return this.ql;
    }
    set allowMove(t) {
      const i = this.ql;
      i !== t && (Util.t(t, "boolean", Layer2, "allowMove"), this.ql = t, this.i("allowMove", i, t));
    }
    get allowReshape() {
      return this.Wl;
    }
    set allowReshape(t) {
      const i = this.Wl;
      i !== t && (Util.t(t, "boolean", Layer2, "allowReshape"), this.Wl = t, this.i("allowReshape", i, t));
    }
    get allowResize() {
      return this.jl;
    }
    set allowResize(t) {
      const i = this.jl;
      i !== t && (Util.t(t, "boolean", Layer2, "allowResize"), this.jl = t, this.i("allowResize", i, t));
    }
    get allowRotate() {
      return this.Jl;
    }
    set allowRotate(t) {
      const i = this.Jl;
      i !== t && (Util.t(t, "boolean", Layer2, "allowRotate"), this.Jl = t, this.i("allowRotate", i, t));
    }
    get allowSelect() {
      return this.Zl;
    }
    set allowSelect(t) {
      const i = this.Zl;
      i !== t && (Util.t(t, "boolean", Layer2, "allowSelect"), this.Zl = t, this.i("allowSelect", i, t));
    }
  }
  var AutoScale2 = ((w) => (w[w.None = 1] = "None", w[w.Uniform = 2] = "Uniform", w[w.UniformToFill = 3] = "UniformToFill", w))(AutoScale2 || {}), CycleMode2 = ((w) => (w[w.All = 1] = "All", w[w.NotDirected = 2] = "NotDirected", w[w.NotDirectedFast = 3] = "NotDirectedFast", w[w.NotUndirected = 4] = "NotUndirected", w[w.DestinationTree = 5] = "DestinationTree", w[w.SourceTree = 6] = "SourceTree", w))(CycleMode2 || {}), ScrollMode2 = ((w) => (w[w.Document = 1] = "Document", w[w.Infinite = 2] = "Infinite", w))(ScrollMode2 || {}), CollapsePolicy2 = ((w) => (w[w.TreeParent = 1] = "TreeParent", w[w.AllParents = 2] = "AllParents", w[w.AnyParents = 3] = "AnyParents", w))(CollapsePolicy2 || {});
  const _Diagram = class _Diagram {
    constructor(t, i) {
      __publicField(this, "bs");
      __publicField(this, "wi");
      __publicField(this, "WM");
      __publicField(this, "Cx");
      __publicField(this, "Rr");
      __publicField(this, "zu");
      __publicField(this, "Ax");
      __publicField(this, "Lx");
      __publicField(this, "Tx");
      __publicField(this, "Dx");
      __publicField(this, "Fx");
      __publicField(this, "Rx");
      __publicField(this, "Vf");
      __publicField(this, "Zh");
      __publicField(this, "Ix");
      __publicField(this, "Ox");
      __publicField(this, "Ex");
      __publicField(this, "Ql");
      __publicField(this, "Bf");
      __publicField(this, "Ir");
      __publicField(this, "Wm");
      __publicField(this, "Vx");
      __publicField(this, "Bx");
      __publicField(this, "Xu");
      __publicField(this, "_n");
      __publicField(this, "Or");
      __publicField(this, "_h");
      __publicField(this, "zo");
      __publicField(this, "jm");
      __publicField(this, "zf");
      __publicField(this, "Jm");
      __publicField(this, "Xf");
      __publicField(this, "Yu");
      __publicField(this, "Er");
      __publicField(this, "to");
      __publicField(this, "jM");
      __publicField(this, "JM");
      __publicField(this, "zx");
      __publicField(this, "Xx");
      __publicField(this, "ZM");
      __publicField(this, "Yx");
      __publicField(this, "$M");
      __publicField(this, "QM");
      __publicField(this, "_M");
      __publicField(this, "Kx");
      __publicField(this, "Zm");
      __publicField(this, "Vr");
      __publicField(this, "Br");
      __publicField(this, "zr");
      __publicField(this, "Xr");
      __publicField(this, "Yr");
      __publicField(this, "Kr");
      __publicField(this, "Ux");
      __publicField(this, "Ur");
      __publicField(this, "Gx");
      __publicField(this, "Gr");
      __publicField(this, "Hr");
      __publicField(this, "vr");
      __publicField(this, "qr");
      __publicField(this, "Hx");
      __publicField(this, "tP");
      __publicField(this, "Xo");
      __publicField(this, "iP");
      __publicField(this, "vx");
      __publicField(this, "qx");
      __publicField(this, "eP");
      __publicField(this, "Li");
      __publicField(this, "sP");
      __publicField(this, "nP");
      __publicField(this, "oP");
      __publicField(this, "Ys");
      __publicField(this, "Yo");
      __publicField(this, "Xi");
      __publicField(this, "Wx");
      __publicField(this, "Xl");
      __publicField(this, "Yl");
      __publicField(this, "jx");
      __publicField(this, "Jx");
      __publicField(this, "Kl");
      __publicField(this, "Ul");
      __publicField(this, "Gl");
      __publicField(this, "Zx");
      __publicField(this, "Hl");
      __publicField(this, "vl");
      __publicField(this, "ql");
      __publicField(this, "Wl");
      __publicField(this, "jl");
      __publicField(this, "Jl");
      __publicField(this, "Zl");
      __publicField(this, "$x");
      __publicField(this, "Qx");
      __publicField(this, "rP");
      __publicField(this, "Ku");
      __publicField(this, "Uu");
      __publicField(this, "_x");
      __publicField(this, "t1");
      __publicField(this, "i1");
      __publicField(this, "e1");
      __publicField(this, "$m");
      __publicField(this, "s1");
      __publicField(this, "o1");
      __publicField(this, "l1");
      __publicField(this, "ei");
      __publicField(this, "lP");
      __publicField(this, "h1");
      __publicField(this, "hP");
      __publicField(this, "Gu");
      __publicField(this, "kn");
      __publicField(this, "io");
      __publicField(this, "le");
      __publicField(this, "eo");
      __publicField(this, "hA");
      __publicField(this, "_l");
      __publicField(this, "aP");
      __publicField(this, "fP");
      __publicField(this, "a1");
      __publicField(this, "Hu");
      __publicField(this, "Qm");
      __publicField(this, "f1");
      __publicField(this, "Wr");
      __publicField(this, "th");
      __publicField(this, "ta");
      __publicField(this, "RF");
      __publicField(this, "IF");
      __publicField(this, "_m");
      __publicField(this, "c1");
      __publicField(this, "u1");
      __publicField(this, "ls");
      __publicField(this, "t0");
      __publicField(this, "i0");
      __publicField(this, "vu");
      __publicField(this, "ih");
      __publicField(this, "Yf");
      __publicField(this, "e0");
      __publicField(this, "jr");
      __publicField(this, "ia");
      __publicField(this, "cP");
      __publicField(this, "s0");
      __publicField(this, "$t");
      __publicField(this, "D");
      __publicField(this, "qe");
      __publicField(this, "Tr");
      __publicField(this, "Ui");
      __publicField(this, "Ps");
      __publicField(this, "OF");
      __publicField(this, "eh");
      __publicField(this, "Jr");
      __publicField(this, "Al");
      __publicField(this, "Zr");
      __publicField(this, "ea");
      __publicField(this, "Kf");
      __publicField(this, "uP");
      __publicField(this, "qu");
      __publicField(this, "sa");
      __publicField(this, "Wu");
      __publicField(this, "Jt");
      __publicField(this, "sh");
      __publicField(this, "lt");
      __publicField(this, "v");
      __publicField(this, "ju");
      __publicField(this, "Ct");
      __publicField(this, "At");
      __publicField(this, "xt");
      __publicField(this, "Uf");
      __publicField(this, "Hw");
      __publicField(this, "d1");
      __publicField(this, "na");
      __publicField(this, "Gf");
      __publicField(this, "g1");
      __publicField(this, "m1");
      __publicField(this, "p1");
      __publicField(this, "EF");
      __publicField(this, "VF");
      __publicField(this, "Gi");
      __publicField(this, "Tl");
      __publicField(this, "Hm");
      __publicField(this, "o0");
      __publicField(this, "dP");
      __publicField(this, "gP");
      __publicField(this, "aA");
      __publicField(this, "r0");
      __publicField(this, "BF");
      __publicField(this, "zF");
      __publicField(this, "XF");
      __publicField(this, "w1");
      __publicField(this, "YF");
      __publicField(this, "KF");
      __publicField(this, "UF");
      __publicField(this, "oa");
      __publicField(this, "fA");
      __publicField(this, "nh");
      __publicField(this, "ra");
      __publicField(this, "la");
      __publicField(this, "ha");
      __publicField(this, "aa");
      __publicField(this, "Pu");
      __publicField(this, "jh");
      __publicField(this, "ai");
      __publicField(this, "Ot");
      __publicField(this, "Hf");
      __publicField(this, "eS");
      __publicField(this, "sS");
      __publicField(this, "wf");
      __publicField(this, "_t");
      __publicField(this, "Mu");
      __publicField(this, "k1");
      __publicField(this, "S1");
      __publicField(this, "M1");
      __publicField(this, "P1");
      __publicField(this, "N1");
      __publicField(this, "l0");
      __publicField(this, "yP");
      __publicField(this, "h0");
      __publicField(this, "a0");
      __publicField(this, "f0");
      __publicField(this, "fx");
      __publicField(this, "wP");
      __publicField(this, "C1");
      __publicField(this, "vf");
      if (_Diagram.ww || (_Diagram.Hk(), _Diagram.ww = true), GSet2.ji(this), _Diagram.uA(this), this.$t = true, this.Ot = null, this.Ct = 0, this.At = 0, this.xt = null, _Diagram.isUsingDOM()) {
        const s = this, n = () => {
          s.Ti(root.document, "DOMContentLoaded", n, false), s.setRTL();
        };
        root.document.body !== null ? this.setRTL() : s.Ht(root.document, "DOMContentLoaded", n, false);
      }
      this.Uf = null, _Diagram.xP("Model", PartManager);
      const e = this;
      return this.sP = (s) => e.partManager.doModelDataChanged(s), this.nP = (s) => e.partManager.doModelChanged(s), this.g1 = null, this.m1 = null, this.dA(), this.model = Model2.initDiagramModel(), this.C1 = null, this.themeManager = new ThemeManager2(), this.Xo = true, this.gA(), this.layout = new Layout2(), this.Xo = false, this.BF = null, this.zF = null, this.XF = null, this.w1 = null, this.YF = null, this.KF = null, this.UF = null, this.oa = null, this.fA = null, this.nh = null, this.ra = null, this.la = null, this.ha = null, this.aa = null, this.Pu = () => {
      }, this.jh = null, this.vu = false, this.Hf = new DiagramHelper(this), t !== void 0 && (typeof t == "string" || root.Element && t instanceof Element ? this.bP(t) : i = t), i && this.setProperties(i), this.$t = false, this.requestUpdate(), this;
    }
    ZD() {
      return this.xt !== null;
    }
    get renderer() {
      return this.Yf;
    }
    set renderer(t) {
      if (this instanceof Overview2)
        return;
      t === "" && (t = "default");
      const i = t.toLowerCase(), e = this.Yf;
      if (i === e)
        return;
      this.Yf = i;
      let s = null;
      i === "default" || i === "canvas" ? (s = this.ih.get("svg"), s !== null && s.Bt.remove(), this.xt && (this.ai = this.xt.gi)) : i === "svg" ? (this.ih.contains("svg") ? s = this.ih.get("svg") : (s = new SVGSurface(this, root.document), this.addRenderer("svg", s)), this.div !== null && this.div.appendChild(s.Bt), this.ai = s.gi, this.xt && (this.xt.gi.setTransform(this.Gi, 0, 0, this.Gi, 0, 0), this.xt.gi.clearRect(0, 0, this.Ct, this.At))) : i === "debug" && (this.ih.contains("SVG") || (s = new SVGSurface(this, root.document), this.addRenderer("SVG", s), s.Bt.style.backgroundColor = "whitesmoke", this.div !== null && this.div.after(s.Bt))), this.$t || this.redraw();
    }
    dA() {
      this.vf = new List2(), this.setupRouters(), this.bs = new AnimationManager2(), this.bs.Vo(this), this.wi = 17, this.WM = false, this.ju = false, this.Cx = "default", this.Jt = new List2(), this.ih = new GMap2(), this.Yf = "default", this.resetRenderingHints(), this.GF(), this._t = 1, this.lt = new Point2(NaN, NaN).w(), this.fx = new Point2(NaN, NaN), this.v = 1, this.s0 = 1, this.Ax = new Point2(NaN, NaN).w(), this.Lx = NaN, this.Tx = 1e-4, this.Dx = 100, this.D = new Transform(), this.Fx = new Point2(NaN, NaN).w(), this.Rx = new Rect2(NaN, NaN, NaN, NaN).w(), this.Vf = new Margin2(0, 0, 0, 0).w(), this.Zh = 1, this.Ix = false, this.Ox = null, this.Ex = null, this.Ql = 1, this.Bf = Spot2.Default, this.Ir = 1, this.Wm = Spot2.Default, this.Vx = Spot2.None, this.Bx = Spot2.None, this.qe = true, this.Xu = false, this._n = /* @__PURE__ */ new Set(), this.Or = new GSet2(), this._h = new GSet2(), this.zo = false, this.sh = new GMap2(), this.qu = true, this.jm = 250, this.zf = -1, this.Jm = new Margin2(16, 16, 16, 16).w(), this.Tr = false, this.Xf = false, this.Yu = true, this.e0 = new InputEvent2(), this.e0.diagram = this, this.jr = new InputEvent2(), this.jr.diagram = this, this.ia = new InputEvent2(), this.ia.diagram = this, this.Er = null, this.to = null, this.Hw = false, this.HF(), this.Zr = new GSet2(), this.zx = true, this.Xx = 1, this.ZM = false, this.Yx = 1, this.Kx = "auto", this.Zm = "auto", this.Vr = null, this.Br = null, this.zr = null, this.Xr = null, this.Yr = null, this.Kr = null, this.Ux = null, this.Ur = null, this.Gx = false, this.Gr = null, this.Hr = null, this.vr = null, this.qr = null, this.Hx = false, this.d1 = {}, this.na = [null, null], this.Xo = false, this.iP = false, this.vx = false, this.qx = false, this.eP = true, this.Ps = false, this.sa = false, this.oP = true, this.Ys = -2, this.eh = new GMap2(), this.Wu = new List2(), this.Yo = false, this.Xi = true, this.Wx = true, this.Xl = true, this.Yl = true, this.jx = false, this.Jx = true, this.Kl = true, this.Ul = true, this.Gl = true, this.Zx = true, this.Hl = true, this.vl = true, this.ql = true, this.Wl = true, this.jl = true, this.Jl = true, this.Zl = true, this.$x = true, this.Qx = true, this.rP = false, this.Gf = false, this.Ku = true, this.Uu = true, this._x = true, this.t1 = true, this.i1 = 16, this.e1 = 16, this.$m = false, this.s1 = false, this.o1 = 0, this.l1 = 0, this.ei = new Margin2(5).w(), this.lP = new GSet2().w(), this.h1 = 999999999, this.hP = new GSet2().w(), this.ea = true, this.Gu = true, this.Kf = true, this.kn = false, this.io = false, this.Jr = true, this.Al = false, this.eo = false, this.hA = new GSet2(), this.uP = new GSet2(), this._l = null, this.aP = new Size2(8, 8), this.fP = 999, this.eS = 1, this.sS = 0, this.Ui = { scale: 1, position: new Point2(), bounds: new Rect2(), canvasSize: new Size2(), newCanvasSize: new Size2(), isScroll: false }, this.Ui.canvasSize = this.Ui.canvasSize, this.Ui.newCanvasSize = this.Ui.newCanvasSize, this.Ui.isScroll = false, this.a1 = new Rect2(NaN, NaN, NaN, NaN).w(), this.Hu = new Size2(NaN, NaN).w(), this.Qm = new Rect2(NaN, NaN, NaN, NaN).w(), this.f1 = false, this.vF(), this.ls = null, this.t0 = false, this.wf = null, this.partManager = new PartManager(), this.toolManager = new ToolManager2(), this.toolManager.initializeStandardTools(), this.defaultTool = this.toolManager, this.currentTool = this.defaultTool, this.S1 = null, this.M1 = new DraggingOptions2(), this.P1 = null, this.N1 = null, this.k1 = false, this.Mu = false, this.commandHandler = new CommandHandler2(), this.a0 = null, this.f0 = Point2.Ek, this.wP = false, this.Gi = 1, this.Tl = null, this.Hm = 1, this.l0 = 0, this.yP = [0, 0, 0, 0, 0], this.h0 = 0, this.o0 = 1, this.dP = 0, this.gP = new Point2(), this.aA = 500, this.i0 = new Point2(), this.r0 = false;
    }
    static isUsingDOM() {
      return _Diagram.mA;
    }
    static useDOM(t) {
      _Diagram.mA = t ? root.document !== void 0 : false;
    }
    clear() {
      this.animationManager.stopAnimation(), this.model.clear(), _Diagram.pA(), this.yA(false), this.Wu.clear(), this.wA(), this._l = null, this.invalidateDocumentBounds(), this.ensureBounds(), this.T();
    }
    yA(t) {
      this.animationManager.stopAnimation(true), this.lP = new GSet2().w(), this.hP = new GSet2().w();
      const i = this.skipsUndoManager, e = this.Li !== null && this.Li !== void 0;
      e && (this.skipsUndoManager = true);
      let s = null;
      this.ls !== null && (s = this.ls.part, s !== null && this.remove(s));
      const n = [], o = this.Jt.length;
      if (t) {
        for (let r = 0; r < o; r++) {
          const h = this.Jt.h[r].parts;
          for (; h.next(); ) {
            const a = h.value;
            a !== s && a.data === null && n.push(a);
          }
        }
        for (let r = 0; r < n.length; r++) {
          const l = n[r];
          this.remove(l);
        }
      }
      for (let r = 0; r < o; r++)
        this.Jt.h[r].MF();
      return this.partManager.clear(), this._n.clear(), this.Or.clear(), this._h.clear(), this.sh.clear(), this.Zr.clear(), this.wf = null, this.Wu.clear(), this.wA(), Util.Ik = [], s !== null && (this.add(s), this.partManager.parts.remove(s)), e && (this.skipsUndoManager = i), n;
    }
    static pA() {
      _Diagram.c0 = null, _Diagram.A1 = "";
    }
    static fE() {
      return null;
    }
    reset() {
      this.clear(), this.$t = true, this.dA(), this.themeManager = new ThemeManager2(), this.$r(), this.Xo = true, this.gA(), this.layout = new Layout2(), this.Xo = false, this.model = Model2.initDiagramModel(), this.model.undoManager = new UndoManager2(), this.vu = false, this.$t = false, this.T();
    }
    vF() {
      this.Wr = new GMap2(), this.Wr.add("", new Node2().add(new TextBlock2({ stroke: "black", font: "10pt sans-serif" }).bind("text", "", Util.toString).theme("stroke", "text").theme("font", "normal"))), this.Wr.add("Comment", new Node2().add(new TextBlock2({ stroke: "brown", font: "10pt sans-serif" }).bind("text", "", Util.toString).theme("stroke", "comment").theme("font", "normal"))), this.Wr.add("LinkLabel", new Node2({ selectable: false, avoidable: false }).add(new Shape2("Ellipse", { fill: "black", stroke: null, desiredSize: new Size2(3, 3).rt() }).theme("fill", "link"))), this.ta = new GMap2(), this.ta.add("", new Group2(Panel2.Vertical, { selectionObjectName: "GROUPPANEL" }).add(new TextBlock2({ stroke: "black", font: "bold 12pt sans-serif" }).bind("text", "", Util.toString).theme("stroke", "text").theme("font", "bold"), new Panel2(Panel2.Auto, { name: "GROUPPPANEL" }).add(new Shape2({ fill: "rgba(128,128,128,0.2)", stroke: "black", strokeWidth: 1 }).theme("fill", "group").theme("stroke", "outline").theme("strokeWidth", "group"), new Placeholder2({ padding: 5 }).theme("padding", "group")))), this.th = new GMap2(), this.th.add("", new Link2().add(new Shape2({ isPanelMain: true, stroke: "black" }).theme("stroke", "link"), new Shape2({ toArrow: "Standard", fill: "black", stroke: null, strokeWidth: 0 }).theme("toArrow").theme("fill", "link"))), this.th.add("Comment", new Link2().add(new Shape2({ isPanelMain: true, stroke: "brown" }).theme("stroke", "comment"))), this._m = new Adornment2(Panel2.Auto).add(new Shape2({ fill: null, stroke: "dodgerblue", strokeWidth: 3 }).theme("stroke", "selection").theme("strokeWidth", "selection"), new Placeholder2({ margin: 1.5 }).theme("margin", "selection", "numbers", null, (t) => t ? new Margin2(t / 2) : 1.5)), this.c1 = this._m, this.u1 = new Adornment2(Panel2.Link).add(new Shape2({ isPanelMain: true, fill: null, stroke: "dodgerblue", strokeWidth: 3 }).theme("stroke", "selection").theme("strokeWidth", "selection"));
    }
    setRTL(t) {
      let i = t === void 0 ? this.div : t;
      i === null && (i = root.document.body);
      const e = Util.hn("div");
      e.dir = "rtl", e.style.cssText = "font-size: 14px; width: 1px; height: 1px; position: absolute; top: -1000px; overflow: scroll;", e.textContent = "A", i.appendChild(e);
      let s = "reverse";
      e.scrollLeft > 0 ? s = "default" : (e.scrollLeft = 1, e.scrollLeft === 0 && (s = "negative")), i.removeChild(e), this.Cx = s;
    }
    setScrollWidth(t) {
      let i = t === void 0 ? this.div : t;
      i === null && (i = root.document.body);
      let e = 0;
      if (_Diagram.isUsingDOM()) {
        let s = _Diagram.pP, n = _Diagram.mP;
        s === null && (_Diagram.pP = Util.hn("p"), s = _Diagram.pP, s.style.width = "100%", s.style.height = "200px", s.style.boxSizing = "content-box", _Diagram.mP = Util.hn("div"), n = _Diagram.mP, n.style.position = "absolute", n.style.visibility = "hidden", n.style.width = "200px", n.style.height = "150px", n.style.boxSizing = "content-box", n.appendChild(s)), n.style.overflow = "hidden", i.appendChild(n);
        const o = s.offsetWidth;
        n.style.overflow = "scroll";
        let r = s.offsetWidth;
        o === r && (r = n.clientWidth), i.removeChild(n), e = o - r, e === 0 && !Util.dr && (e = 11);
      }
      this.wi = e, this.WM = true;
    }
    ci(t) {
      t in AutoScale2 ? this.autoScale = t : Util.gr(this, t);
    }
    toString(t) {
      t === void 0 && (t = 0);
      let i = "";
      this.div && this.div.id && (i = this.div.id);
      let e = 'Diagram "' + i + '"';
      if (t <= 0)
        return e;
      const s = this.Jt.iterator;
      for (; s.next(); ) {
        const n = s.value;
        e += `
  ` + n.toString(t - 1);
      }
      return e;
    }
    static uA(t) {
      _Diagram.b1 = t;
    }
    static Pm() {
      return _Diagram.b1;
    }
    static fromDiv(t) {
      let i = t;
      return typeof t == "string" && (i = root.document.getElementById(t)), i instanceof HTMLDivElement && _Diagram.he.has(i) ? _Diagram.he.get(i) : null;
    }
    get div() {
      return this.Ot;
    }
    set div(t) {
      if (t !== null && Util.s(t, HTMLDivElement, _Diagram, "div"), this.Ot !== t) {
        const i = this.Ot;
        if (i !== null) {
          if (_Diagram.he.delete(i), i.goDiagram = void 0, i.go = void 0, i.innerHTML = "", this.xt !== null) {
            const s = this.xt.Bt;
            this.Ti(s, "pointermove", this.ra, false), this.Ti(s, "pointerdown", this.nh, false), this.Ti(s, "pointerup", this.la, false), this.Ti(s, "pointerout", this.ha, false), this.Ti(s, "pointercancel", this.aa, false), this.xt.dispose();
          }
          this.Uf && (this.Uf.disconnect(), this.Uf = null);
          const e = this.toolManager;
          e !== null && (e.mouseDownTools.each((s) => s.cancelWaitAfter()), e.mouseMoveTools.each((s) => s.cancelWaitAfter()), e.mouseUpTools.each((s) => s.cancelWaitAfter())), e.cancelWaitAfter(), this.currentTool.doCancel(), this.xt = null, this.Ti(root, "resize", this.w1, false), this.Ti(root, "wheel", this.oa, true), _Diagram.Pm() === this && _Diagram.uA(null);
        } else
          this.nh === null && (this.eo = false);
        if (this.Ot = null, t !== null) {
          const e = _Diagram.he.get(t);
          e && (e.div = null), this.bP(t), this.Pu(), this.themeManager && this.themeManager.qF();
        } else
          this.themeManager && this.themeManager.WF();
      }
    }
    setupRouters() {
      this.vf.push(new AvoidsNodesRouter());
    }
    bP(t) {
      const i = this;
      if (!_Diagram.isUsingDOM())
        return;
      t == null && Util.n("Diagram setup requires an argument DIV."), i.Ot !== null && Util.n("Diagram has already completed setup."), typeof t == "string" ? i.Ot = root.document.getElementById(t) : t instanceof HTMLDivElement ? i.Ot = t : Util.n("No DIV or DIV id supplied: " + t), i.Ot === null && Util.n("Invalid DIV id; could not get element with id: " + t);
      const e = _Diagram.he.get(i.Ot);
      if (e && e !== this && Util.n("Invalid div id; div already has a Diagram associated with it."), !i.Uf && root.ResizeObserver) {
        const f = root.ResizeObserver, c = Util.Rk(() => i.requestUpdate(), 250, false);
        i.Uf = new f(() => c()), i.Uf.observe(i.Ot);
      }
      root.getComputedStyle(i.Ot, null).position === "static" && (i.Ot.style.position = "relative");
      let s = 5;
      const n = "rgba(2" + s + "5, 255, 255, 0)";
      s--, i.Ot.style["-webkit-tap-highlight-color"] = n, i.Ot.innerHTML = "", _Diagram.he.set(i.Ot, i), i.Ot.goDiagram = i, i.Ot.go = root.go;
      const o = new CanvasSurface(i);
      o.style !== void 0 && (o.style.position = "absolute", o.style.top = "0px", o.style.left = "0px", root.getComputedStyle(i.Ot, null).getPropertyValue("direction") === "rtl" && (i.ju = true), o.style.zIndex = "2", o.style.userSelect = "none", o.style.MozUserSelect = "none", o.style.touchAction = "none", o.style.letterSpacing = "normal !important", o.style.wordSpacing = "normal !important", o.style.lang = "unknown"), i.xt = o, i.ai = o.gi;
      const r = i.ai;
      i.Gi = i.computePixelRatio(), i.viewSize.isReal() || (i.Ct = i.Ot.clientWidth || 1, i.At = i.Ot.clientHeight || 1), i.xA(i.Ct, i.At);
      const l = i;
      i.Ot.insertBefore(o.Bt, i.Ot.firstChild);
      const h = new CanvasSurface(null);
      if (h.width = 1, h.height = 1, i.EF = h, i.VF = h.gi, _Diagram.isUsingDOM()) {
        const f = Util.hn("div"), c = Util.hn("div");
        f.style.position = "absolute", f.style.overflow = "auto", f.style.width = i.Ct + "px", f.style.height = i.At + "px", f.style.zIndex = "1", c.style.position = "absolute", c.style.width = "1px", c.style.height = "1px", i.Ot.appendChild(f), f.appendChild(c), f.onscroll = _Diagram.jF, f.addEventListener("pointerdown", _Diagram.JF), f.b = i, f.ZF = true, f.$F = true, i.g1 = f, i.m1 = c;
      }
      i.Pu = Util.Rk(() => {
        i.Tl = null, i.T();
      }, 300, false), i.w1 = Util.Rk(() => {
        i.RM();
      }, 250, false), i.jh = (f) => (f.preventDefault(), false), i.oa = (f) => {
        if (!l.isEnabled)
          return;
        const c = l.qf(f, true);
        c.bubbles = true;
        let u = 0, d = 0;
        c.delta = 0, f.deltaX !== void 0 ? (f.deltaX !== 0 && (u = f.deltaX > 0 ? 1 : -1), f.deltaY !== 0 && (d = f.deltaY > 0 ? 1 : -1), c.delta = Math.abs(f.deltaX) > Math.abs(f.deltaY) ? -u : -d) : f.wheelDeltaX !== void 0 ? (f.wheelDeltaX !== 0 && (u = f.wheelDeltaX > 0 ? -1 : 1), f.wheelDeltaY !== 0 && (d = f.wheelDeltaY > 0 ? -1 : 1), c.delta = Math.abs(f.wheelDeltaX) > Math.abs(f.wheelDeltaY) ? -u : -d) : f.wheelDelta !== void 0 && f.wheelDelta !== 0 && (c.delta = f.wheelDelta > 0 ? 1 : -1), l.doMouseWheel(), l.fa(c, f);
      }, i.fA = (f) => {
        if (!l.isEnabled)
          return;
        i.Gf = false, l.qf(f, true);
        const c = l.currentTool;
        c.cancelWaitAfter(), c.standardMouseOver();
      }, i.nh = (f) => {
        if (!l.isEnabled)
          return;
        i.Gf = true;
        const c = l.d1;
        c[f.pointerId] === void 0 && (c[f.pointerId] = f);
        const u = l.na;
        let d = false;
        if (u[0] !== null && (u[0].pointerId === f.pointerId || u[0].pointerType !== f.pointerType))
          u[0] = f;
        else if (u[1] !== null && u[1].pointerId === f.pointerId)
          u[1] = f, d = true;
        else if (u[0] === null)
          u[0] = f;
        else if (u[1] === null)
          u[1] = f, d = true;
        else {
          f.preventDefault();
          return;
        }
        const m = f.pointerType === "touch" || f.pointerType === "pen";
        m && (l.Hw = false, l.r0 = true);
        const g = l.QF(f, f, d), p = l.gP, y = m ? 25 : 10;
        if (f.timeStamp - l.dP < l.aA && !(Math.abs(p.x - f.screenX) > y || Math.abs(p.y - f.screenY) > y) ? l.o0++ : l.o0 = 1, g.clickCount = l.o0, l.dP = f.timeStamp, l.gP.setTo(f.screenX, f.screenY), l.doMouseDown(), f.button === 1) {
          f.preventDefault();
          return;
        }
        l.fa(g, f);
      }, i.ra = (f) => {
        if (!l.isEnabled)
          return;
        i.Gf = true;
        const c = l.na;
        if (c[0] !== null && (c[0].pointerId === f.pointerId || c[0].pointerType !== f.pointerType))
          c[0] = f;
        else if (c[1] !== null && c[1].pointerId === f.pointerId) {
          c[1] = f;
          return;
        } else if (c[0] === null)
          c[0] = f;
        else
          return;
        if (c[0].pointerId !== f.pointerId)
          return;
        const u = l._F(f, f, c[1] !== null);
        l.doMouseMove(), l.fa(u, f);
      }, i.la = (f) => {
        if (!l.isEnabled)
          return;
        i.Gf = true;
        const c = f.pointerType === "touch" || f.pointerType === "pen", u = l.d1;
        if (c && l.Hw) {
          delete u[f.pointerId], f.preventDefault();
          return;
        }
        const d = l.na;
        if (d[0] !== null && (d[0].pointerId === f.pointerId || d[0].pointerType !== f.pointerType))
          d[0] = null;
        else if (d[1] !== null && d[1].pointerId === f.pointerId) {
          d[1] = null;
          return;
        } else
          return;
        const m = l.kP(f, false, true, false, true, false);
        let g = root.document.elementFromPoint(f.clientX, f.clientY) || null;
        g !== null && g.shadowRoot !== void 0 && g.shadowRoot !== null && (g = g.shadowRoot.elementFromPoint(f.clientX, f.clientY)), g !== null && g.b instanceof _Diagram && g.b !== l && g.b.u0(f, m), g === null && (g = f.target), l.u0(f, m), m.clickCount = l.o0, m.targetDiagram = l.SP(f, g), m.targetObject = null, l.doMouseUp(), l.fa(m, f), c && (l.r0 = false);
      }, i.ha = (f) => {
        if (!l.isEnabled)
          return;
        i.Gf = false;
        const c = l.d1;
        c[f.pointerId] && delete c[f.pointerId];
        const u = l.na;
        if (u[0] !== null && u[0].pointerId === f.pointerId && (u[0] = null), u[1] !== null && u[1].pointerId === f.pointerId && (u[1] = null), f.pointerType === "touch" || f.pointerType === "pen")
          return;
        const d = l.currentTool;
        d.cancelWaitAfter(), d.standardMouseOver();
      }, i.aa = (f) => {
        const c = l.na;
        c[0] !== null && c[0].pointerId === f.pointerId ? (c[0] = null, l.r0 = false) : c[1] !== null && c[1].pointerId === f.pointerId && (c[1] = null);
      };
      const a = r;
      if (i.p1 = a.Y[Util.Os("7eba17a4ca3b1a8346")][Util.Os("78a118b7")](a.Y, _Diagram.Ju, s, s), r.clearContextCache(true), i.tR(), this.Yf === "svg") {
        const f = this.ih.get("svg");
        this.Ot.appendChild(f.Bt), this.ai = f.gi;
      }
    }
    addEventListener(t, i, e, s) {
      t.addEventListener(i, e, { capture: s, passive: false });
    }
    Ht(t, i, e, s) {
      t.addEventListener(i, e, { capture: s, passive: false });
    }
    removeEventListener(t, i, e, s) {
      t.removeEventListener(i, e, { capture: s });
    }
    Ti(t, i, e, s) {
      t.removeEventListener(i, e, { capture: s });
    }
    tR() {
      const t = this;
      let i = this.xt.Bt;
      i instanceof HTMLCanvasElement || (i = t.div), this.Ht(i, "pointerdown", t.nh, false), this.Ht(i, "pointermove", t.ra, false), this.Ht(i, "pointerup", t.la, false), this.Ht(i, "pointerout", t.ha, false), this.Ht(i, "pointercancel", t.aa, false), this.Ht(i, "pointerenter", t.iR, false), this.Ht(i, "pointerleave", t.eR, false), this.Ht(i, "wheel", t.oa, false), this.Ht(i, "keydown", t.sR, false), this.Ht(i, "keyup", t.nR, false), this.Ht(i, "blur", t.oR, false), this.Ht(i, "focus", t.rR, false), this.Ht(i, "selectstart", (e) => (e.preventDefault(), false), false), this.Ht(i, "contextmenu", (e) => (e.preventDefault(), false), false), this.Ht(root, "resize", t.w1, false);
    }
    vw() {
      this.l0 > 30 && (this.Tl = 1);
    }
    NS(t) {
      this.Tl !== null && (this.Tl = null, t && this.Pu(), Debug && Debug.drawFrames || (this.l0 = 0, this.yP = [0, 0, 0, 0, 0], this.h0 = 0));
    }
    computePixelRatio() {
      return this.Tl !== null ? this.Tl : root.devicePixelRatio || 1;
    }
    get avgSpf() {
      return this.l0;
    }
    doMouseDown() {
      this.currentTool.doMouseDown();
    }
    doMouseMove() {
      this.currentTool.doMouseMove();
    }
    doMouseUp() {
      this.currentTool.doMouseUp();
    }
    doMouseWheel() {
      this.currentTool.doMouseWheel();
    }
    doKeyDown() {
      this.currentTool.doKeyDown();
    }
    doKeyUp() {
      this.currentTool.doKeyUp();
    }
    doFocus() {
      this.focus();
    }
    focus() {
      if (this.xt)
        if (this.scrollsPageOnFocus)
          this.xt.focus();
        else {
          const t = root.scrollX, i = root.scrollY;
          this.xt.focus(), root.scrollTo(t, i);
        }
    }
    rR(t) {
      _Diagram.he.get(this).V("GainedFocus");
    }
    oR(t) {
      _Diagram.he.get(this).V("LostFocus");
    }
    RM() {
      if (this.xt === null)
        return;
      const i = this.Ot;
      if (i === null || i.clientWidth === 0 || i.clientHeight === 0)
        return;
      this.WM || this.setScrollWidth();
      const e = this.io ? this.wi : 0, s = this.kn ? this.wi : 0, n = this.Gi;
      if (this.Gi = this.computePixelRatio(), this.Gi !== n && (this.Xu = true, this.requestUpdate()), i.clientWidth !== this.Ct + e || i.clientHeight !== this.At + s) {
        this.ca(), this.qe = true;
        const o = this.layout;
        o !== null && o.isViewportSized && this.autoScale === 1 && (this.Xf = true, o.invalidateLayout()), this.Ps || this.requestUpdate();
      }
    }
    gA() {
      let t = 0, i = new Layer2();
      i.name = "Grid", i.allowSelect = false, i.pickable = false, i.isTemporary = true, i.isInDocumentBounds = false, this.Qr(i, t++), i = new Layer2(), i.name = "ViewportBackground", i.isViewportAligned = true, i.isTemporary = true, i.isInDocumentBounds = false, this.Qr(i, t++), i = new Layer2(), i.name = "Background", this.Qr(i, t++), i = new Layer2(), i.name = "", this.Qr(i, t++), i = new Layer2(), i.name = "Foreground", this.Qr(i, t++), i = new Layer2(), i.name = "ViewportForeground", i.isViewportAligned = true, i.isTemporary = true, i.isInDocumentBounds = false, this.Qr(i, t++), i = new Layer2(), i.name = "Adornment", i.isTemporary = true, i.isInDocumentBounds = false, this.Qr(i, t++), i = new Layer2(), i.name = "Tool", i.isTemporary = true, i.isInDocumentBounds = true, this.Qr(i, t++);
    }
    bA() {
      const t = new Panel2(Panel2.Grid, { name: "GRID" }).add(new Shape2("LineH", { stroke: "lightgray", strokeWidth: 0.5, interval: 1 }).theme("stroke", "gridMinor"), new Shape2("LineV", { stroke: "lightgray", strokeWidth: 0.5, interval: 1 }).theme("stroke", "gridMinor"), new Shape2("LineH", { stroke: "gray", strokeWidth: 0.5, interval: 5 }).theme("stroke", "gridMajor"), new Shape2("LineV", { stroke: "gray", strokeWidth: 0.5, interval: 5 }).theme("stroke", "gridMajor"), new Shape2("LineH", { stroke: "gray", strokeWidth: 1, interval: 10 }).theme("stroke", "gridMajor"), new Shape2("LineV", { stroke: "gray", strokeWidth: 1, interval: 10 }).theme("stroke", "gridMajor")), i = new Part2({ layerName: "Grid", zOrder: 0, isInDocumentBounds: false, isAnimated: false, pickable: false, locationObjectName: "GRID" }).add(t);
      return this.add(i), this.partManager.parts.remove(i), t.visible = false, t;
    }
    static jF() {
      const t = _Diagram.he.get(this.parentElement || this);
      if (t) {
        if (t.s1) {
          t.s1 = false;
          return;
        }
        if (!t.isEnabled) {
          t.kA();
          return;
        }
        t.diagramScroll(this);
      }
    }
    static JF(t) {
      if (!this.b.isEnabled) {
        this.b.updateScroll();
        return;
      }
      this.b.o1 = t.target.scrollTop, this.b.l1 = t.target.scrollLeft;
    }
    diagramScroll(t) {
      if (this.xt === null)
        return;
      const i = this.g1, e = this.m1;
      this.$m = true;
      let s = this.documentBounds, n = this.viewportBounds;
      const o = this.Vf;
      let r = s.x - o.left, l = s.y - o.top;
      const h = s.width + o.left + o.right, a = s.height + o.top + o.bottom;
      let f = s.right + o.right, c = s.bottom + o.bottom, u = n.x, d = n.y;
      const m = n.width, g = n.height;
      let p = n.right, y = n.bottom;
      const x = this.scale;
      let b, k = t.scrollLeft;
      if (this.ju)
        switch (this.Cx) {
          case "negative":
            k = k + t.scrollWidth - t.clientWidth;
            break;
          case "reverse":
            k = t.scrollWidth - k - t.clientWidth;
            break;
        }
      const S = k;
      if (m < h || g < a) {
        b = Point2.H(this.position.x, this.position.y), this.allowHorizontalScroll && this.l1 !== S && (b.x = S / x + r, this.l1 = S), this.allowVerticalScroll && this.o1 !== t.scrollTop && (b.y = t.scrollTop / x + l, this.o1 = t.scrollTop), this.position = b, Point2.o(b), this.$m = false, this.Gu = false;
        return;
      }
      if (b = Point2.a(), t.ZF && this.allowHorizontalScroll && (r < u && (this.position = b.e(S + r, this.position.y)), f > p)) {
        const M = i.scrollWidth - this.Ct;
        this.position = b.e(-M + S - this.Ct / x + f, this.position.y);
      }
      if (t.$F && this.allowVerticalScroll && (l < d && (this.position = b.e(this.position.x, t.scrollTop + l)), c > y)) {
        const M = i.scrollHeight - this.At;
        this.position = b.e(this.position.x, -M + t.scrollTop - this.At / x + c);
      }
      Point2.o(b), this.oh(), this.$m = false, this.Gu = false, s = this.documentBounds, n = this.viewportBounds, f = s.right, p = n.right, c = s.bottom, y = n.bottom, r = s.x, u = n.x, l = s.y, d = n.y, m >= h && r >= u && f <= p && (e.style.width = "1px"), g >= a && l >= d && c <= y && (e.style.height = "1px");
    }
    computeBounds(t) {
      return t === void 0 && (t = new Rect2()), this.Fi(), this.SA(t);
    }
    SA(t) {
      if (this.fixedBounds.isReal())
        return t.c(this.fixedBounds), t.addMargin(this.ei), t;
      let i = true;
      const e = this.Jt.h, s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n];
        if (!o.visible || !o.isInDocumentBounds)
          continue;
        const r = o.It.h, l = r.length;
        for (let h = 0; h < l; h++) {
          const a = r[h];
          if (!a.isInDocumentBounds || !a.isVisible())
            continue;
          const f = a.actualBounds;
          f.isReal() && (i ? (i = false, t.c(f)) : t.unionRect(f));
        }
      }
      return i && t.e(0, 0, 0, 0), t.addMargin(this.ei), t;
    }
    computePartsBounds(t, i) {
      i === void 0 && (i = false);
      let e = null;
      if (Array.isArray(t))
        for (let s = 0; s < t.length; s++) {
          const n = t[s];
          !i && n instanceof Link2 || (n.ensureBounds(), e === null ? e = n.actualBounds.copy() : e.unionRect(n.actualBounds));
        }
      else {
        const s = t.iterator;
        for (; s.next(); ) {
          const n = s.value;
          !i && n instanceof Link2 || (n.ensureBounds(), e === null ? e = n.actualBounds.copy() : e.unionRect(n.actualBounds));
        }
      }
      return e === null ? new Rect2(NaN, NaN, 0, 0) : e;
    }
    Hs(t) {
      if (!t && !this.eo || this.$t || this.xt === null || !this.documentBounds.isReal())
        return;
      if (this.$t = true, t) {
        const c = this.initialPosition;
        if (c.isReal()) {
          this.$t = false, this.position = c;
          return;
        }
        let u = this.initialDocumentSpot, d = this.initialViewportSpot;
        u.isNoSpot() && (u = Spot2.TopLeft), d.isNoSpot() && (d = Spot2.TopLeft);
        const m = Point2.a();
        m.setRectSpot(this.documentBounds, u);
        const g = this.viewportBounds, p = Rect2.H(0, 0, g.width, g.height), y = Point2.a();
        y.setRectSpot(p, d), y.e(m.x - y.x, m.y - y.y), this.$t = false, this.position = y, Rect2.o(p), Point2.o(y);
      }
      let i = this.Ql;
      t && this.Ir !== 1 && (i = this.Ir);
      const e = i !== 1 ? this.Zu(i) : this.scale, s = this.lt.x, n = this.lt.y, o = this.Ct / e, r = this.At / e;
      let l = this.Bf;
      const h = this.Wm;
      if (t && !l.isSpot() && (h.isSpot() || h.isDefault())) {
        const c = this.initialDocumentSpot.isSpot() && this.initialViewportSpot.isSpot();
        l = h.isDefault() && !c ? Spot2.Center : h;
      }
      this.MP(this.documentBounds, o, r, l, t);
      const a = this.scale;
      this.scale = e, this.$t = false;
      const f = this.viewportBounds;
      f.equalsApproxTo(s, n, o, r) || this.onViewportBoundsChanged(new Rect2(s, n, o, r), f, a, false);
    }
    Zu(t) {
      const i = this.s0;
      if (this.xt === null)
        return i;
      this.ensureBounds();
      const e = this.documentBounds;
      if (!e.isReal())
        return i;
      const s = e.width, n = e.height, o = this.Ct + (this.io ? this.wi : 0), r = this.At + (this.kn ? this.wi : 0), l = o / s, h = r / n;
      let a;
      return t === 2 ? (a = Math.min(h, l), a > i && (a = i), a < this.minScale && (a = this.minScale), a > this.maxScale && (a = this.maxScale), a) : t === 3 ? (a = 0, h > l ? a = (r - this.wi) / n : a = (o - this.wi) / s, a > i && (a = i), a < this.minScale && (a = this.minScale), a > this.maxScale && (a = this.maxScale), a) : this.scale;
    }
    zoomToFit() {
      const t = this.Zh;
      this.Zh = 1, this.scale = this.Zu(2), t !== 1 && (this.Hs(false), this.MP(this.documentBounds, this.Ct / this.v, this.At / this.v, this.Bf, false)), this.Zh = t;
    }
    zoomToRect(t, i) {
      i === void 0 && (i = 2);
      const e = t.width, s = t.height;
      if (e === 0 || s === 0 || isNaN(e) && isNaN(s))
        return;
      let n = 1;
      if (i === 2 || i === 3)
        if (isNaN(e))
          n = this.viewportBounds.height * this.scale / s;
        else if (isNaN(s))
          n = this.viewportBounds.width * this.scale / e;
        else {
          const o = this.Ct, r = this.At;
          i === 3 ? r / s > o / e ? n = (r - (this.kn ? this.wi : 0)) / s : n = (o - (this.io ? this.wi : 0)) / e : n = Math.min(r / s, o / e);
        }
      this.scale = n, this.position = new Point2(t.x, t.y);
    }
    get lR() {
      return this.$t;
    }
    set lR(t) {
      this.$t = t;
    }
    alignDocument(t, i) {
      this.ensureBounds();
      const e = this.documentBounds, s = this.viewportBounds;
      this.position = new Point2(e.x + (t.x * e.width + t.offsetX) - (i.x * s.width - i.offsetX), e.y + (t.y * e.height + t.offsetY) - (i.y * s.height - i.offsetY));
    }
    focusObject(t) {
      if (t instanceof GraphObject2) {
        this.a0 = t;
        const i = Point2.a();
        this.f0 = this.transformDocToView(t.getDocumentPoint(Spot2.TopLeft, i)), Point2.o(i);
      } else
        this.a0 = null, this.f0 = Point2.Ek;
    }
    MP(t, i, e, s, n) {
      const o = Point2.H(this.lt.x, this.lt.y);
      let r = o.x, l = o.y;
      if (this.a0 !== null) {
        let h = Point2.a();
        h = this.a0.getDocumentPoint(Spot2.TopLeft, h), r = h.x - this.f0.x / this.scale, l = h.y - this.f0.y / this.scale, s = Spot2.None, Point2.o(h);
      }
      if (n || this.scrollMode === 1) {
        s.isSpot() && (i > t.width && (r = t.x + (s.x * t.width + s.offsetX) - (s.x * i - s.offsetX)), e > t.height && (l = t.y + (s.y * t.height + s.offsetY) - (s.y * e - s.offsetY)));
        const h = this.Vf, a = i - t.width;
        if (i < t.width + h.left + h.right) {
          let c = r + i / 2;
          c = Math.min(c, t.right + Math.max(a, h.right) - i / 2), c = Math.max(c, t.left - Math.max(a, h.left) + i / 2), r = c - i / 2;
        } else
          r > t.left ? r = t.left : r < t.right - i && (r = t.right - i);
        const f = e - t.height;
        if (e < t.height + h.top + h.bottom) {
          let c = l + e / 2;
          c = Math.min(c, t.bottom + Math.max(f, h.bottom) - e / 2), c = Math.max(c, t.top - Math.max(f, h.top) + e / 2), l = c - e / 2;
        } else
          l > t.top ? l = t.top : l < t.bottom - e && (l = t.bottom - e);
      }
      if (o.x = isFinite(r) ? r : -this.ei.left, o.y = isFinite(l) ? l : -this.ei.top, this.positionComputation !== null) {
        const h = this.positionComputation(this, o);
        o.x = h.x, o.y = h.y;
      }
      this.bs.tA(this.lt, o), o.x = Math.round(o.x), o.y = Math.round(o.y), this.lt.e(o.x, o.y), this.$r(), this.hR(), Point2.o(o);
    }
    findPartAt(t, i) {
      if (i === void 0 && (i = true), i) {
        const e = this.DS(t, (s) => s.part, (s) => s.canSelect());
        if (e instanceof Part2)
          return e;
      } else {
        const e = this.DS(t, (s) => s.part);
        if (e instanceof Part2)
          return e;
      }
      return null;
    }
    findObjectAt(t, i, e) {
      i === void 0 && (i = null), e === void 0 && (e = null), this.Fi();
      const s = this.Jt.iteratorBackwards;
      for (; s.next(); ) {
        const n = s.value;
        if (!n.visible)
          continue;
        const o = n.findObjectAt(t, i, e);
        if (o !== null)
          return o;
      }
      return null;
    }
    DS(t, i, e) {
      i === void 0 && (i = null), e === void 0 && (e = null), this.Fi();
      const s = this.Jt.iteratorBackwards;
      for (; s.next(); ) {
        const n = s.value;
        if (!n.visible || n.isTemporary)
          continue;
        const o = n.findObjectAt(t, i, e);
        if (o !== null)
          return o;
      }
      return null;
    }
    findPartsAt(t, i, e) {
      return i === void 0 && (i = true), this.aR(t, (s) => s.part, i ? (s) => s instanceof Part2 && s.canSelect() : null, e);
    }
    aR(t, i, e, s) {
      i === void 0 && (i = null), e === void 0 && (e = null), !(s instanceof List2) && !(s instanceof GSet2) && (s = new GSet2()), this.Fi();
      const n = this.Jt.iteratorBackwards;
      for (; n.next(); ) {
        const o = n.value;
        !o.visible || o.isTemporary || o.findObjectsAt(t, i, e, s);
      }
      return s;
    }
    findObjectsAt(t, i, e, s) {
      i === void 0 && (i = null), e === void 0 && (e = null), !(s instanceof List2) && !(s instanceof GSet2) && (s = new GSet2()), this.Fi();
      const n = this.Jt.iteratorBackwards;
      for (; n.next(); ) {
        const o = n.value;
        o.visible && o.findObjectsAt(t, i, e, s);
      }
      return s;
    }
    findPartsIn(t, i, e, s) {
      return i === void 0 && (i = false), e === void 0 && (e = true), this.fR(t, null, (n) => n instanceof Part2 && (!e || n.canSelect()), i, s);
    }
    findObjectsIn(t, i, e, s, n) {
      i === void 0 && (i = null), e === void 0 && (e = null), s === void 0 && (s = false), !(n instanceof List2) && !(n instanceof GSet2) && (n = new GSet2()), this.Fi();
      const o = this.Jt.iteratorBackwards;
      for (; o.next(); ) {
        const r = o.value;
        r.visible && r.findObjectsIn(t, i, e, s, n);
      }
      return n;
    }
    IS(t, i, e, s, n, o) {
      const r = new GSet2();
      this.Fi();
      const l = this.Jt.iteratorBackwards;
      for (; l.next(); ) {
        const h = l.value;
        h.visible && h.IS(t, i, e, s, r, n, o);
      }
      return r;
    }
    fR(t, i, e, s, n) {
      i === void 0 && (i = null), e === void 0 && (e = null), s === void 0 && (s = false), !(n instanceof List2) && !(n instanceof GSet2) && (n = new GSet2()), this.Fi();
      const o = this.Jt.iteratorBackwards;
      for (; o.next(); ) {
        const r = o.value;
        !r.visible || r.isTemporary || r.findObjectsIn(t, i, e, s, n);
      }
      return n;
    }
    findPartsNear(t, i, e, s, n) {
      return e === void 0 && (e = true), s === void 0 && (s = true), this.cR(t, i, null, (o) => o instanceof Part2 && (!s || o.canSelect()), e, n);
    }
    findObjectsNear(t, i, e, s, n, o) {
      e === void 0 && (e = null), s === void 0 && (s = null), n === void 0 && (n = true), n !== false && n !== true && ((n instanceof List2 || n instanceof GSet2) && (o = n), n = true), !(o instanceof List2) && !(o instanceof GSet2) && (o = new GSet2()), this.Fi();
      const r = this.Jt.iteratorBackwards;
      for (; r.next(); ) {
        const l = r.value;
        l.visible && l.findObjectsNear(t, i, e, s, n, o);
      }
      return o;
    }
    cR(t, i, e, s, n, o) {
      e === void 0 && (e = null), s === void 0 && (s = null), n === void 0 && (n = true), n !== false && n !== true && ((n instanceof List2 || n instanceof GSet2) && (o = n), n = true), !(o instanceof List2) && !(o instanceof GSet2) && (o = new GSet2()), this.Fi();
      const r = this.Jt.iteratorBackwards;
      for (; r.next(); ) {
        const l = r.value;
        !l.visible || l.isTemporary || l.findObjectsNear(t, i, e, s, n, o);
      }
      return o;
    }
    acceptEvent(t) {
      return this.qf(t, t instanceof MouseEvent);
    }
    qf(t, i) {
      const e = this.jr;
      this.jr = this.ia, this.ia = e, e.diagram = this, e.event = t, i ? this.u0(t, e) : (e.viewPoint = this.jr.viewPoint, e.documentPoint = this.jr.documentPoint);
      let s = 0;
      const n = t;
      return n.ctrlKey && (s += 1), n.altKey && (s += 2), n.shiftKey && (s += 4), n.metaKey && (s += 8), e.modifiers = s, e.button = n.button, n.buttons !== void 0 && (e.buttons = n.buttons), Util.dr && n.button === 0 && n.ctrlKey && (e.button = 2), e.down = false, e.up = false, e.clickCount = 1, e.delta = 0, e.handled = false, e.bubbles = false, e.timestamp = t.timeStamp, e.isMultiTouch = false, e.targetDiagram = this.SP(t, t.target), e.targetObject = null, e;
    }
    SP(t, i) {
      if (i === null)
        return null;
      const e = _Diagram.he.get(i);
      if (e)
        return e;
      let s = t.path;
      return !s && typeof t.composedPath == "function" && (s = t.composedPath()), s && s[0] && _Diagram.he.has(s[0]) ? _Diagram.he.get(s[0]) : null;
    }
    QF(t, i, e) {
      const s = this.kP(t, true, false, false, true, e);
      return this.u0(i, s), s.targetDiagram = this.SP(t, t.target), s.targetObject = null, e || s.clone(this.e0), s;
    }
    _F(t, i, e) {
      const s = this.kP(t, false, false, false, false, e);
      let n = root.document.elementFromPoint(i.clientX, i.clientY) || null;
      n !== null && n.shadowRoot !== void 0 && n.shadowRoot !== null && (n = n.shadowRoot.elementFromPoint(i.clientX, i.clientY));
      let o = this, r = t;
      return n && _Diagram.he.get(n) && (r = i, o = _Diagram.he.get(n)), s.targetDiagram = o, this.u0(r, s), s.targetObject = null, s;
    }
    kP(t, i, e, s, n, o) {
      const r = this.jr;
      this.jr = this.ia, this.ia = r, r.diagram = this, r.clickCount = 1, r.delta = 0;
      let l = 0;
      return t.ctrlKey && (l += 1), t.altKey && (l += 2), t.shiftKey && (l += 4), t.metaKey && (l += 8), r.modifiers = l, r.event = t, r.timestamp = t.timeStamp, r.button = e ? this.firstInput.button : t.button, r.buttons = t.buttons, Util.dr && t.button === 0 && t.ctrlKey && (r.button = 2), r.down = i, r.up = e, r.handled = s, r.bubbles = n, r.isMultiTouch = o, r;
    }
    fa(t, i) {
      return t.bubbles ? (Debug && Debug.handleMessages && Util.ft("NOT handled " + i.type + " " + t.toString()), true) : (Debug && Debug.handleMessages && Util.ft("handled " + i.type + " " + this.currentTool.name + " " + t.toString()), i.stopPropagation !== void 0 && i.stopPropagation(), i.cancelable !== false && i.preventDefault(), i.cancelBubble = true, false);
    }
    sR(t) {
      const i = _Diagram.he.get(this);
      if (!i.isEnabled)
        return false;
      const e = i.qf(t, false);
      return e.key = t.key, e.code = t.code, e.down = true, i.doKeyDown(), i.fa(e, t);
    }
    nR(t) {
      const i = _Diagram.he.get(this);
      if (!i.isEnabled)
        return false;
      const e = i.qf(t, false);
      return e.key = t.key, e.code = t.code, e.up = true, i.doKeyUp(), i.fa(e, t);
    }
    iR(t) {
      const i = _Diagram.he.get(this);
      if (!i.isEnabled)
        return false;
      const e = i.qf(t, true);
      return i.mouseEnter !== null && i.mouseEnter(e), i.currentTool.standardMouseOver(), i.fa(e, t);
    }
    eR(t) {
      const i = _Diagram.he.get(this);
      if (!i.isEnabled)
        return false;
      const e = i.qf(t, true);
      return i.mouseLeave !== null && i.mouseLeave(e), i.fa(e, t);
    }
    getMouse(t) {
      const i = this.xt;
      if (i === null)
        return new Point2(0, 0);
      const e = i.getBoundingClientRect(), s = (t.clientX - e.left) * (this.Ct / e.width), n = (t.clientY - e.top) * (this.At / e.height);
      return this.D !== null ? new Point2(s, n).Ge(this.D) : new Point2(s, n);
    }
    u0(t, i) {
      const e = this.xt;
      let s = 0, n = 0;
      if (e !== null) {
        const o = e.getBoundingClientRect();
        s = (t.clientX - o.left) * (this.Ct / o.width), n = (t.clientY - o.top) * (this.At / o.height);
      }
      if (i.viewPoint.e(s, n), this.D !== null) {
        const o = Point2.H(s, n);
        this.D.rs(o), i.documentPoint.c(o), Point2.o(o);
      } else
        i.documentPoint.e(s, n);
    }
    NC(t, i, e) {
      let s;
      if (this.na[0] !== null)
        s = this.na[i];
      else
        return;
      const n = this.xt;
      if (n !== null) {
        const o = n.getBoundingClientRect();
        e.e((s.clientX - o.left) * (this.Ct / o.width), (s.clientY - o.top) * (this.At / o.height));
      }
    }
    invalidateDocumentBounds() {
      this.ea || (this.ea = true, this.requestUpdate(false));
    }
    uR() {
      this.Ps || this.Fi(), this.ensureBounds();
    }
    redraw() {
      this.$t || this.Ps || (this.T(), this.maybeUpdate());
    }
    isUpdateRequested() {
      return this.Tr;
    }
    delayInitialization(t) {
      t === void 0 && (t = null);
      const i = this.animationManager, e = i.isEnabled;
      i.stopAnimation(), i.isEnabled = false, this.Pr(), this.eo = false, this.fx = new Point2(NaN, NaN), i.isEnabled = e, this.Ps = true;
      const s = this;
      t !== null && Util.Xh(() => {
        s.Ps = false, i.zl("Model"), t(s);
      }, 1);
    }
    requestUpdate(t) {
      if (t === void 0 && (t = false), this.Tr === true || this.$t || t === false && this.Ps)
        return;
      this.Tr = true;
      const i = this;
      root.requestAnimationFrame(() => {
        i.Tr && i.maybeUpdate();
      });
    }
    maybeUpdate() {
      this.Yu && !this.Tr || (this.Yu && (this.Yu = false), this.Pr());
    }
    PP(t, i) {
      !this.Gu || this.$t || this.animationManager.defaultAnimation.isAnimating || this.kA() || (t && this.Fi(), i && this.Hs(false));
    }
    Pr(t) {
      if (this.Ps || (this.Tr = false, this.Ot === null && !this.Hu.isReal()))
        return;
      this.Ps = true;
      const i = this.animationManager, e = this.Wu;
      if (!i.isAnimating && e.length !== 0) {
        const f = e.h, c = f.length;
        for (let u = 0; u < c; u++) {
          const d = f[u];
          d.ae(false), d.u();
        }
        e.clear();
      }
      const s = this.uP;
      s.count > 0 && (s.each((f) => f.NP()), s.clear());
      let n = false, o = false;
      i.defaultAnimation.isAnimating && (o = true, n = this.skipsUndoManager, this.skipsUndoManager = true), i.Mi || this.RM(), t || this.PP(false, true), this.ls !== null && (this.ls.visible && !this.t0 && (this._r(), this.t0 = true), !this.ls.visible && this.t0 && (this.t0 = false));
      const r = !this.undoManager.isUndoingRedoing && (this.Al || this.vf.count !== 0 && this.Or.size !== 0), l = !this.eo || this.Jr;
      this.Fi(true);
      let h = false;
      (l || r) && (this.eo ? this.CP(!this.Xf, r) : (this.startTransaction("Initial Layout"), i.isEnabled === false && i.stopAnimation(), this.CP(false, r)), h = l), this.Xf = false, this.Al = false, this.Fi(), this.vx || this.uR(), t || this.PP(true, false);
      let a = false;
      if (h) {
        const f = Rect2.a();
        f.c(this.viewportBounds), this.eo || (this.eo = true, a = true, this.skipsUndoManager || (this.undoManager.Kw = true), this.undoManager.Uw = true, this.dR()), this.gR(), this.Fi(false), t || this.PP(true, true), Rect2.o(f);
      } else if (i.Lf && i.ax) {
        if (this.Ir !== 1)
          this.scale = this.Zu(this.Ir);
        else if (this.Ql !== 1)
          this.scale = this.Zu(this.Ql);
        else {
          const f = this.initialScale;
          isFinite(f) && f > 0 && (this.scale = f);
        }
        this.Hs(true);
      }
      h && a && this.commitTransaction("Initial Layout"), t || this.Ji(this.ai), o && (this.skipsUndoManager = n), this.Ps = false;
    }
    get Uh() {
      return this.eo;
    }
    dR() {
      if (this.Ir !== 1)
        this.scale = this.Zu(this.Ir);
      else if (this.Ql !== 1)
        this.scale = this.Zu(this.Ql);
      else {
        const i = this.initialScale;
        isFinite(i) && i > 0 && (this.scale = i);
      }
      this.Hs(true);
      const t = this.Jt.h;
      this.Gs(t, t.length, this, this.viewportBounds), this.V("InitialLayoutCompleted"), this.fx.c(this.lt), this._r();
    }
    gR() {
      this.V("LayoutCompleted");
    }
    d0(t) {
      this._n.add(t);
    }
    addInvalidRoute(t) {
      this.zo ? this._h.add(t) : this.Or.add(t);
    }
    Fi(t) {
      if (this._n.size !== 0 && !(!this.Ps && this.animationManager.isTicking)) {
        if (this.Ps || (this.Al = true), t) {
          this.MA(this._n);
          return;
        }
        for (let i = 0; i < 23 && this._n.size !== 0; i++) {
          const e = new Set(this._n);
          this._n.clear(), this.NP(e, this._n), Debug && i === 22 && Util.ft("failure to validate parts");
        }
        this.nodes.each((i) => {
          i instanceof Group2 && i.PA(false);
        });
      }
    }
    MA(t, i) {
      for (const e of t)
        !e.De() || e instanceof Group2 || (e.tl() ? (e.wt(1 / 0, 1 / 0), e.vt()) : i && i.add(e));
      for (const e of t)
        if (e instanceof Group2) {
          if (!e.isVisible())
            continue;
          this.L1(e);
        }
    }
    NP(t, i) {
      this.MA(t, i);
      for (const e of t) {
        if (!(e instanceof Link2))
          continue;
        const s = e;
        s.isVisible() && (s.tl() ? (s.wt(1 / 0, 1 / 0), s.vt()) : i.add(s));
      }
      for (const e of t)
        e instanceof Adornment2 && e.isVisible() && (e.tl() ? (e.wt(1 / 0, 1 / 0), e.vt()) : i.add(e));
    }
    g0(t) {
      const i = t instanceof _Diagram, e = i ? t.links : t.memberParts, s = this._n;
      if (i)
        this.Fi(true);
      else {
        for (; e.next(); ) {
          const n = e.value;
          s.has(n) && (!n.De() || n instanceof Group2 || n.tl() && (n.wt(1 / 0, 1 / 0), n.vt()));
        }
        for (e.reset(); e.next(); ) {
          const n = e.value;
          if (s.has(n) && n instanceof Group2) {
            if (!n.isVisible())
              continue;
            this.L1(n);
          }
        }
        e.reset();
      }
      for (; e.next(); ) {
        const n = e.value;
        n instanceof Link2 && s.has(n) && n.isVisible() && n.tl() && (n.wt(1 / 0, 1 / 0), n.vt());
      }
    }
    L1(t) {
      const i = Util.ct(), e = Util.ct(), s = t.memberParts;
      for (; s.next(); ) {
        const o = s.value;
        o.isVisible() && (o instanceof Group2 ? (o.Ko() || o.hs() || o.rh()) && this.L1(o) : o instanceof Link2 ? o.fromNode === t || o.toNode === t ? e.push(o) : i.push(o) : (o.wt(1 / 0, 1 / 0), o.vt()));
      }
      let n = i.length;
      for (let o = 0; o < n; o++) {
        const r = i[o];
        r.wt(1 / 0, 1 / 0), r.vt();
      }
      Util.ot(i), t.wt(1 / 0, 1 / 0), t.vt(), n = e.length;
      for (let o = 0; o < n; o++) {
        const r = e[o];
        r.wt(1 / 0, 1 / 0), r.vt();
      }
      Util.ot(e);
    }
    Gs(t, i, e, s) {
      if (!(!this.Kf && !this.animationManager.isAnimating)) {
        for (let n = 0; n < i; n++)
          t[n].Gs(e, s);
        this.Fi();
      }
    }
    Ji(t) {
      if (this.Ot === null)
        return;
      this.xt === null && Util.n("No canvas specified"), this.Yf === "svg" ? this.mR(t) : this.pR(t);
    }
    pR(t) {
      const i = this.animationManager;
      if (i.Mi || i.isAnimating && !i.isTicking)
        return;
      const e = /* @__PURE__ */ new Date();
      if (this.m0(), this.Ot.style.opacity === "0")
        return;
      const s = t !== this.ai, n = this.Jt.h, o = n.length, r = this;
      if (this.Gs(n, o, r, r.viewportBounds), s)
        t.clearContextCache(true), this.oh();
      else if (!this.qe && !i.isAnimating)
        return;
      const l = this.D;
      l.ti();
      const h = this.Gi, a = this.lt, f = this.v;
      f !== 1 && l.v(f), (a.x !== 0 || a.y !== 0) && l.se(-a.x, -a.y), t.setTransform(h, 0, 0, h, 0, 0), t.clearRect(0, 0, this.Ct, this.At), this._t !== 1 && (t.globalAlpha = this._t), this.AP(t);
      for (let p = 0; p < o; p++)
        t.setTransform(h, 0, 0, h, 0, 0), t.transform(l.m11, l.m12, l.m21, l.m22, l.dx, l.dy), t.commitTransform(), n[p].Ji(t, r);
      let c = false;
      this.Hf ? this.Hf.Ju(this) && (c = this.p1()) : c = true, c && (Transform.prototype.rs = Transform.prototype.Pw), s ? (this.ai.clearContextCache(true), this.oh()) : (this.Kf = false, this.qe = false);
      const d = +/* @__PURE__ */ new Date() - +e, m = Debug && Debug.drawFrames, g = this.yP;
      if (m || this.Tl === null) {
        g[this.h0] = d, this.h0 = (this.h0 + 1) % g.length;
        let p = 0;
        for (let y = 0; y < g.length; y++)
          p += g[y];
        this.l0 = p / g.length;
      }
      if (this._t !== 1 && (t.globalAlpha = 1), m) {
        t.setTransform(1, 0, 0, 1, 0, 0);
        for (let p = 0; p < g.length; p++)
          t.fillText(g[p].toString(), 20, 150 + +(p * 20));
      }
    }
    mR(t) {
      if (this.Ot === null)
        return;
      const i = this.animationManager;
      if (i.Mi || i.isAnimating && !i.isTicking)
        return;
      this.m0();
      const e = this.Ct, s = this.At;
      t.surface.resize(e, s, e, s);
      const o = this.Jt.h, r = o.length, l = this;
      if (this.Gs(o, r, l, l.viewportBounds), !this.qe && !i.isAnimating)
        return;
      const h = this.lt, a = this.v, f = this.D;
      f.ti(), a !== 1 && f.v(a), (h.x !== 0 || h.y !== 0) && f.se(-h.x, -h.y), t.lastDrawnPart = null, t.setDiagramPosScale(f.m11, f.m12, f.m21, f.m22, f.dx, f.dy), this._t !== 1 && (t.globalAlpha = this._t), this.AP(t);
      const c = this.Gi;
      this.xt.gi.setTransform(c, 0, 0, c, 0, 0), this.xt.gi.clearRect(0, 0, this.Ct, this.At);
      for (let d = 0; d < r; d++)
        o[d].Ji(t, l);
      let u = false;
      this.Hf ? this.Hf.Ju(this) && (u = this.p1()) : u = true, u && (Transform.prototype.rs = Transform.prototype.Pw), this.Kf = false, this.qe = false;
    }
    T1(t, i, e, s, n, o, r, l, h) {
      if (this.Ot === null)
        return;
      this.xt === null && Util.n("No canvas specified"), o === void 0 && (o = null), r === void 0 && (r = null), l === void 0 && (l = false), h === void 0 && (h = false), this.m0(), this.ai.clearContextCache(true), this.oh(), this.sa = true;
      const a = this.v;
      this.v = s;
      const f = this, c = this.Jt.h, u = c.length;
      try {
        const d = new Rect2(n.x, n.y, e.width / s, e.height / s), m = d.copy();
        m.addMargin(i), this._r(m), this.Fi(), this.Gs(c, u, f, d), t.setTransform(1, 0, 0, 1, 0, 0), t.clearRect(0, 0, e.width, e.height), r !== null && r !== "" && (t.fillStyle = r, t.fillBackground(0, 0, e.width, e.height));
        const g = this.Gi;
        t.scale(g, g);
        const p = Transform.a();
        p.ti(), p.se(i.left, i.top), p.v(s), (n.x !== 0 || n.y !== 0) && p.se(-n.x, -n.y), t.setTransform(p.m11, p.m12, p.m21, p.m22, p.dx, p.dy), t.commitTransform(), t instanceof SVGContext && t.setDiagramPosScale(p.m11, p.m12, p.m21, p.m22, p.dx, p.dy), Transform.o(p), this.AP(t), t.globalAlpha = this._t;
        const y = this.findLayer("Grid");
        if (o) {
          const x = new GSet2(), b = o.iterator;
          for (b.reset(); b.next(); ) {
            const k = b.value;
            k instanceof Part2 && (!h && k.layer === y || (k.Bu(), x.add(k)));
          }
          for (let k = 0; k < u; k++)
            c[k].PF(t, f, x, l);
          x.each((k) => k.Bu());
        } else
          for (let x = 0; x < u; x++) {
            const b = c[x];
            b === y ? h && b.Ji(t, f, true) : b.Ji(t, f, l);
          }
        this.sa = false, this.Hf && this.Hf.Ju(this) && this.p1();
      } finally {
        this.v = a, this.ai.clearContextCache(true), this.oh(), this.Gs(c, u, f, f.viewportBounds), this._r(), this.ai instanceof SVGContext && (this.ai.diagramGroup.replaceChildren(), this.redraw());
      }
    }
    getRenderingHint(t) {
      return this.Rr[t];
    }
    setRenderingHint(t, i) {
      t === "minDrawingLength" && (this.Hm = i), this.Rr[t] = i, this.redraw();
    }
    resetRenderingHints() {
      this.Rr = new PropertyCollection(), this.Rr.drawShadows = true, this.Rr.textGreeking = true, this.Rr.viewportOptimizations = !Util.dr, this.Rr.temporaryPixelRatio = true, this.Rr.pictureRatioOptimization = true, this.Rr.minDrawingLength = 1, this.Hm = 1;
    }
    AP(t) {
      const i = this.Rr;
      if (i === null)
        return;
      if (i.imageSmoothingEnabled !== void 0) {
        const s = !!i.imageSmoothingEnabled;
        t.setImageSmoothingEnabled(s);
      }
      const e = i.defaultFont;
      e != null && (t.font = e);
    }
    getInputOption(t) {
      return this.zu[t];
    }
    setInputOption(t, i) {
      this.zu[t] = i;
    }
    GF() {
      this.zu = new PropertyCollection(), this.zu.extraTouchArea = 10, this.zu.extraTouchThreshold = 10, this.zu.hasGestureZoom = true;
    }
    set(t) {
      if (Debug)
        for (const i in t)
          (i.startsWith("_") || i.indexOf(".") !== -1) && Util.n("Property with underscore or period passed to Diagram.set. Did you mean to use Diagram.assign?");
      return Object.assign(this, t), this;
    }
    attach(t) {
      return this.setProperties(t);
    }
    setProperties(t) {
      return _Diagram.p0(this, t), this;
    }
    static p0(t, i) {
      const e = t instanceof Panel2, s = t instanceof _Diagram;
      for (const n in i) {
        n === "" && Util.n("Setting properties requires non-empty property names");
        let o = t, r = n;
        if (e || s) {
          const h = n.indexOf(".");
          if (h > 0) {
            const a = n.substring(0, h);
            e ? o = t.findObject(a) : (o = t[a], o == null && (o = t.toolManager[a])), Util.Mt(o) ? r = n.substring(h + 1) : Util.n("Unable to find object named: " + a + " in " + t.toString() + " when trying to set property: " + n);
          }
        }
        if (r[0] !== "_" && !Util.yw(o, r))
          if (s && r === "ModelChanged") {
            t.addModelChangedListener(i[r]);
            continue;
          } else if (s && r === "Changed") {
            t.addChangedListener(i[r]);
            continue;
          } else if (s && Util.yw(t.toolManager, r))
            o = t.toolManager;
          else if (s && t.NA(r)) {
            t.addDiagramListener(r, i[r]);
            continue;
          } else if (t instanceof Model2 && r === "Changed") {
            t.addChangedListener(i[r]);
            continue;
          } else
            Util.n('Trying to set undefined property "' + r + '" on object: ' + o.toString());
        const l = i[n];
        o[r] = l, r[0] === "_" && o instanceof GraphObject2 && o.addCopyProperty(r);
      }
    }
    yR() {
      if (this.sh.count !== 0 && !(this.undoManager.transactionLevel > 1)) {
        for (; this.sh.count > 0; ) {
          const t = this.sh;
          this.sh = new GMap2();
          const i = t.iterator;
          for (; i.next(); ) {
            const e = i.key;
            e.invalidateOtherJumpOvers(i.value), e.fe();
          }
        }
        this.T();
      }
    }
    T(t) {
      if (t === void 0)
        this.qe = true, this.requestUpdate();
      else {
        const i = this.viewportBounds;
        t.isReal() && i.intersectsRect(t) && (this.qe = true, this.requestUpdate());
      }
      this.V("InvalidateDraw");
    }
    invalidateViewport(t, i) {
      if (this.qe === true)
        return;
      if (this.qe = true, this.Yf === "svg") {
        this.maybeUpdate();
        return;
      }
      this.getRenderingHint("temporaryPixelRatio") === true ? (this.vw(), this.maybeUpdate(), this.NS(true)) : this.maybeUpdate();
    }
    ca() {
      this.Gu = true;
    }
    oh() {
      this.Kf = true;
    }
    m0() {
      this.Xu !== false && (this.Xu = false, this.xA(this.Ct, this.At));
    }
    xA(t, i) {
      this.$r();
      const e = this.Gi, s = t * e, n = i * e;
      this.xt.resize(s, n, t, i) && (this.qe = true, this.ai.clearContextCache(true));
    }
    kA() {
      const t = this.xt;
      if (t === null || this.Hu.isReal())
        return true;
      const i = this.Ct, e = this.At, s = this.Ot;
      let n = false, o = this.io ? this.wi : 0, r = this.kn ? this.wi : 0, l = s.clientWidth || i + o, h = s.clientHeight || e + r;
      const a = this.viewportBounds, f = a.x, c = a.y, u = a.width, d = a.height;
      if ((l !== i + o || h !== e + r) && (this.io = false, this.kn = false, o = 0, r = 0, this.Ct = l, this.At = h, this.Xu = true, n = true, this.$r()), !this.eo || !this.viewportBounds.isReal())
        return true;
      const m = this.g1, g = this.m1;
      if (this.Gu = false, !n && !this.io && !this.kn && !this.Ku && !this.Uu)
        return true;
      const p = this.documentBounds;
      let y = 0, x = 0, b = 0, k = 0;
      const S = a.width, M = a.height, A = this.Vf;
      this.contentAlignment.isSpot() ? (p.width > S && (y = A.left, x = A.right), p.height > M && (b = A.top, k = A.bottom)) : (y = A.left, x = A.right, b = A.top, k = A.bottom);
      const C = p.width + y + x, P = p.height + b + k, N = this.scale, T = N;
      let L = C > l / N, D = P > h / N;
      if (!n && !this.io && !this.kn && !L && !D)
        return true;
      const F = p.x - y, R = a.x, I = p.right + x;
      let O = a.right + o;
      const B = p.y - b, K = a.y, V = p.bottom + k;
      let X = a.bottom + r, z = "1px", G = "1px";
      if (this.scrollMode === 1 && (L || D)) {
        if (L && this.hasHorizontalScrollbar && this.allowHorizontalScroll) {
          let Y = 1;
          F + 1 < R && (Y = Math.max((R - F) * N + this.Ct, Y)), I > O + 1 && (Y = Math.max((I - O) * N + this.Ct, Y)), S + o + 1 < C && (Y = Math.max((C - S) * N + this.Ct, Y)), z = Y.toString() + "px";
        }
        if (D && this.hasVerticalScrollbar && this.allowVerticalScroll) {
          let Y = 1;
          B + 1 < K && (Y = Math.max((K - B) * N + this.At, Y)), V > X + 1 && (Y = Math.max((V - X) * N + this.At, Y)), M + r + 1 < P && (Y = Math.max((P - M) * N + this.At, Y)), G = Y.toString() + "px";
        }
      }
      let v = z !== "1px", q = G !== "1px";
      if (!(v && q) && (v || q)) {
        if (L = !(C < S + o), D = !(P < M + r), q && (O -= this.wi), v && (X -= this.wi), L && this.hasHorizontalScrollbar && this.allowHorizontalScroll) {
          let j = 1;
          F + 1 < R && (j = Math.max((R - F) * N + this.Ct, j)), I > O + 1 && (j = Math.max((I - O) * N + this.Ct, j)), S + 1 < C && (j = Math.max((C - S) * N + this.Ct, j)), z = j.toString() + "px";
        }
        v = z !== "1px";
        let Y = this.At;
        if (v !== this.kn && (Y = v ? this.At - this.wi : this.At + this.wi), D && this.hasVerticalScrollbar && this.allowVerticalScroll) {
          let j = 1;
          B + 1 < K && (j = Math.max((K - B) * N + Y, j)), V > X + 1 && (j = Math.max((V - X) * N + Y, j)), M + 1 < P && (j = Math.max((P - M) * N + Y, j)), G = j.toString() + "px";
        }
        q = G !== "1px";
      }
      if (this.$m && !(v !== this.kn || q !== this.io))
        return (i !== this.Ct || e !== this.At) && this.maybeUpdate(), false;
      if (v !== this.kn && (z === "1px" ? this.At = this.At + this.wi : this.At = Math.max(this.At - this.wi, 1), n = true), this.kn = v, g.style.width = z, q !== this.io && (G === "1px" ? this.Ct = this.Ct + this.wi : this.Ct = Math.max(this.Ct - this.wi, 1), n = true, this.ju)) {
        const Y = Point2.a();
        q ? (t.style.left = this.wi + "px", this.position = Y.e(this.lt.x + this.wi / this.scale, this.lt.y)) : (t.style.left = "0px", this.position = Y.e(this.lt.x - this.wi / this.scale, this.lt.y)), Point2.o(Y);
      }
      n && this.$r(), this.io = q, g.style.height = G, this.s1 = true, n && (this.Xu = true);
      let J = m.scrollLeft;
      if (this.hasHorizontalScrollbar && this.allowHorizontalScroll && (S + 1 < C ? J = (this.position.x - F) * N : F + 1 < R ? J = m.scrollWidth - m.clientWidth : I > O + 1 && (J = this.position.x * N)), this.ju)
        switch (this.Cx) {
          case "negative":
            J = -(m.scrollWidth - J - m.clientWidth);
            break;
          case "reverse":
            J = m.scrollWidth - J - m.clientWidth;
            break;
        }
      if (m.scrollLeft = J, this.hasVerticalScrollbar && this.allowVerticalScroll && (M + 1 < P ? m.scrollTop = (this.position.y - B) * N : B + 1 < K ? m.scrollTop = m.scrollHeight - m.clientHeight : V > X + 1 && (m.scrollTop = this.position.y * N)), l = this.Ct, h = this.At, m.style.width = l + (this.io ? this.wi : 0) + "px", m.style.height = h + (this.kn ? this.wi : 0) + "px", i !== l || e !== h || this.animationManager.Mi) {
        const Y = Rect2.H(f, c, u, d);
        return this.onViewportBoundsChanged(Y, this.viewportBounds, T, n), Rect2.o(Y), false;
      }
      return true;
    }
    add(t) {
      Util.s(t, Part2, _Diagram, "add:part");
      const i = t.diagram;
      if (i === this)
        return;
      i !== null && Util.n("Cannot add part " + t.toString() + " to " + this.toString() + ". It is already a part of " + i.toString());
      let e = this.findLayer(t.layerName);
      if (e === null && (e = this.findLayer("")), e === null && Util.n('Cannot add a Part when unable find a Layer named "' + t.layerName + '" and there is no default Layer'), t.layer === e)
        return;
      const s = e.Qh(99999999, t, t.diagram === this);
      s >= 0 && this.raiseChangedEvent(3, "parts", e, null, t, null, s), e.isTemporary || this.invalidateDocumentBounds(), t.invalidateLayout(1);
      const n = t.layerChanged;
      n !== null && n(t, null, e);
    }
    Qh(t) {
      this.partManager.Qh(t);
      const i = this;
      t.il((s) => i.CA(s)), t.data || t.Uo(), t.hasPlaceholder() && t.u(), t.data !== null && t.il((s) => i.partManager.LP(s, null)), (t.hs() === true || t.rh() === true) && this.d0(t), t.AA(true, this), t.LA() ? (t.actualBounds.isReal() && this.T(t.$h(t.actualBounds)), this.invalidateDocumentBounds()) : t.isVisible() && t.actualBounds.isReal() && this.T(t.$h(t.actualBounds)), this.requestUpdate();
    }
    re(t) {
      t.clearAdornments(), this.partManager.re(t);
      const i = this;
      t.data !== null && t.il((s) => i.partManager.TP(s, i)), this._n.delete(t), t instanceof Link2 && this.Or.delete(t), t.LA() ? (t.actualBounds.isReal() && this.T(t.$h(t.actualBounds)), this.invalidateDocumentBounds()) : t.isVisible() && t.actualBounds.isReal() && this.T(t.$h(t.actualBounds)), this.requestUpdate();
    }
    remove(t) {
      Util.s(t, Part2, _Diagram, "remove:part"), this.DP(t, true);
    }
    DP(t, i) {
      const e = t.layer;
      if (e === null || e.diagram !== this)
        return;
      t.isSelected = false, t.isHighlighted = false, t.invalidateLayout(2), i && t.Wf();
      const s = e.re(-1, t, false);
      s >= 0 && this.raiseChangedEvent(4, "parts", e, t, null, s, null);
      const n = t.layerChanged;
      n !== null && n(t, e, null);
    }
    removeParts(t, i) {
      if (i === void 0 && (i = false), Array.isArray(t)) {
        const e = t.length;
        for (let s = 0; s < e; s++) {
          const n = t[s];
          i && !n.canDelete() || this.remove(n);
        }
      } else {
        const e = new GSet2();
        e.addAll(t);
        const s = e.iterator;
        for (; s.next(); ) {
          const n = s.value;
          i && !n.canDelete() || this.remove(n);
        }
      }
    }
    copyParts(t, i, e) {
      return e === void 0 && (e = false), this.partManager.copyParts(t, i, e);
    }
    moveParts(t, i, e, s) {
      if (e === void 0 && (e = false), s === void 0 && (s = this.y0()), Util.s(i, Point2, _Diagram, "moveParts:offset"), this.toolManager === null)
        return;
      const o = new GMap2();
      if (t !== null)
        if (Array.isArray(t))
          for (let r = 0; r < t.length; r++)
            this.el(o, t[r], e, s);
        else {
          const r = t.iterator;
          for (; r.next(); )
            this.el(o, r.value, e, s);
        }
      else {
        let r = this.parts;
        for (; r.next(); ) {
          const l = r.value;
          this.el(o, l, e, s);
        }
        for (r = this.nodes; r.next(); ) {
          const l = r.value;
          this.el(o, l, e, s);
        }
        for (r = this.links; r.next(); ) {
          const l = r.value;
          this.el(o, l, e, s);
        }
      }
      this.LS(o, i, s, e);
    }
    el(t, i, e, s, n) {
      if (!t.contains(i) && (n === void 0 && (n = false), !(e && !n && !i.canMove() && !i.canCopy())))
        if (s === void 0 && (s = this.y0()), i instanceof Node2) {
          if (t.add(i, this.Us(s, i, i.location)), i instanceof Group2 && (i.hasPlaceholder() || s.dragsMembers)) {
            const r = i.memberParts;
            for (; r.next(); ) {
              const l = r.value;
              this.el(t, l, e, s, s.groupsAlwaysMove);
            }
          }
          const o = i.linksConnected;
          for (; o.next(); ) {
            const r = o.value;
            if (t.contains(r))
              continue;
            const l = r.fromNode, h = r.toNode;
            l !== null && t.contains(l) && h !== null && t.contains(h) && this.el(t, r, e, s);
          }
          if (s.dragsTree) {
            const r = i.findTreeChildrenNodes();
            for (; r.next(); ) {
              const l = r.value;
              this.el(t, l, e, s);
            }
          }
        } else if (i instanceof Link2) {
          t.add(i, this.Us(s, i));
          const o = i.labelNodes;
          for (; o.next(); ) {
            const r = o.value;
            this.el(t, r, e, s);
          }
        } else
          i instanceof Adornment2 || t.add(i, this.Us(s, i, i.location));
    }
    LS(t, i, e, s) {
      if (t === null || (Util.s(t, GMap2, _Diagram, "moveParts:parts"), t.count === 0))
        return;
      const n = Point2.a(), o = Point2.a();
      o.c(i), isNaN(o.x) && (o.x = 0), isNaN(o.y) && (o.y = 0);
      const r = this.k1;
      r || this.qw(t);
      const l = Util.ct(), h = Util.ct(), a = t.iterator;
      let f = Point2.a();
      for (; a.next(); ) {
        const g = a.key, p = a.value;
        if (g.De()) {
          const y = this.TA(g, t);
          if (y !== null)
            l.push(new DraggingNodeInfoPair(g, p, y));
          else if (!s || g.canMove()) {
            const x = p.point;
            n.c(x), this.computeMove(g, n.add(o), e, f), g.location = f, p.shifted === void 0 && (p.shifted = new Point2()), p.shifted.c(f.subtract(x));
          }
        } else
          a.key instanceof Link2 && h.push(new KeyValuePair(a.key, a.value));
      }
      Point2.o(f);
      const c = l.length;
      for (let g = 0; g < c; g++) {
        const p = l[g], y = p.DA.point;
        n.c(y), p.D1.shifted === void 0 && (p.D1.shifted = new Point2()), p.be.location = n.add(p.D1.shifted);
      }
      const u = Point2.a(), d = Point2.a(), m = h.length;
      for (let g = 0; g < m; g++) {
        const p = h[g], y = p.key;
        if (y instanceof Link2) {
          if (y.wn) {
            y.Dr = null;
            const x = y.fromNode, b = y.toNode;
            if (this.draggedLink !== null && e.dragsLink) {
              const k = p.value.point;
              if (y.dragComputation === null) {
                t.add(y, this.Us(e, y, o));
                const S = o.x - k.x, M = o.y - k.y;
                y.Mr(S, M);
              } else {
                const S = Point2.H(0, 0), M = y.getPoint(0);
                M && M.isReal() && S.c(M), f = Point2.a().c(S).add(o);
                let A = f;
                e.isGridSnapEnabled && (e.isGridSnapRealtime || this.lastInput.up) && (A = Point2.a(), this.mM(y, f, A, e)), f.c(y.dragComputation(y, f, A)).subtract(S), t.add(y, this.Us(e, y, f));
                const C = f.x - k.x, P = f.y - k.y;
                y.Mr(C, P), Point2.o(S), Point2.o(f), A !== f && Point2.o(A);
              }
            } else {
              if (x !== null) {
                u.c(x.location);
                const k = t.getValue(x);
                k !== null && u.subtract(k.point);
              }
              if (b !== null) {
                d.c(b.location);
                const k = t.getValue(b);
                k !== null && d.subtract(k.point);
              }
              if (x !== null && b !== null)
                if (u.equalsApprox(d)) {
                  const k = p.value.point, S = n;
                  S.c(u), S.subtract(k), t.add(y, this.Us(e, y, u)), y.Mr(S.x, S.y);
                } else
                  y.wn = false, y.invalidateRoute();
              else {
                const k = p.value.point;
                let S;
                x !== null ? S = u : b !== null ? S = d : S = o, t.add(y, this.Us(e, y, S));
                const M = S.x - k.x, A = S.y - k.y;
                y.Mr(M, A);
              }
            }
          } else if (y.fromNode === null || y.toNode === null) {
            const x = p.value.point;
            t.add(y, this.Us(e, y, o));
            const b = o.x - x.x, k = o.y - x.y;
            y.Mr(b, k);
          }
        }
      }
      Point2.o(n), Point2.o(o), Point2.o(u), Point2.o(d), Util.ot(l), Util.ot(h), r || (this.Fi(), this.Lm(t));
    }
    computeMove(t, i, e, s) {
      if (s === void 0 && (s = new Point2()), s.c(i), t === null)
        return s;
      let n = i;
      const o = e.isGridSnapEnabled;
      o && (e.isGridSnapRealtime || this.lastInput.up) && (n = Point2.a(), this.mM(t, i, n, e));
      const r = t.dragComputation !== null ? t.dragComputation(t, i, n) : n, l = t.minLocation;
      let h = l.x;
      isNaN(h) && (h = o ? Math.round(t.location.x * 1e3) / 1e3 : t.location.x);
      let a = l.y;
      isNaN(a) && (a = o ? Math.round(t.location.y * 1e3) / 1e3 : t.location.y);
      const f = t.maxLocation;
      let c = f.x;
      isNaN(c) && (c = o ? Math.round(t.location.x * 1e3) / 1e3 : t.location.x);
      let u = f.y;
      return isNaN(u) && (u = o ? Math.round(t.location.y * 1e3) / 1e3 : t.location.y), s.e(Math.max(h, Math.min(r.x, c)), Math.max(a, Math.min(r.y, u))), n !== i && Point2.o(n), s;
    }
    y0() {
      const t = this.toolManager.findTool("Dragging");
      return t instanceof DraggingTool2 ? t.dragOptions : this.M1;
    }
    mM(t, i, e, s) {
      if (s === void 0 && (s = this.y0()), e.c(i), t === null)
        return e;
      const n = this.grid, o = s.gridSnapCellSize;
      let r = o.width, l = o.height;
      const h = s.gridSnapOrigin;
      let a = h.x, f = h.y;
      const c = s.gridSnapCellSpot;
      if (n !== null) {
        const d = n.gridCellSize;
        isNaN(r) && (r = d.width), isNaN(l) && (l = d.height);
        const m = n.gridOrigin;
        isNaN(a) && (a = m.x), isNaN(f) && (f = m.y);
      }
      const u = Point2.H(0, 0);
      return u.setSpot(0, 0, r, l, c), Geo.vg(i.x, i.y, a + u.x, f + u.y, r, l, e), Point2.o(u), e;
    }
    qw(t) {
      if (t === null)
        return;
      this.k1 = true;
      const i = t.iterator;
      for (; i.next(); ) {
        const e = i.key;
        e instanceof Link2 && (e.wn = true);
      }
    }
    Lm(t) {
      if (t === null)
        return;
      const i = t.iterator;
      for (; i.next(); ) {
        const e = i.key;
        e instanceof Link2 && (e.wn = false, e.FA() && e.invalidateRoute());
      }
      this.k1 = false;
    }
    get draggedLink() {
      return this.S1;
    }
    set draggedLink(t) {
      this.S1 !== t && (this.S1 = t, t !== null && (this.P1 = t.fromPort, this.N1 = t.toPort));
    }
    get FS() {
      return this.P1;
    }
    set FS(t) {
      this.P1 = t;
    }
    get RS() {
      return this.N1;
    }
    set RS(t) {
      this.N1 = t;
    }
    TA(t, i) {
      const e = t.containingGroup;
      if (e !== null) {
        let s = this.TA(e, i);
        if (s !== null || (s = i.getValue(e), s !== null))
          return s;
      }
      return null;
    }
    Us(t, i, e) {
      if (e === void 0)
        return new DraggingInfo2(Point2.To);
      let s = t.isGridSnapEnabled;
      return !t.groupsSnapMembers && i.containingGroup !== null && (s = false), s ? new DraggingInfo2(new Point2(Math.round(e.x * 1e3) / 1e3, Math.round(e.y * 1e3) / 1e3)) : new DraggingInfo2(e.copy());
    }
    FP(t, i) {
      if (Util.s(t, Layer2, _Diagram, "addLayer:layer"), t.diagram !== null && t.diagram !== this && Util.n("Cannot share a Layer with another Diagram: " + t + " of " + t.diagram), i === null ? t.diagram !== null && Util.n("Cannot add an existing Layer to this Diagram again: " + t) : (Util.s(i, Layer2, _Diagram, "addLayer:existingLayer"), i.diagram !== this && Util.n("Existing Layer must be in this Diagram: " + i + " not in " + i.diagram), t === i && Util.n("Cannot move a Layer before or after itself: " + t)), t.diagram === this)
        return;
      const e = t.name, s = this.Jt, n = s.count;
      for (let o = 0; o < n; o++)
        s.elt(o).name === e && Util.n("Cannot add Layer with the name '" + e + "'; a Layer with the same name is already present in this Diagram.");
    }
    addLayer(t) {
      this.FP(t, null), t.Vo(this);
      const i = this.Jt;
      let e = i.count - 1;
      if (!t.isTemporary)
        for (; e >= 0 && i.elt(e).isTemporary; )
          e--;
      return i.insertAt(e + 1, t), this.Li !== null && this.raiseChangedEvent(3, "layers", this, null, t, null, e + 1), this.T(), this.invalidateDocumentBounds(), this;
    }
    addLayerBefore(t, i) {
      this.FP(t, i), t.Vo(this);
      const e = this.Jt, s = e.indexOf(t);
      s >= 0 && (e.remove(t), this.Li !== null && this.raiseChangedEvent(4, "layers", this, t, null, s, null));
      const n = e.count;
      let o;
      for (o = 0; o < n; o++)
        if (e.elt(o) === i) {
          e.insertAt(o, t);
          break;
        }
      return this.Li !== null && this.raiseChangedEvent(3, "layers", this, null, t, null, o), this.T(), s < 0 && this.invalidateDocumentBounds(), this;
    }
    addLayerAfter(t, i) {
      this.FP(t, i), t.Vo(this);
      const e = this.Jt, s = e.indexOf(t);
      s >= 0 && (e.remove(t), this.Li !== null && this.raiseChangedEvent(4, "layers", this, t, null, s, null));
      const n = e.count;
      let o;
      for (o = 0; o < n; o++)
        if (e.elt(o) === i) {
          e.insertAt(o + 1, t);
          break;
        }
      return this.Li !== null && this.raiseChangedEvent(3, "layers", this, null, t, null, o + 1), this.T(), s < 0 && this.invalidateDocumentBounds(), this;
    }
    Qr(t, i) {
      t.Vo(this), this.Jt.insertAt(i, t);
    }
    RA(t) {
      this.Jt.removeAt(t);
    }
    removeLayer(t) {
      if (Util.s(t, Layer2, _Diagram, "removeLayer:layer"), t.diagram !== this && Util.n("Cannot remove a Layer from another Diagram: " + t + " of " + t.diagram), t.name === "")
        return;
      const i = this.Jt, e = i.indexOf(t);
      if (i.remove(t)) {
        const n = t.It.copy().iterator;
        for (; n.next(); ) {
          const o = n.value, r = o.layerName;
          r !== t.name ? o.layerName = r : o.layerName = "";
        }
        this.Li !== null && this.raiseChangedEvent(4, "layers", this, t, null, e, null), this.T(), this.invalidateDocumentBounds();
      }
    }
    findLayer(t) {
      const i = this.layers;
      for (; i.next(); ) {
        const e = i.value;
        if (e.name === t)
          return e;
      }
      return null;
    }
    findRouter(t) {
      for (const i of this.vf)
        if (i.name === t)
          return i;
      return null;
    }
    addModelChangedListener(t) {
      return Util.t(t, "function", _Diagram, "addModelChangedListener:listener"), this.to === null && (this.to = new List2()), this.to.add(t), this.model.addChangedListener(t), this;
    }
    removeModelChangedListener(t) {
      Util.t(t, "function", _Diagram, "removeModelChangedListener:listener"), this.to !== null && (this.to.remove(t), this.to.count === 0 && (this.to = null)), this.model.removeChangedListener(t);
    }
    addChangedListener(t) {
      return Util.t(t, "function", _Diagram, "addChangedListener:listener"), this.Er === null && (this.Er = new List2()), this.Er.add(t), this;
    }
    removeChangedListener(t) {
      Util.t(t, "function", _Diagram, "removeChangedListener:listener"), this.Er !== null && (this.Er.remove(t), this.Er.count === 0 && (this.Er = null));
    }
    Gw(t) {
      if (!this.skipsUndoManager && !this.model.skipsUndoManager && this.model.undoManager.handleChanged(t), t.change !== 1 && (this.isModified = true), this.Er !== null) {
        const i = this.Er, e = i.length;
        for (let s = 0; s < e; s++)
          i.elt(s)(t);
      }
    }
    raiseChangedEvent(t, i, e, s, n, o, r) {
      o === void 0 && (o = null), r === void 0 && (r = null);
      const l = new ChangedEvent2();
      l.diagram = this, l.change = t, l.propertyName = i, l.object = e, l.oldValue = s, l.oldParam = o, l.newValue = n, l.newParam = r, this.Gw(l);
    }
    raiseChanged(t, i, e, s, n) {
      this.raiseChangedEvent(2, t, this, i, e, s, n);
    }
    i(t, i, e, s, n) {
      this.raiseChangedEvent(2, t, this, i, e, s, n);
    }
    get animationManager() {
      return this.bs;
    }
    get undoManager() {
      return this.Li.undoManager;
    }
    get skipsUndoManager() {
      return this.Xo;
    }
    set skipsUndoManager(t) {
      Util.t(t, "boolean", _Diagram, "skipsUndoManager"), this.Xo = t, this.Li.skipsUndoManager = t;
    }
    get delaysLayout() {
      return this.qx;
    }
    set delaysLayout(t) {
      this.qx = t;
    }
    CC(t, i) {
      if (t === null || t.diagram !== this)
        return;
      const e = this.xe;
      try {
        this.xe = true;
        const s = t.change;
        if (s === 2) {
          const n = t.object, o = t.propertyName, r = t.getValue(i);
          if (Model2.dt(n, o, r), n instanceof GraphObject2) {
            const l = n.part;
            l !== null && l.invalidateAdornments();
          }
          this.isModified = true;
        } else if (s === 3) {
          const n = t.object, o = t.newParam, r = t.newValue;
          if (n instanceof Panel2)
            if (typeof o == "number" && r instanceof GraphObject2) {
              i ? n.re(o) : n.insertAt(o, r);
              const l = n.part;
              l !== null && l.invalidateAdornments();
            } else
              typeof o == "number" && r instanceof RowColumnDefinition2 && (r.isRow ? n.IA(o, i ? void 0 : r) : n.OA(o, i ? void 0 : r));
          else if (n instanceof Layer2) {
            const l = t.oldParam === true;
            typeof o == "number" && r instanceof Part2 && (i ? (r.isSelected = false, r.isHighlighted = false, r.invalidateAdornments(), n.re(l ? o : -1, r, l)) : n.Qh(o, r, l));
          } else
            n instanceof _Diagram ? typeof o == "number" && r instanceof Layer2 && (i ? this.RA(o) : this.Qr(r, o)) : Util.n("unknown ChangeType.Insert object: " + t.toString());
          this.isModified = true;
        } else if (s === 4) {
          const n = t.object, o = t.oldParam, r = t.oldValue;
          if (n instanceof Panel2)
            typeof o == "number" && r instanceof GraphObject2 ? i ? n.insertAt(o, r) : n.re(o) : typeof o == "number" && r instanceof RowColumnDefinition2 && (r.isRow ? n.IA(o, i ? r : void 0) : n.OA(o, i ? r : void 0));
          else if (n instanceof Layer2) {
            const l = t.newParam === true;
            typeof o == "number" && r instanceof Part2 && (i ? n.It.indexOf(r) < 0 && n.Qh(o, r, l) : (r.isSelected = false, r.isHighlighted = false, r.invalidateAdornments(), n.re(l ? o : -1, r, l)));
          } else
            n instanceof _Diagram ? typeof o == "number" && r instanceof Layer2 && (i ? this.Qr(r, o) : this.RA(o)) : Util.n("unknown ChangeType.Remove object: " + t.toString());
          this.isModified = true;
        } else
          s === 1 || Util.n("unknown ChangedEvent: " + t.toString());
      } finally {
        this.xe = e;
      }
    }
    startTransaction(t) {
      return this.undoManager.startTransaction(t);
    }
    commitTransaction(t) {
      return this.undoManager.commitTransaction(t);
    }
    rollbackTransaction() {
      return this.undoManager.rollbackTransaction();
    }
    commit(t, i) {
      let e = i;
      e === void 0 && (e = "");
      const s = this.skipsUndoManager;
      e === null && (this.skipsUndoManager = true, e = ""), this.undoManager.startTransaction(e);
      let n = false;
      try {
        t(this), n = true;
      } finally {
        n ? this.undoManager.commitTransaction(e) : this.undoManager.rollbackTransaction(), this.skipsUndoManager = s;
      }
    }
    updateAllTargetBindings(t) {
      this.partManager.updateAllTargetBindings(t);
    }
    updateAllThemeBindings() {
      if (this.partManager.updateAllThemeBindings(), this.ls !== null) {
        const t = this.ls.part;
        t !== null && t.Uo();
      }
    }
    setDivBackground(t) {
      this.div && (this.div.style.backgroundColor = t);
    }
    updateAllRelationshipsFromData() {
      this.partManager.updateAllRelationshipsFromData();
    }
    EA(t, i) {
      const e = this.animationManager;
      if (this.$t || this.Ps) {
        this.v = i, this.$r(), this.T(), this.ca(), e.iA(t, this.v);
        return;
      }
      if (this.xt === null) {
        this.v = i, this.$r();
        return;
      }
      this.$t = true;
      const n = this.viewportBounds.copy(), o = this.Ct, r = this.At;
      let l = this.zoomPoint.x, h = this.zoomPoint.y;
      const a = this.contentAlignment;
      isNaN(l) && (a.isSide() ? a.includesSide(Spot2.LeftSide) ? l = 0 : a.includesSide(Spot2.RightSide) && (l = o - 1) : a.isSpot() ? l = a.x * (o - 1) : l = o / 2), isNaN(h) && (a.isSide() ? a.includesSide(Spot2.TopSide) ? h = 0 : a.includesSide(Spot2.BottomSide) && (h = r - 1) : a.isSpot() ? h = a.y * (r - 1) : h = r / 2), this.scaleComputation !== null && !this.animationManager.defaultAnimation.isAnimating && (i = this.scaleComputation(this, i)), i < this.minScale && (i = this.minScale), i > this.maxScale && (i = this.maxScale);
      const f = Point2.H(this.lt.x + l / t - l / i, this.lt.y + h / t - h / i);
      this.position = f, Point2.o(f), this.v = i, this.$r(), this.$t = false, this.onViewportBoundsChanged(n, this.viewportBounds, t, false), this.Hs(false), e.iA(t, this.v), this.T();
    }
    hR() {
      const t = this.Jt.h;
      for (let i = 0; i < t.length; i++)
        t[i].lA();
    }
    onViewportBoundsChanged(t, i, e, s) {
      if (t.equals(i))
        return;
      s === void 0 && (s = false), s || this.ca(), this.oh();
      const n = this.layout;
      n !== null && n.isViewportSized && this.autoScale === 1 && (t.width !== i.width || t.height !== i.height) && n.invalidateLayout();
      const o = this.currentTool;
      this.Gf === true && o instanceof ToolManager2 && !this.animationManager.isTicking && (this.lastInput.documentPoint = this.transformViewToDoc(this.lastInput.viewPoint), o.standardMouseActivity(this)), this.$t || this.invalidateViewport(t, i), this._r(), this.Ui.scale = e, this.Ui.position.x = t.x, this.Ui.position.y = t.y, this.Ui.bounds.c(t), this.Ui.canvasSize.width = Math.round(t.width * e), this.Ui.canvasSize.height = Math.round(t.height * e), this.Ui.newCanvasSize.width = this.Ct, this.Ui.newCanvasSize.height = this.At, this.Ui.isScroll = s, this.V("ViewportBoundsChanged", this.Ui, t), this.isVirtualized && this.links.each((r) => {
        r.isAvoiding && r.actualBounds.intersectsRect(i) && r.invalidateRoute();
      });
    }
    _r(t) {
      const i = this.ls;
      if (i === null || !i.visible || i.layer === null)
        return;
      const e = t !== void 0 ? t : this.a1;
      if (!e.isReal())
        return;
      const s = e.width, n = e.height;
      if (i.scale = 1, i.angle = 0, i.layer.isViewportAligned)
        i.width = s * this.scale, i.height = n * this.scale, i.part.alignment = Spot2.TopLeft;
      else {
        i.Pi === null && (i.Pi = new GridPanelSettings());
        const o = i.Pi.jf;
        if (!o.isReal())
          return;
        i.width = s + o.width * 2, i.height = n + o.height * 2;
        const r = Point2.a();
        Geo.vg(e.x, e.y, 0, 0, o.width, o.height, r), r.offset(-o.width, -o.height), i.part.location = r, Point2.o(r);
      }
    }
    clearSelection(t) {
      t === void 0 && (t = false);
      const i = this.selection;
      if (i.count === 0)
        return;
      t || this.V("ChangingSelection", i);
      const e = i.toArray(), s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n];
        o.isSelected = false;
      }
      i.ut(), i.clear(), i.w(), t || this.V("ChangedSelection", i);
    }
    select(t) {
      t !== null && (Util.s(t, Part2, _Diagram, "select:part"), t.diagram === this && (!t.isSelected || this.selection.count > 1) && (this.V("ChangingSelection", this.selection), this.clearSelection(true), t.isSelected = true, this.V("ChangedSelection", this.selection)));
    }
    selectCollection(t) {
      if (this.V("ChangingSelection", this.selection), this.clearSelection(true), Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++) {
          const s = t[e];
          s instanceof Part2 || Util.n("Diagram.selectCollection given something that is not a Part: " + s), s.isSelected = true;
        }
      } else {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          e instanceof Part2 || Util.n("Diagram.selectCollection given something that is not a Part: " + e), e.isSelected = true;
        }
      }
      this.V("ChangedSelection", this.selection);
    }
    clearHighlighteds() {
      const t = this.highlighteds;
      if (t.count > 0) {
        const i = t.toArray(), e = i.length;
        for (let s = 0; s < e; s++) {
          const n = i[s];
          n.isHighlighted = false;
        }
        t.ut(), t.clear(), t.w();
      }
    }
    highlight(t) {
      t !== null && t.diagram === this && (Util.s(t, Part2, _Diagram, "highlight:part"), (!t.isHighlighted || this.highlighteds.count > 1) && (this.clearHighlighteds(), t.isHighlighted = true));
    }
    highlightCollection(t) {
      const i = new GSet2().addAll(t), s = this.highlighteds.copy().removeAll(i).iterator;
      for (; s.next(); ) {
        const o = s.value;
        o.isHighlighted = false;
      }
      const n = i.iterator;
      for (; n.next(); ) {
        const o = n.value;
        o instanceof Part2 || Util.n("Diagram.highlightCollection given something that is not a Part: " + o), o.isHighlighted = true;
      }
    }
    scroll(t, i, e) {
      e === void 0 && (e = 1);
      const s = i === "up" || i === "down";
      let n = 0;
      const o = Point2.a();
      if (t === "pixel")
        n = e;
      else if (t === "line")
        n = e * (s ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange);
      else if (t === "page") {
        let l = s ? this.viewportBounds.height : this.viewportBounds.width;
        if (l *= this.scale, l !== 0) {
          const h = Math.max(l - (s ? this.scrollVerticalLineChange : this.scrollHorizontalLineChange), 0);
          n = e * h;
        }
      } else if (t === "document") {
        const l = this.documentBounds, h = this.viewportBounds;
        i === "up" ? this.position = o.e(h.x, l.y) : i === "left" ? this.position = o.e(l.x, h.y) : i === "down" ? this.position = o.e(h.x, l.bottom - h.height) : i === "right" && (this.position = o.e(l.right - h.width, h.y)), Point2.o(o);
        return;
      } else
        Util.n("scrolling unit must be 'pixel', 'line', 'page', or 'document', not: " + t);
      n /= this.scale;
      const r = this.position;
      i === "up" ? this.position = o.e(r.x, r.y - n) : i === "down" ? this.position = o.e(r.x, r.y + n) : i === "left" ? this.position = o.e(r.x - n, r.y) : i === "right" ? this.position = o.e(r.x + n, r.y) : Util.n("scrolling direction must be 'up', 'down', 'left', or 'right', not: " + i), Point2.o(o);
    }
    scrollToRect(t) {
      const i = this.viewportBounds;
      if (i.containsRect(t))
        return;
      const e = t.center;
      e.x -= i.width / 2, e.y -= i.height / 2, this.position = e;
    }
    centerRect(t) {
      const i = this.viewportBounds, e = t.center;
      e.x -= i.width / 2, e.y -= i.height / 2, this.position = e;
    }
    transformDocToView(t) {
      const i = this.D;
      i.ti(), this.v !== 1 && i.v(this.v);
      const e = this.lt;
      return (e.x !== 0 || e.y !== 0) && isFinite(e.x) && isFinite(e.y) && i.se(-e.x, -e.y), t.copy().D(i);
    }
    transformViewToDoc(t) {
      const i = this.D;
      i.ti(), this.v !== 1 && i.v(this.v);
      const e = this.lt;
      return (e.x !== 0 || e.y !== 0) && isFinite(e.x) && isFinite(e.y) && i.se(-e.x, -e.y), t.copy().Ge(i);
    }
    FF(t) {
      const i = this.D;
      i.ti(), this.v !== 1 && i.v(this.v);
      const e = this.lt;
      return (e.x !== 0 || e.y !== 0) && isFinite(e.x) && isFinite(e.y) && i.se(-e.x, -e.y), t.Ge(this.D);
    }
    get opacity() {
      return this._t;
    }
    set opacity(t) {
      const i = this._t;
      i !== t && (Util.t(t, "number", _Diagram, "opacity"), (t < 0 || t > 1) && Util.G(t, "0 <= value <= 1", _Diagram, "opacity"), this._t = t, this.i("opacity", i, t), this.T());
    }
    get validCycle() {
      return this.Yx;
    }
    set validCycle(t) {
      const i = this.Yx;
      i !== t && (Util.it(t, CycleMode2, "CycleMode"), this.Yx = t, this.i("validCycle", i, t));
    }
    get layers() {
      return this.Jt.iterator;
    }
    get isModelReadOnly() {
      const t = this.Li;
      return t === null ? false : t.isReadOnly;
    }
    set isModelReadOnly(t) {
      const i = this.Li;
      i !== null && (i.isReadOnly = t);
    }
    get isReadOnly() {
      return this.Yo;
    }
    set isReadOnly(t) {
      const i = this.Yo;
      i !== t && (Util.t(t, "boolean", _Diagram, "isReadOnly"), this.Yo = t, this.i("isReadOnly", i, t));
    }
    get isEnabled() {
      return this.Xi;
    }
    set isEnabled(t) {
      const i = this.Xi;
      i !== t && (Util.t(t, "boolean", _Diagram, "isEnabled"), this.Xi = t, this.i("isEnabled", i, t));
    }
    get allowClipboard() {
      return this.Wx;
    }
    set allowClipboard(t) {
      const i = this.Wx;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowClipboard"), this.Wx = t, this.i("allowClipboard", i, t));
    }
    get allowCopy() {
      return this.Xl;
    }
    set allowCopy(t) {
      const i = this.Xl;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowCopy"), this.Xl = t, this.i("allowCopy", i, t));
    }
    get allowDelete() {
      return this.Yl;
    }
    set allowDelete(t) {
      const i = this.Yl;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowDelete"), this.Yl = t, this.i("allowDelete", i, t));
    }
    get allowDragOut() {
      return this.jx;
    }
    set allowDragOut(t) {
      const i = this.jx;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowDragOut"), this.jx = t, this.i("allowDragOut", i, t));
    }
    get allowDrop() {
      return this.Jx;
    }
    set allowDrop(t) {
      const i = this.Jx;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowDrop"), this.Jx = t, this.i("allowDrop", i, t));
    }
    get allowTextEdit() {
      return this.Kl;
    }
    set allowTextEdit(t) {
      const i = this.Kl;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowTextEdit"), this.Kl = t, this.i("allowTextEdit", i, t));
    }
    get allowGroup() {
      return this.Ul;
    }
    set allowGroup(t) {
      const i = this.Ul;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowGroup"), this.Ul = t, this.i("allowGroup", i, t));
    }
    get allowUngroup() {
      return this.Gl;
    }
    set allowUngroup(t) {
      const i = this.Gl;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowUngroup"), this.Gl = t, this.i("allowUngroup", i, t));
    }
    get allowInsert() {
      return this.Zx;
    }
    set allowInsert(t) {
      const i = this.Zx;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowInsert"), this.Zx = t, this.i("allowInsert", i, t));
    }
    get allowLink() {
      return this.Hl;
    }
    set allowLink(t) {
      const i = this.Hl;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowLink"), this.Hl = t, this.i("allowLink", i, t));
    }
    get allowRelink() {
      return this.vl;
    }
    set allowRelink(t) {
      const i = this.vl;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowRelink"), this.vl = t, this.i("allowRelink", i, t));
    }
    get allowMove() {
      return this.ql;
    }
    set allowMove(t) {
      const i = this.ql;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowMove"), this.ql = t, this.i("allowMove", i, t));
    }
    get allowReshape() {
      return this.Wl;
    }
    set allowReshape(t) {
      const i = this.Wl;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowReshape"), this.Wl = t, this.i("allowReshape", i, t));
    }
    get allowResize() {
      return this.jl;
    }
    set allowResize(t) {
      const i = this.jl;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowResize"), this.jl = t, this.i("allowResize", i, t));
    }
    get allowRotate() {
      return this.Jl;
    }
    set allowRotate(t) {
      const i = this.Jl;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowRotate"), this.Jl = t, this.i("allowRotate", i, t));
    }
    get allowSelect() {
      return this.Zl;
    }
    set allowSelect(t) {
      const i = this.Zl;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowSelect"), this.Zl = t, this.i("allowSelect", i, t));
    }
    get allowUndo() {
      return this.$x;
    }
    set allowUndo(t) {
      const i = this.$x;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowUndo"), this.$x = t, this.i("allowUndo", i, t));
    }
    get allowZoom() {
      return this.Qx;
    }
    set allowZoom(t) {
      const i = this.Qx;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowZoom"), this.Qx = t, this.i("allowZoom", i, t));
    }
    get hasVerticalScrollbar() {
      return this.Uu;
    }
    set hasVerticalScrollbar(t) {
      const i = this.Uu;
      i !== t && (Util.t(t, "boolean", _Diagram, "hasVerticalScrollbar"), this.Uu = t, this.ca(), this.T(), this.i("hasVerticalScrollbar", i, t), this.Hs(false));
    }
    get hasHorizontalScrollbar() {
      return this.Ku;
    }
    set hasHorizontalScrollbar(t) {
      const i = this.Ku;
      i !== t && (Util.t(t, "boolean", _Diagram, "hasHorizontalScrollbar"), this.Ku = t, this.ca(), this.T(), this.i("hasHorizontalScrollbar", i, t), this.Hs(false));
    }
    get allowHorizontalScroll() {
      return this._x;
    }
    set allowHorizontalScroll(t) {
      const i = this._x;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowHorizontalScroll"), this._x = t, this.i("allowHorizontalScroll", i, t), this.Hs(false));
    }
    get allowVerticalScroll() {
      return this.t1;
    }
    set allowVerticalScroll(t) {
      const i = this.t1;
      i !== t && (Util.t(t, "boolean", _Diagram, "allowVerticalScroll"), this.t1 = t, this.i("allowVerticalScroll", i, t), this.Hs(false));
    }
    get scrollHorizontalLineChange() {
      return this.i1;
    }
    set scrollHorizontalLineChange(t) {
      const i = this.i1;
      i !== t && (Util.t(t, "number", _Diagram, "scrollHorizontalLineChange"), t < 0 && Util.G(t, ">= 0", _Diagram, "scrollHorizontalLineChange"), this.i1 = t, this.i("scrollHorizontalLineChange", i, t));
    }
    get scrollVerticalLineChange() {
      return this.e1;
    }
    set scrollVerticalLineChange(t) {
      const i = this.e1;
      i !== t && (Util.t(t, "number", _Diagram, "scrollVerticalLineChange"), t < 0 && Util.G(t, ">= 0", _Diagram, "scrollVerticalLineChange"), this.e1 = t, this.i("scrollVerticalLineChange", i, t));
    }
    get lastInput() {
      return this.ia;
    }
    set lastInput(t) {
      Debug && Util.s(t, InputEvent2, _Diagram, "lastInput"), this.ia = t;
    }
    get previousInput() {
      return this.jr;
    }
    set previousInput(t) {
      Debug && Util.s(t, InputEvent2, _Diagram, "previousInput"), this.jr = t;
    }
    get firstInput() {
      return this.e0;
    }
    set firstInput(t) {
      Debug && Util.s(t, InputEvent2, _Diagram, "firstInput"), this.e0 = t;
    }
    get currentCursor() {
      return this.Kx;
    }
    set currentCursor(t) {
      if (t === "" && (t = this.Zm), this.Kx !== t) {
        Util.t(t, "string", _Diagram, "currentCursor");
        const e = this.xt, s = this.Ot;
        if (e === null || s === null)
          return;
        this.Kx = t;
        const n = e.style.cursor;
        e.style.cursor = t, s.style.cursor = t, e.style.cursor === n && (e.style.cursor = "-webkit-" + t, s.style.cursor = "-webkit-" + t, e.style.cursor === n && (e.style.cursor = "-moz-" + t, s.style.cursor = "-moz-" + t, e.style.cursor === n && (e.style.cursor = t, s.style.cursor = t)));
      }
    }
    get defaultCursor() {
      return this.Zm;
    }
    set defaultCursor(t) {
      t === "" && (t = "auto");
      const i = this.Zm;
      i !== t && (Util.t(t, "string", _Diagram, "defaultCursor"), this.Zm = t, this.i("defaultCursor", i, t));
    }
    get click() {
      return this.Vr;
    }
    set click(t) {
      const i = this.Vr;
      i !== t && (t !== null && Util.t(t, "function", _Diagram, "click"), this.Vr = t, this.i("click", i, t));
    }
    get doubleClick() {
      return this.Br;
    }
    set doubleClick(t) {
      const i = this.Br;
      i !== t && (t !== null && Util.t(t, "function", _Diagram, "doubleClick"), this.Br = t, this.i("doubleClick", i, t));
    }
    get contextClick() {
      return this.zr;
    }
    set contextClick(t) {
      const i = this.zr;
      i !== t && (t !== null && Util.t(t, "function", _Diagram, "contextClick"), this.zr = t, this.i("contextClick", i, t));
    }
    get mouseOver() {
      return this.Xr;
    }
    set mouseOver(t) {
      const i = this.Xr;
      i !== t && (t !== null && Util.t(t, "function", _Diagram, "mouseOver"), this.Xr = t, this.i("mouseOver", i, t));
    }
    get mouseHover() {
      return this.Yr;
    }
    set mouseHover(t) {
      const i = this.Yr;
      i !== t && (t !== null && Util.t(t, "function", _Diagram, "mouseHover"), this.Yr = t, this.i("mouseHover", i, t));
    }
    get mouseHold() {
      return this.Kr;
    }
    set mouseHold(t) {
      const i = this.Kr;
      i !== t && (t !== null && Util.t(t, "function", _Diagram, "mouseHold"), this.Kr = t, this.i("mouseHold", i, t));
    }
    get mouseDragOver() {
      return this.Ux;
    }
    set mouseDragOver(t) {
      const i = this.Ux;
      i !== t && (t !== null && Util.t(t, "function", _Diagram, "mouseDragOver"), this.Ux = t, this.i("mouseDragOver", i, t));
    }
    get mouseDrop() {
      return this.Ur;
    }
    set mouseDrop(t) {
      const i = this.Ur;
      i !== t && (Debug && t !== null && Util.t(t, "function", _Diagram, "mouseDrop"), this.Ur = t, this.i("mouseDrop", i, t));
    }
    get handlesDragDropForTopLevelParts() {
      return this.Gx;
    }
    set handlesDragDropForTopLevelParts(t) {
      const i = this.Gx;
      i !== t && (Util.t(t, "boolean", _Diagram, "handlesDragDropForTopLevelParts"), this.Gx = t, this.i("handlesDragDropForTopLevelParts", i, t));
    }
    get mouseEnter() {
      return this.Gr;
    }
    set mouseEnter(t) {
      const i = this.Gr;
      i !== t && (t !== null && Util.t(t, "function", _Diagram, "mouseEnter"), this.Gr = t, this.i("mouseEnter", i, t));
    }
    get mouseLeave() {
      return this.Hr;
    }
    set mouseLeave(t) {
      const i = this.Hr;
      i !== t && (t !== null && Util.t(t, "function", _Diagram, "mouseLeave"), this.Hr = t, this.i("mouseLeave", i, t));
    }
    get toolTip() {
      return this.vr;
    }
    set toolTip(t) {
      const i = this.vr;
      i !== t && (Debug && t !== null && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && Util.n("Diagram.toolTip must be an Adornment or HTMLInfo."), this.vr = t, this.i("toolTip", i, t));
    }
    get contextMenu() {
      return this.qr;
    }
    set contextMenu(t) {
      const i = this.qr;
      i !== t && (Debug && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && Util.n("Diagram.contextMenu must be an Adornment or HTMLInfo."), this.qr = t, this.i("contextMenu", i, t));
    }
    get commandHandler() {
      return this.tP;
    }
    set commandHandler(t) {
      this.tP !== t && (this.tP = t, t.Vo(this));
    }
    get toolManager() {
      return this.$M;
    }
    set toolManager(t) {
      this.$M !== t && (Util.s(t, ToolManager2, _Diagram, "toolManager"), this.$M = t, t.diagram = this);
    }
    get defaultTool() {
      return this.QM;
    }
    set defaultTool(t) {
      const i = this.QM;
      i !== t && (Util.s(t, Tool2, _Diagram, "defaultTool"), this.QM = t, t.diagram = this, this.currentTool === i && (this.currentTool = t));
    }
    get currentTool() {
      return this._M;
    }
    set currentTool(t) {
      const i = this._M;
      i && (i.isActive && i.doDeactivate(), i.cancelWaitAfter(), i.doStop()), t === null && (t = this.defaultTool), t !== null && (Util.s(t, Tool2, _Diagram, "currentTool"), this._M = t, t.diagram = this, t.doStart());
    }
    get selection() {
      return this.lP;
    }
    get maxSelectionCount() {
      return this.h1;
    }
    set maxSelectionCount(t) {
      const i = this.h1;
      if (i !== t)
        if (Util.t(t, "number", _Diagram, "maxSelectionCount"), t >= 0 && !isNaN(t)) {
          if (this.h1 = t, this.i("maxSelectionCount", i, t), !this.undoManager.isUndoingRedoing) {
            const e = this.selection.count - t;
            if (e > 0) {
              this.V("ChangingSelection", this.selection);
              const s = this.selection.toArray();
              for (let n = 0; n < e; n++)
                s[n].isSelected = false;
              this.V("ChangedSelection", this.selection);
            }
          }
        } else
          Util.G(t, ">= 0", _Diagram, "maxSelectionCount");
    }
    get nodeSelectionAdornmentTemplate() {
      return this._m;
    }
    set nodeSelectionAdornmentTemplate(t) {
      const i = this._m;
      i !== t && (Util.s(t, Adornment2, _Diagram, "nodeSelectionAdornmentTemplate"), this._m = t, this.i("nodeSelectionAdornmentTemplate", i, t));
    }
    get groupSelectionAdornmentTemplate() {
      return this.c1;
    }
    set groupSelectionAdornmentTemplate(t) {
      const i = this.c1;
      i !== t && (Util.s(t, Adornment2, _Diagram, "groupSelectionAdornmentTemplate"), this.c1 = t, this.i("groupSelectionAdornmentTemplate", i, t));
    }
    get linkSelectionAdornmentTemplate() {
      return this.u1;
    }
    set linkSelectionAdornmentTemplate(t) {
      const i = this.u1;
      i !== t && (Util.s(t, Adornment2, _Diagram, "linkSelectionAdornmentTemplate"), this.u1 = t, this.i("linkSelectionAdornmentTemplate", i, t));
    }
    get highlighteds() {
      return this.hP;
    }
    get isModified() {
      const t = this.undoManager;
      return t.isEnabled ? t.currentTransaction !== null ? true : this.vu && this.Ys !== t.historyIndex : this.vu;
    }
    set isModified(t) {
      if (this.vu !== t) {
        Util.t(t, "boolean", _Diagram, "isModified"), this.vu = t;
        const e = this.undoManager;
        !t && e.isEnabled && (this.Ys = e.historyIndex), t || this.VA();
      }
    }
    VA() {
      const t = this.isModified;
      this.oP !== t && (this.oP = t, this.V("Modified"));
    }
    get model() {
      return this.Li;
    }
    set model(t) {
      const i = this.Li;
      if (i !== t) {
        Util.s(t, Model2, _Diagram, "model"), this.currentTool.doCancel(), i && i.undoManager !== t.undoManager && i.undoManager.isInTransaction && Util.n("Do not replace a Diagram.model while a transaction is in progress."), this.animationManager.stopAnimation(true);
        const e = this.yA(true);
        this.eo = false, this.Yu = true, this.Ys = -2, this.Tr = false;
        const s = this.$t;
        this.$t = true, this.animationManager.zl("Model"), i && (this.to !== null && this.to.each((n) => i.removeChangedListener(n)), i.removeChangedListener(this.nP)), this.Li = t, this.partManager = this.wR(this.Li.type), this.initializePartManager(this.partManager);
        for (let n = 0; n < e.length; n++)
          this.add(e[n]);
        t.addChangedListener(this.sP), this.partManager.RP(), t.removeChangedListener(this.sP), t.addChangedListener(this.nP), this.to !== null && this.to.each((n) => t.addChangedListener(n)), this.$t = s, this.invalidateDocumentBounds(), this.$t || this.T(), i && t.undoManager.copyProperties(i.undoManager);
      }
    }
    get themeManager() {
      return this.C1;
    }
    set themeManager(t) {
      const i = this.C1;
      i !== t && (Util.s(t, ThemeManager2, Model2, "themeManager"), i !== null && i.removeDiagram(this), this.C1 = t, t !== null && t.addDiagram(this));
    }
    initializePartManager(t) {
    }
    static xP(t, i) {
      _Diagram.cA.add(t, i);
    }
    static get licenseKey() {
      return _Diagram.IP.last();
    }
    static set licenseKey(t) {
      _Diagram.IP.add(t.replace(/\s/g, ""));
    }
    static get version() {
      return _Diagram.xR;
    }
    wR(t) {
      const i = _Diagram.cA.get(t);
      return i !== null ? new i() : new PartManager();
    }
    get W() {
      return this.eP;
    }
    set W(t) {
      this.eP = t;
    }
    get Mx() {
      return this.hA;
    }
    bR(t) {
      if (t.model !== this.model)
        return;
      const i = t.change, e = t.propertyName;
      if (i === 1 && e[0] === "S") {
        if (e === "StartingFirstTransaction") {
          const s = this, n = this.toolManager;
          n.mouseDownTools.each((o) => o.diagram = s), n.mouseMoveTools.each((o) => o.diagram = s), n.mouseUpTools.each((o) => o.diagram = s), this.routers.each((o) => o.diagram = s), !this.Ps && !this.eo && (this.Xf = true, this.Yu && (this.Tr = true));
        } else if (e === "StartingUndo" || e === "StartingRedo") {
          const s = this.animationManager;
          this.skipsUndoManager || (s.defaultAnimation.isAnimating && s.stopAnimation(), s.getBundleAnimation().isAnimating && s.getBundleAnimation().stop()), this.V("ChangingSelection", this.selection);
        } else if (e === "StartedTransaction") {
          const s = this.animationManager;
          s.defaultAnimation.isAnimating && !this.skipsUndoManager && s.stopAnimation();
        }
        return;
      }
      if (this.W) {
        this.W = false;
        try {
          if (t.modelChange === "" && i === 1) {
            (e === "FinishedUndo" || e === "FinishedRedo") && (this.V("ChangedSelection", this.selection), this.Fi());
            const s = this.animationManager;
            e === "RolledBackTransaction" && s.stopAnimation(), this.yR(), this.Xf = true, this.maybeUpdate(), (this.undoManager.transactionLevel === 0 || this.undoManager.transactionLevel === 1) && s.FM(), e === "CommittedTransaction" && this.undoManager.isJustDiscarded && (this.Ys = Math.min(this.Ys, this.undoManager.historyIndex - 1)), (e === "CommittedTransaction" || e === "RolledBackTransaction") && this.undoManager.Uw && setTimeout(() => {
              this.isModified = false;
            }, 1);
            const n = t.isTransactionFinished;
            if (n && (this.VA(), this.Mx.clear(), this.animationManager.mF()), !this.Hx && n && this.lastInput.targetDiagram) {
              this.Hx = true;
              const o = this;
              Util.Xh(() => {
                o.currentTool.standardMouseOver(), o.Hx = false;
              }, 10);
            }
          }
        } finally {
          this.W = true;
        }
      }
    }
    get xe() {
      return this.iP;
    }
    set xe(t) {
      this.iP = t;
    }
    get Am() {
      return this.vx;
    }
    set Am(t) {
      this.vx = t;
    }
    CA(t) {
      const i = t.F.h;
      for (const e of i)
        e instanceof Picture2 && this.OP(e);
    }
    OP(t) {
      const i = t.element;
      if (i === null || !(i instanceof HTMLImageElement) || (i.as instanceof GSet2 && i.as.add(this), t.kR(), !i.w0))
        return;
      const e = i.getAttribute("src") || "", s = this.eh.getValue(e);
      if (s === null) {
        Picture2.BA(t, i);
        const n = [];
        n.push(t), this.eh.add(e, n);
      } else {
        for (let n = 0; n < s.length; n++)
          if (s[n] === t)
            return;
        s.push(t);
      }
    }
    SR(t) {
      const i = t.F.h, e = i.length;
      for (let s = 0; s < e; s++)
        this.EP(i[s]);
    }
    EP(t) {
      if (!(t instanceof Picture2))
        return;
      const i = t.element;
      if (i === null || !(i instanceof HTMLImageElement) || !i.w0)
        return;
      const e = i.getAttribute("src") || "", s = this.eh.getValue(e);
      if (s !== null) {
        for (let n = 0; n < s.length; n++)
          if (s[n] === t) {
            s.splice(n, 1), s.length === 0 && (this.eh.remove(e), Picture2.MR(i), i.as instanceof GSet2 && i.as.remove(this), Picture2.clearCache(e));
            return;
          }
      }
    }
    wA() {
      Picture2.clearCache(), this.eh.clear();
    }
    rebuildParts() {
      this.partManager.rebuildParts();
    }
    Rf(t, i) {
      this.bs.Rf(t, i);
    }
    Ff(t, i) {
      this.bs.Ff(t, i);
    }
    findPartForKey(t) {
      return this.partManager.findPartForKey(t);
    }
    findNodeForKey(t) {
      return this.partManager.findNodeForKey(t);
    }
    findLinkForKey(t) {
      return this.partManager.findLinkForKey(t);
    }
    findPartForData(t) {
      return this.partManager.findPartForData(t);
    }
    findNodeForData(t) {
      return this.partManager.findNodeForData(t);
    }
    findLinkForData(t) {
      return this.partManager.findLinkForData(t);
    }
    findNodesByExample(...t) {
      return this.partManager.findNodesByExample(...t);
    }
    findLinksByExample(...t) {
      return this.partManager.findLinksByExample(...t);
    }
    get nodeTemplate() {
      return this.Wr.getValue("");
    }
    set nodeTemplate(t) {
      const i = this.Wr.getValue("");
      i !== t && (Util.s(t, Part2, _Diagram, "nodeTemplate"), this.Wr.add("", t), this.i("nodeTemplate", i, t), this.undoManager.isUndoingRedoing || this.rebuildParts());
    }
    get nodeTemplateMap() {
      return this.Wr;
    }
    set nodeTemplateMap(t) {
      const i = this.Wr;
      i !== t && (Util.s(t, GMap2, _Diagram, "nodeTemplateMap"), this.Wr = t, this.i("nodeTemplateMap", i, t), this.undoManager.isUndoingRedoing || this.rebuildParts());
    }
    get groupTemplate() {
      return this.ta.getValue("");
    }
    set groupTemplate(t) {
      const i = this.ta.getValue("");
      i !== t && (Util.s(t, Group2, _Diagram, "groupTemplate"), this.ta.add("", t), this.i("groupTemplate", i, t), this.undoManager.isUndoingRedoing || this.rebuildParts());
    }
    get groupTemplateMap() {
      return this.ta;
    }
    set groupTemplateMap(t) {
      const i = this.ta;
      i !== t && (Util.s(t, GMap2, _Diagram, "groupTemplateMap"), this.ta = t, this.i("groupTemplateMap", i, t), this.undoManager.isUndoingRedoing || this.rebuildParts());
    }
    get linkTemplate() {
      return this.th.getValue("");
    }
    set linkTemplate(t) {
      const i = this.th.getValue("");
      i !== t && (Util.s(t, Link2, _Diagram, "linkTemplate"), this.th.add("", t), this.i("linkTemplate", i, t), this.undoManager.isUndoingRedoing || this.rebuildParts());
    }
    get linkTemplateMap() {
      return this.th;
    }
    set linkTemplateMap(t) {
      const i = this.th;
      i !== t && (Util.s(t, GMap2, _Diagram, "linkTemplateMap"), this.th = t, this.i("linkTemplateMap", i, t), this.undoManager.isUndoingRedoing || this.rebuildParts());
    }
    get isMouseCaptured() {
      return this.rP;
    }
    set isMouseCaptured(t) {
      const i = this.xt;
      if (i === null)
        return;
      const e = i.Bt;
      e instanceof SVGElement || (t ? (this.lastInput.bubbles = false, this.Ti(e, "pointermove", this.ra, false), this.Ti(e, "pointerdown", this.nh, false), this.Ti(e, "pointerup", this.la, false), this.Ti(e, "pointerout", this.ha, false), this.Ti(e, "pointercancel", this.aa, false), this.Ht(root, "pointermove", this.ra, true), this.Ht(root, "pointerdown", this.nh, true), this.Ht(root, "pointerup", this.la, true), this.Ht(root, "pointerout", this.ha, true), this.Ht(root, "pointercancel", this.aa, true), this.Ti(e, "wheel", this.oa, false), this.Ht(root, "wheel", this.oa, true), this.Ht(root, "selectstart", this.jh, false)) : (this.Ti(root, "pointermove", this.ra, true), this.Ti(root, "pointerdown", this.nh, true), this.Ti(root, "pointerup", this.la, true), this.Ti(root, "pointerout", this.ha, true), this.Ti(root, "pointercancel", this.aa, true), this.Ht(e, "pointermove", this.ra, false), this.Ht(e, "pointerdown", this.nh, false), this.Ht(e, "pointerup", this.la, false), this.Ht(e, "pointerout", this.ha, false), this.Ht(e, "pointercancel", this.aa, false), this.Ti(root, "wheel", this.oa, true), this.Ti(root, "selectstart", this.jh, false), this.Ht(e, "wheel", this.oa, false)), this.rP = t);
    }
    get position() {
      return this.lt;
    }
    set position(t) {
      if (this.lt.equals(t))
        return;
      const i = Point2.a().c(this.lt), e = this.viewportBounds.copy();
      if (this.lt.c(t), this.animationManager.tA(i, this.lt), !this.$t && !(this.xt === null && !this.Hu.isReal())) {
        this.$t = true;
        const s = this.scale, n = this.Ct / s, o = this.At / s;
        this.MP(this.Qm, n, o, this.Bf, false), this.$t = false;
      } else
        this.$r();
      if (!this.$t) {
        const s = this.viewportBounds;
        this.onViewportBoundsChanged(e, s, this.v, false);
      }
      Point2.o(i);
    }
    get initialPosition() {
      return this.Ax;
    }
    set initialPosition(t) {
      this.Ax.equals(t) || (Util.s(t, Point2, _Diagram, "initialPosition"), this.Ax = t.L());
    }
    get initialScale() {
      return this.Lx;
    }
    set initialScale(t) {
      this.Lx !== t && (Util.t(t, "number", _Diagram, "initialScale"), this.Lx = t);
    }
    get grid() {
      return this.ls === null && (this.ls = this.bA()), this.ls;
    }
    set grid(t) {
      let i = this.ls;
      if (i !== t) {
        i === null && (this.ls = this.bA(), i = this.ls), Util.s(t, Panel2, _Diagram, "grid"), t.type !== Panel2.Grid && Util.n("Diagram.grid must be a Panel of type Panel.Grid");
        const e = i.panel;
        e !== null && e.remove(i), this.ls = t, t.name = "GRID", e !== null && e.add(t), this._r(), this.T(), this.i("grid", i, t);
      }
    }
    get viewportBounds() {
      return this.a1;
    }
    $r() {
      const t = this.a1, i = this.lt, e = this.v;
      t.e(i.x, i.y, Math.max(this.Ct, 0) / e, Math.max(this.At, 0) / e), this.oh();
    }
    get viewSize() {
      return this.Hu;
    }
    set viewSize(t) {
      const i = this.viewSize;
      if (!i.equals(t)) {
        Util.s(t, Size2, _Diagram, "viewSize"), t = t.L(), this.Hu = t;
        let e = 0, s = 0;
        t.isReal() ? (e = t.width, s = t.height) : this.Ot !== null && (e = this.Ot.clientWidth || 1, s = this.Ot.clientHeight || 1), this.Ct = e, this.At = s, this.$r(), this.invalidateDocumentBounds(), this.i("viewSize", i, t), this.T();
      }
    }
    get fixedBounds() {
      return this.Rx;
    }
    set fixedBounds(t) {
      const i = this.Rx;
      i.equals(t) || (Util.s(t, Rect2, _Diagram, "fixedBounds"), (Debug && t.width === 1 / 0 || t.width === -1 / 0 || t.height === 1 / 0 || t.height === -1 / 0) && Util.n("fixedBounds width/height must not be Infinity"), t = t.L(), this.Rx = t, this.invalidateDocumentBounds(), this.i("fixedBounds", i, t));
    }
    get scrollMargin() {
      return this.Vf;
    }
    set scrollMargin(t) {
      typeof t == "number" ? t = new Margin2(t) : Util.s(t, Margin2, _Diagram, "scrollMargin");
      const i = this.Vf;
      i.equals(t) || (t = t.L(), this.Vf = t, this.i("scrollMargin", i, t), this.Pu());
    }
    get scrollMode() {
      return this.Zh;
    }
    set scrollMode(t) {
      const i = this.Zh;
      i !== t && (Util.it(t, ScrollMode2, "ScrollMode"), this.Zh = t, t === 1 && this.Hs(false), this.i("scrollMode", i, t), this.ca(), this.T());
    }
    get scrollsPageOnFocus() {
      return this.Ix;
    }
    set scrollsPageOnFocus(t) {
      const i = this.Ix;
      i !== t && (Util.t(t, "boolean", _Diagram, "scrollsPageOnFocus"), this.Ix = t, this.i("scrollsPageOnFocus", i, t));
    }
    get positionComputation() {
      return this.Ox;
    }
    set positionComputation(t) {
      const i = this.Ox;
      i !== t && (t !== null && Util.t(t, "function", _Diagram, "positionComputation"), this.Ox = t, this.Hs(false), this.i("positionComputation", i, t));
    }
    get scaleComputation() {
      return this.Ex;
    }
    set scaleComputation(t) {
      const i = this.Ex;
      i !== t && (t !== null && Util.t(t, "function", _Diagram, "scaleComputation"), this.Ex = t, this.EA(this.scale, this.scale), this.i("scaleComputation", i, t));
    }
    get documentBounds() {
      return this.Qm;
    }
    zA(t) {
      this.ea = false;
      let i = this.Qm;
      i.equals(t) || (i = i.copy(), this.Qm.c(t), this.Hs(false), this.V("DocumentBoundsChanged", void 0, i), this.ca(), this.T());
    }
    ensureBounds() {
      if (this.ea) {
        const t = Rect2.a();
        this.zA(this.computeBounds(t)), Rect2.o(t);
      }
    }
    get isVirtualized() {
      return this.f1;
    }
    set isVirtualized(t) {
      const i = this.f1;
      i !== t && (Util.t(t, "boolean", _Diagram, "isVirtualized"), this.f1 = t, this.i("isVirtualized", i, t));
    }
    get scale() {
      return this.v;
    }
    set scale(t) {
      const i = this.v;
      Util.r(t, _Diagram, "scale"), i !== t && this.EA(i, t);
    }
    get defaultScale() {
      return this.s0;
    }
    set defaultScale(t) {
      Debug && Util.r(t, _Diagram, "defaultScale"), Debug && !(t > 0) && Util.n("defaultScale must be larger than zero, not: " + t), this.s0 = t;
    }
    get autoScale() {
      return this.Ql;
    }
    set autoScale(t) {
      const i = this.Ql;
      i !== t && (Util.it(t, AutoScale2, "AutoScale"), this.Ql = t, this.i("autoScale", i, t), t !== 1 && this.Hs(false));
    }
    get initialAutoScale() {
      return this.Ir;
    }
    set initialAutoScale(t) {
      const i = this.Ir;
      i !== t && (Util.it(t, AutoScale2, "AutoScale"), this.Ir = t, this.i("initialAutoScale", i, t));
    }
    get initialViewportSpot() {
      return this.Bx;
    }
    set initialViewportSpot(t) {
      const i = this.Bx;
      i !== t && (Util.s(t, Spot2, _Diagram, "initialViewportSpot"), t.isSpot() || Util.n("initialViewportSpot must be a specific Spot: " + t), this.Bx = t, this.i("initialViewportSpot", i, t));
    }
    get initialDocumentSpot() {
      return this.Vx;
    }
    set initialDocumentSpot(t) {
      const i = this.Vx;
      i !== t && (Util.s(t, Spot2, _Diagram, "initialDocumentSpot"), t.isSpot() || Util.n("initialViewportSpot must be a specific Spot: " + t), this.Vx = t, this.i("initialDocumentSpot", i, t));
    }
    get minScale() {
      return this.Tx;
    }
    set minScale(t) {
      Util.r(t, _Diagram, "minScale");
      const i = this.Tx;
      i !== t && (t > 0 ? (this.Tx = t, this.i("minScale", i, t), t > this.scale && (this.scale = t)) : Util.G(t, "> 0", _Diagram, "minScale"));
    }
    get maxScale() {
      return this.Dx;
    }
    set maxScale(t) {
      Util.r(t, _Diagram, "maxScale");
      const i = this.Dx;
      i !== t && (t > 0 ? (this.Dx = t, this.i("maxScale", i, t), t < this.scale && (this.scale = t)) : Util.G(t, "> 0", _Diagram, "maxScale"));
    }
    get zoomPoint() {
      return this.Fx;
    }
    set zoomPoint(t) {
      this.Fx.equals(t) || (Util.s(t, Point2, _Diagram, "zoomPoint"), t = t.L(), this.Fx = t);
    }
    get contentAlignment() {
      return this.Bf;
    }
    set contentAlignment(t) {
      const i = this.Bf;
      i.equals(t) || (Util.s(t, Spot2, _Diagram, "contentAlignment"), t = t.L(), this.Bf = t, this.i("contentAlignment", i, t), this.Hs(false));
    }
    get initialContentAlignment() {
      return this.Wm;
    }
    set initialContentAlignment(t) {
      const i = this.Wm;
      i.equals(t) || (Util.s(t, Spot2, _Diagram, "initialContentAlignment"), t = t.L(), this.Wm = t, this.i("initialContentAlignment", i, t));
    }
    get padding() {
      return this.ei;
    }
    set padding(t) {
      typeof t == "number" ? t = new Margin2(t) : Util.s(t, Margin2, _Diagram, "padding");
      const i = this.ei;
      i.equals(t) || (t = t.L(), this.ei = t, this.invalidateDocumentBounds(), this.i("padding", i, t));
    }
    get partManager() {
      return this.cP;
    }
    set partManager(t) {
      const i = this.cP;
      i !== t && (Util.s(t, PartManager, _Diagram, "partManager"), t.diagram !== null && Util.n("Cannot share PartManagers between Diagrams: " + t.toString()), i && i.Vo(null), this.cP = t, t.Vo(this));
    }
    get nodes() {
      return this.partManager.nodes.iterator;
    }
    get links() {
      return this.partManager.links.iterator;
    }
    get parts() {
      return this.partManager.parts.iterator;
    }
    findTopLevelNodesAndLinks() {
      const t = new GSet2(), i = this.nodes;
      for (; i.next(); ) {
        const s = i.value;
        s.isTopLevel && t.add(s);
      }
      const e = this.links;
      for (; e.next(); ) {
        const s = e.value;
        s.isTopLevel && t.add(s);
      }
      return t.iterator;
    }
    findTopLevelGroups() {
      return this.Zr.iterator;
    }
    get routers() {
      return this.vf;
    }
    doLinkRouting(t) {
      this.zo = true;
      const i = this.vf.h;
      for (let e = 0; e < i.length; e++)
        i[e].canRoute(t) && i[e].routeLinks(this.Or, t);
      this.zo = false;
    }
    get layout() {
      return this.le;
    }
    set layout(t) {
      const i = this.le;
      i !== t && (Util.s(t, Layout2, _Diagram, "layout"), this.le = t, t.diagram = this, t.group = null, this.Jr = true, this.i("layout", i, t), this.requestUpdate());
    }
    layoutDiagram(t) {
      this.Fi(), t && this.F1(true), this.Ps ? this.CP(false, this.Al || this.vf.count !== 0 && this._n.size !== 0) : (this.Xf = true, this.Pr());
    }
    F1(t) {
      const i = this.Zr.iterator;
      for (; i.next(); )
        this.XA(i.value, t);
      this.layout && (t ? this.layout.isValidLayout = false : this.layout.invalidateLayout());
    }
    XA(t, i) {
      if (t === null)
        return;
      const e = t.ua.iterator;
      for (; e.next(); ) {
        const s = e.value;
        this.XA(s, i);
      }
      t.layout !== null && (i ? t.layout.isValidLayout = false : t.layout.invalidateLayout());
    }
    CP(t, i) {
      if (this.qx)
        return;
      const e = this.W;
      this.W = true;
      const s = "Layout", n = this.undoManager.transactionLevel, o = this.layout, r = this.animationManager;
      try {
        n === 0 && (this.undoManager.Cl = true, this.startTransaction(s)), n <= 1 && !r.defaultAnimation.isAnimating && !r.Mi && (t || r.zl(s)), this.Jr = false;
        let l = this.Zr.iterator;
        for (; l.next(); )
          this.YA(l.value, t, n, i);
        let h = false;
        if (o.isValidLayout || (!t || o.isRealtime || o.isRealtime === null || n === 0 ? (o.doLayout(this), this.g0(this), h = true, o.isValidLayout = true) : this.Jr = true), h || this.g0(this), this.doLinkRouting(this), this.Or.clear(), this._h.size !== 0) {
          for (let a = 0; a < 23 && this._h.size !== 0; a++) {
            for (l = this.Zr.iterator; l.next(); )
              this.KA(l.value);
            const f = this.Or;
            this.Or = this._h, this._h = f, this.g0(this), this.doLinkRouting(this);
          }
          this.Or.clear(), this._h.clear();
        }
      } finally {
        const l = this.undoManager.Cl;
        n === 0 && (this.commitTransaction(s), this.undoManager.Cl = false), l && (n === 0 || n === 1) && r.FM(), this.Jr && (this.Jr = !o.isValidLayout), this.W = e;
      }
    }
    YA(t, i, e, s) {
      const n = t.ua.iterator;
      for (; n.next(); )
        this.YA(n.value, i, e, s);
      const o = t.layout;
      o !== null && !o.isValidLayout ? !i || o.isRealtime || e === 0 ? (t.sl = !t.location.isReal(), o.doLayout(t), t.invalidateLayout(32), this.L1(t), this.g0(t), this.doLinkRouting(t), o.isValidLayout = true) : (this.doLinkRouting(t), this.Jr = true) : s && this.doLinkRouting(t);
    }
    KA(t) {
      const i = t.ua.iterator;
      for (; i.next(); )
        this.KA(i.value);
      this.g0(t), this.doLinkRouting(t);
    }
    get isTreePathToChildren() {
      return this.zx;
    }
    set isTreePathToChildren(t) {
      const i = this.zx;
      if (i !== t && (Util.t(t, "boolean", _Diagram, "isTreePathToChildren"), this.zx = t, this.i("isTreePathToChildren", i, t), !this.undoManager.isUndoingRedoing)) {
        const e = this.nodes;
        for (; e.next(); )
          e.value.x0();
      }
    }
    findTreeRoots() {
      const t = new List2(), i = this.nodes;
      for (; i.next(); ) {
        const e = i.value;
        e.isTopLevel && e.findTreeParentLink() === null && t.add(e);
      }
      return t.iterator;
    }
    get treeCollapsePolicy() {
      return this.Xx;
    }
    set treeCollapsePolicy(t) {
      const i = this.Xx;
      i !== t && (t !== 1 && t !== 2 && t !== 3 && Util.n("Unknown Diagram.treeCollapsePolicy: " + t), this.Xx = t, this.i("treeCollapsePolicy", i, t));
    }
    get isCollapsingExpanding() {
      return this.ZM;
    }
    set isCollapsingExpanding(t) {
      this.ZM = t;
    }
    HF() {
      const t = new GMap2(), i = new GMap2();
      function e(s) {
        const n = s.toLowerCase(), o = new List2();
        t.add(s, o), t.add(n, o), i.add(s, s), i.add(n, s);
      }
      e("InitialAnimationStarting"), e("AnimationStarting"), e("AnimationFinished"), e("BackgroundSingleClicked"), e("BackgroundDoubleClicked"), e("BackgroundContextClicked"), e("ClipboardChanged"), e("ClipboardPasted"), e("DocumentBoundsChanged"), e("ExternalObjectsDropped"), e("GainedFocus"), e("InitialLayoutCompleted"), e("LayoutCompleted"), e("LinkDrawn"), e("LinkRelinked"), e("LinkReshaped"), e("LostFocus"), e("Modified"), e("ObjectSingleClicked"), e("ObjectDoubleClicked"), e("ObjectContextClicked"), e("PartCreated"), e("PartResized"), e("PartRotated"), e("SelectionMoved"), e("SelectionCopied"), e("SelectionDeleting"), e("SelectionDeleted"), e("SelectionGrouped"), e("SelectionUngrouped"), e("ChangingSelection"), e("ChangedSelection"), e("SubGraphCollapsed"), e("SubGraphExpanded"), e("TextEdited"), e("ThemeChanged"), e("TreeCollapsed"), e("TreeExpanded"), e("ViewportBoundsChanged"), e("InvalidateDraw"), this.jM = t, this.JM = i;
    }
    NA(t) {
      const i = this.JM.getValue(t);
      return i !== null ? i : this.JM.getValue(t.toLowerCase());
    }
    VP(t) {
      let i = this.jM.getValue(t);
      if (i !== null)
        return i;
      const e = t.toLowerCase();
      if (i = this.jM.getValue(e), i !== null)
        return i;
      Util.n("Unknown DiagramEvent name: " + t);
    }
    addDiagramListener(t, i) {
      Util.t(t, "string", _Diagram, "addDiagramListener:name"), Util.t(i, "function", _Diagram, "addDiagramListener:listener");
      const e = this.VP(t);
      return e !== null && e.add(i), this;
    }
    removeDiagramListener(t, i) {
      Util.t(t, "string", _Diagram, "removeDiagramListener:name"), Util.t(i, "function", _Diagram, "addDiagramListener:listener");
      const e = this.VP(t);
      e !== null && e.remove(i);
    }
    raiseDiagramEvent(t, i, e) {
      this.V(t, i, e);
    }
    V(t, i, e) {
      Debug && Util.t(t, "string", _Diagram, "raiseDiagramEvent:name");
      const s = this.VP(t), n = new DiagramEvent2();
      n.diagram = this;
      const o = this.NA(t);
      o !== null && (n.name = o), i !== void 0 && (n.subject = i), e !== void 0 && (n.parameter = e);
      const r = s.length;
      if (r === 1)
        s.elt(0)(n);
      else if (r !== 0) {
        const l = s.toArray();
        for (let h = 0; h < r; h++) {
          const a = l[h];
          a(n);
        }
      }
    }
    isUnoccupied(t, i) {
      return this.getPositions(false, null, i || null).isUnoccupied(t.x, t.y, t.width, t.height);
    }
    computeOccupiedArea(t) {
      return this.isVirtualized ? this.viewportBounds.copy() : this.ea ? this.SA(t) : t.c(this.documentBounds);
    }
    getPositions(t, i, e) {
      let s = this._l;
      s === null && (this._l = s = new PositionArray(this.avoidanceCellSize));
      let n = i;
      if (s.Go || s.da !== n || s.BP !== e) {
        if (s.zP = Math.max(s.Jf + 1, Math.floor(this.avoidanceLimit / this.avoidanceCellSize.width)), s.XP = Math.max(s.Jf + 1, Math.floor(this.avoidanceLimit / this.avoidanceCellSize.height)), n !== null && (n = this.UA(n)), n === null) {
          const o = Rect2.a();
          this.computeOccupiedArea(o), o.inflate(100, 100), s.R1(o);
          const r = this.nodes;
          for (; r.next(); ) {
            const l = r.value, h = l.layer;
            h === null || !h.visible || h.isTemporary || this.YP(l, e, o);
          }
          Rect2.o(o);
        } else {
          if (n.memberParts.count > 0) {
            const l = this.computePartsBounds(n.memberParts, false);
            l.inflate(20, 20), s.R1(l);
          }
          const o = Rect2.a(), r = n.memberParts;
          for (; r.next(); ) {
            const l = r.value;
            l instanceof Node2 && this.YP(l, e, o);
          }
          Rect2.o(o);
        }
        s.da = n, s.BP = e, s.Go = false;
      } else
        t && s.GA();
      return s;
    }
    get avoidanceCellSize() {
      return this.aP;
    }
    set avoidanceCellSize(t) {
      this._l = null, this.aP = new Size2(Math.max(1, t.width), Math.max(1, t.height));
    }
    get avoidanceLimit() {
      return this.fP;
    }
    set avoidanceLimit(t) {
      this.fP = Math.max(1, t);
    }
    UA(t) {
      return t.canAvoid() ? t : t.containingGroup !== null ? this.UA(t.containingGroup) : null;
    }
    YP(t, i, e) {
      if (t === i || !t.isVisible())
        return;
      const s = t.canAvoid();
      if (s) {
        const n = t.getAvoidableRect(e);
        this._l.PR(n.x, n.y, n.width, n.height);
      }
      if (t instanceof Group2 && (!s || t.avoidableMembers)) {
        const n = t.memberParts;
        for (; n.next(); ) {
          const o = n.value;
          o instanceof Node2 && this.YP(o, i, e);
        }
      }
    }
    KP(t) {
      this._l !== null && !this._l.Go && (t === void 0 || t.canAvoid()) && (this._l.Go = true);
    }
    get autoScrollInterval() {
      return this.jm;
    }
    set autoScrollInterval(t) {
      const i = this.jm;
      Util.r(t, _Diagram, "scale"), i !== t && (this.jm = t, this.i("autoScrollInterval", i, t));
    }
    get autoScrollRegion() {
      return this.Jm;
    }
    set autoScrollRegion(t) {
      typeof t == "number" ? t = new Margin2(t) : Util.s(t, Margin2, _Diagram, "autoScrollRegion");
      const i = this.Jm;
      i.equals(t) || (t = t.L(), this.Jm = t, this.invalidateDocumentBounds(), this.i("autoScrollRegion", i, t));
    }
    doAutoScroll(t) {
      this.i0.c(t), this.computeAutoScrollPosition(this.i0).equalsApprox(this.position) ? this.stopAutoScroll() : this.HA();
    }
    HA() {
      if (this.zf !== -1)
        return;
      const t = this.jm, i = this;
      this.zf = Util.Xh(() => {
        if (i.zf === -1 || (i.stopAutoScroll(), i.lastInput.event === null))
          return;
        const s = i.computeAutoScrollPosition(i.i0);
        if (s.equalsApprox(i.position))
          return;
        i.position = s, i.lastInput.documentPoint = i.transformViewToDoc(i.i0), i.doMouseMove(), i.ea = true;
        const n = Rect2.a();
        i.computeBounds(n), n.unionRect(i.documentBounds), i.zA(n), Rect2.o(n), i.qe = true, i.maybeUpdate(), i.HA();
      }, t);
    }
    stopAutoScroll() {
      this.zf !== -1 && (Util.Gg(this.zf), this.zf = -1);
    }
    computeAutoScrollPosition(t) {
      let i = this.position;
      const e = this.Jm;
      if (e.top <= 0 && e.left <= 0 && e.right <= 0 && e.bottom <= 0)
        return i;
      const s = this.viewportBounds, n = this.scale, o = Rect2.H(0, 0, s.width * n, s.height * n), r = Point2.H(0, 0);
      if (t.x >= o.x && t.x < o.x + e.left && this.allowHorizontalScroll) {
        let l = Math.max(this.scrollHorizontalLineChange, 1);
        l = l | 0, r.x -= l, t.x < o.x + e.left / 2 && (r.x -= l), t.x < o.x + e.left / 4 && (r.x -= 4 * l);
      } else if (t.x <= o.x + o.width && t.x > o.x + o.width - e.right && this.allowHorizontalScroll) {
        let l = Math.max(this.scrollHorizontalLineChange, 1);
        l = l | 0, r.x += l, t.x > o.x + o.width - e.right / 2 && (r.x += l), t.x > o.x + o.width - e.right / 4 && (r.x += 4 * l);
      }
      if (t.y >= o.y && t.y < o.y + e.top && this.allowVerticalScroll) {
        let l = Math.max(this.scrollVerticalLineChange, 1);
        l = l | 0, r.y -= l, t.y < o.y + e.top / 2 && (r.y -= l), t.y < o.y + e.top / 4 && (r.y -= 4 * l);
      } else if (t.y <= o.y + o.height && t.y > o.y + o.height - e.bottom && this.allowVerticalScroll) {
        let l = Math.max(this.scrollVerticalLineChange, 1);
        l = l | 0, r.y += l, t.y > o.y + o.height - e.bottom / 2 && (r.y += l), t.y > o.y + o.height - e.bottom / 4 && (r.y += 4 * l);
      }
      return r.equalsApprox(Point2.To) || (i = new Point2(i.x + r.x / n, i.y + r.y / n)), Rect2.o(o), Point2.o(r), i;
    }
    makeSvg(t) {
      this.ih.contains("SVG") || this.addRenderer("SVG", new SVGSurface(this, root.document));
      const i = new SVGSurface(this, root.document, true);
      t === void 0 && (t = {});
      const e = this;
      function s(n, o) {
        const r = e.vA(n, "SVG", i), l = r !== null ? r.svg : null;
        return typeof o == "function" ? (o(l), null) : l;
      }
      return this.qA(s, t);
    }
    makeSVG(t) {
      return this.makeSvg(t);
    }
    addRenderer(t, i) {
      this.ih.add(t, i);
    }
    removeRenderer(t) {
      this.ih.remove(t);
    }
    cacheGroupExternalLinks(t) {
      this.wP = t, t || this.nodes.each((i) => {
        i instanceof Group2 && (i.b0 = null);
      });
    }
    qA(t, i) {
      const e = i.callback;
      let s = true;
      const o = this.eh.iterator;
      for (; o.next(); )
        if (!o.value[0].Sn) {
          s = false;
          break;
        }
      if (typeof e != "function" || s)
        return t(i, e, this);
      const r = this;
      function l() {
        const f = +/* @__PURE__ */ new Date();
        for (s = true, o.reset(); o.next(); )
          if (!o.value[0].Sn) {
            s = false;
            break;
          }
        if (s || f - a > h) {
          t(i, e, r);
          return;
        }
        root.requestAnimationFrame(l);
      }
      const h = i.callbackTimeout || 300, a = +/* @__PURE__ */ new Date();
      return root.requestAnimationFrame(() => l()), null;
    }
    makeImage(t) {
      return _Diagram.isUsingDOM() ? (t === void 0 && (t = {}), t.returnType = "Image", this.makeImageData(t)) : null;
    }
    makeImageData(t) {
      return t === void 0 && (t = {}), this.qA(this.NR, t);
    }
    NR(t, i, e) {
      const s = e.vA(t, "canvas", null);
      if (s === null)
        return null;
      const n = s.Y.canvas;
      let o = null;
      if (n !== null) {
        let r = t.returnType;
        switch (r === void 0 ? r = "string" : r = r.toLowerCase(), r) {
          case _Diagram.img + "data":
            o = s.getImageData(0, 0, n.width, n.height);
            break;
          case _Diagram.img:
            const h = (t.document || document).createElement("img");
            h.src = n.toDataURL(t.type, t.details), o = h;
            break;
          case "blob": {
            const a = n;
            return typeof i != "function" && (o = "", Util.n('Error: Diagram.makeImageData called with "returnType: toBlob", but no required "callback" function property defined.')), typeof a.toBlob == "function" ? (a.toBlob(i, t.type, t.details), "toBlob") : (i(null), null);
          }
          case "string":
          default:
            o = n.toDataURL(t.type, t.details);
        }
      }
      return typeof i == "function" ? (i(o), null) : o;
    }
    vA(t, i, e) {
      if (this.animationManager.stopAnimation(), this.maybeUpdate(), this.xt === null)
        return null;
      typeof t != "object" && Util.n("properties argument must be an Object.");
      let n = false, o = t.size || null, r = t.scale || null;
      t.scale !== void 0 && isNaN(t.scale) && (r = "NaN");
      let l = t.maxSize;
      t.maxSize === void 0 && (n = true, i === "SVG" ? l = new Size2(1 / 0, 1 / 0) : l = new Size2(2e3, 2e3));
      const h = t.position || null;
      let a = t.parts || null;
      Array.isArray(a) && (a = new List2(a));
      let f = t.padding === void 0 ? 1 : t.padding;
      const c = t.background || null;
      let u = t.omitTemporary;
      u === void 0 && (u = true);
      const d = t.document || document, m = t.elementFinished || null;
      let g = t.showTemporary;
      g === void 0 && (g = !u);
      let p = t.showGrid;
      p === void 0 && (p = g), o !== null && isNaN(o.width) && isNaN(o.height) && (o = null), typeof f == "number" ? f = new Margin2(f) : f instanceof Margin2 || Util.n("MakeImage padding must be a Margin or a number."), f.left = Math.max(f.left, 0), f.right = Math.max(f.right, 0), f.top = Math.max(f.top, 0), f.bottom = Math.max(f.bottom, 0), this.ai.clearContextCache(true);
      const y = new CanvasSurface(null, d, void 0, true), x = y.gi;
      if (!(o || r || a || h))
        return y.width = this.Ct + Math.ceil(f.left + f.right), y.height = this.At + Math.ceil(f.top + f.bottom), i === "SVG" ? e === null ? null : (e.resize(y.width, y.height, y.width, y.height), e.ga = d, e.$u = m, this.T1(e.gi, f, new Size2(y.width, y.height), this.v, this.lt, a, c, g, p), e.gi) : (this.qu = false, this.T1(x, f, new Size2(y.width, y.height), this.v, this.lt, a, c, g, p), this.qu = true, y.gi);
      const b = this.s0, k = this.documentBounds.copy();
      if (k.subtractMargin(this.ei), g) {
        const L = this.Jt.h, D = L.length;
        for (let F = 0; F < D; F++) {
          const R = L[F];
          if (!R.visible || !R.isTemporary)
            continue;
          const I = R.It.h, O = I.length;
          for (let B = 0; B < O; B++) {
            const K = I[B];
            if (!K.isInDocumentBounds || !K.isVisible())
              continue;
            const V = K.actualBounds;
            V.isReal() && k.unionRect(V);
          }
        }
      }
      let S = new Point2(k.x, k.y);
      if (a !== null) {
        const L = new Rect2(0, 0, 0, 0);
        let D = true;
        const F = a.iterator;
        for (F.reset(); F.next(); ) {
          const R = F.value;
          if (!(R instanceof Part2))
            continue;
          const I = R.layer;
          if (I !== null && !I.visible || I !== null && !g && I.isTemporary || !R.isVisible())
            continue;
          const O = R.actualBounds;
          O.isReal() && (D ? (D = false, L.c(O)) : L.unionRect(O));
        }
        k.width = L.width, k.height = L.height, S.x = L.x, S.y = L.y;
      }
      h !== null && h.isReal() && (S = h, r || (r = b));
      let M = 0, A = 0;
      f !== null && (M = f.left + f.right, A = f.top + f.bottom);
      let C = 0, P = 0;
      o !== null && (C = o.width, P = o.height, isFinite(C) && (C = Math.max(0, C - M)), isFinite(P) && (P = Math.max(0, P - A)));
      let N = 0, T = 0;
      if (o !== null && r !== null ? (r === "NaN" && (r = b), o.isReal() ? (N = C, T = P) : isNaN(P) ? (N = C, T = k.height * r) : (N = k.width * r, T = P)) : o !== null ? o.isReal() ? (r = Math.min(C / k.width, P / k.height), N = C, T = P) : isNaN(P) ? (r = C / k.width, N = C, T = k.height * r) : (r = P / k.height, N = k.width * r, T = P) : r !== null ? r === "NaN" && l.isReal() ? (r = Math.min((l.width - M) / k.width, (l.height - A) / k.height), r > b ? (r = b, N = k.width, T = k.height) : (N = l.width, T = l.height)) : (N = k.width * r, T = k.height * r) : (r = b, N = k.width, T = k.height), f !== null ? (N += M, T += A) : f = new Margin2(0), l !== null) {
        let L = l.width, D = l.height;
        i !== "SVG" && n && !_Diagram.WA && Debug && (N > L || T > D) && (Util.ft("Diagram.makeImage(data): Diagram width or height is larger than the default max size. (" + Math.ceil(N) + "x" + Math.ceil(T) + " vs 2000x2000) Consider increasing the max size."), _Diagram.WA = true), isNaN(L) && (L = 2e3), isNaN(D) && (D = 2e3), isFinite(L) && (N = Math.min(N, L)), isFinite(D) && (T = Math.min(T, D));
      }
      return y.width = Math.ceil(N), y.height = Math.ceil(T), i === "SVG" ? e === null ? null : (e.resize(y.width, y.height, y.width, y.height), e.ga = d, e.$u = m, this.T1(e.gi, f, new Size2(Math.ceil(N), Math.ceil(T)), r, S, a, c, g, p), e.gi) : (this.qu = false, this.T1(x, f, new Size2(Math.ceil(N), Math.ceil(T)), r, S, a, c, g, p), this.qu = true, y.gi);
    }
  };
  __publicField(_Diagram, "b1", null);
  __publicField(_Diagram, "cA", new GMap2());
  __publicField(_Diagram, "mP");
  __publicField(_Diagram, "pP", null);
  __publicField(_Diagram, "mA", root.document !== void 0);
  __publicField(_Diagram, "he", /* @__PURE__ */ new WeakMap());
  __publicField(_Diagram, "c0", null);
  __publicField(_Diagram, "A1", "");
  __publicField(_Diagram, "None", 1);
  __publicField(_Diagram, "Uniform", 2);
  __publicField(_Diagram, "UniformToFill", 3);
  __publicField(_Diagram, "CycleAll", 1);
  __publicField(_Diagram, "CycleNotDirected", 2);
  __publicField(_Diagram, "CycleNotDirectedFast", 3);
  __publicField(_Diagram, "CycleNotUndirected", 4);
  __publicField(_Diagram, "CycleDestinationTree", 5);
  __publicField(_Diagram, "CycleSourceTree", 6);
  __publicField(_Diagram, "DocumentScroll", 1);
  __publicField(_Diagram, "InfiniteScroll", 2);
  __publicField(_Diagram, "TreeParentCollapsed", 1);
  __publicField(_Diagram, "AllParentsCollapsed", 2);
  __publicField(_Diagram, "AnyParentsCollapsed", 3);
  __publicField(_Diagram, "IP", new List2());
  __publicField(_Diagram, "xR", "3.0.2");
  __publicField(_Diagram, "img", "image");
  __publicField(_Diagram, "WA", false);
  __publicField(_Diagram, "Ju", null);
  __publicField(_Diagram, "jA", "5da73c80a36555d4038e4972187c3cae51fd22");
  __publicField(_Diagram, "ww", false);
  __publicField(_Diagram, "Hk", () => {
    if (_Diagram.jA[5] === void 0 && (Transform.prototype.rs = Transform.prototype.Pw), !_Diagram.isUsingDOM())
      return;
    const t = root.document.createElement("canvas"), i = t.getContext("2d"), e = Util.Os("7ca11abfd022028846");
    i[e] = Util.Os("398c3597c01238");
    const s = "7ca11abfd7330390", n = [_Diagram.jA, Util.ww + "4ae6247590da4bb21c324ba3a84e385776", Transform.Hk + "fb236cdfda5de14c134ba1a95a2d4c7cc6f93c1387", Geo.za], o = 10, r = 0;
    for (let l = 1; l < 5; l++)
      i[Util.Os(s)](Util.Os(n[l - 1]), o, l * 15 + r);
    i[e] = Util.Os("39f046ebb36e4b");
    for (let l = 1; l < 5; l++)
      i[Util.Os(s)](Util.Os(n[l - 1]), o, l * 15 + r);
    (n.length !== 4 || n[0][0] !== "5" || n[3][0] !== "7") && (Transform.prototype.rs = Transform.prototype.Pw), _Diagram.Ju = t;
  });
  let Diagram2 = _Diagram;
  class DiagramHelper {
    constructor(t) {
      __publicField(this, "JA");
      __publicField(this, "ZA");
      __publicField(this, "UP");
      __publicField(this, "Ie");
      if (this.JA = null, this.ZA = "63ad05bbe23a1786468a4c741b6d2", this.UP = "@onz", this.ZA === this._tk) {
        this.UP = true, this.Ie = this.UP;
        return;
      }
      this.Ie = null;
    }
    CR(t, i) {
      let e = "f";
      const s = root[Util.Os("76a715b2f73f148a")][Util.Os("72ba13b5")] || "", n = Util.Os;
      if (this.Ie = true, !Diagram2.isUsingDOM())
        return;
      let o = Diagram2[n("76a115b6ed251eaf4692")];
      if (!o) {
        const l = s[n("76ad18b4f73e")];
        for (let a = s[n("73a612b6fb191d")](n("35e7")) + 2; a < l; a++)
          e += s[a];
        const h = e[n("73a612b6fb191d")](n("7da71ca0ad381e90"));
        this.Ie = !(h >= 0 && h < e[n("73a612b6fb191d")](n("35")));
        return;
      }
      const r = Diagram2.IP.iterator;
      for (; r.next(); ) {
        o = r.value;
        const l = n(o).split(n("39e9"));
        if (l.length < 6)
          return;
        const h = n(l[1]).split(".");
        if (l[4] !== "7da71ca0")
          return;
        const a = n(Util[n("6cae19")]).split(".");
        if (!(h[0] > a[0] || h[0] === a[0] && h[1] >= a[1]))
          continue;
        const f = "73a612b6fb191d", c = root[n("74a900bae4370f8b51")][n("6fbb13a1c2311e8a57")].toLowerCase(), u = c[n(f)](n("3aad1ab6e022098b4dc4")), d = n(l[2]);
        if (u > -1) {
          const P = c[n(f)](d.toLowerCase() + "/");
          if (this.Ie = !(P > -1 && P < u), !this.Ie)
            return;
        }
        const m = s[n("76ad18b4f73e")];
        for (let P = s[n(f)](n("35e7")) + 2; P < m; P++)
          e += s[P];
        let g = e[n(f)](d);
        if (g < 0 && d !== n("7da71ca0ad381e90") && (g = e[n(f)](n("76a715b2ef3e149757"))), g < 0 && (g = e[n(f)](n("76a715b2ef3e149757"))), g < 0 && (g = e[n(f)](n("2bfa41fdb3784bca12"))), g < 0 && (g = s[n(f)](n("7baa19a6f76c1988428554"))), this.Ie = !(g >= 0 && g < e[n(f)](n("35")) || e[n(f)](n("35")) === -1), !this.Ie || s[n(f)](n("7fb002b6ed25128b4da25b2e")) && (this.Ie = !(s[n(f)](d) > -1), !this.Ie))
          return;
        const p = root[Util.Os("76a715b2f73f148a")][Util.Os("69ad17a1e03e")], y = p[n(f)](n("7fb002b6ed25128b4da25b2e"));
        if (y > -1 && (this.Ie = !(p[n(f)](d) > y), !this.Ie))
          return;
        const x = d;
        if (x[0] !== "#")
          continue;
        const b = root.document.createElement("div");
        let k = l[0].replace(/[A-Za-z]/g, "");
        for (; k.length < 4; )
          k += "9";
        const S = k;
        k = k.substring(k.length - 4);
        let M = "";
        const A = ["gsh", "gsf"], C = ["Header", "Background", "Display", "Feedback"];
        if (M += A[parseInt(k.substring(0, 1), 10) % 2], M += C[parseInt(k.substring(0, 1), 10) % 4], b[n("79a417a0f0181a8946")] = M, root.document[n("78a712aa")]) {
          root.document[n("78a712aa")][n("7bb806b6ed32388c4a875b")](b);
          const P = root.getComputedStyle(b).getPropertyValue(n("78a704b7e62456904c9b12701b6532a8")), N = root.getComputedStyle(b).getPropertyValue(n("75b817b0ea2202"));
          if (root.document[n("78a712aa")][n("68ad1bbcf533388c4a875b")](b), !P)
            continue;
          const T = root[n("77a902b0eb1b1e804a8a")], L = "0." + parseInt(S, 10) % 100;
          if (N === L || P.indexOf(parseInt(x[1] + x[2], 16)) !== -1 && P.indexOf(parseInt(x[3] + x[4], 16)) !== -1) {
            this.Ie = false;
            return;
          } else if (T && T(n("32ae19a1e0331fc94084537c067a67fa59f1386b89d006")).matches) {
            M = "." + M;
            for (let D = 0; D < document.styleSheets.length; D++) {
              const F = document.styleSheets[D].rules || document.styleSheets[D].cssRules;
              for (const R in F)
                if (M === F[R].selectorText) {
                  this.Ie = false;
                  return;
                }
            }
          }
        } else
          this.Ie = null, i && (this.Ie = false);
      }
    }
    Ju(t) {
      return t.ai.setTransform(t.Gi, 0, 0, t.Gi, 0, 0), t.ai.commitTransform(), this.Ie === null && this.CR(t, true), 0 < this.Ie && this !== this.JA;
    }
  }
  class DraggingInfo2 {
    constructor(t) {
      __publicField(this, "GP");
      __publicField(this, "HP");
      this.GP = t === void 0 ? new Point2() : t, this.HP = new Point2();
    }
    get point() {
      return this.GP;
    }
    set point(t) {
      this.GP = t;
    }
    get shifted() {
      return this.HP;
    }
    set shifted(t) {
      this.HP = t;
    }
  }
  class DraggingNodeInfoPair {
    constructor(t, i, e) {
      __publicField(this, "be");
      __publicField(this, "DA");
      __publicField(this, "D1");
      this.be = t, this.DA = i, this.D1 = e;
    }
  }
  class DraggingOptions2 {
    constructor(t) {
      __publicField(this, "isGridSnapEnabled");
      __publicField(this, "isGridSnapRealtime");
      __publicField(this, "gridSnapCellSize");
      __publicField(this, "gridSnapCellSpot");
      __publicField(this, "gridSnapOrigin");
      __publicField(this, "dragsLink");
      __publicField(this, "dragsTree");
      __publicField(this, "groupsSnapMembers");
      __publicField(this, "groupsAlwaysMove");
      __publicField(this, "dragsMembers");
      this.ti(), t && Object.assign(this, t);
    }
    ti() {
      this.isGridSnapEnabled = false, this.isGridSnapRealtime = true, this.gridSnapCellSize = new Size2(NaN, NaN).w(), this.gridSnapCellSpot = Spot2.TopLeft, this.gridSnapOrigin = new Point2(NaN, NaN).w(), this.dragsLink = false, this.dragsTree = false, this.groupsSnapMembers = false, this.groupsAlwaysMove = true, this.dragsMembers = true;
    }
  }
  class Palette2 extends Diagram2 {
    constructor(t, i) {
      return typeof t == "string" || root.Element && t instanceof Element ? super(t) : (super(), i = t), this.$A(), i && this.setProperties(i), this;
    }
    $A() {
      this.allowDragOut = true, this.allowMove = false, this.isReadOnly = true, this.contentAlignment = Spot2.TopCenter, this.layout = new GridLayout2();
    }
    setupRouters() {
    }
    reset() {
      super.reset(), this.$A();
    }
  }
  class Overview2 extends Diagram2 {
    constructor(t, i) {
      var __super = (...args) => {
        super(...args);
        __publicField(this, "I1");
        __publicField(this, "O1");
        __publicField(this, "E1");
        __publicField(this, "V1");
        __publicField(this, "k0");
        __publicField(this, "Zf");
        __publicField(this, "El");
        __publicField(this, "vP");
        __publicField(this, "qP");
        __publicField(this, "B1");
        __publicField(this, "WP");
        return this;
      };
      return typeof t == "string" || root.Element && t instanceof Element ? __super(t) : (__super(), i = t), this.animationManager.isEnabled = false, this.$t = true, this.I1 = null, this.Ku = false, this.Uu = false, this.O1 = true, this.E1 = true, this.V1 = 0, this.k0 = false, this.Zf = null, this.setRenderingHint("drawShadows", false), this.El = new Part2({ selectable: true, selectionAdorned: false, selectionObjectName: "BOXSHAPE", locationObjectName: "BOXSHAPE", resizeObjectName: "BOXSHAPE", cursor: "move" }).add(new Shape2({ name: "BOXSHAPE", fill: "transparent", stroke: "magenta", strokeWidth: 2 }).theme("stroke", "overviewBox")).ui(), this.allowCopy = false, this.allowDelete = false, this.allowSelect = true, this.autoScrollRegion = new Margin2(0, 0, 0, 0), this.lt.e(0, 0), this.toolManager.ii("Dragging", new OverviewDraggingTool(), this.toolManager.mouseMoveTools), this.click = () => {
        const e = this.observed;
        if (e === null)
          return;
        const s = e.viewportBounds, n = this.lastInput.documentPoint;
        e.position = new Point2(n.x - s.width / 2, n.y - s.height / 2);
      }, this.vP = (e) => {
        this.invalidateDocumentBounds(), this.S0();
      }, this.qP = (e) => {
        this.observed !== null && (this.invalidateDocumentBounds(), this.T());
      }, this.B1 = (e) => {
        this.updateDelay < 1 ? this.T() : this.k0 || (this.k0 = true, setTimeout(() => this.redraw(), this.updateDelay));
      }, this.WP = (e) => {
        this.observed !== null && this.S0();
      }, this.autoScale = 2, this.$t = false, i && Object.assign(this, i), this;
    }
    setupRouters() {
    }
    computePixelRatio() {
      return 1;
    }
    redraw() {
      this.k0 && this.updateDelay >= 1 && (this.k0 = false, this.AR()), super.redraw();
    }
    Ji() {
      if (this.Ot === null && Util.n("No div specified"), this.xt === null && Util.n("No canvas specified"), this.xt instanceof SVGSurface || (this.box.qM(), !this.qe))
        return;
      const t = this.observed;
      if (t === null || t.animationManager.defaultAnimation.isAnimating || !t.Uh)
        return;
      this.m0();
      const i = this.xt, e = this.ai;
      if (e.clearContextCache(true), e.setTransform(1, 0, 0, 1, 0, 0), e.clearRect(0, 0, i.width, i.height), this.updateDelay < 1)
        this.QA();
      else if (this.Zf !== null) {
        e.drawImage(this.Zf.Bt, 0, 0);
        const o = this.D;
        o.ti(), this.scale !== 1 && o.v(this.scale), (this.position.x !== 0 || this.position.y !== 0) && o.se(-this.position.x, -this.position.y), e.scale(this.Gi, this.Gi), e.transform(o.m11, o.m12, o.m21, o.m22, o.dx, o.dy), e.commitTransform();
      }
      const s = this.Jt.h, n = s.length;
      for (let o = 0; o < n; o++)
        s[o].Ji(e, this);
      this.Kf = false, this.qe = false;
    }
    AR() {
      const t = this.xt, i = this.ai;
      if (!(t === null || i === null)) {
        if (this.m0(), this.Zf === null) {
          const e = new CanvasSurface(null);
          e.width = t.width, e.height = t.height, this.Zf = e;
        }
        try {
          this.xt = this.Zf, this.ai = this.xt.gi, this.ai.clearContextCache(true), this.ai.setTransform(1, 0, 0, 1, 0, 0), this.ai.clearRect(0, 0, this.xt.width, this.xt.height), this.QA();
        } finally {
          this.xt = t, this.ai = i;
        }
      }
    }
    QA() {
      const t = this.observed;
      if (t === null)
        return;
      const i = this.drawsTemporaryLayers, e = this.drawsGrid && i, s = t.grid;
      if (e && s !== null && s.visible && !(isNaN(s.width) || isNaN(s.height))) {
        const a = Rect2.a().c(this.viewportBounds).unionRect(t.viewportBounds);
        t._r(a), Rect2.o(a), t.Fi();
      }
      const n = this.D;
      n.ti(), this.scale !== 1 && n.v(this.scale), (this.position.x !== 0 || this.position.y !== 0) && n.se(-this.position.x, -this.position.y);
      const o = this.ai;
      o.scale(this.Gi, this.Gi), o.transform(n.m11, n.m12, n.m21, n.m22, n.dx, n.dy), o.commitTransform();
      const r = this.viewportBounds, l = t.Jt.h, h = l.length;
      for (let a = 0; a < h; a++)
        l[a].NF(o, r, this, i, e);
    }
    get observed() {
      return this.I1;
    }
    set observed(t) {
      const i = this.I1;
      if (t !== null && Util.s(t, Diagram2, Overview2, "observed"), t instanceof Overview2 && Util.n("Overview.observed Diagram may not be an Overview itself: " + t), i !== t) {
        if (this.LR(i), this.I1 = t, this.TR(t), this.invalidateDocumentBounds(), t === null) {
          this.Zf = null;
          const e = this.xt, s = this.ai;
          e && s && (s.setTransform(1, 0, 0, 1, 0, 0), s.clearRect(0, 0, e.width, e.height));
        } else
          this.B1(null), this.S0(), this.T();
        this.i("observed", i, t);
      }
    }
    get box() {
      return this.El;
    }
    set box(t) {
      const i = this.El;
      i !== t && (t.ui(), this.El = t, this.remove(i), this.add(this.El), this.S0(), this.i("box", i, t));
    }
    get drawsTemporaryLayers() {
      return this.O1;
    }
    set drawsTemporaryLayers(t) {
      this.O1 !== t && (this.O1 = t, this.redraw());
    }
    get drawsGrid() {
      return this.E1;
    }
    set drawsGrid(t) {
      this.E1 !== t && (this.E1 = t, this.redraw());
    }
    get updateDelay() {
      return this.V1;
    }
    set updateDelay(t) {
      t < 0 && (t = 0), this.V1 !== t && (this.V1 = t);
    }
    TR(t) {
      t !== null && (t.addDiagramListener("ViewportBoundsChanged", this.vP), t.addDiagramListener("DocumentBoundsChanged", this.qP), t.addDiagramListener("InvalidateDraw", this.B1), t.addDiagramListener("AnimationFinished", this.WP), this.add(this.box));
    }
    LR(t) {
      t !== null && (this.remove(this.box), t.removeDiagramListener("ViewportBoundsChanged", this.vP), t.removeDiagramListener("DocumentBoundsChanged", this.qP), t.removeDiagramListener("InvalidateDraw", this.B1), t.removeDiagramListener("AnimationFinished", this.WP));
    }
    S0() {
      const t = this.box;
      if (t === null)
        return;
      const i = this.observed;
      if (i === null)
        return;
      this.qe = true;
      const e = i.viewportBounds, s = t.selectionObject, n = Size2.a();
      n.e(e.width, e.height), s.desiredSize = n, Size2.o(n);
      const o = 2 / this.scale;
      s instanceof Shape2 && (s.strokeWidth = o), t.location = new Point2(e.x - o / 2, e.y - o / 2), t.isSelected = true;
    }
    computeBounds() {
      const t = this.observed;
      if (t === null)
        return Rect2.Xk;
      const i = t.documentBounds.copy();
      return i.unionRect(t.viewportBounds), i;
    }
    invalidateViewport(t, i) {
      this.qe !== true && (this.qe = true, this.requestUpdate());
    }
    onViewportBoundsChanged(t, i, e, s) {
      this.$t || (this.oh(), this.T(), this.ca(), this.invalidateDocumentBounds(), this.S0(), this.Ui.scale = e, this.Ui.position.x = t.x, this.Ui.position.y = t.y, this.Ui.bounds.c(t), this.Ui.isScroll = s, this.V("ViewportBoundsChanged", this.Ui, t));
    }
  }
  class OverviewDraggingTool extends DraggingTool2 {
    constructor() {
      super();
      __publicField(this, "lh");
      this.lh = null;
    }
    canStart() {
      if (!this.isEnabled)
        return false;
      const t = this.diagram;
      if (t === null || !t.allowMove || !t.allowSelect)
        return false;
      const i = t.observed;
      if (i === null)
        return false;
      const e = t.lastInput;
      if (!e.left || t.currentTool !== this && (!this.isBeyondDragSize() || e.isTouchEvent && e.timestamp - t.firstInput.timestamp < this.delay))
        return false;
      if (this.findDraggablePart() === null) {
        const n = i.viewportBounds;
        this.lh = new Point2(n.width / 2, n.height / 2);
        const o = t.firstInput.documentPoint;
        i.position = new Point2(o.x - this.lh.x, o.y - this.lh.y);
      }
      return true;
    }
    doActivate() {
      this.lh = null, super.doActivate();
    }
    doUpdateCursor(t) {
      const i = this.diagram, e = i.box;
      e !== null && e.cursor && (i.currentCursor = e.cursor);
    }
    moveParts(t, i, e) {
      e === void 0 && (e = false);
      const s = this.diagram, n = s.observed;
      if (n === null)
        return;
      const o = s.box;
      if (o === null)
        return;
      if (this.lh === null) {
        const l = s.firstInput.documentPoint, h = o.location;
        this.lh = new Point2(l.x - h.x, l.y - h.y);
      }
      const r = s.lastInput.documentPoint;
      n.position = new Point2(r.x - this.lh.x, r.y - this.lh.y);
    }
  }
  class CommandHandler2 {
    constructor(t) {
      __publicField(this, "b");
      __publicField(this, "jP");
      __publicField(this, "JP");
      __publicField(this, "ZP");
      __publicField(this, "$P");
      __publicField(this, "QP");
      __publicField(this, "_P");
      __publicField(this, "t2");
      __publicField(this, "i2");
      __publicField(this, "hh");
      __publicField(this, "e2");
      __publicField(this, "z1");
      __publicField(this, "s2");
      __publicField(this, "X1");
      __publicField(this, "Y1");
      __publicField(this, "o2");
      __publicField(this, "Ho");
      __publicField(this, "l2");
      GSet2.ji(this), this.b = Diagram2.Pm(), this.jP = true, this.JP = true, this.ZP = true, this.$P = false, this.QP = false, this._P = false, this.t2 = false, this.i2 = null, this.hh = null, this.e2 = 1.05, this.z1 = NaN, this.s2 = null, this.X1 = NaN, this.Y1 = Rect2.Xk, this.o2 = false, this.Ho = null, this.l2 = 200, t && Object.assign(this, t);
    }
    toString() {
      return "CommandHandler";
    }
    get diagram() {
      return this.b;
    }
    Vo(t) {
      this.b = t;
    }
    doKeyDown() {
      const t = this.diagram, i = t.lastInput, e = Util.dr ? i.meta : i.control, s = i.shift, n = i.alt, o = i.code;
      e && (o === "KeyC" || o === "Insert") ? this.canCopySelection() && this.copySelection() : e && o === "KeyX" || s && o === "Delete" ? this.canCutSelection() && this.cutSelection() : e && o === "KeyV" || s && o === "Insert" ? this.canPasteSelection() && this.pasteSelection() : e && o === "KeyY" || n && s && o === "Backspace" ? this.canRedo() && this.redo() : e && o === "KeyZ" || n && o === "Backspace" ? this.canUndo() && this.undo() : o === "Delete" || o === "Backspace" ? this.canDeleteSelection() && this.deleteSelection() : e && o === "KeyA" ? this.canSelectAll() && this.selectAll() : o === "Escape" ? this.canStopCommand() && this.stopCommand() : o === "ArrowUp" ? t.allowVerticalScroll && (e ? t.scroll("pixel", "up") : t.scroll("line", "up")) : o === "ArrowDown" ? t.allowVerticalScroll && (e ? t.scroll("pixel", "down") : t.scroll("line", "down")) : o === "ArrowLeft" ? t.allowHorizontalScroll && (e ? t.scroll("pixel", "left") : t.scroll("line", "left")) : o === "ArrowRight" ? t.allowHorizontalScroll && (e ? t.scroll("pixel", "right") : t.scroll("line", "right")) : o === "PageUp" ? s && t.allowHorizontalScroll ? t.scroll("page", "left") : t.allowVerticalScroll && t.scroll("page", "up") : o === "PageDown" ? s && t.allowHorizontalScroll ? t.scroll("page", "right") : t.allowVerticalScroll && t.scroll("page", "down") : o === "Home" ? e && t.allowVerticalScroll ? t.scroll("document", "up") : !e && t.allowHorizontalScroll && t.scroll("document", "left") : o === "End" ? e && t.allowVerticalScroll ? t.scroll("document", "down") : !e && t.allowHorizontalScroll && t.scroll("document", "right") : o === "Space" ? this.canScrollToPart() && this.scrollToPart() : o === "Minus" || o === "NumpadSubtract" ? this.canDecreaseZoom() && this.decreaseZoom() : o === "Equal" || o === "NumpadAdd" ? this.canIncreaseZoom() && this.increaseZoom() : e && o === "Digit0" ? this.canResetZoom() && this.resetZoom() : s && o === "KeyZ" ? this.canZoomToFit() && this.zoomToFit() : e && !s && o === "KeyG" ? this.canGroupSelection() && this.groupSelection() : e && s && o === "KeyG" ? this.canUngroupSelection() && this.ungroupSelection() : o === "F2" ? this.canEditTextBlock() && this.editTextBlock() : o === "ContextMenu" ? this.canShowContextMenu() && this.showContextMenu() : i.bubbles = true;
    }
    doKeyUp() {
      const i = this.diagram.lastInput;
      i.bubbles = true;
    }
    stopCommand() {
      const t = this.diagram, i = t.currentTool;
      i instanceof ToolManager2 && t.allowSelect && t.clearSelection(), i !== null && i.doCancel();
    }
    canStopCommand() {
      return true;
    }
    selectAll() {
      const t = this.diagram;
      t.T();
      try {
        t.currentCursor = "wait", t.V("ChangingSelection", t.selection);
        const i = t.parts;
        for (; i.next(); ) {
          const n = i.value;
          n.canSelect() && !n.layer.isTemporary && (n.isSelected = true);
        }
        const e = t.nodes;
        for (; e.next(); ) {
          const n = e.value;
          n.canSelect() && !n.layer.isTemporary && (n.isSelected = true);
        }
        const s = t.links;
        for (; s.next(); ) {
          const n = s.value;
          n.canSelect() && !n.layer.isTemporary && (n.isSelected = true);
        }
      } finally {
        t.V("ChangedSelection", t.selection), t.currentCursor = "";
      }
    }
    canSelectAll() {
      return this.diagram.allowSelect;
    }
    deleteSelection() {
      const t = this.diagram;
      try {
        t.currentCursor = "wait", t.V("ChangingSelection", t.selection), t.startTransaction("Delete"), t.V("SelectionDeleting", t.selection);
        const i = new GSet2(), e = t.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          Part2.ah(i, s, true, this.deletesTree ? 1 / 0 : 0, this.deletesConnectedLinks ? null : false, (n) => n.canDelete());
        }
        t.removeParts(i, true), t.V("SelectionDeleted", i);
      } finally {
        t.commitTransaction("Delete"), t.V("ChangedSelection", t.selection), t.currentCursor = "";
      }
    }
    canDeleteSelection() {
      const t = this.diagram;
      return !(t.isReadOnly || t.isModelReadOnly || !t.allowDelete || t.selection.count === 0);
    }
    copySelection() {
      const t = this.diagram;
      try {
        const i = new GSet2(), e = t.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          Part2.ah(i, s, true, this.copiesTree ? 1 / 0 : 0, this.copiesConnectedLinks, (n) => n.canCopy());
        }
        this.copyToClipboard(i);
      } finally {
      }
    }
    canCopySelection() {
      const t = this.diagram;
      return !(!t.allowCopy || !t.allowClipboard || t.selection.count === 0);
    }
    cutSelection() {
      this.copySelection(), this.deleteSelection();
    }
    canCutSelection() {
      const t = this.diagram;
      return !(t.isReadOnly || t.isModelReadOnly || !t.allowCopy || !t.allowDelete || !t.allowClipboard || t.selection.count === 0);
    }
    copyToClipboard(t) {
      const i = this.diagram;
      let e = null;
      if (t === null)
        Diagram2.pA();
      else {
        const s = i.model;
        let n = false, o = false, r = null;
        try {
          s.Qu() && (n = s.copiesParentKeyOfNodeData, s.copiesParentKeyOfNodeData = this.copiesParentKey), (s.bf() || s._u()) && (o = s.copiesGroupKeyOfNodeData, s.copiesGroupKeyOfNodeData = this.copiesGroupKey), r = i.copyParts(t, null, true);
        } finally {
          s.Qu() && (s.copiesParentKeyOfNodeData = n), (s.bf() || s._u()) && (s.copiesGroupKeyOfNodeData = o), e = new List2(), e.addAll(r.iteratorValues), Diagram2.c0 = e, Diagram2.A1 = i.model.dataFormat;
        }
      }
      i.V("ClipboardChanged", e);
    }
    pasteFromClipboard() {
      const t = new GSet2(), i = Diagram2.c0;
      if (i === null)
        return t;
      const e = this.diagram;
      if (Diagram2.A1 !== e.model.dataFormat)
        return t;
      const s = e.model;
      let n = false, o = false, r = null;
      try {
        s.Qu() && (n = s.copiesParentKeyOfNodeData, s.copiesParentKeyOfNodeData = this.copiesParentKey), (s.bf() || s._u()) && (o = s.copiesGroupKeyOfNodeData, s.copiesGroupKeyOfNodeData = this.copiesGroupKey), r = e.copyParts(i, e, false);
      } finally {
        s.Qu() && (s.copiesParentKeyOfNodeData = n), (s.bf() || s._u()) && (s.copiesGroupKeyOfNodeData = o);
        const l = r.iterator;
        for (; l.next(); ) {
          const h = l.value, a = l.key;
          h.location.isReal() || (a.location.isReal() ? h.location = a.location : !h.position.isReal() && a.position.isReal() && (h.position = a.position)), t.add(h);
        }
      }
      return t;
    }
    pasteSelection(t) {
      t === void 0 && (t = null);
      const i = this.diagram;
      try {
        i.currentCursor = "wait", i.V("ChangingSelection", i.selection), i.startTransaction("Paste");
        const e = this.pasteFromClipboard();
        e.count > 0 && i.clearSelection(true);
        const s = e.iterator;
        for (; s.next(); ) {
          const n = s.value;
          n.isSelected = true;
        }
        if (t !== null) {
          const n = i.computePartsBounds(i.selection);
          if (n.isReal()) {
            const o = this.computeEffectiveCollection(i.selection, i.M1);
            i.LS(o, new Point2(t.x - n.centerX, t.y - n.centerY), i.M1, false);
          }
        }
        i.V("ClipboardPasted", e);
      } finally {
        i.commitTransaction("Paste"), i.V("ChangedSelection", i.selection), i.currentCursor = "";
      }
    }
    canPasteSelection(t) {
      const i = this.diagram;
      return !(i.isReadOnly || i.isModelReadOnly || !i.allowInsert || !i.allowClipboard || Diagram2.c0 === null || Diagram2.c0.count === 0 || Diagram2.A1 !== i.model.dataFormat);
    }
    undo() {
      this.diagram.undoManager.undo();
    }
    canUndo() {
      const t = this.diagram;
      return t.isReadOnly || t.isModelReadOnly ? false : t.allowUndo && t.undoManager.canUndo();
    }
    redo() {
      this.diagram.undoManager.redo();
    }
    canRedo() {
      const t = this.diagram;
      return t.isReadOnly || t.isModelReadOnly ? false : t.allowUndo && t.undoManager.canRedo();
    }
    decreaseZoom(t) {
      t === void 0 && (t = 1 / this.zoomFactor), Util.r(t, CommandHandler2, "decreaseZoom:factor");
      const i = this.diagram;
      if (i.autoScale !== 1)
        return;
      const e = i.scale * t;
      e < i.minScale || e > i.maxScale || (i.scale = e);
    }
    canDecreaseZoom(t) {
      t === void 0 && (t = 1 / this.zoomFactor), Util.r(t, CommandHandler2, "canDecreaseZoom:factor");
      const i = this.diagram;
      if (i.autoScale !== 1)
        return false;
      const e = i.scale * t;
      return e < i.minScale || e > i.maxScale ? false : i.allowZoom;
    }
    increaseZoom(t) {
      t === void 0 && (t = this.zoomFactor), Util.r(t, CommandHandler2, "increaseZoom:factor");
      const i = this.diagram;
      if (i.autoScale !== 1)
        return;
      const e = i.scale * t;
      e < i.minScale || e > i.maxScale || (i.scale = e);
    }
    canIncreaseZoom(t) {
      t === void 0 && (t = this.zoomFactor), Util.r(t, CommandHandler2, "canIncreaseZoom:factor");
      const i = this.diagram;
      if (i.autoScale !== 1)
        return false;
      const e = i.scale * t;
      return e < i.minScale || e > i.maxScale ? false : i.allowZoom;
    }
    resetZoom(t) {
      t === void 0 && (t = this.defaultScale), Util.r(t, CommandHandler2, "resetZoom:newscale");
      const i = this.diagram;
      t < i.minScale || t > i.maxScale || (i.scale = t);
    }
    canResetZoom(t) {
      t === void 0 && (t = this.defaultScale), Util.r(t, CommandHandler2, "canResetZoom:newscale");
      const i = this.diagram;
      return t < i.minScale || t > i.maxScale ? false : i.allowZoom;
    }
    zoomToFit() {
      const t = this.diagram, i = t.animationManager;
      i.stopAnimation(), t.redraw();
      const e = t.position, s = t.scale;
      i.zl("Zoom To Fit"), this.isZoomToFitRestoreEnabled && s === this.X1 && !isNaN(this.z1) && t.documentBounds.equals(this.Y1) ? (t.scale = this.z1, t.position = this.s2, this.X1 = NaN, this.Y1 = Rect2.Xk) : (this.z1 = s, this.s2 = e.copy(), t.zoomToFit(), this.X1 = t.scale, this.Y1 = t.documentBounds.copy()), i.FM();
    }
    canZoomToFit() {
      return this.diagram.allowZoom;
    }
    scrollToPart(t) {
      t === void 0 && (t = null), t !== null && Util.s(t, Part2, CommandHandler2, "part");
      const i = this.diagram;
      if (i.ensureBounds(), t === null) {
        try {
          this.Ho !== null && (this.Ho.next() ? t = this.Ho.value : this.Ho = null);
        } catch {
          this.Ho = null;
        }
        t === null && (i.highlighteds.count > 0 ? this.Ho = i.highlighteds.iterator : i.selection.count > 0 && (this.Ho = i.selection.iterator), this.Ho !== null && this.Ho.next() && (t = this.Ho.value));
      }
      if (t !== null) {
        const e = i.animationManager;
        e.zl("Scroll To Part");
        const s = this.scrollToPartPause;
        if (s > 0) {
          const n = this.$f(t, [t]);
          if (n.length === 1)
            i.startTransaction(), i.centerRect(t.actualBounds), i.commitTransaction("Scroll To Part");
          else {
            const o = () => {
              i.startTransaction();
              let l = n.pop();
              for (; n.length > 0 && l instanceof Node2 && l.isTreeExpanded && (!(l instanceof Group2) || l.isSubGraphExpanded); )
                l = n.pop();
              n.length > 0 ? (l instanceof Part2 && i.scrollToRect(l.actualBounds), l instanceof Node2 && !l.isTreeExpanded && (l.isTreeExpanded = true), l instanceof Group2 && !l.isSubGraphExpanded && (l.isSubGraphExpanded = true)) : (l instanceof Part2 && i.centerRect(l.actualBounds), i.removeDiagramListener("LayoutCompleted", r)), i.commitTransaction("Scroll To Part");
            }, r = () => {
              Util.Xh(o, (e.isEnabled ? e.duration : 0) + s);
            };
            i.addDiagramListener("LayoutCompleted", r), o();
          }
        } else {
          const n = i.position.copy();
          i.centerRect(t.actualBounds), n.equalsApprox(i.position) && e.stopAnimation();
        }
      }
    }
    $f(t, i) {
      if (t.isVisible())
        return i;
      if (t instanceof Adornment2)
        this.$f(t.adornedPart, i);
      else if (t instanceof Link2) {
        const e = t.fromNode;
        e !== null && this.$f(e, i);
        const s = t.toNode;
        s !== null && this.$f(s, i);
      } else {
        if (t instanceof Node2) {
          const s = t.labeledLink;
          s !== null && this.$f(s, i);
          const n = t.findTreeParentNode();
          n !== null && (!n.isTreeExpanded && !n.wasTreeExpanded && i.push(n), this.$f(n, i));
        }
        const e = t.containingGroup;
        e !== null && (!e.isSubGraphExpanded && !e.wasSubGraphExpanded && i.push(e), this.$f(e, i));
      }
      return i;
    }
    canScrollToPart(t) {
      if (t === void 0 && (t = null), t !== null && !(t instanceof Part2))
        return false;
      const i = this.diagram;
      return i.selection.count === 0 && i.highlighteds.count === 0 ? false : i.allowHorizontalScroll && i.allowVerticalScroll;
    }
    collapseTree(t) {
      t === void 0 && (t = null);
      const i = this.diagram, e = "Collapse Tree";
      try {
        i.startTransaction(e), i.animationManager.zl(e);
        const n = new List2();
        if (t !== null && t.isTreeExpanded)
          t.collapseTree(), n.add(t);
        else if (t === null) {
          const o = i.selection.iterator;
          for (; o.next(); ) {
            const r = o.value;
            r instanceof Node2 && r.isTreeExpanded && (r.collapseTree(), n.add(r));
          }
        }
        i.V("TreeCollapsed", n);
      } finally {
        i.commitTransaction(e);
      }
    }
    canCollapseTree(t) {
      t === void 0 && (t = null);
      const i = this.diagram;
      if (i.isReadOnly)
        return false;
      if (t !== null) {
        if (!(t instanceof Node2) || !t.isTreeExpanded)
          return false;
        if (t.findTreeChildrenLinks().count > 0)
          return true;
      } else {
        const e = i.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          if (s instanceof Node2) {
            if (!s.isTreeExpanded)
              continue;
            if (s.findTreeChildrenLinks().count > 0)
              return true;
          }
        }
      }
      return false;
    }
    expandTree(t) {
      t === void 0 && (t = null);
      const i = this.diagram, e = "Expand Tree";
      try {
        i.startTransaction(e), i.animationManager.zl(e);
        const n = new List2();
        if (t !== null && !t.isTreeExpanded)
          t.expandTree(), n.add(t);
        else if (t === null) {
          const o = i.selection.iterator;
          for (; o.next(); ) {
            const r = o.value;
            r instanceof Node2 && (r.isTreeExpanded || (r.expandTree(), n.add(r)));
          }
        }
        i.V("TreeExpanded", n);
      } finally {
        i.commitTransaction(e);
      }
    }
    canExpandTree(t) {
      t === void 0 && (t = null);
      const i = this.diagram;
      if (i.isReadOnly)
        return false;
      if (t !== null) {
        if (!(t instanceof Node2) || t.isTreeExpanded)
          return false;
        if (t.findTreeChildrenLinks().count > 0)
          return true;
      } else {
        const e = i.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          if (s instanceof Node2) {
            if (s.isTreeExpanded)
              continue;
            if (s.findTreeChildrenLinks().count > 0)
              return true;
          }
        }
      }
      return false;
    }
    groupSelection() {
      const t = this.diagram, i = t.model;
      if (!i.ma())
        return;
      const e = this.archetypeGroupData;
      if (e === null)
        return;
      let s = null;
      try {
        t.currentCursor = "wait", t.V("ChangingSelection", t.selection), t.startTransaction("Group");
        const n = new List2(), o = t.selection.iterator;
        for (; o.next(); ) {
          const h = o.value;
          h.De() && h.canGroup() && n.add(h);
        }
        const r = new List2(), l = n.iterator;
        for (; l.next(); ) {
          const h = l.value;
          let a = false;
          const f = n.iterator;
          for (; f.next(); ) {
            const c = f.value;
            if (h.isMemberOf(c)) {
              a = true;
              break;
            }
          }
          a || r.add(h);
        }
        if (r.count > 0) {
          let h = r.first().containingGroup;
          if (h !== null)
            for (; h !== null; ) {
              let a = false;
              const f = r.iterator;
              for (; f.next(); )
                if (!f.value.isMemberOf(h)) {
                  a = true;
                  break;
                }
              if (a)
                h = h.containingGroup;
              else
                break;
            }
          if (e instanceof Group2)
            e.ui(), s = e.copy(), s !== null && t.add(s);
          else if (i.isGroupForData(e)) {
            const a = i.copyNodeData(e);
            Util.Mt(a) && (i.addNodeData(a), s = t.findNodeForData(a));
          }
          if (s !== null) {
            h !== null && this.isValidMember(h, s) && (s.containingGroup = h);
            const a = r.iterator;
            for (; a.next(); ) {
              const f = a.value;
              this.isValidMember(s, f) && (f.containingGroup = s);
            }
            t.clearSelection(true), s.isSelected = true;
          }
        }
        t.V("SelectionGrouped", s);
      } finally {
        t.commitTransaction("Group"), t.V("ChangedSelection", t.selection), t.currentCursor = "";
      }
    }
    canGroupSelection() {
      const t = this.diagram;
      if (t.isReadOnly || t.isModelReadOnly || !t.allowInsert || !t.allowGroup || !t.model.ma() || this.archetypeGroupData === null)
        return false;
      const e = t.selection.iterator;
      for (; e.next(); ) {
        const s = e.value;
        if (s.De() && s.canGroup())
          return true;
      }
      return false;
    }
    h2(t) {
      const i = Util.ct();
      if (Array.isArray(t))
        t.forEach((n) => {
          n instanceof Link2 || n instanceof Part2 && i.push(n);
        });
      else {
        const n = t.iterator;
        for (; n.next(); ) {
          const o = n.value;
          o instanceof Link2 || o instanceof Part2 && i.push(o);
        }
      }
      const e = new GSet2(), s = i.length;
      for (let n = 0; n < s; n++) {
        const o = i[n];
        let r = true;
        for (let l = 0; l < s; l++)
          if (o.isMemberOf(i[l])) {
            r = false;
            break;
          }
        r && e.add(o);
      }
      return Util.ot(i), e;
    }
    isValidMember(t, i) {
      if (i === null || t === i || i instanceof Link2)
        return false;
      let e;
      return t !== null && (t === i || t.isMemberOf(i) || (e = t.memberValidation, e !== null && !e(t, i)) || t.data === null && i.data !== null || t.data !== null && i.data === null) ? false : (e = this.memberValidation, e !== null ? e(t, i) : true);
    }
    ungroupSelection(t) {
      t === void 0 && (t = null);
      const i = this.diagram, e = i.model;
      if (e.ma())
        try {
          i.currentCursor = "wait", i.V("ChangingSelection", i.selection), i.startTransaction("Ungroup");
          const s = new List2();
          if (t !== null)
            s.add(t);
          else {
            const o = i.selection.iterator;
            for (; o.next(); ) {
              const r = o.value;
              r instanceof Group2 && r.canUngroup() && s.add(r);
            }
          }
          const n = new List2();
          if (s.count > 0) {
            i.clearSelection(true);
            const o = s.iterator;
            for (; o.next(); ) {
              const r = o.value;
              r.expandSubGraph();
              const l = r.containingGroup, h = l !== null && l.data !== null ? e.getKeyForNodeData(l.data) : void 0;
              n.addAll(r.memberParts);
              const a = n.iterator;
              for (; a.next(); ) {
                const f = a.value;
                if (f.isSelected = true, f instanceof Link2)
                  continue;
                const c = f.data;
                c !== null ? e.setGroupForData(c, h) : f.containingGroup = l;
              }
              i.remove(r);
            }
          }
          i.V("SelectionUngrouped", s, n);
        } finally {
          i.commitTransaction("Ungroup"), i.V("ChangedSelection", i.selection), i.currentCursor = "";
        }
    }
    canUngroupSelection(t) {
      t === void 0 && (t = null);
      const i = this.diagram;
      if (i.isReadOnly || i.isModelReadOnly || !i.allowDelete || !i.allowUngroup || !i.model.ma())
        return false;
      if (t !== null) {
        if (!(t instanceof Group2))
          return false;
        if (t.canUngroup())
          return true;
      } else {
        const s = i.selection.iterator;
        for (; s.next(); ) {
          const n = s.value;
          if (n instanceof Group2 && n.canUngroup())
            return true;
        }
      }
      return false;
    }
    addTopLevelParts(t, i) {
      const e = this.h2(t);
      let s = true;
      const n = e.iterator;
      for (; n.next(); ) {
        const o = n.value;
        o.containingGroup !== null && (!i || this.isValidMember(null, o) ? o.containingGroup = null : s = false);
      }
      return s;
    }
    collapseSubGraph(t) {
      t === void 0 && (t = null);
      const i = this.diagram, e = "Collapse SubGraph";
      try {
        i.startTransaction(e), i.animationManager.zl(e);
        const n = new List2();
        if (t !== null && t.isSubGraphExpanded)
          t.collapseSubGraph(), n.add(t);
        else if (t === null) {
          const o = i.selection.iterator;
          for (; o.next(); ) {
            const r = o.value;
            r instanceof Group2 && r.isSubGraphExpanded && (r.collapseSubGraph(), n.add(r));
          }
        }
        i.V("SubGraphCollapsed", n);
      } finally {
        i.commitTransaction(e);
      }
    }
    canCollapseSubGraph(t) {
      t === void 0 && (t = null);
      const i = this.diagram;
      if (i.isReadOnly)
        return false;
      if (t !== null)
        return !(!(t instanceof Group2) || !t.isSubGraphExpanded);
      {
        const e = i.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          if (s instanceof Group2 && s.isSubGraphExpanded)
            return true;
        }
      }
      return false;
    }
    expandSubGraph(t) {
      t === void 0 && (t = null);
      const i = this.diagram, e = "Expand SubGraph", s = new List2();
      try {
        if (i.startTransaction(e), i.animationManager.zl(e), t !== null && !t.isSubGraphExpanded)
          t.expandSubGraph(), s.add(t);
        else if (t === null) {
          const o = i.selection.iterator;
          for (; o.next(); ) {
            const r = o.value;
            r instanceof Group2 && (r.isSubGraphExpanded || (r.expandSubGraph(), s.add(r)));
          }
        }
        i.V("SubGraphExpanded", s);
      } finally {
        for (const n of s)
          this._A(i, n);
        t && this._A(i, t), i.commitTransaction(e);
      }
    }
    _A(t, i) {
      for (const e of i.memberParts)
        e instanceof Node2 && t.Ff(e, i);
    }
    canExpandSubGraph(t) {
      t === void 0 && (t = null);
      const i = this.diagram;
      if (i.isReadOnly)
        return false;
      if (t !== null)
        return !(!(t instanceof Group2) || t.isSubGraphExpanded);
      {
        const e = i.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          if (s instanceof Group2 && !s.isSubGraphExpanded)
            return true;
        }
      }
      return false;
    }
    editTextBlock(t) {
      t === void 0 && (t = null), t !== null && Util.s(t, TextBlock2, CommandHandler2, "editTextBlock");
      const i = this.diagram, e = i.toolManager.findTool("TextEditing");
      if (e !== null) {
        if (t === null) {
          let s = null;
          const n = i.selection.iterator;
          for (; n.next(); ) {
            const o = n.value;
            if (o.canEdit()) {
              s = o;
              break;
            }
          }
          if (s === null)
            return;
          t = s.findInVisualTree((o) => o instanceof TextBlock2 && o.editable);
        }
        t !== null && (i.currentTool = null, e.textBlock = t, i.currentTool = e);
      }
    }
    canEditTextBlock(t) {
      t === void 0 && (t = null);
      const i = this.diagram;
      if (i.isReadOnly || i.isModelReadOnly || !i.allowTextEdit || i.toolManager.findTool("TextEditing") === null)
        return false;
      if (t !== null) {
        if (!(t instanceof TextBlock2))
          return false;
        const e = t.part;
        if (e !== null && e.canEdit())
          return true;
      } else {
        const e = i.selection.iterator;
        for (; e.next(); ) {
          const s = e.value;
          if (s.canEdit() && (t = s.findInVisualTree((n) => n instanceof TextBlock2 && n.editable), t !== null))
            return true;
        }
      }
      return false;
    }
    showContextMenu(t) {
      const i = this.diagram, e = i.toolManager.findTool("ContextMenu");
      if (e === null)
        return;
      t === void 0 && (i.selection.count > 0 ? t = i.selection.first() : t = i);
      const s = e.findObjectWithContextMenu(t);
      if (s !== null) {
        const n = i.lastInput;
        let o = null;
        if (s instanceof GraphObject2)
          o = s.getDocumentPoint(Spot2.Center);
        else if (!i.viewportBounds.containsPoint(n.documentPoint)) {
          const r = i.viewportBounds;
          o = new Point2(r.x + r.width / 2, r.y + r.height / 2);
        }
        o !== null && (n.viewPoint = i.transformDocToView(o), n.documentPoint = o, n.left = false, n.right = true, n.up = true), i.currentTool = e, e.openMenu(false, s);
      }
    }
    canShowContextMenu(t) {
      const i = this.diagram, e = i.toolManager.findTool("ContextMenu");
      return !(e === null || (t === void 0 && (i.selection.count > 0 ? t = i.selection.first() : t = i), e.findObjectWithContextMenu(t) === null));
    }
    get copiesClipboardData() {
      return this.jP;
    }
    set copiesClipboardData(t) {
      Util.t(t, "boolean", CommandHandler2, "copiesClipboardData"), this.jP = t;
    }
    get copiesConnectedLinks() {
      return this.JP;
    }
    set copiesConnectedLinks(t) {
      Util.t(t, "boolean", CommandHandler2, "copiesConnectedLinks"), this.JP = t;
    }
    get deletesConnectedLinks() {
      return this.ZP;
    }
    set deletesConnectedLinks(t) {
      Util.t(t, "boolean", CommandHandler2, "deletesConnectedLinks"), this.ZP = t;
    }
    get copiesTree() {
      return this.$P;
    }
    set copiesTree(t) {
      Util.t(t, "boolean", CommandHandler2, "copiesTree"), this.$P = t;
    }
    get deletesTree() {
      return this.QP;
    }
    set deletesTree(t) {
      Util.t(t, "boolean", CommandHandler2, "deletesTree"), this.QP = t;
    }
    get copiesParentKey() {
      return this._P;
    }
    set copiesParentKey(t) {
      Util.t(t, "boolean", CommandHandler2, "copiesParentKey"), this._P = t;
    }
    get copiesGroupKey() {
      return this.t2;
    }
    set copiesGroupKey(t) {
      Util.t(t, "boolean", CommandHandler2, "copiesGroupKey"), this.t2 = t;
    }
    get archetypeGroupData() {
      return this.i2;
    }
    set archetypeGroupData(t) {
      t !== null && Util.t(t, "object", CommandHandler2, "archetypeGroupData");
      const i = this.diagram;
      if (Debug) {
        const e = i.model;
        e.ma() && !(t instanceof Group2) && !e.isGroupForData(t) && Util.n("CommandHandler.archetypeGroupData must be either a Group or a data object for which GraphLinksModel.isGroupForNodeData is true: " + t);
      }
      this.i2 = t;
    }
    get memberValidation() {
      return this.hh;
    }
    set memberValidation(t) {
      t !== null && Util.t(t, "function", CommandHandler2, "memberValidation"), this.hh = t;
    }
    get defaultScale() {
      return this.diagram.defaultScale;
    }
    set defaultScale(t) {
      this.diagram.defaultScale = t;
    }
    get zoomFactor() {
      return this.e2;
    }
    set zoomFactor(t) {
      Util.r(t, CommandHandler2, "zoomFactor"), t > 1 || Util.n("zoomFactor must be larger than 1.0, not: " + t), this.e2 = t;
    }
    get isZoomToFitRestoreEnabled() {
      return this.o2;
    }
    set isZoomToFitRestoreEnabled(t) {
      Util.t(t, "boolean", CommandHandler2, "isZoomToFitRestoreEnabled"), this.o2 = t;
    }
    get scrollToPartPause() {
      return this.l2;
    }
    set scrollToPartPause(t) {
      Util.r(t, CommandHandler2, "scrollToPartPause"), this.l2 = t;
    }
    computeEffectiveCollection(t, i) {
      const e = this.diagram, s = e.toolManager.findTool("Dragging"), n = e.currentTool === s;
      i === void 0 && (i = e.y0());
      const o = new GMap2();
      if (t === null)
        return o;
      let r = t.iterator;
      for (; r.next(); ) {
        const l = r.value;
        e.el(o, l, n, i);
      }
      if (e.draggedLink !== null && i.dragsLink)
        return o;
      for (r = t.iterator; r.next(); ) {
        const l = r.value;
        if (l instanceof Link2) {
          const h = l.fromNode;
          if (h !== null && !o.contains(h))
            o.remove(l);
          else {
            const a = l.toNode;
            a !== null && !o.contains(a) && o.remove(l);
          }
        }
      }
      return o;
    }
  }
  var Stretch2 = ((w) => (w[w.None = 0] = "None", w[w.Default = 1] = "Default", w[w.Vertical = 4] = "Vertical", w[w.Horizontal = 5] = "Horizontal", w[w.Fill = 2] = "Fill", w))(Stretch2 || {}), Orientation2 = ((w) => (w[w.None = 0] = "None", w[w.Along = 21] = "Along", w[w.Plus90 = 22] = "Plus90", w[w.Minus90 = 23] = "Minus90", w[w.Opposite = 24] = "Opposite", w[w.Upright = 25] = "Upright", w[w.Plus90Upright = 26] = "Plus90Upright", w[w.Minus90Upright = 27] = "Minus90Upright", w[w.Upright45 = 28] = "Upright45", w))(Orientation2 || {}), Flip2 = ((w) => (w[w.None = 0] = "None", w[w.Vertical = 1] = "Vertical", w[w.Horizontal = 2] = "Horizontal", w[w.Both = 3] = "Both", w))(Flip2 || {});
  const _GraphObject = class _GraphObject {
    constructor() {
      __publicField(this, "l");
      __publicField(this, "td");
      __publicField(this, "ed");
      __publicField(this, "vo");
      __publicField(this, "g");
      __publicField(this, "fh");
      __publicField(this, "$");
      __publicField(this, "lt");
      __publicField(this, "ce");
      __publicField(this, "_t");
      __publicField(this, "sd");
      __publicField(this, "vs");
      __publicField(this, "Ft");
      __publicField(this, "We");
      __publicField(this, "nl");
      __publicField(this, "ch");
      __publicField(this, "Ni");
      __publicField(this, "Qf");
      __publicField(this, "v");
      __publicField(this, "qt");
      __publicField(this, "ol");
      __publicField(this, "Ri");
      __publicField(this, "Hi");
      __publicField(this, "nd");
      __publicField(this, "fi");
      __publicField(this, "_f");
      __publicField(this, "Ut");
      __publicField(this, "hi");
      __publicField(this, "rl");
      __publicField(this, "a2");
      __publicField(this, "od");
      GSet2.ji(this), this.l = 30723, this._t = 1, this.sd = "", this.vs = null, this.Ft = null, this.lt = new Point2(NaN, NaN).w(), this.We = Size2.xw, this.nl = new Transform(), this.ch = new Transform(), this.Ni = null, this.Qf = 1, this.v = 1, this.qt = 0, this.ol = Margin2.qg, this.ce = new Rect2(NaN, NaN, NaN, NaN).w(), this.Ri = new Rect2(NaN, NaN, NaN, NaN).w(), this.Hi = new Rect2(0, 0, NaN, NaN).w(), this.nd = null, this.td = null, this.$ = null, this.fi = Spot2.Default, this._f = Spot2.Default, this.ed = 0, this.vo = 0, this.Ut = null, this.g = null, this.fh = null, this.hi = null, this.a2 = null, this.rl = null, this.od = null;
    }
    cloneProtected(t) {
      t.l = (this.l | 2048 | 4096) & -32769, t._t = this._t, t.sd = this.sd, t.Ft = this.Ft, t.lt.c(this.lt), t.We = this.We.L(), this.Ni !== null ? t.Ni = this.Ni.copy() : t.Ni = null, t.v = this.v, t.qt = this.qt, t.ol = this.ol.L(), t.ce.c(this.ce), t.Ri.c(this.Ri), t.Hi.c(this.Hi), t.td = this.td, this.$ !== null && (t.$ = this.$.copy()), t.fi = this.fi.L(), t._f = this._f.L(), t.ed = this.ed, t.vo = this.vo, this.Ut !== null && (t.Ut = this.Ut.copy()), this.g !== null && (this.g.xi ? t.g = this.g : t.g = this.g.copy()), this.fh !== null && (t.fh = this.fh.slice()), this.hi !== null && (t.hi = this.hi.copy());
    }
    addCopyProperty(t) {
      let i = this.fh;
      if (!Array.isArray(i))
        i = [], this.fh = i;
      else
        for (let e = 0; e < i.length; e++)
          if (i[e] === t)
            return;
      i.push(t);
    }
    qo(t) {
      t.nd = null, t.rl = null, t.u();
    }
    clone() {
      const t = new this.constructor();
      if (this.cloneProtected(t), this.fh !== null)
        for (let i = 0; i < this.fh.length; i++) {
          const e = this.fh[i];
          t[e] = this[e];
        }
      return t;
    }
    copy() {
      return this.clone();
    }
    Tm() {
      const t = this.Ii;
      if (t !== null) {
        this.Ii = null;
        for (const i of t)
          i.rd() && (i.isToData ? this.themeData(i.targetProperty, i.sourceProperty, i.themeSource, i.converter, i.themeConverter) : i.isToObject ? this.themeObject(i.targetProperty, i.sourceProperty, i.themeSource, i.converter, i.themeConverter, i.sourceName) : i.isToModel ? this.themeModel(i.targetProperty, i.sourceProperty, i.themeSource, i.converter, i.themeConverter) : this.theme(i.targetProperty, i.sourceProperty, i.themeSource, i.converter, i.themeConverter));
      }
      return this;
    }
    ci(t) {
      t in Orientation2 ? this.segmentOrientation = t : t in Stretch2 ? this.stretch = t : Util.gr(this, t);
    }
    toString() {
      return Util.an(this.constructor) + "#" + GSet2.ps(this);
    }
    uh() {
      this.g !== null && (this.g.xi = true);
    }
    Zt() {
      this.g === null ? this.g = new GraphObjectTemplateSettings() : this.g.xi && (this.g = this.g.copy());
    }
    je() {
      if (this.$ === null) {
        const t = new LinkSettings();
        t.pa = Spot2.None, t.ya = Spot2.None, t.wa = 10, t.xa = 10, t.ba = 0, t.ka = 0, this.$ = t;
      }
    }
    raiseChangedEvent(t, i, e, s, n, o, r) {
      const l = this.part;
      if (l !== null) {
        l.tc(t, i, e, s, n, o, r), e === this && t === 2 && this.ic() && this.Sa(l, i);
        const h = this.diagram;
        if (this.Ns !== null && h !== null && h.Uh && !h.undoManager.isUndoingRedoing && !h.animationManager.Nu) {
          const a = this.Ns.get(i);
          if (a !== null && h.animationManager.isEnabled && !h.animationManager.isTicking) {
            this.od === null && (this.od = new GMap2());
            let f = h.undoManager.transactionLevel === 0;
            if (a.startCondition === 2 ? f = true : a.startCondition === 3 && (f = false), f) {
              const c = new Animation2();
              a.SF(c);
              const u = this.od.get(a);
              u !== null && u.stop(), this.od.add(a, c), c.xx = this, c.zM = a, c.add(this, i, s, n), c.start();
            } else
              h.animationManager.getBundleAnimation().add(this, i, s, n);
          }
        }
        if (this instanceof Panel2 && e === l && l.f2() && l.data !== null) {
          const a = this.F.h, f = a.length;
          for (let c = 0; c < f; c++) {
            const u = a[c];
            u instanceof Panel2 && u.il((d) => {
              d.data !== null && d.f2() && d.updateTargetBindings(i);
            });
          }
        }
      }
    }
    wF(t) {
      this.od.remove(t);
    }
    Uo() {
      if (this.diagram === null)
        return;
      if (this.findBindingPanel() === null && this.Ii !== null) {
        const i = this.Ii.iterator;
        for (; i.next(); ) {
          const e = i.value;
          if (!e.isToTheme)
            continue;
          let s = null;
          const n = e.sourceName;
          e.isToObject && (s = this.tL(n));
          let o = this;
          const r = e.targetId;
          r !== -1 && (o = this.M0(r), o === null) || (n === "/" ? s = o.part : n === "." ? s = o : n === ".." && (s = o.panel), e.updateTarget(o, s));
        }
      }
    }
    Sa(t, i) {
      const e = this.findBindingPanel();
      if (e !== null) {
        const s = this.Ii.iterator;
        for (; s.next(); ) {
          const n = s.value;
          let o = null;
          if (n.isToObject) {
            if (o = n.iL(e, this), o === null)
              continue;
            n.updateSource(this, o, i, null);
          } else if (n.isToModel) {
            const r = t.diagram;
            r !== null && !r.xe && n.updateSource(this, r.model.modelData, i, e);
          } else if (!n.isToTheme) {
            const r = e.data;
            if (r === null)
              continue;
            const l = t.diagram;
            l !== null && !l.xe && n.updateSource(this, r, i, e);
          }
          if (o === this) {
            const r = n.targetId, l = e.M0(r);
            l !== null && n.updateTarget(l, o, i);
          }
        }
      }
    }
    M0(t) {
      return this.so === t ? this : null;
    }
    tL(t) {
      let i;
      return t === "" ? i = this : t === "/" ? i = this : t === "." ? i = this : t === ".." ? i = this : (i = this.part.findObject(t), i === null && Debug && Util.ft("Binding error: missing GraphObject named " + t + " in " + this.part.toString())), i;
    }
    get so() {
      return this.g !== null ? this.g.so : -1;
    }
    set so(t) {
      this.so !== t && (this.g === null && (this.g = new GraphObjectTemplateSettings()), this.g.so = t);
    }
    get Ii() {
      return this.g !== null ? this.g.Ii : null;
    }
    set Ii(t) {
      this.Ii !== t && (this.g === null && (this.g = new GraphObjectTemplateSettings()), this.g.Ii = t);
    }
    get no() {
      return this.g !== null ? this.g.no : null;
    }
    set no(t) {
      this.no !== t && (this.g === null && (this.g = new GraphObjectTemplateSettings()), this.g.no = t);
    }
    raiseChanged(t, i, e) {
      this.raiseChangedEvent(2, t, this, i, e);
    }
    i(t, i, e) {
      this.raiseChangedEvent(2, t, this, i, e);
    }
    oo(t, i, e, s) {
      const n = this.ce;
      if (n.e(t, i, e, s), this.v !== 1 || this.qt !== 0) {
        this.Ni === null && (this.Ni = new Transform());
        const o = this.Ni;
        o.ti(), this.P0(o, t, i, e, s), o.Nw(n);
      }
    }
    eL(t, i, e) {
      return this.pickable === false ? false : (e.hf(this.D), i ? this.intersectsRect(t, e) : this.containedInRect(t, e));
    }
    sL(t, i, e) {
      if (this.pickable === false)
        return false;
      const s = this.naturalBounds, n = t.distanceSquaredPoint(i);
      return e ? Point2.distanceLineSegmentSquared(t.x, t.y, 0, 0, 0, s.height) <= n || Point2.distanceLineSegmentSquared(t.x, t.y, 0, s.height, s.width, s.height) <= n || Point2.distanceLineSegmentSquared(t.x, t.y, s.width, s.height, s.width, 0) <= n || Point2.distanceLineSegmentSquared(t.x, t.y, s.width, 0, 0, 0) <= n : t.distanceSquared(0, 0) <= n && t.distanceSquared(0, s.height) <= n && t.distanceSquared(s.width, 0) <= n && t.distanceSquared(s.width, s.height) <= n;
    }
    Mn() {
      return true;
    }
    containsPoint(t) {
      Debug && Util.s(t, Point2, _GraphObject, "containsPoint:p");
      const i = Point2.a();
      i.c(t), this.D.Pt(i);
      const e = this.actualBounds;
      if (!e.isReal())
        return Point2.o(i), false;
      const s = this.diagram;
      if (s !== null && s.r0) {
        const o = s.getInputOption("extraTouchThreshold"), r = s.getInputOption("extraTouchArea"), l = r / 2, h = this.naturalBounds, a = this.getDocumentScale() * s.scale, f = 1 / a;
        if (h.width * a < o && h.height * a < o) {
          const c = Rect2.contains(e.x - l * f, e.y - l * f, e.width + r * f, e.height + r * f, i.x, i.y);
          return Point2.o(i), c;
        }
      }
      let n = false;
      return (this instanceof Adornment2 || this instanceof Shape2 ? Rect2.contains(e.x - 5, e.y - 5, e.width + 10, e.height + 10, i.x, i.y) : e.containsPoint(i)) && (this.hi && !this.hi.containsPoint(i) ? n = false : this.Ft !== null && this.Hi.containsPoint(t) ? n = true : n = this.dh(t)), Point2.o(i), n;
    }
    dh(t) {
      const i = this.naturalBounds;
      return Rect2.contains(0, 0, i.width, i.height, t.x, t.y);
    }
    containsRect(t) {
      if (this.angle === 0)
        return this.actualBounds.containsRect(t);
      const i = this.naturalBounds, e = Rect2.H(0, 0, i.width, i.height), s = this.D;
      let n = false;
      const o = Point2.H(t.x, t.y);
      return e.containsPoint(s.rs(o)) && (o.e(t.x, t.bottom), e.containsPoint(s.rs(o)) && (o.e(t.right, t.bottom), e.containsPoint(s.rs(o)) && (o.e(t.right, t.y), e.containsPoint(s.rs(o)) && (n = true)))), Point2.o(o), Rect2.o(e), n;
    }
    containedInRect(t, i) {
      if (Debug && Util.s(t, Rect2, _GraphObject, "containedInRect:r"), i === void 0)
        return t.containsRect(this.actualBounds);
      const e = this.naturalBounds, s = i;
      let n = false;
      const o = Point2.H(0, 0);
      return t.containsPoint(s.Pt(o)) && (o.e(0, e.height), t.containsPoint(s.Pt(o)) && (o.e(e.width, e.height), t.containsPoint(s.Pt(o)) && (o.e(e.width, 0), t.containsPoint(s.Pt(o)) && (n = true)))), Point2.o(o), n;
    }
    intersectsRect(t, i) {
      if (Debug && Util.s(t, Rect2, _GraphObject, "intersectsRect:r"), i === void 0 && (i = this.D, this.angle === 0))
        return t.intersectsRect(this.actualBounds);
      const e = this.naturalBounds, s = i, n = Point2.H(0, 0), o = Point2.H(0, e.height), r = Point2.H(e.width, e.height), l = Point2.H(e.width, 0);
      let h = false;
      if (t.containsPoint(s.Pt(n)) || t.containsPoint(s.Pt(o)) || t.containsPoint(s.Pt(r)) || t.containsPoint(s.Pt(l)))
        h = true;
      else {
        const a = Rect2.H(0, 0, e.width, e.height), f = Point2.H(t.x, t.y);
        a.containsPoint(s.rs(f)) ? h = true : (f.e(t.x, t.bottom), a.containsPoint(s.rs(f)) ? h = true : (f.e(t.right, t.bottom), a.containsPoint(s.rs(f)) ? h = true : (f.e(t.right, t.y), a.containsPoint(s.rs(f)) && (h = true)))), Point2.o(f), Rect2.o(a), h || (Geo.Lw(t, n, o) || Geo.Lw(t, o, r) || Geo.Lw(t, r, l) || Geo.Lw(t, l, n)) && (h = true);
      }
      return Point2.o(n), Point2.o(o), Point2.o(r), Point2.o(l), h;
    }
    getDocumentPoint(t, i) {
      if (i === void 0 && (i = new Point2()), t instanceof Spot2) {
        const e = t;
        Debug && e.isNoSpot() && Util.n("getDocumentPoint:s Spot must be specific: " + e.toString());
        const s = this.naturalBounds;
        return i.e(e.x * s.width + e.offsetX, e.y * s.height + e.offsetY), this.Ms.Pt(i), i;
      } else
        return i.set(t), this.Ms.Pt(i), i;
    }
    getDocumentBounds(t) {
      t === void 0 && (t = new Rect2());
      const i = this.naturalBounds, e = this.Ms, s = Point2.H(0, 0).D(e);
      return t.e(s.x, s.y, 0, 0), s.e(i.width, 0).D(e), t.unionNoCheck(s.x, s.y, 0, 0), s.e(i.width, i.height).D(e), t.unionNoCheck(s.x, s.y, 0, 0), s.e(0, i.height).D(e), t.unionNoCheck(s.x, s.y, 0, 0), Point2.o(s), t;
    }
    getDocumentAngle() {
      return this.Ms.ID();
    }
    getDocumentScale() {
      if (this.N0() === false)
        return this.Qf;
      const t = this.v;
      return this.panel !== null ? t * this.panel.getDocumentScale() : t;
    }
    getLocalPoint(t, i) {
      return i === void 0 && (i = new Point2()), i.c(t), this.Ms.rs(i), i;
    }
    getNearestIntersectionPoint(t, i, e) {
      return this.ec(t.x, t.y, i.x, i.y, e);
    }
    ec(t, i, e, s, n) {
      const o = this.D, r = 1 / (o.m11 * o.m22 - o.m12 * o.m21), l = o.m22 * r, h = -o.m12 * r, a = -o.m21 * r, f = o.m11 * r, c = r * (o.m21 * o.dy - o.m22 * o.dx), u = r * (o.m12 * o.dx - o.m11 * o.dy), d = t * l + i * a + c, m = t * h + i * f + u, g = e * l + s * a + c, p = e * h + s * f + u;
      n.e(0, 0);
      const y = this.naturalBounds, x = Geo.Ml(0, 0, y.width, y.height, d, m, g, p, n);
      return n.D(o), x;
    }
    wt(t, i, e, s) {
      if (this.Ko() === false)
        return;
      const n = this.ol, o = n.right + n.left, r = n.top + n.bottom;
      t = Math.max(t - o, 0), i = Math.max(i - r, 0), e = e || 0, s = s || 0, e = Math.max(e - o, 0), s = Math.max(s - r, 0);
      const l = this.angle;
      let h = 0;
      const a = this.desiredSize, f = this.K1();
      l === 90 || l === 270 ? (t = isFinite(a.height) ? a.height + f : t, i = isFinite(a.width) ? a.width + f : i) : (t = isFinite(a.width) ? a.width + f : t, i = isFinite(a.height) ? a.height + f : i);
      let c = e || 0, u = s || 0;
      const d = this instanceof Panel2;
      switch (this.qs(true)) {
        case 0:
          c = 0, u = 0, d && (t = 1 / 0, i = 1 / 0);
          break;
        case 2:
          isFinite(t) && t > e && (c = t), isFinite(i) && i > s && (u = i);
          break;
        case 5:
          isFinite(t) && t > e && (c = t), u = 0, d && (i = 1 / 0);
          break;
        case 4:
          isFinite(i) && i > s && (u = i), c = 0, d && (t = 1 / 0);
          break;
      }
      const g = this.maxSize, p = this.minSize;
      c > g.width && p.width < g.width && (c = g.width), u > g.height && p.height < g.height && (u = g.height), e = Math.max(c, p.width), s = Math.max(u, p.height), g.width < e && (e = Math.min(p.width, e)), g.height < s && (s = Math.min(p.height, s)), t = Math.min(g.width, t), i = Math.min(g.height, i), t = Math.max(e, t), i = Math.max(s, i), (l === 90 || l === 270) && (h = t, t = i, i = h, h = e, e = s, s = h), this.ce.ut(), this.ld(t, i, e, s), this.ce.w(), this.ce.isReal() || Util.n("Non-real measuredBounds has been set. Object " + this + ", measuredBounds: " + this.ce.toString()), this.ae(false);
    }
    ld(t, i, e, s) {
    }
    Ws() {
      return false;
    }
    vt(t, i, e, s, n) {
      this.hd();
      const o = Rect2.a();
      o.c(this.Ri), this.Ri.ut(), this.hs() === false ? this.Ri.e(t, i, e, s) : this.gh(t, i, e, s), this.Ri.w(), n === void 0 ? this.hi = null : this.hi = n;
      let r = false;
      if (n !== void 0)
        r = true;
      else {
        let l = this.panel;
        if (l !== null && l.ll() && (l = l.panel), l !== null) {
          const h = l.Hi, a = this.measuredBounds, f = i + a.height, c = t + a.width;
          if (r = !(0 <= t + 0.05 && c <= h.width + 0.05 && 0 <= i + 0.05 && f <= h.height + 0.05), this instanceof TextBlock2) {
            const u = this.naturalBounds;
            (this.C0 > u.height || this.bi > u.width) && (r = true);
          }
        }
      }
      r ? this.l |= 256 : this.l &= -257, this.Ri.isReal() || Util.n("Non-real actualBounds has been set. Object " + this + ", actualBounds: " + this.Ri.toString()), this.ad(o, this.Ri), this.ro(false), Rect2.o(o);
    }
    gh(t, i, e, s) {
    }
    commonArrange(t, i, e, s) {
      if (this.Ri.e(t, i, e, s), this.desiredSize.isReal())
        return;
      const n = this.ce, o = this.ol, r = o.right + o.left, l = o.top + o.bottom, h = n.width + r, a = n.height + l;
      e += r, s += l;
      let f = this.qs(true);
      switch (h === e && a === s && (f = 0), f) {
        case 0:
          (h > e || a > s) && (this.ae(true), this.wt(h > e ? e : h, a > s ? s : a, 0, 0));
          break;
        case 2:
          this.ae(true), this.wt(e, s, 0, 0);
          break;
        case 5:
          this.ae(true), this.wt(e, a, 0, 0);
          break;
        case 4:
          this.ae(true), this.wt(h, s, 0, 0);
          break;
      }
    }
    ad(t, i) {
      const e = this.part;
      e !== null && e.diagram !== null && ((e.selectionObject === this || e.resizeObject === this || e.rotateObject === this) && e.c2(true), this.T(), !t.equalsApproxClose(i) && (e.mh(), this.A0(e)));
    }
    A0(t) {
      this.portId !== null && (t.c2(true), t instanceof Node2 && t.nL(this));
    }
    get shadowVisible() {
      return this.g !== null ? this.g.L0 : null;
    }
    set shadowVisible(t) {
      const i = this.shadowVisible;
      i !== t && (Debug && t !== null && Util.t(t, "boolean", _GraphObject, "shadowVisible"), this.Zt(), this.g.L0 = t, this.fs(true), this.T(), this.i("shadowVisible", i, t));
    }
    DR(t, i) {
      const e = this.naturalBounds, s = this.ch, n = s.m11, o = s.m21, r = s.dx, l = s.m12, h = s.m22, a = s.dy;
      let f = 0, c = 0, u = f, d = c;
      f = u * n + d * o + r, c = u * l + d * h + a;
      let m = f, g = c, p = 0, y = 0;
      u = e.width + i, d = 0, f = u * n + d * o + r, c = u * l + d * h + a;
      let x = Math.min(m, f), b = Math.min(g, c);
      p = Math.max(m + p, f) - x, y = Math.max(g + y, c) - b, m = x, g = b, u = e.width + i, d = e.height + i, f = u * n + d * o + r, c = u * l + d * h + a, x = Math.min(m, f), b = Math.min(g, c), p = Math.max(m + p, f) - x, y = Math.max(g + y, c) - b, m = x, g = b, u = 0, d = e.height + i, f = u * n + d * o + r, c = u * l + d * h + a, x = Math.min(m, f), b = Math.min(g, c), p = Math.max(m + p, f) - x, y = Math.max(g + y, c) - b, m = x, g = b;
      const k = t.viewportBounds, S = k.x, M = k.y, A = k.width, C = k.height;
      return m > A + S || S > p + m || g > C + M || M > y + g;
    }
    Ji(t, i) {
      if (this.FR(t, i) || !this.visible)
        return;
      const e = this.opacity;
      if (e === 0)
        return;
      let s = 1;
      e !== 1 && (s = t.globalAlpha, t.globalAlpha = s * e);
      let n = "";
      this.filter !== "" && (n = t.filter, t.filter = this.filter);
      const o = this.D, r = this.panel;
      this.N0() === true && this.U1();
      const l = this.part;
      let h = false, a = 0;
      if (l && i.getRenderingHint("drawShadows") && (h = l.isShadowed, h)) {
        const g = l.shadowOffset;
        a = Math.max(g.y, g.x) * i.scale * i.Gi;
      }
      const f = this instanceof Panel2 && this.ll(), c = this.Ri;
      if (f && (this.oL(h, t, false, r), this.RR(t, i), this.rL(h, t, false, r), this.lL(h, t, false)), f || !f && (c.width === 0 || c.height === 0 || isNaN(c.x) || isNaN(c.y))) {
        e !== 1 && (t.globalAlpha = s), this.filter !== "" && (t.filter = n);
        return;
      }
      const u = this.Ws();
      if (!i.sa && u && this.DR(i, a)) {
        e !== 1 && (t.globalAlpha = s), this.filter !== "" && (t.filter = n);
        return;
      }
      let d = (this.l & 256) !== 0;
      if (t.clipInsteadOfFill && (d = false), this instanceof TextBlock2 && (t.font = this.font), d) {
        const g = r.Mn() ? r.naturalBounds : r.actualBounds;
        let p = Math.max(c.x, g.x), y = Math.max(c.y, g.y), x = Math.min(c.right, g.right) - p, b = Math.min(c.bottom, g.bottom) - y;
        const k = this.hi;
        if (k !== null && (p = k.x, y = k.y, x = k.width, b = k.height), p > c.width + c.x || c.x > g.width + g.x) {
          e !== 1 && (t.globalAlpha = s), this.filter !== "" && (t.filter = n);
          return;
        }
        t.save(), t.beginPath(), t.rect(p, y, x, b), t.clip();
      }
      if (u) {
        if (!l.isVisible()) {
          e !== 1 && (t.globalAlpha = s), this.filter !== "" && (t.filter = n);
          return;
        }
        if (h) {
          const g = l.shadowOffset;
          t.shadowsSet(g.x * i.scale * this.scale * i.Gi, g.y * i.scale * this.scale * i.Gi, l.shadowBlur), t.shadowsOn(), t.shadowColor = l.shadowColor;
        }
      }
      const m = this.naturalBounds;
      if (t.transform(o.m11, o.m12, o.m21, o.m22, o.dx, o.dy), this.oL(h, t, u, r), this.Ft !== null && (t.commitTransform(), this.G1(t, m, c)), this.rL(h, t, u, r), this.ph(t, i), this.lL(h, t, u), d && (t.restore(), t.clearContextCache(this instanceof Panel2)), !o.Gk()) {
        const g = 1 / (o.m11 * o.m22 - o.m12 * o.m21);
        t.transform(o.m22 * g, -o.m12 * g, -o.m21 * g, o.m11 * g, g * (o.m21 * o.dy - o.m22 * o.dx), g * (o.m12 * o.dx - o.m11 * o.dy));
      }
      e !== 1 && (t.globalAlpha = s), this.filter !== "" && (t.filter = n);
    }
    oL(t, i, e, s) {
      t && this.shadowVisible === true ? i.shadowsOn() : t && this.shadowVisible === false && i.shadowsOff(), t && this.H1(s) && this.shadowVisible === null && i.shadowsOff();
    }
    rL(t, i, e, s) {
      t && (this.Ft !== null || this.H1(s)) ? (this.v1(true), this.shadowVisible === null && i.shadowsOff()) : this.v1(false);
    }
    lL(t, i, e) {
      t && this.u2() === true && i.shadowsOn(), e && t && i.shadowsOff();
    }
    IR(t, i, e) {
      const s = this.part;
      let n = false;
      s && t.getRenderingHint("drawShadows") && (n = s.isShadowed), i.clipInsteadOfFill && (n = false), this.Ws() && n && i.shadowsOn(), n && this.shadowVisible === true ? i.shadowsOn() : n && this.shadowVisible === false && i.shadowsOff();
      const o = this.panel;
      if (n && this.H1(o) && this.shadowVisible === null && i.shadowsOff(), i.hl) {
        const r = t.computePixelRatio(), l = `drop-shadow(${i.shadowOffsetX / r}px ${i.shadowOffsetY / r}px ${i.shadowBlur / r / 2}px ${i.shadowColor})`;
        this.background !== null && e.Ft.setAttributeNS(null, "filter", l);
      }
      return n && (this.Ft !== null || this.H1(o)) ? (this.v1(true), this.shadowVisible === null && i.shadowsOff()) : this.v1(false), n;
    }
    OR(t, i, e, s) {
      if (e.hl) {
        const n = i.computePixelRatio(), o = `drop-shadow(${e.shadowOffsetX / n}px ${e.shadowOffsetY / n}px ${e.shadowBlur / n / 2}px ${e.shadowColor})`;
        this.d2(t, o);
      }
      s && this.u2() === true && e.shadowsOn(), this.Ws() && e.shadowsOff();
    }
    H1(t) {
      return t === null ? false : (t.ll() && (t = t.panel), t.u2() || (t.type === Panel2.Auto || t.type === Panel2.Spot) && t.findMainElement() !== this);
    }
    d2(t, i) {
    }
    G1(t, i, e) {
      const s = this.K1(), n = i.x, o = i.y, r = i.width + s, l = i.height + s;
      this.bn(t, this.Ft, true, false, i, e), this.Ft instanceof Brush2 && this.Ft.type === 3 ? (t.beginPath(), t.rect(n - s / 2, o - s / 2, r, l), t.fillContext(this.Ft, false, null)) : t.fillRect(n - s / 2, o - s / 2, r, l);
    }
    hL(t, i) {
      let e = t.ER(this);
      if (e !== -1)
        if (e === 0)
          if (t.svg.Ft)
            t.svg.Ft.after(i);
          else if (t.type === Panel2.Table) {
            const s = t.svg.getElementsByClassName("gojs-ts"), n = s.length !== 0 ? s[0] : null;
            n !== null && n.after(i);
          } else
            t.svg.prepend(i);
        else {
          for (; e !== 0 && !t.elt(e - 1).isVisibleObject(); )
            e--;
          if (e === 0)
            t.svg.prepend(i);
          else {
            const s = t.elt(e - 1).svg;
            s !== null ? s.after(i) : t.svg.appendChild(i);
          }
        }
    }
    FR(t, i) {
      if (!(t instanceof SVGContext))
        return false;
      if (!this.visible || this.opacity === 0)
        return this.svg !== null && this.svg.parentNode !== null && this.svg.remove(), true;
      if (this.Ws() && !this.isVisible())
        return this.svg !== null && this.svg.parentNode !== null && this.svg.remove(), true;
      const e = this.panel, s = this.fd(t);
      if (this.sc(t, i, s))
        return this.aL(this.svg), this.svg.parentElement !== null ? (this.Ws() && (t.lastDrawnPart = this.svg), true) : (this.Ws() ? (t.lastDrawnPart !== null ? t.lastDrawnPart.after(this.svg) : t.diagramGroup.prepend(this.svg), t.lastDrawnPart = this.svg) : e && this.hL(e, this.svg), true);
      if (this.Ws() && this.isShadowed) {
        const m = this.shadowOffset;
        t.shadowsSet(m.x * i.scale * this.scale * i.Gi, m.y * i.scale * this.scale * i.Gi, this.shadowBlur), t.shadowsOn(), t.shadowColor = this.shadowColor;
      }
      this instanceof TextBlock2 && (t.font = this.font), t.currentElement = null;
      const n = this.D, o = this instanceof Panel2, r = this instanceof Panel2 ? this.ll() : false, l = this.svg;
      this.N0() === true && this.U1();
      const h = this.Ri;
      t.setCurrentTransform(1, 0, 0, 1, 0, 0), t.outerGroup = false, s && (t.outerGroup = true, o && r ? (t.newGroup(1, 0, 0, 1, 0, 0), this.svg = t.lastCreatedElement) : o ? (t.newGroup(n.m11, n.m12, n.m21, n.m22, n.dx, n.dy), this.svg = t.lastCreatedElement) : t.newGroup(1, 0, 0, 1, 0, 0));
      const a = this.naturalBounds;
      o || t.setCurrentTransform(n.m11, n.m12, n.m21, n.m22, n.dx, n.dy), this.background !== null && (o ? (r && t.setCurrentTransform(n.m11, n.m12, n.m21, n.m22, n.dx, n.dy), this.G1(t, a, h), r && t.setCurrentTransform(1, 0, 0, 1, 0, 0)) : (t.setCurrentTransform(n.m11, n.m12, n.m21, n.m22, n.dx, n.dy), this.G1(t, a, h)), t.currentElement.Ft = t.lastCreatedElement, t.currentElement.prepend(t.lastCreatedElement));
      const f = this.IR(i, t, t.currentElement);
      this.ph(t, i), o && t.endGroup(), t.outerGroup && t.endGroup();
      const c = t.surface.$u, u = o ? this.svg : t.currentElement;
      if (!o && l !== null && u !== l && l.parentNode === this.panel.svg) {
        const m = this.svg.getAttribute("filter");
        return m !== null && u.setAttribute("filter", m), this.svg.replaceWith(u), this.svg = u, u !== null && this.T0(t, e, h, u), this.fL(t, l), true;
      }
      if (this.svg = u, c !== null && u === null && t.dummyGroup(), u === null)
        return true;
      this.T0(t, e, h, u), this.OR(u, i, t, f);
      const d = this.Ws() ? this.opacity * t.globalAlpha : this.opacity;
      if (d !== 1 && u.setAttributeNS(null, "opacity", d.toString()), this.filter !== "" && u.setAttributeNS(null, "filter", this.filter), this.Ws()) {
        if (l !== null && u !== l && l.parentNode === t.diagramGroup) {
          const m = l.getAttribute("filter");
          m !== null && u.setAttribute("filter", m), l.replaceWith(u);
        } else
          t.lastDrawnPart ? t.lastDrawnPart.after(u) : t.diagramGroup.prepend(u);
        t.lastDrawnPart = u;
      } else
        e !== null && this.hL(e, u);
      return c !== null && c(this, u), this.aL(u), true;
    }
    aL(t) {
      const i = this, e = t.dataset;
      i instanceof _GraphObject && (i.portId !== null && (e.portId = i.portId), i instanceof Panel2 && (isNaN(i.itemIndex) || (e.itemIndex = i.itemIndex.toString()), i instanceof Part2 && (e.className = Util.an(i), i.key !== void 0 && (e.key = i.key.toString()), i instanceof Link2 && (i.fromNode !== null && i.fromNode.key !== void 0 && (e.fromKey = i.fromNode.key.toString()), i.fromPortId !== "" && (e.fromPortId = i.fromPortId), i.toNode !== null && i.toNode.key !== void 0 && (e.toKey = i.toNode.key.toString()), i.toPortId !== "" && (e.toPortId = i.toPortId)))));
    }
    T0(t, i, e, s) {
      let n = (this.l & 256) !== 0;
      if (t.clipInsteadOfFill && (n = false), !n) {
        s.removeAttributeNS(null, "clip-path"), this.fL(t, s);
        return;
      }
      const o = i.Mn() ? i.naturalBounds : i.actualBounds;
      let r = Math.max(e.x, o.x), l = Math.max(e.y, o.y), h = Math.min(e.right, o.right) - r, a = Math.min(e.bottom, o.bottom) - l;
      const f = this.hi;
      f !== null && (r = f.x, l = f.y, h = f.width, a = f.height);
      const c = s.getAttribute("clip-path");
      let u = null;
      if (c !== null && (u = t.svg.getElementById(c.split("#")[1].slice(0, -1))), u === null) {
        const d = "CLIP" + GSet2.fu++, m = { id: d }, g = t.makeElement("clipPath", m), p = t.makeElement("rect", { x: r, y: l, width: h, height: a });
        if (this instanceof Panel2) {
          const y = this.D.copy().Mw();
          p.setAttribute("transform", `matrix(${y.m11}, ${y.m12}, ${y.m21}, ${y.m22}, ${y.dx}, ${y.dy})`);
        }
        g.appendChild(p), t.svg.appendChild(g), s.setAttributeNS(null, "clip-path", "url(#" + d + ")");
      } else {
        const d = u.firstElementChild;
        d.setAttribute("x", r.toString()), d.setAttribute("y", l.toString()), d.setAttribute("width", h.toString()), d.setAttribute("height", a.toString());
      }
    }
    fL(t, i) {
      const e = i.getAttribute("clip-path");
      if (e === null)
        return;
      const s = t.svg.getElementById(e.split("#")[1].slice(0, -1));
      s !== null && s.remove();
    }
    VR() {
      if (this.svg === null)
        return;
      const t = this.svg.innerHTML.match(/url\(#((CLIP|GRAD).+?)\)/g), i = this.svg.ownerDocument;
      if (t !== null)
        for (const e of t) {
          const s = i.getElementById(e.split("#")[1].slice(0, -1));
          s !== null && s.remove();
        }
      this.svg.remove();
    }
    RR(t, i) {
      const e = this.Ri, s = this.Hi, n = this.Ft;
      n !== null && t.commitTransform(), n !== null && (this.bn(t, n, true, false, s, e), n instanceof Brush2 && n.type === 3 ? (t.beginPath(), t.rect(e.x, e.y, e.width, e.height), t.fillContext(n, false, null)) : t.fillRect(e.x, e.y, e.width, e.height)), this.ph(t, i);
    }
    ph(t, i) {
    }
    g2() {
      this.fs(true);
    }
    sc(t, i, e) {
      const s = this.svg;
      if (this.BR()) {
        if (this.g2(), this.fs(false), s === null)
          return false;
        const h = this.svg.getAttribute("clip-path");
        if (h !== null) {
          const a = t.svg.getElementById(h.split("#")[1].slice(0, -1));
          a !== null && a.remove();
        }
        return false;
      }
      if (s === null)
        return false;
      if (!this.visible)
        return s.remove(), false;
      if (s.nodeName !== "g" && e || s.nodeName === "g" && !e)
        return false;
      const n = this.D, o = this instanceof Panel2, r = this instanceof Panel2 ? this.ll() : false;
      if (!(o && r))
        if (this instanceof Picture2) {
          const h = this.q1;
          t.setCurrentTransform(n.m11, n.m12, n.m21, n.m22, n.dx, n.dy), h !== null && t.amendImageTransform(h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7]), e ? s.lastElementChild.setAttributeNS(null, "transform", t.getCurrentTransform()) : s.setAttributeNS(null, "transform", t.getCurrentTransform());
        } else if (e && !(this instanceof Panel2))
          if (this instanceof Shape2) {
            const h = s.getElementsByTagName("path");
            for (let a = 0; a < h.length; a++)
              h[a].setAttributeNS(null, "transform", "matrix(" + n.m11 + ", " + n.m12 + ", " + n.m21 + ", " + n.m22 + ", " + n.dx + ", " + n.dy + ")");
          } else
            (s.lastElementChild || s).setAttributeNS(null, "transform", "matrix(" + n.m11 + ", " + n.m12 + ", " + n.m21 + ", " + n.m22 + ", " + n.dx + ", " + n.dy + ")");
        else
          s.setAttributeNS(null, "transform", "matrix(" + n.m11 + ", " + n.m12 + ", " + n.m21 + ", " + n.m22 + ", " + n.dx + ", " + n.dy + ")");
      const l = this.Ws() ? this.opacity * t.globalAlpha : this.opacity;
      if (l === 1 ? s.removeAttribute("opacity") : s.setAttributeNS(null, "opacity", l.toString()), t.setCurrentTransform(1, 0, 0, 1, 0, 0), this.background !== null || s.Ft !== void 0) {
        const h = s.Ft;
        if (this.background === null)
          t.removeOldGradient(this, s.Ft, "fill"), s.Ft.remove(), s.Ft = void 0;
        else {
          if ((r || e && !(this instanceof Panel2)) && t.setCurrentTransform(n.m11, n.m12, n.m21, n.m22, n.dx, n.dy), this.G1(t, this.naturalBounds, this.actualBounds), s.Ft) {
            t.removeOldGradient(this, s.Ft, "fill");
            const a = s.Ft.getAttribute("filter");
            a !== null && t.lastCreatedElement.setAttribute("filter", a), s.Ft.replaceWith(t.lastCreatedElement);
          } else
            s.prepend(t.lastCreatedElement);
          s.Ft = t.lastCreatedElement;
        }
        h && t.removeOldGradient(this, h, "fill");
      }
      return this.T0(t, this.panel, this.actualBounds, s), true;
    }
    fd(t) {
      if (this.background !== null)
        return true;
      let i = (this.l & 256) !== 0;
      return t.clipInsteadOfFill && (i = false), !!i;
    }
    static cE(t, i, e, s, n, o, r) {
      let l = 1e-3;
      const h = o.length;
      t.moveTo(i, e);
      let a = s - i;
      const f = n - e;
      a === 0 && (a = 1e-3);
      const c = f / a;
      let u = Math.sqrt(a * a + f * f), d = 0, m = true;
      l = o[d % h];
      let g = r !== 0;
      for (; u >= 0.1; ) {
        if (g) {
          for (l = o[d++ % h], l -= r; l < 0; )
            l += o[d++ % h], m = !m;
          g = false;
        } else
          l = o[d++ % h];
        l > u && (l = u);
        let p = Math.sqrt(l * l / (1 + c * c));
        a < 0 && (p = -p), i += p, e += c * p, m ? t.lineTo(i, e) : t.moveTo(i, e), u -= l, m = !m;
      }
    }
    bn(t, i, e, s, n, o) {
      let r = 1, l = 1;
      if (typeof i == "string") {
        e ? t.fillStyle = i : t.strokeStyle = i;
        return;
      } else if (i.type === 1) {
        e ? t.fillStyle = i.color : t.strokeStyle = i.color;
        return;
      }
      let h;
      const a = this.K1();
      r = n.width, l = n.height, s ? (r = o.width, l = o.height) : e || (r += a, l += a);
      const f = t instanceof CanvasSurfaceContext;
      if (f && i.Pn && (i.type === 4 || i.nc === r && i.W1 === l))
        h = i.Pn;
      else {
        let c = 0, u = 0, d = 0, m = 0, g = 0, p = 0, y = 0, x = 0;
        if (s ? (y = o.x, x = o.y) : e || (y -= a / 2, x -= a / 2), c = i.start.x * r + i.start.offsetX + y, u = i.start.y * l + i.start.offsetY + x, d = i.end.x * r + i.end.offsetX + y, m = i.end.y * l + i.end.offsetY + x, i.type === 2)
          h = t.createLinearGradient(c, u, d, m);
        else if (i.type === 3)
          p = isNaN(i.endRadius) ? Math.max(r, l) / 2 : i.endRadius, isNaN(i.startRadius) ? (g = 0, p = Math.max(r, l) / 2) : g = i.startRadius, h = t.createRadialGradient(c, u, g, d, m, p);
        else if (i.type === 4)
          try {
            h = t.createPattern(i.pattern, "repeat");
          } catch {
            h = null;
          }
        else
          Util.Bi(i.type, "Brush type");
        if (i.type !== 4) {
          const b = i.colorStops;
          if (b !== null) {
            const k = b.iterator;
            for (; k.next(); )
              h.addColorStop(k.key, k.value);
          }
        }
        if (f && (i.Pn = h, h !== null && (i.nc = r, i.W1 = l), h === null && i.type === 4 && i.nc !== -1)) {
          i.nc = -1;
          const b = this.diagram;
          b !== null && i.nc === -1 && Util.Xh(() => {
            b.redraw();
          }, 600);
        }
      }
      e ? t.fillStyle = h : t.strokeStyle = h;
    }
    isContainedBy(t) {
      return t instanceof Panel2 ? this.zR(this, t) : false;
    }
    zR(t, i) {
      if (t === i || i === null)
        return false;
      let e = t.panel;
      for (; e !== null; ) {
        if (e === i)
          return true;
        e = e.panel;
      }
      return false;
    }
    isVisibleObject() {
      if (!this.visible)
        return false;
      const t = this.panel;
      return t !== null ? t.isVisibleObject() : true;
    }
    isEnabledObject() {
      let t = this instanceof Panel2 ? this : this.panel;
      for (; t !== null && t.isEnabled; )
        t = t.panel;
      return t === null;
    }
    get enabledChanged() {
      return this.g !== null ? this.g.D0 : null;
    }
    set enabledChanged(t) {
      const i = this.enabledChanged;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "enabledChanged"), this.Zt(), this.g.D0 = t, this.i("enabledChanged", i, t));
    }
    U1() {
      if (this.j1() === true) {
        const t = this.nl;
        if (t.ti(), !this.Ri.isReal() || !this.ce.isReal()) {
          this.cd(false);
          return;
        }
        if (t.se(this.Ri.x - this.ce.x, this.Ri.y - this.ce.y), this.scale !== 1 || this.angle !== 0) {
          const i = this.naturalBounds;
          this.P0(t, i.x, i.y, i.width, i.height);
        }
        this.cd(false), this.Ma(true);
      }
      if (this.N0() === true) {
        const t = this.panel;
        if (t === null)
          this.ch.set(this.nl), this.Qf = this.scale;
        else if (t.Ms !== null) {
          const i = this.ch;
          i.ti(), t.Mn() ? i.hf(t.ch) : t.panel !== null && i.hf(t.panel.ch), i.hf(this.nl), this.Qf = this.scale * t.Qf;
        }
        this.Ma(false);
      }
    }
    P0(t, i, e, s, n) {
      if (this.v !== 1 && t.v(this.v), this.qt === 0)
        return;
      const o = Point2.a();
      o.setSpot(i, e, s, n, Spot2.Center), t.ys(this.qt, o.x, o.y), Point2.o(o);
    }
    u(t) {
      if (this.Ko())
        return;
      t === void 0 && (t = false), this.ae(true), this.ro(true);
      const i = this.panel;
      i !== null && !t && i.u();
    }
    oc() {
      this.Ko() || (this.ae(true), this.ro(true));
    }
    rc(t) {
      if (this.hs())
        return;
      const i = this.panel;
      !t && i !== null && i.u(), this.ro(true);
    }
    hd() {
      this.j1() === false && (this.cd(true), this.Ma(true));
    }
    m2() {
      this.Ma(true);
    }
    T() {
      const t = this.part;
      t !== null && t.T();
    }
    qs(t) {
      const i = this.stretch, e = this.panel;
      if (e !== null && e.type === Panel2.Table)
        return this.F0(e.getRowDefinition(this.row), e.getColumnDefinition(this.column), t);
      if (e !== null && e.type === Panel2.Auto && e.findMainElement() === this)
        return this.Wo(2, t);
      if (i === 1) {
        if (e !== null) {
          if (e.type === Panel2.Spot && e.findMainElement() === this)
            return this.Wo(2, t);
          const s = e.defaultStretch;
          return s === 1 ? this.Wo(0, t) : this.Wo(s, t);
        }
        return this.Wo(0, t);
      }
      return this.Wo(i, t);
    }
    F0(t, i, e) {
      const s = this.stretch;
      if (s !== 1)
        return this.Wo(s, e);
      let n = null, o = null;
      switch (t.stretch) {
        case 1:
        case 5:
          break;
        case 4:
          o = true;
          break;
        case 2:
          o = true;
          break;
      }
      switch (i.stretch) {
        case 1:
        case 4:
          break;
        case 5:
          n = true;
          break;
        case 2:
          n = true;
          break;
      }
      const r = this.panel.defaultStretch;
      return n === null && (n = r === 5 || r === 2), o === null && (o = r === 4 || r === 2), n === true && o === true ? this.Wo(2, e) : n === true ? this.Wo(5, e) : o === true ? this.Wo(4, e) : this.Wo(0, e);
    }
    Wo(t, i) {
      if (i)
        return t;
      if (t === 0)
        return 0;
      const e = this.desiredSize;
      if (e.isReal())
        return 0;
      const s = !isNaN(e.width), n = !isNaN(e.height), o = this.angle;
      if (s)
        if (o !== 90 && o !== 270) {
          if (t === 5)
            return 0;
          if (t === 2)
            return 4;
        } else {
          if (t === 4)
            return 0;
          if (t === 2)
            return 5;
        }
      if (n)
        if (o !== 90 && o !== 270) {
          if (t === 4)
            return 0;
          if (t === 2)
            return 5;
        } else {
          if (t === 5)
            return 0;
          if (t === 2)
            return 4;
        }
      return t;
    }
    get segmentOrientation() {
      return this.Ut !== null ? this.Ut.R0 : 0;
    }
    set segmentOrientation(t) {
      const i = this.segmentOrientation;
      i !== t && (Debug && Util.it(t, Orientation2, "Orientation"), this.Ut === null && (this.Ut = new LinkElementSettings()), this.Ut.R0 = t, this.u(), this.i("segmentOrientation", i, t), t === 0 && (this.angle = 0));
    }
    XR() {
      this.segmentOrientation = 21;
    }
    get segmentIndex() {
      return this.Ut !== null ? this.Ut.I0 : -1 / 0;
    }
    set segmentIndex(t) {
      Debug && Util.t(t, "number", _GraphObject, "segmentIndex"), t = Math.round(t);
      const i = this.segmentIndex;
      i !== t && (this.Ut === null && (this.Ut = new LinkElementSettings()), this.Ut.I0 = t, this.u(), this.i("segmentIndex", i, t));
    }
    get segmentFraction() {
      return this.Ut !== null ? this.Ut.O0 : 0;
    }
    set segmentFraction(t) {
      Debug && Util.t(t, "number", _GraphObject, "segmentFraction"), isNaN(t) || t < 0 ? t = 0 : t > 1 && (t = 1);
      const i = this.segmentFraction;
      i !== t && (this.Ut === null && (this.Ut = new LinkElementSettings()), this.Ut.O0 = t, this.u(), this.i("segmentFraction", i, t));
    }
    get segmentOffset() {
      return this.Ut !== null ? this.Ut.E0 : Point2.To;
    }
    set segmentOffset(t) {
      const i = this.segmentOffset;
      i.equals(t) || (Debug && Util.s(t, Point2, _GraphObject, "segmentOffset"), t = t.L(), this.Ut === null && (this.Ut = new LinkElementSettings()), this.Ut.E0 = t, this.u(), this.i("segmentOffset", i, t));
    }
    get stretch() {
      return this.g !== null ? this.g.lo : 1;
    }
    set stretch(t) {
      const i = this.stretch;
      i !== t && (this.Zt(), this.g.lo = t, this.u(), this.i("stretch", i, t));
    }
    get name() {
      return this.g !== null ? this.g.Tt : "";
    }
    set name(t) {
      const i = this.name;
      i !== t && (Debug && Util.t(t, "string", _GraphObject, "name"), this.Zt(), this.g.Tt = t, this.part !== null && this.part.V0(), this.i("name", i, t));
    }
    get opacity() {
      return this._t;
    }
    set opacity(t) {
      const i = this._t;
      if (i !== t) {
        Util.t(t, "number", _GraphObject, "opacity"), (t < 0 || t > 1) && Util.G(t, "0 <= value <= 1", _GraphObject, "opacity"), this._t = t, this.i("opacity", i, t);
        const e = this.diagram, s = this.part;
        e !== null && s !== null && e.T(s.$h(s.actualBounds));
      }
    }
    get filter() {
      return this.sd;
    }
    set filter(t) {
      Debug && Util.t(t, "string", _GraphObject, "filter");
      const i = this.sd;
      if (i !== t) {
        this.sd = t, this.fs(true), this.i("filter", i, t);
        const e = this.diagram, s = this.part;
        e !== null && s !== null && e.T(s.$h(s.actualBounds));
      }
    }
    get visible() {
      return (this.l & 1) !== 0;
    }
    set visible(t) {
      const i = (this.l & 1) !== 0;
      if (i !== t) {
        Debug && Util.t(t, "boolean", _GraphObject, "visible"), this.l = this.l ^ 1, this.i("visible", i, t);
        const e = this.panel;
        e !== null ? e.u() : this.Ws() && this.Ki(t), this.T(), this.cL();
      }
    }
    get pickable() {
      return (this.l & 2) !== 0;
    }
    set pickable(t) {
      const i = (this.l & 2) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _GraphObject, "pickable"), this.l = this.l ^ 2, this.i("pickable", i, t));
    }
    get fromLinkableDuplicates() {
      return (this.l & 4) !== 0;
    }
    set fromLinkableDuplicates(t) {
      const i = (this.l & 4) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _GraphObject, "fromLinkableDuplicates"), this.l = this.l ^ 4, this.i("fromLinkableDuplicates", i, t));
    }
    get fromLinkableSelfNode() {
      return (this.l & 8) !== 0;
    }
    set fromLinkableSelfNode(t) {
      const i = (this.l & 8) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _GraphObject, "fromLinkableSelfNode"), this.l = this.l ^ 8, this.i("fromLinkableSelfNode", i, t));
    }
    get toLinkableDuplicates() {
      return (this.l & 16) !== 0;
    }
    set toLinkableDuplicates(t) {
      const i = (this.l & 16) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _GraphObject, "toLinkableDuplicates"), this.l = this.l ^ 16, this.i("toLinkableDuplicates", i, t));
    }
    get toLinkableSelfNode() {
      return (this.l & 32) !== 0;
    }
    set toLinkableSelfNode(t) {
      const i = (this.l & 32) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _GraphObject, "toLinkableSelfNode"), this.l = this.l ^ 32, this.i("toLinkableSelfNode", i, t));
    }
    get isPanelMain() {
      return (this.l & 64) !== 0;
    }
    set isPanelMain(t) {
      const i = (this.l & 64) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _GraphObject, "isPanelMain"), this.l = this.l ^ 64, this.u(), this.i("isPanelMain", i, t));
    }
    get isActionable() {
      return (this.l & 128) !== 0;
    }
    set isActionable(t) {
      const i = (this.l & 128) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _GraphObject, "isActionable"), this.l = this.l ^ 128, this.i("isActionable", i, t));
    }
    get background() {
      return this.Ft;
    }
    set background(t) {
      const i = this.Ft;
      i !== t && (t !== null && Brush2.ud(t, "GraphObject.background"), t instanceof Brush2 && t.w(), this.Ft = t, this.T(), this.i("background", i, t));
    }
    u2() {
      return (this.l & 512) !== 0;
    }
    v1(t) {
      t ? this.l |= 512 : this.l &= -513;
    }
    ic() {
      return (this.l & 1024) !== 0;
    }
    p2(t) {
      t ? this.l |= 1024 : this.l &= -1025;
    }
    j1() {
      return (this.l & 2048) !== 0;
    }
    cd(t) {
      t ? this.l |= 2048 : this.l &= -2049;
    }
    N0() {
      return (this.l & 4096) !== 0;
    }
    Ma(t) {
      t ? this.l |= 4096 : this.l &= -4097;
    }
    Ko() {
      return (this.l & 8192) !== 0;
    }
    ae(t) {
      t ? this.l |= 8192 : this.l &= -8193;
    }
    hs() {
      return (this.l & 16384) !== 0;
    }
    ro(t) {
      t ? this.l |= 16384 : this.l &= -16385;
    }
    BR() {
      return (this.l & 32768) !== 0;
    }
    fs(t) {
      t ? this.l |= 32768 : this.l &= -32769;
    }
    get part() {
      if (this.Ws())
        return this;
      if (this.rl !== null)
        return this.rl;
      let t = this;
      for (t = t.panel; t; ) {
        if (t instanceof Part2)
          return this.rl = t, t;
        t = t.panel;
      }
      return null;
    }
    get svg() {
      return this.a2;
    }
    set svg(t) {
      this.a2 = t;
    }
    Bu() {
      this.svg = null;
    }
    get panel() {
      return this.vs;
    }
    Pa(t) {
      this.vs = t, this.svg !== null && this.svg.remove();
    }
    get layer() {
      const t = this.part;
      return t !== null ? t.layer : null;
    }
    get diagram() {
      const t = this.part;
      return t !== null ? t.diagram : null;
    }
    get position() {
      return this.lt;
    }
    set position(t) {
      Debug && Util.s(t, Point2, _GraphObject, "position");
      const i = t.x, e = t.y, s = this.lt, n = s.x, o = s.y;
      n !== i && (!isNaN(n) || !isNaN(i)) || o !== e && (!isNaN(o) || !isNaN(e)) ? (t = t.copy(), this.w2(t, n, o) && this.i("position", new Point2(n, o), t)) : this.b2();
    }
    b2() {
    }
    w2(t, i, e) {
      return this.lt = t, this.rc(), true;
    }
    Nf(t, i, e) {
      this.lt.x === t && this.lt.y === i || (this.lt.e(t, i), this.hd());
    }
    get actualBounds() {
      return this.Ri;
    }
    get scale() {
      return this.v;
    }
    set scale(t) {
      const i = this.v;
      i !== t && (Debug && Util.r(t, _GraphObject, "scale"), t <= 0 && Util.n("GraphObject.scale for " + this + " must be greater than zero, not: " + t), this.v = t, this.u(), this.i("scale", i, t));
    }
    get angle() {
      return this.qt;
    }
    set angle(t) {
      const i = this.qt;
      if (i !== t) {
        if (Debug && Util.r(t, _GraphObject, "angle"), t = t % 360, t < 0 && (t += 360), i === t)
          return;
        this.qt = t, this.cL(), this.u(), this.i("angle", i, t);
      }
    }
    get desiredSize() {
      return this.We;
    }
    set desiredSize(t) {
      Debug && Util.s(t, Size2, _GraphObject, "desiredSize");
      const i = t.width, e = t.height, s = this.We, n = s.width, o = s.height;
      if ((n !== i && (!isNaN(n) || !isNaN(i)) || o !== e && (!isNaN(o) || !isNaN(e))) && (t = t.L(), this.We = t, this.u(), this instanceof Shape2 && this.fe(), this.i("desiredSize", s, t), this.ic())) {
        const r = this.part;
        r !== null && (this.Sa(r, "width"), this.Sa(r, "height"));
      }
    }
    get width() {
      return this.We.width;
    }
    set width(t) {
      const i = this.We.width;
      if (i !== t && (!isNaN(i) || !isNaN(t))) {
        Debug && Util.t(t, "number", _GraphObject, "width");
        const e = this.We, s = new Size2(t, this.We.height).w();
        if (this.We = s, this.u(), this instanceof Shape2 && this.fe(), this.i("desiredSize", e, s), this.ic()) {
          const n = this.part;
          n !== null && this.Sa(n, "width");
        }
      }
    }
    get height() {
      return this.We.height;
    }
    set height(t) {
      const i = this.We.height;
      if (i !== t && (!isNaN(i) || !isNaN(t))) {
        Debug && Util.t(t, "number", _GraphObject, "height");
        const e = this.We, s = new Size2(this.We.width, t).w();
        if (this.We = s, this.u(), this instanceof Shape2 && this.fe(), this.i("desiredSize", e, s), this.ic()) {
          const n = this.part;
          n !== null && this.Sa(n, "height");
        }
      }
    }
    get minSize() {
      return this.g !== null ? this.g.Cr : Size2.lf;
    }
    set minSize(t) {
      const i = this.minSize;
      i.equals(t) || (Debug && Util.s(t, Size2, _GraphObject, "minSize"), t = t.copy(), isNaN(t.width) && (t.width = 0), isNaN(t.height) && (t.height = 0), t.w(), this.Zt(), this.g.Cr = t, this.u(), this.i("minSize", i, t));
    }
    get maxSize() {
      return this.g !== null ? this.g.Ar : Size2.zk;
    }
    set maxSize(t) {
      const i = this.maxSize;
      i.equals(t) || (Debug && Util.s(t, Size2, _GraphObject, "maxSize"), t = t.copy(), isNaN(t.width) && (t.width = 1 / 0), isNaN(t.height) && (t.height = 1 / 0), t.w(), this.Zt(), this.g.Ar = t, this.u(), this.i("maxSize", i, t));
    }
    get measuredBounds() {
      return this.ce;
    }
    get naturalBounds() {
      return this.Hi;
    }
    K1() {
      return 0;
    }
    get margin() {
      return this.ol;
    }
    set margin(t) {
      typeof t == "number" ? t = new Margin2(t) : Debug && Util.s(t, Margin2, _GraphObject, "margin");
      const i = this.ol;
      i.equals(t) || (t = t.L(), this.ol = t, this.u(), this.i("margin", i, t));
    }
    get D() {
      return this.j1() === true && this.U1(), this.nl;
    }
    get Ms() {
      return this.N0() === true && this.U1(), this.ch;
    }
    trigger(t) {
      return t.Te = this, this.Ns === null && (this.Ns = new GMap2()), this.Ns.add(t.propertyName, t), this;
    }
    get Ns() {
      return this.g !== null ? this.g.Ns : null;
    }
    set Ns(t) {
      this.Ns !== t && (this.Zt(), this.g.Ns = t);
    }
    get Nr() {
      return this.g !== null ? this.g.Nr : 0;
    }
    set Nr(t) {
      this.Nr !== t && (this.Zt(), this.g.Nr = t);
    }
    get alignment() {
      return this.fi;
    }
    set alignment(t) {
      const i = this.fi;
      i.equals(t) || (Debug && Util.s(t, Spot2, _GraphObject, "alignment"), t.isNoSpot() && !t.isDefault() && Util.n("GraphObject.alignment for " + this + " must be a real Spot or Spot.Default, not: " + t), t = t.L(), this.fi = t, this.rc(), this.i("alignment", i, t));
    }
    get column() {
      return this.vo;
    }
    set column(t) {
      Debug && Util.r(t, _GraphObject, "column"), t = Math.round(t);
      const i = this.vo;
      i !== t && (t < 0 && Util.G(t, ">= 0", _GraphObject, "column"), this.vo = t, this.u(), this.i("column", i, t), this.svg !== null && this.svg.remove());
    }
    get columnSpan() {
      return this.g !== null ? this.g.B0 : 1;
    }
    set columnSpan(t) {
      Debug && Util.t(t, "number", _GraphObject, "columnSpan"), t = Math.round(t);
      const i = this.columnSpan;
      i !== t && (t < 1 && Util.G(t, ">= 1", _GraphObject, "columnSpan"), this.Zt(), this.g.B0 = t, this.u(), this.i("columnSpan", i, t));
    }
    get row() {
      return this.ed;
    }
    set row(t) {
      Debug && Util.r(t, _GraphObject, "row"), t = Math.round(t);
      const i = this.ed;
      i !== t && (t < 0 && Util.G(t, ">= 0", _GraphObject, "row"), this.ed = t, this.u(), this.i("row", i, t), this.svg !== null && this.svg.remove());
    }
    get rowSpan() {
      return this.g !== null ? this.g.z0 : 1;
    }
    set rowSpan(t) {
      Debug && Util.t(t, "number", _GraphObject, "rowSpan"), t = Math.round(t);
      const i = this.rowSpan;
      i !== t && (t < 1 && Util.G(t, ">= 1", _GraphObject, "rowSpan"), this.Zt(), this.g.z0 = t, this.u(), this.i("rowSpan", i, t));
    }
    get spanAllocation() {
      return this.g !== null ? this.g.X0 : null;
    }
    set spanAllocation(t) {
      const i = this.spanAllocation;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "spanAllocation"), this.Zt(), this.g.X0 = t, this.u(), this.i("spanAllocation", i, t));
    }
    get alignmentFocus() {
      return this._f;
    }
    set alignmentFocus(t) {
      const i = this._f;
      i.equals(t) || (Debug && Util.s(t, Spot2, _GraphObject, "alignmentFocus"), Debug && t.isNoSpot() && !t.isDefault() && !(t.isNone() && this instanceof Node2) && Util.n("GraphObject.alignmentFocus must be a real Spot or Spot.Default, not: " + t), t = t.L(), this._f = t, this.u(), this.i("alignmentFocus", i, t));
    }
    get portId() {
      return this.td;
    }
    set portId(t) {
      const i = this.td;
      if (i !== t) {
        Debug && t !== null && Util.t(t, "string", _GraphObject, "portId");
        const e = this.part;
        e !== null && !(e instanceof Node2) && Util.n("Cannot set portID on a Link: " + t);
        const s = e;
        i !== null && s !== null && s.k2(this), this.td = t, t !== null && s !== null && (s.Nn = true, s.uL(this)), this.i("portId", i, t);
      }
    }
    Na() {
      const t = this.part;
      if (t instanceof Node2 && (this.portId !== null || this === t.port)) {
        const i = t.diagram;
        i !== null && !i.undoManager.isUndoingRedoing && t.nL(this);
      }
    }
    cL() {
      const t = this.diagram;
      t === null || t.undoManager.isUndoingRedoing || (this instanceof Panel2 ? this instanceof Node2 ? this.invalidateConnectedLinks() : this.walkVisualTreeFrom(this, (i) => {
        i.Na();
      }) : this.Na());
    }
    get toSpot() {
      return this.$ !== null ? this.$.ya : Spot2.None;
    }
    set toSpot(t) {
      const i = this.toSpot;
      i.equals(t) || (Debug && Util.s(t, Spot2, _GraphObject, "toSpot"), t = t.L(), this.je(), this.$.ya = t, this.i("toSpot", i, t), this.Na());
    }
    get toEndSegmentLength() {
      return this.$ !== null ? this.$.xa : 10;
    }
    set toEndSegmentLength(t) {
      const i = this.toEndSegmentLength;
      i !== t && (Debug && Util.t(t, "number", _GraphObject, "toEndSegmentLength"), t < 0 && Util.G(t, ">= 0", _GraphObject, "toEndSegmentLength"), this.je(), this.$.xa = t, this.i("toEndSegmentLength", i, t), this.Na());
    }
    get toShortLength() {
      return this.$ !== null ? this.$.ka : 0;
    }
    set toShortLength(t) {
      const i = this.toShortLength;
      i !== t && (Debug && Util.t(t, "number", _GraphObject, "toShortLength"), this.je(), this.$.ka = t, this.i("toShortLength", i, t), this.Na());
    }
    get toLinkable() {
      return this.$ !== null ? this.$.Y0 : null;
    }
    set toLinkable(t) {
      const i = this.toLinkable;
      i !== t && (Debug && t !== null && Util.t(t, "boolean", _GraphObject, "toLinkable"), this.je(), this.$.Y0 = t, this.i("toLinkable", i, t));
    }
    get toMaxLinks() {
      return this.$ !== null ? this.$.K0 : 1 / 0;
    }
    set toMaxLinks(t) {
      const i = this.toMaxLinks;
      i !== t && (Debug && Util.t(t, "number", _GraphObject, "toMaxLinks"), t < 0 && Util.G(t, ">= 0", _GraphObject, "toMaxLinks"), this.je(), this.$.K0 = t, this.i("toMaxLinks", i, t));
    }
    get fromSpot() {
      return this.$ !== null ? this.$.pa : Spot2.None;
    }
    set fromSpot(t) {
      const i = this.fromSpot;
      i.equals(t) || (Debug && Util.s(t, Spot2, _GraphObject, "fromSpot"), t = t.L(), this.je(), this.$.pa = t, this.i("fromSpot", i, t), this.Na());
    }
    get fromEndSegmentLength() {
      return this.$ !== null ? this.$.wa : 10;
    }
    set fromEndSegmentLength(t) {
      const i = this.fromEndSegmentLength;
      i !== t && (Debug && Util.t(t, "number", _GraphObject, "fromEndSegmentLength"), t < 0 && Util.G(t, ">= 0", _GraphObject, "fromEndSegmentLength"), this.je(), this.$.wa = t, this.i("fromEndSegmentLength", i, t), this.Na());
    }
    get fromShortLength() {
      return this.$ !== null ? this.$.ba : 0;
    }
    set fromShortLength(t) {
      const i = this.fromShortLength;
      i !== t && (Debug && Util.t(t, "number", _GraphObject, "fromShortLength"), this.je(), this.$.ba = t, this.i("fromShortLength", i, t), this.Na());
    }
    get fromLinkable() {
      return this.$ !== null ? this.$.U0 : null;
    }
    set fromLinkable(t) {
      const i = this.fromLinkable;
      i !== t && (Debug && t !== null && Util.t(t, "boolean", _GraphObject, "fromLinkable"), this.je(), this.$.U0 = t, this.i("fromLinkable", i, t));
    }
    get fromMaxLinks() {
      return this.$ !== null ? this.$.G0 : 1 / 0;
    }
    set fromMaxLinks(t) {
      const i = this.fromMaxLinks;
      i !== t && (Debug && Util.t(t, "number", _GraphObject, "fromMaxLinks"), t < 0 && Util.G(t, ">= 0", _GraphObject, "fromMaxLinks"), this.je(), this.$.G0 = t, this.i("fromMaxLinks", i, t));
    }
    get cursor() {
      return this.g !== null ? this.g.Dl : "";
    }
    set cursor(t) {
      const i = this.cursor;
      i !== t && (Util.t(t, "string", _GraphObject, "cursor"), this.Zt(), this.g.Dl = t, this.i("cursor", i, t));
    }
    get click() {
      return this.g !== null ? this.g.Vr : null;
    }
    set click(t) {
      const i = this.click;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "click"), this.Zt(), this.g.Vr = t, this.i("click", i, t));
    }
    get doubleClick() {
      return this.g !== null ? this.g.Br : null;
    }
    set doubleClick(t) {
      const i = this.doubleClick;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "doubleClick"), this.Zt(), this.g.Br = t, this.i("doubleClick", i, t));
    }
    get contextClick() {
      return this.g !== null ? this.g.zr : null;
    }
    set contextClick(t) {
      const i = this.contextClick;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "contextClick"), this.Zt(), this.g.zr = t, this.i("contextClick", i, t));
    }
    get mouseEnter() {
      return this.g !== null ? this.g.Gr : null;
    }
    set mouseEnter(t) {
      const i = this.mouseEnter;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "mouseEnter"), this.Zt(), this.g.Gr = t, this.i("mouseEnter", i, t));
    }
    get mouseLeave() {
      return this.g !== null ? this.g.Hr : null;
    }
    set mouseLeave(t) {
      const i = this.mouseLeave;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "mouseLeave"), this.Zt(), this.g.Hr = t, this.i("mouseLeave", i, t));
    }
    get mouseOver() {
      return this.g !== null ? this.g.Xr : null;
    }
    set mouseOver(t) {
      const i = this.mouseOver;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "mouseOver"), this.Zt(), this.g.Xr = t, this.i("mouseOver", i, t));
    }
    get mouseHover() {
      return this.g !== null ? this.g.Yr : null;
    }
    set mouseHover(t) {
      const i = this.mouseHover;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "mouseHover"), this.Zt(), this.g.Yr = t, this.i("mouseHover", i, t));
    }
    get mouseHold() {
      return this.g !== null ? this.g.Kr : null;
    }
    set mouseHold(t) {
      const i = this.mouseHold;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "mouseHold"), this.Zt(), this.g.Kr = t, this.i("mouseHold", i, t));
    }
    get mouseDragEnter() {
      return this.g !== null ? this.g.H0 : null;
    }
    set mouseDragEnter(t) {
      const i = this.mouseDragEnter;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "mouseDragEnter"), this.Zt(), this.g.H0 = t, this.i("mouseDragEnter", i, t));
    }
    get mouseDragLeave() {
      return this.g !== null ? this.g.v0 : null;
    }
    set mouseDragLeave(t) {
      const i = this.mouseDragLeave;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "mouseDragLeave"), this.Zt(), this.g.v0 = t, this.i("mouseDragLeave", i, t));
    }
    get mouseDrop() {
      return this.g !== null ? this.g.Ur : null;
    }
    set mouseDrop(t) {
      const i = this.mouseDrop;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "mouseDrop"), this.Zt(), this.g.Ur = t, this.i("mouseDrop", i, t));
    }
    get actionDown() {
      return this.g !== null ? this.g.q0 : null;
    }
    set actionDown(t) {
      const i = this.actionDown;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "actionDown"), this.Zt(), this.g.q0 = t, this.i("actionDown", i, t));
    }
    get actionMove() {
      return this.g !== null ? this.g.W0 : null;
    }
    set actionMove(t) {
      const i = this.actionMove;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "actionMove"), this.Zt(), this.g.W0 = t, this.i("actionMove", i, t));
    }
    get actionUp() {
      return this.g !== null ? this.g.j0 : null;
    }
    set actionUp(t) {
      const i = this.actionUp;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "actionUp"), this.Zt(), this.g.j0 = t, this.i("actionUp", i, t));
    }
    get actionCancel() {
      return this.g !== null ? this.g.J0 : null;
    }
    set actionCancel(t) {
      const i = this.actionCancel;
      i !== t && (t !== null && Util.t(t, "function", _GraphObject, "actionCancel"), this.Zt(), this.g.J0 = t, this.i("actionCancel", i, t));
    }
    get toolTip() {
      return this.g !== null ? this.g.vr : null;
    }
    set toolTip(t) {
      const i = this.toolTip;
      i !== t && (Debug && t !== null && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && Util.n("GraphObject.toolTip must be an Adornment or HTMLInfo."), this.Zt(), this.g.vr = t, this.i("toolTip", i, t));
    }
    get contextMenu() {
      return this.g !== null ? this.g.qr : null;
    }
    set contextMenu(t) {
      const i = this.contextMenu;
      i !== t && (Debug && !(t instanceof Adornment2 || t instanceof HTMLInfo2) && Util.n("GraphObject.contextMenu must be an Adornment or HTMLInfo."), this.Zt(), this.g.qr = t, this.i("contextMenu", i, t));
    }
    findBindingPanel() {
      let t = this instanceof Panel2 ? this : this.panel;
      for (; t !== null; ) {
        if (t.S2())
          return t;
        t = t.panel;
      }
      return null;
    }
    bind(t, i, e, s) {
      return this.lc(t, i, e, s), this;
    }
    bindTwoWay(t, i, e, s) {
      return this.lc(t, i, e, s).makeTwoWay(), this;
    }
    bindModel(t, i, e, s) {
      return this.lc(t, i, e, s).ofModel(), this;
    }
    bindObject(t, i, e, s, n) {
      return this.lc(t, i, e, s).ofObject(n), this;
    }
    theme(t, i, e, s, n) {
      return this.yh(t, i, e, s, n), this;
    }
    themeData(t, i, e, s, n) {
      return this.yh(t, i, e, s, n).ofData(), this;
    }
    themeObject(t, i, e, s, n, o) {
      return this.yh(t, i, e, s, n).ofObject(o), this;
    }
    themeModel(t, i, e, s, n) {
      return this.yh(t, i, e, s, n).ofModel(), this;
    }
    lc(t, i, e, s) {
      let n = null;
      return typeof t == "string" ? n = new Binding2(t, i, e, s) : n = t, this.Z0(n), n;
    }
    yh(t, i, e, s, n) {
      let o = null;
      return typeof t == "string" ? o = new ThemeBinding2(t, i, e, s, n) : o = t, this.Z0(o), o;
    }
    Z0(t) {
      t.Te = this;
      const i = this.findBindingPanel();
      i !== null && i.dL() && Util.n("Cannot add a Binding to a template that has already been copied: " + t), this.Ii === null && (this.Ii = new List2()), this.Ii.add(t);
    }
    set(t) {
      if (Debug)
        for (const i in t)
          (i.startsWith("_") || i.indexOf(".") !== -1) && Util.n("Property with underscore or period passed to GraphObject.set. Did you mean to use GraphObject.attach?");
      return Object.assign(this, t), this;
    }
    attach(t) {
      return _GraphObject.M2(this, t), this;
    }
    apply(t) {
      return t(this), this;
    }
    setProperties(t) {
      return Diagram2.p0(this, t), this;
    }
    static build(t, i, ...e) {
      const s = _GraphObject.$0.getValue(t);
      if (typeof s == "function") {
        const n = s([t].concat(e));
        if (n instanceof _GraphObject)
          return i && n.setProperties(i), n;
      }
      Util.n('GraphObject.build invoked object builder "' + t + '", but it did not return an Object');
    }
    static make(t, ...i) {
      let e = arguments, s = null, n = null;
      if (typeof t == "function")
        n = t;
      else if (typeof t == "string") {
        const r = _GraphObject.$0.getValue(t);
        typeof r == "function" ? (e = Array.prototype.slice.call(e), s = r(e), Util.Mt(s) || Util.n('GraphObject.make invoked object builder "' + t + '", but it did not return an Object')) : n = root.go[t];
      }
      s === null && ((n == null || !n.constructor) && Util.n("GraphObject.make requires a class function or GoJS class name or name of an object builder, not: " + t), s = new n());
      let o = 1;
      if (s instanceof Diagram2 && e.length > 1) {
        const r = s, l = e[1];
        (typeof l == "string" || l instanceof HTMLDivElement) && (r.bP(l), o++);
      }
      for (let r = o; r < e.length; r++) {
        const l = e[r];
        l === void 0 ? Util.n("Undefined value at argument " + r + " for object being constructed by GraphObject.make: " + s) : _GraphObject.M2(s, l);
      }
      return s;
    }
    static M2(t, i) {
      if (typeof i == "number")
        _GraphObject.YR(t, i);
      else if (typeof i == "string")
        _GraphObject.KR(t, i);
      else if (i instanceof _GraphObject)
        t instanceof Panel2 || Util.n("A GraphObject can only be added to a Panel, not to: " + t), t.add(i);
      else if (i instanceof RowColumnDefinition2) {
        let e;
        i.isRow && typeof t.getRowDefinition == "function" ? e = t.getRowDefinition(i.index) : !i.isRow && typeof t.getColumnDefinition == "function" && (e = t.getColumnDefinition(i.index)), e instanceof RowColumnDefinition2 ? e.J1(i) : Util.n("A RowColumnDefinition can only be added to an object that implements getRowDefinition/getColumnDefinition, not to: " + t);
      } else if (i instanceof PanelLayout2) {
        const e = t;
        e.type = i;
      } else if (i instanceof Binding2)
        t instanceof _GraphObject || t instanceof RowColumnDefinition2 ? t.bind(i) : Util.n("A Binding can only be applied to a GraphObject or RowColumnDefinition, not to: " + t);
      else if (i instanceof AnimationTrigger2)
        t instanceof _GraphObject ? t.trigger(i) : Util.n("An AnimationTrigger can only be applied to a GraphObject, not to: " + t);
      else if (i instanceof PathFigure2)
        t instanceof Geometry2 && t.type === 4 ? t.figures.add(i) : Util.n("A PathFigure can only be added to a Path Geometry, not to: " + t);
      else if (i instanceof PathSegment2)
        t instanceof PathFigure2 ? t.segments.add(i) : Util.n("A PathSegment can only be added to a PathFigure, not to: " + t);
      else if (i instanceof Layout2)
        t instanceof Diagram2 || t instanceof Group2 ? t.layout = i : Util.n("A Layout can only be assigned to a Diagram or a Group, not to: " + t);
      else if (Array.isArray(i))
        for (let e = 0; e < i.length; e++) {
          const s = i[e];
          _GraphObject.M2(t, s);
        }
      else
        typeof i == "object" && i !== null ? _GraphObject.UR(t, i) : Util.n('Unknown initializer "' + i + '" for object being constructed by GraphObject.make: ' + t);
    }
    static KR(t, i) {
      if (t instanceof TextBlock2)
        t.text = i;
      else if (t instanceof Shape2)
        t.figure = i;
      else if (t instanceof Picture2)
        t.source = i;
      else if (t instanceof Panel2) {
        const e = PanelLayout2.Layouts.getValue(i);
        e !== null ? t.type = e : Debug && Util.n("Unknown Panel type as an argument to GraphObject.make: " + i + ". If building from source, you may need to call Panel.definePanelLayout.");
      } else if (t instanceof Brush2) {
        const e = Util.Yh(BrushType2, i);
        e !== null ? t.type = e : Util.n("Unknown Brush type as an argument to GraphObject.make: " + i);
      } else if (t instanceof Geometry2) {
        const e = Util.Yh(GeometryType2, i);
        e !== null ? t.type = e : Debug && Util.n("Unknown Geometry type as an argument to GraphObject.make: " + i);
      } else if (t instanceof PathSegment2) {
        const e = Util.Yh(SegmentType2, i);
        e !== null ? t.type = e : Debug && Util.n("Unknown PathSegment type as an argument to GraphObject.make: " + i);
      } else
        Debug && Util.n("Unable to use a string as an argument to GraphObject.make: " + i);
    }
    static YR(t, i) {
      typeof t.ci == "function" ? t.ci(i) : Util.gr(t, i);
    }
    static UR(t, i) {
      if (t instanceof Brush2) {
        const e = new PropertyCollection();
        for (const s in i) {
          const n = parseFloat(s);
          isNaN(n) ? e[s] = i[s] : t.addColorStop(n, i[s]);
        }
        Diagram2.p0(t, e);
      } else if (t instanceof RowColumnDefinition2) {
        if (i.row !== void 0) {
          const s = i.row;
          (s == null || s === 1 / 0 || isNaN(s) || s < 0) && Util.n("Must specify non-negative integer row for RowColumnDefinition " + i + ", not: " + s), t.isRow = true, t.index = s;
        } else if (i.column !== void 0) {
          const s = i.column;
          (s == null || s === 1 / 0 || isNaN(s) || s < 0) && Util.n("Must specify non-negative integer column for RowColumnDefinition " + i + ", not: " + s), t.isRow = false, t.index = s;
        }
        const e = new PropertyCollection();
        for (const s in i)
          s === "row" || s === "column" || (e[s] = i[s]);
        Diagram2.p0(t, e);
      } else
        Diagram2.p0(t, i);
    }
    static uE() {
      const t = new GMap2();
      for (const i in _GraphObject.$0) {
        if (i === i.toLowerCase())
          continue;
        const e = _GraphObject.$0.getValue(i);
        typeof e == "function" && t.add(i, e);
      }
      return t.w(), t;
    }
    static defineBuilder(t, i) {
      Util.t(t, "string", _GraphObject, "defineBuilder:name"), Util.t(i, "function", _GraphObject, "defineBuilder:func");
      const e = t.toLowerCase();
      Debug && (t === "" || e === "none" || t === e) && Util.n("Shape.defineFigureGenerator name must not be empty or None or all-lower-case: " + t), _GraphObject.$0.add(t, i);
    }
    static takeBuilderArgument(t, i, e) {
      e === void 0 && (e = null);
      const s = t[1];
      if (typeof e == "function" ? e(s) : typeof s == "string")
        return t.splice(1, 1), s;
      if (i === void 0)
        throw new Error("no " + (typeof e == "function" ? "satisfactory" : "string") + " argument for GraphObject builder " + t[0]);
      return i;
    }
  };
  __publicField(_GraphObject, "None", 0);
  __publicField(_GraphObject, "Default", 1);
  __publicField(_GraphObject, "Fill", 2);
  __publicField(_GraphObject, "Vertical");
  __publicField(_GraphObject, "Horizontal");
  __publicField(_GraphObject, "Uniform", 6);
  __publicField(_GraphObject, "UniformToFill", 7);
  __publicField(_GraphObject, "FlipVertical", 1);
  __publicField(_GraphObject, "FlipHorizontal", 2);
  __publicField(_GraphObject, "FlipBoth", 3);
  __publicField(_GraphObject, "$0", new GMap2());
  _GraphObject.Vertical = 4, _GraphObject.Horizontal = 5, _GraphObject.defineBuilder("Button", (t) => {
    const i = "#f5f5f5", e = "#737373", s = "#d4d4d4", n = "#737373", o = "#a3a3a3", r = 2.76142374915397, l = 2.761423749153969, h = new Panel2(Panel2.Auto, { isActionable: true, enabledChanged: (a, f) => {
      if (a instanceof Panel2) {
        const c = a.findObject("ButtonBorder");
        c !== null && (f ? (a._buttonFillDisabled = c.fill, c.fill = a._buttonFillNormal) : (a._buttonFillNormal = c.fill, c.fill = a._buttonFillDisabled));
      }
    }, cursor: "pointer" }).attach({ _buttonFillNormal: i, _buttonStrokeNormal: e, _buttonFillOver: s, _buttonStrokeOver: n, _buttonFillDisabled: o }).add(new Shape2("RoundedRectangle", { name: "ButtonBorder", spot1: new Spot2(0, 0, r, l), spot2: new Spot2(1, 1, -r, -l), parameter1: 2, fill: i, stroke: e }));
    return h.mouseEnter = (a, f, c) => {
      if (!f.isEnabledObject() || !(f instanceof Panel2))
        return;
      const u = f.findObject("ButtonBorder");
      u instanceof Shape2 && (f._buttonFillNormal = u.fill, u.fill = f._buttonFillOver, f._buttonStrokeNormal = u.stroke, u.stroke = f._buttonStrokeOver);
    }, h.mouseLeave = (a, f, c) => {
      if (!f.isEnabledObject() || !(f instanceof Panel2))
        return;
      const u = f.findObject("ButtonBorder");
      u instanceof Shape2 && (u.fill = f._buttonFillNormal, u.stroke = f._buttonStrokeNormal);
    }, h;
  }), _GraphObject.defineBuilder("TreeExpanderButton", (t) => {
    const i = _GraphObject.build("Button");
    return i.attach({ _treeExpandedFigure: "MinusLine", _treeCollapsedFigure: "PlusLine", visible: false }), i.add(new Shape2("MinusLine", { name: "ButtonIcon", stroke: "#0a0a0a", strokeWidth: 2, desiredSize: Size2.du }).bindObject("figure", "isTreeExpanded", (e, s) => {
      const n = s.panel;
      return e ? n._treeExpandedFigure : n._treeCollapsedFigure;
    })), i.bindObject("visible", "isTreeLeaf", (e) => !e), i.click = (e, s) => {
      let n = s.part;
      if (n instanceof Adornment2 && (n = n.adornedPart), !(n instanceof Node2))
        return;
      const o = n.diagram;
      if (o === null)
        return;
      const r = o.commandHandler;
      if (n.isTreeExpanded) {
        if (!r.canCollapseTree(n))
          return;
      } else if (!r.canExpandTree(n))
        return;
      e.handled = true, n.isTreeExpanded ? r.collapseTree(n) : r.expandTree(n);
    }, i;
  }), _GraphObject.defineBuilder("SubGraphExpanderButton", (t) => {
    const i = _GraphObject.build("Button");
    return i.attach({ _subGraphExpandedFigure: "MinusLine", _subGraphCollapsedFigure: "PlusLine" }), i.add(new Shape2("MinusLine", { name: "ButtonIcon", stroke: "#0a0a0a", strokeWidth: 2, desiredSize: Size2.du }).bindObject("figure", "isSubGraphExpanded", (e, s) => {
      const n = s.panel;
      return e ? n._subGraphExpandedFigure : n._subGraphCollapsedFigure;
    })), i.click = (e, s) => {
      let n = s.part;
      if (n instanceof Adornment2 && (n = n.adornedPart), !(n instanceof Group2))
        return;
      const o = n.diagram;
      if (o === null)
        return;
      const r = o.commandHandler;
      if (n.isSubGraphExpanded) {
        if (!r.canCollapseSubGraph(n))
          return;
      } else if (!r.canExpandSubGraph(n))
        return;
      e.handled = true, n.isSubGraphExpanded ? r.collapseSubGraph(n) : r.expandSubGraph(n);
    }, i;
  }), _GraphObject.defineBuilder("ToolTip", (t) => new Adornment2(Panel2.Auto, { isShadowed: true, shadowColor: "rgba(0, 0, 0, .4)", shadowOffset: new Point2(0, 2) }).add(new Shape2("RoundedRectangle", { name: "Border", parameter1: 1, fill: "#f5f5f5", strokeWidth: 0, spot1: new Spot2(0, 0, 4, 6), spot2: new Spot2(1, 1, -4, -4) }))), _GraphObject.defineBuilder("ContextMenu", (t) => new Adornment2(Panel2.Vertical, { background: "#f5f5f5", isShadowed: true, shadowColor: "rgba(0, 0, 0, .4)", shadowOffset: new Point2(0, 2) }).bindObject("background", "", (i) => i.adornedPart !== null && i.hasPlaceholder() ? null : "#f5f5f5")), _GraphObject.defineBuilder("ContextMenuButton", (t) => {
    const i = _GraphObject.build("Button");
    i.stretch = 5;
    const e = i.findObject("ButtonBorder");
    return e instanceof Shape2 && (e.figure = "Rectangle", e.strokeWidth = 0, e.spot1 = new Spot2(0, 0, 4, 6), e.spot2 = new Spot2(1, 1, -4, -4)), i;
  }), _GraphObject.defineBuilder("PanelExpanderButton", (t) => {
    const i = _GraphObject.takeBuilderArgument(t, "COLLAPSIBLE"), e = _GraphObject.build("Button");
    e.attach({ _buttonExpandedFigure: "M0 0 M0 6 L4 2 8 6 M8 8", _buttonCollapsedFigure: "M0 0 M0 2 L4 6 8 2 M8 8", _buttonFillNormal: "rgba(0, 0, 0, 0)", _buttonStrokeNormal: null, _buttonFillOver: "rgba(0, 0, 0, .2)", _buttonStrokeOver: null }), e.add(new Shape2({ name: "ButtonIcon", strokeWidth: 2 }).bindObject("geometryString", "visible", (n) => n ? e._buttonExpandedFigure : e._buttonCollapsedFigure, void 0, i));
    const s = e.findObject("ButtonBorder");
    return s instanceof Shape2 && (s.stroke = null, s.fill = "rgba(0, 0, 0, 0)"), e.click = (n, o) => {
      if (!(o instanceof Panel2))
        return;
      const r = o.diagram;
      if (r === null || r.isReadOnly)
        return;
      let l = o.findBindingPanel();
      if (l === null && (l = o.part), l !== null) {
        const h = l.findObject(i);
        h !== null && (n.handled = true, r.startTransaction("Collapse/Expand Panel"), h.visible = !h.visible, r.commitTransaction("Collapse/Expand Panel"));
      }
    }, e;
  }), _GraphObject.defineBuilder("CheckBoxButton", (t) => {
    const i = _GraphObject.takeBuilderArgument(t), e = _GraphObject.build("Button", { desiredSize: new Size2(14, 14) });
    e.attach({ "ButtonBorder.spot1": new Spot2(0, 0, 1, 1), "ButtonBorder.spot2": new Spot2(1, 1, -1, -1) });
    const s = new Shape2({ name: "ButtonIcon", geometryString: "M0 0 M0 8.85 L4.9 13.75 16.2 2.45 M16.2 16.2", strokeWidth: 2, stretch: 2, geometryStretch: 6, visible: false });
    return i !== "" && s.bindTwoWay("visible", i), e.add(s), e.click = (n, o) => {
      if (!(o instanceof Panel2))
        return;
      const r = n.diagram;
      if (r === null || r.isReadOnly || i !== "" && r.model.isReadOnly)
        return;
      n.handled = true;
      const l = o.findObject("ButtonIcon");
      r.startTransaction("checkbox"), l !== null && (l.visible = !l.visible), typeof o._doClick == "function" && o._doClick(n, o), r.commitTransaction("checkbox");
    }, e;
  }), _GraphObject.defineBuilder("CheckBox", (t) => {
    const i = _GraphObject.takeBuilderArgument(t), e = _GraphObject.build("CheckBoxButton", { name: "Button", isActionable: false, margin: new Margin2(0, 1, 0, 0) }, i), s = new Panel2("Horizontal", { isActionable: true, cursor: e.cursor, margin: new Margin2(1), mouseEnter: e.mouseEnter, mouseLeave: e.mouseLeave, click: e.click }).attach({ _buttonFillNormal: e._buttonFillNormal, _buttonStrokeNormal: e._buttonStrokeNormal, _buttonFillOver: e._buttonFillOver, _buttonStrokeOver: e._buttonStrokeOver, _buttonFillDisabled: e._buttonFillDisabled, _buttonClick: e.click });
    return s.add(e), e.mouseEnter = null, e.mouseLeave = null, e.click = null, s;
  });
  let GraphObject2 = _GraphObject;
  class GraphObjectTemplateSettings {
    constructor() {
      __publicField(this, "xi");
      __publicField(this, "Tt");
      __publicField(this, "so");
      __publicField(this, "Ii");
      __publicField(this, "no");
      __publicField(this, "js");
      __publicField(this, "Dl");
      __publicField(this, "Vr");
      __publicField(this, "Br");
      __publicField(this, "zr");
      __publicField(this, "Gr");
      __publicField(this, "Hr");
      __publicField(this, "Xr");
      __publicField(this, "Yr");
      __publicField(this, "Kr");
      __publicField(this, "H0");
      __publicField(this, "v0");
      __publicField(this, "Ur");
      __publicField(this, "q0");
      __publicField(this, "W0");
      __publicField(this, "j0");
      __publicField(this, "J0");
      __publicField(this, "vr");
      __publicField(this, "qr");
      __publicField(this, "D0");
      __publicField(this, "X0");
      __publicField(this, "Ns");
      __publicField(this, "Cr");
      __publicField(this, "Ar");
      __publicField(this, "lo");
      __publicField(this, "z0");
      __publicField(this, "B0");
      __publicField(this, "Nr");
      __publicField(this, "L0");
      __publicField(this, "Q0");
      __publicField(this, "_0");
      this.xi = false, this.Tt = "", this.so = -1, this.Ii = null, this.no = null, this.js = null, this.Dl = "", this.Vr = null, this.Br = null, this.zr = null, this.Gr = null, this.Hr = null, this.Xr = null, this.Yr = null, this.Kr = null, this.H0 = null, this.v0 = null, this.Ur = null, this.q0 = null, this.W0 = null, this.j0 = null, this.J0 = null, this.vr = null, this.qr = null, this.D0 = null, this.X0 = null, this.Ns = null, this.Cr = Size2.lf, this.Ar = Size2.zk, this.lo = 1, this.z0 = 1, this.B0 = 1, this.Nr = 0, this.L0 = null, this.Q0 = null, this._0 = "category";
    }
    copy() {
      const t = new GraphObjectTemplateSettings();
      return t.Tt = this.Tt, t.so = this.so, t.Ii = this.Ii, t.js = this.js, t.Dl = this.Dl, t.Vr = this.Vr, t.Br = this.Br, t.zr = this.zr, t.Gr = this.Gr, t.Hr = this.Hr, t.Xr = this.Xr, t.Yr = this.Yr, t.Kr = this.Kr, t.H0 = this.H0, t.v0 = this.v0, t.Ur = this.Ur, t.q0 = this.q0, t.W0 = this.W0, t.j0 = this.j0, t.J0 = this.J0, t.vr = this.vr, t.qr = this.qr, t.D0 = this.D0, t.X0 = this.X0, t.Ns = this.Ns, t.Cr = this.Cr.L(), t.Ar = this.Ar.L(), t.lo = this.lo, t.z0 = this.z0, t.B0 = this.B0, t.Nr = this.Nr, t.L0 = this.L0, t.Q0 = this.Q0, t._0 = this._0, t;
    }
  }
  class STransform {
    constructor() {
      __publicField(this, "m");
      this.m = [1, 0, 0, 1, 0, 0];
    }
    copy() {
      const t = new STransform();
      return t.m[0] = this.m[0], t.m[1] = this.m[1], t.m[2] = this.m[2], t.m[3] = this.m[3], t.m[4] = this.m[4], t.m[5] = this.m[5], t;
    }
    translate(t, i) {
      this.m[4] += this.m[0] * t + this.m[2] * i, this.m[5] += this.m[1] * t + this.m[3] * i;
    }
    scale(t, i) {
      this.m[0] *= t, this.m[1] *= t, this.m[2] *= i, this.m[3] *= i;
    }
    rotate(t, i, e) {
      if (t >= 360 ? t -= 360 : t < 0 && (t += 360), t === 0)
        return;
      this.translate(i, e);
      let s = 0, n = 0;
      if (t === 90)
        s = 0, n = 1;
      else if (t === 180)
        s = -1, n = 0;
      else if (t === 270)
        s = 0, n = -1;
      else {
        const a = t * Math.PI / 180;
        s = Math.cos(a), n = Math.sin(a);
      }
      const o = this.m[0] * s + this.m[2] * n, r = this.m[1] * s + this.m[3] * n, l = this.m[0] * -n + this.m[2] * s, h = this.m[1] * -n + this.m[3] * s;
      this.m[0] = o, this.m[1] = r, this.m[2] = l, this.m[3] = h, this.translate(-i, -e);
    }
  }
  class SGradient {
    constructor(t) {
      __publicField(this, "type");
      __publicField(this, "x1");
      __publicField(this, "y1");
      __publicField(this, "r1");
      __publicField(this, "x2");
      __publicField(this, "y2");
      __publicField(this, "r2");
      __publicField(this, "colors");
      __publicField(this, "pattern");
      this.type = t, this.x1 = 0, this.y1 = 0, this.r1 = 0, this.x2 = 0, this.y2 = 0, this.r2 = 0, this.colors = [], this.pattern = null;
    }
    addColorStop(t, i) {
      this.colors.push({ offset: t, color: i });
    }
  }
  class SVGSurface {
    constructor(t, i, e) {
      __publicField(this, "Bt");
      __publicField(this, "gi");
      __publicField(this, "ga");
      __publicField(this, "$u");
      __publicField(this, "P2");
      const s = i === void 0 ? root.document : i;
      this.ga = s, this.P2 = "http://www.w3.org/2000/svg";
      const n = "http://www.w3.org/2000/xmlns/";
      s !== void 0 && (this.Bt = this.makeElement("svg", { width: "1px", height: "1px", viewBox: "0 0 1 1" }), this.style.display = "block", this.style.letterSpacing = "normal", this.style.wordSpacing = "normal", e || (this.style.position = "absolute"), this.Bt.setAttributeNS(n, "xmlns", this.P2), this.Bt.setAttributeNS(n, "xmlns:xlink", "http://www.w3.org/1999/xlink")), this.$u = null, this.gi = new SVGContext(this, e);
    }
    resize(t, i, e, s) {
      return this.width !== t || this.height !== i ? (this.width = t, this.height = i, this.style.width = e + "px", this.style.height = s + "px", this.Bt.setAttributeNS(null, "width", e + "px"), this.Bt.setAttributeNS(null, "height", s + "px"), this.Bt.setAttributeNS(null, "viewBox", "0 0 " + e + " " + s), this.gi.N2.firstElementChild.setAttributeNS(null, "width", e + "px"), this.gi.N2.firstElementChild.setAttributeNS(null, "height", s + "px"), true) : false;
    }
    makeElement(t, i, e) {
      const s = this.ga.createElementNS(this.P2, t);
      if (Util.Mt(i))
        for (const n in i)
          s.setAttributeNS(n === "href" ? "http://www.w3.org/1999/xlink" : "", n, i[n]);
      return e !== void 0 && (s.textContent = e), s;
    }
    getBoundingClientRect() {
      return this.Bt.getBoundingClientRect();
    }
    focus() {
      this.Bt.focus();
    }
    get width() {
      return this.Bt.width.baseVal.value;
    }
    set width(t) {
      this.Bt.setAttribute("width", t + "px");
    }
    get height() {
      return this.Bt.height.baseVal.value;
    }
    set height(t) {
      this.Bt.setAttribute("height", t + "px");
    }
    dispose() {
      this.ga = null;
    }
    get style() {
      return this.Bt.style;
    }
  }
  class SVGContext {
    constructor(t, i) {
      __publicField(this, "hc");
      __publicField(this, "ac");
      __publicField(this, "Cn");
      __publicField(this, "Oi");
      __publicField(this, "Je");
      __publicField(this, "fillStyle");
      __publicField(this, "font");
      __publicField(this, "globalAlpha");
      __publicField(this, "lineCap");
      __publicField(this, "lineDashOffset");
      __publicField(this, "lineJoin");
      __publicField(this, "lineWidth");
      __publicField(this, "miterLimit");
      __publicField(this, "shadowBlur");
      __publicField(this, "shadowColor");
      __publicField(this, "shadowOffsetX");
      __publicField(this, "shadowOffsetY");
      __publicField(this, "strokeStyle");
      __publicField(this, "textAlign");
      __publicField(this, "imageSmoothingEnabled");
      __publicField(this, "clipInsteadOfFill");
      __publicField(this, "lastCreatedElement");
      __publicField(this, "fc");
      __publicField(this, "cc");
      __publicField(this, "surface");
      __publicField(this, "svg");
      __publicField(this, "N2");
      __publicField(this, "gL");
      __publicField(this, "Z1");
      __publicField(this, "jo");
      __publicField(this, "wh");
      __publicField(this, "Ca");
      __publicField(this, "currentElement");
      __publicField(this, "clipPathGroup");
      __publicField(this, "diagramGroup");
      __publicField(this, "lastDrawnPart");
      __publicField(this, "currentPath");
      __publicField(this, "outerGroup");
      __publicField(this, "pathAttributes");
      __publicField(this, "hl");
      __publicField(this, "Fr");
      __publicField(this, "filter");
      __publicField(this, "partClipRect");
      this.surface = t, this.svg = t.Bt, this.fc = [], this.cc = [], this.fillStyle = "#000000", this.font = "10px sans-serif", this.globalAlpha = 1, this.lineCap = "butt", this.lineDashOffset = 0, this.lineJoin = "miter", this.lineWidth = 1, this.miterLimit = 10, this.shadowBlur = 0, this.shadowColor = "rgba(0, 0, 0, 0)", this.shadowOffsetX = 0, this.shadowOffsetY = 0, this.hl = false, this.strokeStyle = "#000000", this.textAlign = "start", this.clipInsteadOfFill = false, this.hc = 0, this.ac = 0, this.Cn = 0, this.lastCreatedElement = null, this.currentElement = null, this.Oi = [], this.pathAttributes = {}, this.Z1 = false, this.jo = null, this.wh = 0, this.Je = new STransform(), this.clipPathGroup = this.newGroup2(), this.diagramGroup = this.newGroup2("gojs-diagram"), this.lastDrawnPart = null, this.currentPath = null;
      const e = GSet2.fu++, s = this.makeElement("clipPath", { id: "mainClip" + e }), n = { x: 0, y: 0, width: t.width, height: t.height };
      s.appendChild(this.makeElement("rect", n)), this.N2 = s, this.svg.appendChild(this.clipPathGroup), this.clipPathGroup.appendChild(this.diagramGroup), this.svg.appendChild(s), this.clipPathGroup.setAttributeNS(null, "clip-path", "url(#mainClip" + e + ")"), this.gL = {}, this.Fr = !!i, this.filter = "", this.partClipRect = null;
    }
    setDiagramPosScale(t, i, e, s, n, o) {
      this.diagramGroup === void 0 ? this.newGroup(t, i, e, s, n, o) : this.diagramGroup.setAttribute("transform", "matrix(" + t + ", " + i + ", " + e + ", " + s + ", " + n + ", " + o + ")");
    }
    resetInnerSVG() {
      this.diagramGroup !== null && (this.diagramGroup.innerHTML = "");
    }
    arc(t, i, e, s, n, o, r, l) {
      const h = 2 * Math.PI, a = 1e-6, f = h - a, c = e * Math.cos(s), u = e * Math.sin(s), d = t + c, m = i + u, g = o ? 0 : 1;
      let p = o ? s - n : n - s;
      (Math.abs(r - d) > a || Math.abs(l - m) > a) && this.Oi.push(["L", d, +m]), p < 0 && (p = p % h + h), p > f ? (this.Oi.push(["A", e, e, 0, 1, g, t - c, i - u]), this.Oi.push(["A", e, e, 0, 1, g, d, m])) : p > a && this.Oi.push(["A", e, e, 0, +(p >= Math.PI), g, t + e * Math.cos(n), i + e * Math.sin(n)]);
    }
    beginPath() {
      this.Oi = [], this.pathAttributes = { stroke: "none", fill: "none" };
    }
    endPath(t) {
      this.GR(this.Oi, this.Je, t || 0);
    }
    bezierCurveTo(t, i, e, s, n, o) {
      this.Oi.push(["C", t, i, e, s, n, o]);
    }
    clearRect(t, i, e, s) {
    }
    clip() {
      this.pathAttributes.clipPath = true;
    }
    closePath() {
      this.Oi.push(["z"]);
    }
    createLinearGradient(t, i, e, s) {
      const n = new SGradient("linear");
      return n.x1 = t, n.y1 = i, n.x2 = e, n.y2 = s, n;
    }
    createPattern(t, i) {
      let e = "";
      t instanceof HTMLCanvasElement && (e = t.toDataURL()), t instanceof HTMLImageElement && (e = t.getAttribute("src"));
      const s = this.gL;
      if (s[e])
        return "url(#" + s[e] + ")";
      const n = "PATTERN" + GSet2.fu++, o = { width: t.width, height: t.height, id: n, patternUnits: "userSpaceOnUse" }, r = { x: 0, y: 0, width: t.width, height: t.height, href: e }, l = this.makeElement("pattern", o);
      return l.appendChild(this.makeElement(Diagram2.img, r)), this.svg.appendChild(l), s[e] = n, "url(#" + n + ")";
    }
    createRadialGradient(t, i, e, s, n, o) {
      const r = new SGradient("radial");
      return r.x1 = t, r.y1 = i, r.r1 = e, r.x2 = s, r.y2 = n, r.r2 = o, r;
    }
    amendImageTransform(t, i, e, s, n, o, r, l) {
      const h = r / e, a = l / s;
      (n !== 0 || o !== 0) && this.Je.translate(n, o), (h !== 1 || a !== 1) && this.Je.scale(h, a), (t !== 0 || i !== 0) && this.Je.translate(-t, -i);
    }
    drawImage(t, i, e, s, n, o, r, l, h) {
      let a = "";
      t instanceof HTMLCanvasElement && (a = t.toDataURL()), t instanceof HTMLImageElement && (a = t.getAttribute("src"));
      const f = t instanceof HTMLImageElement ? t.naturalWidth : t.width, c = t instanceof HTMLImageElement ? t.naturalHeight : t.height;
      s === void 0 && (o = i, r = e, l = s = f, h = n = c), s = s || 0, n = n || 0, o = o || 0, r = r || 0, l = l || 0, h = h || 0, this.amendImageTransform(i, e, s, n, o, r, l, h);
      const u = { x: 0, y: 0, width: f || s, height: c || n, href: a };
      !Geo.q(s, l) || !Geo.q(n, h) ? u.preserveAspectRatio = "none" : a.toLowerCase().indexOf(".svg") === -1 && a.toLowerCase().indexOf("data:image/svg") === -1 && (u.preserveAspectRatio = "xMidYMid slice"), (i !== 0 || e !== 0 || s !== f || n !== c) && (s += i, n += e, u["clip-path"] = `path('M ${i},${e} L ${s} ${e} L ${s} ${n} L ${i} ${n} z')`), this.processCommon(Diagram2.img, u, this.Je), this.dd(Diagram2.img, u);
    }
    fill(t, i) {
      t && (this.pathAttributes["fill-rule"] = "evenodd"), this.setFill(this.pathAttributes);
    }
    fillContext(t, i, e) {
      this.clipInsteadOfFill ? this.clip() : this.fill(i, e);
    }
    fillRect(t, i, e, s) {
      this.addRect("fill", [t, i, e, s], this.Je);
    }
    fillBackground(t, i, e, s) {
      const n = { x: t, y: i, width: e, height: s };
      this.processCommon("fill", n, this.Je), this.setFill(n), this.svg.prepend(this.makeElement("rect", n));
    }
    fillText(t, i, e) {
      this.addText("fill", [t, i, e], this.Je);
    }
    lineTo(t, i) {
      this.Oi.push(["L", t, i]);
    }
    moveTo(t, i) {
      this.Oi.push(["M", t, i]);
    }
    quadraticCurveTo(t, i, e, s) {
      this.Oi.push(["Q", t, i, e, s]);
    }
    rect(t, i, e, s) {
      this.Oi.push(["M", t, i], ["L", t + e, i], ["L", t + e, i + s], ["L", t, i + s], ["z"]);
    }
    restore() {
      this.Je = this.fc.pop(), this.Oi = this.fc.pop();
      const t = this.fc.pop();
      this.fillStyle = t.fillStyle, this.font = t.font, this.globalAlpha = t.globalAlpha, this.lineCap = t.lineCap, this.lineDashOffset = t.lineDashOffset, this.lineJoin = t.lineJoin, this.lineWidth = t.lineWidth, this.miterLimit = t.miterLimit, this.shadowBlur = t.shadowBlur, this.shadowColor = t.shadowColor, this.shadowOffsetX = t.shadowOffsetX, this.shadowOffsetY = t.shadowOffsetY, this.strokeStyle = t.strokeStyle, this.textAlign = t.textAlign, this.partClipRect = t.partClipRect;
    }
    save() {
      const t = { fillStyle: this.fillStyle, font: this.font, globalAlpha: this.globalAlpha, lineCap: this.lineCap, lineDashOffset: this.lineDashOffset, lineJoin: this.lineJoin, lineWidth: this.lineWidth, miterLimit: this.miterLimit, shadowBlur: this.shadowBlur, shadowColor: this.shadowColor, shadowOffsetX: this.shadowOffsetX, shadowOffsetY: this.shadowOffsetY, strokeStyle: this.strokeStyle, textAlign: this.textAlign, partClipRect: this.partClipRect };
      this.fc.push(t);
      const i = [];
      for (let e = 0; e < this.Oi.length; e++)
        i.push(this.Oi[e]);
      this.fc.push(i), this.fc.push(this.Je.copy());
    }
    setTransform(t, i, e, s, n, o) {
      t === 1 && i === 0 && e === 0 && s === 1 && n === 0 && o === 0 || this.newGroup(t, i, e, s, n, o);
    }
    setCurrentTransform(t, i, e, s, n, o) {
      this.Je.m = [t, i, e, s, n, o];
    }
    getCurrentTransform() {
      const t = this.Je.m;
      return "matrix(" + t[0] + ", " + t[1] + ", " + t[2] + ", " + t[3] + ", " + t[4] + ", " + t[5] + ")";
    }
    scale(t, i) {
      this.Je.scale(t, i);
    }
    translate(t, i) {
      this.Je.translate(t, i);
    }
    transform(t, i, e, s, n, o) {
    }
    commitTransform() {
    }
    stroke() {
      this.setStroke(this.pathAttributes);
    }
    strokeContext() {
      this.clipInsteadOfFill || this.stroke();
    }
    strokeRect(t, i, e, s) {
      this.addRect("stroke", [t, i, e, s], this.Je);
    }
    makeElement(t, i, e) {
      return this.surface.makeElement(t, i, e);
    }
    dd(t, i, e) {
      const s = this.makeElement(t, i, e);
      return this.currentElement !== null ? this.currentElement.appendChild(s) : this.currentElement = s, this.lastCreatedElement = s, s;
    }
    processCommon(t, i, e) {
      if (t === "fill" ? this.setFill(i) : t === "stroke" && this.setStroke(i), e !== null) {
        const s = e.m;
        i.transform = "matrix(" + s[0] + ", " + s[1] + ", " + s[2] + ", " + s[3] + ", " + s[4] + ", " + s[5] + ")";
      }
    }
    setFill(t) {
      if (this.fillStyle instanceof SGradient) {
        t.fill = this.addGradient(this.fillStyle, true);
        return;
      }
      if (/^rgba\(/.test(this.fillStyle)) {
        const e = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(this.fillStyle);
        t.fill = "rgb(" + e[1] + "," + e[2] + "," + e[3] + ")", t["fill-opacity"] = e[4];
      } else
        t.fill = this.fillStyle;
    }
    setFillOrStrokeInPlace(t, i) {
      const e = i ? "fill" : "stroke";
      if (this.fillStyle instanceof SGradient) {
        t.setAttributeNS(null, "fill", this.addGradient(this.fillStyle, true));
        return;
      }
      if (/^rgba\(/.test(this.fillStyle)) {
        const n = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(this.fillStyle);
        t.setAttributeNS(null, e, "rgb(" + n[1] + "," + n[2] + "," + n[3] + ")"), t.setAttributeNS(null, e + "-opacity", n[4]);
      } else
        t.setAttributeNS(null, e, this.fillStyle);
    }
    setStroke(t) {
      if (this.strokeStyle instanceof SGradient)
        t.stroke = this.addGradient(this.strokeStyle, false);
      else if (/^rgba\(/.test(this.strokeStyle)) {
        const e = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(this.strokeStyle);
        t.stroke = "rgb(" + e[1] + "," + e[2] + "," + e[3] + ")", t["stroke-opacity"] = e[4];
      } else
        t.stroke = this.strokeStyle;
      t["stroke-width"] = this.lineWidth, t["stroke-linecap"] = this.lineCap, t["stroke-linejoin"] = this.lineJoin, t["stroke-miterlimit"] = this.miterLimit, this.Z1 && (t["stroke-dasharray"] = this.jo.toString(), t["stroke-dashoffset"] = this.wh);
    }
    addGradient(t, i) {
      let e = "";
      const s = this.currentPath !== null ? this.currentPath.getAttribute(i ? "fill" : "stroke") : null;
      if (s !== null && s.indexOf("GRAD") !== -1) {
        e = s.split("#")[1].slice(0, -1);
        const h = this.svg.getElementById(e);
        h !== null && h.remove();
      } else
        e = "GRAD" + GSet2.fu++;
      let n;
      if (t.type === "linear") {
        const h = { x1: t.x1, x2: t.x2, y1: t.y1, y2: t.y2, id: e, gradientUnits: "userSpaceOnUse" };
        n = this.makeElement("linearGradient", h);
      } else if (t.type === "radial") {
        const h = { x1: t.x1, x2: t.x2, y1: t.y1, y2: t.y2, r1: t.r1, r2: t.r2, id: e };
        n = this.makeElement("radialGradient", h);
      } else
        throw new Error("invalid gradient");
      const o = t.colors, r = o.length, l = [];
      for (let h = 0; h < r; h++) {
        const a = o[h], f = a.color, c = { offset: a.offset, "stop-color": f };
        if (/^rgba\(/.test(f)) {
          const d = /^\s*rgba\s*\(([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\s*,\s*([^,\s]+)\)\s*$/i.exec(f);
          c["stop-color"] = "rgb(" + d[1] + "," + d[2] + "," + d[3] + ")", c["stop-opacity"] = d[4];
        }
        l.push(c);
      }
      l.sort((h, a) => h.offset > a.offset ? 1 : -1);
      for (let h = 0; h < r; h++)
        n.appendChild(this.makeElement("stop", l[h]));
      return this.svg.appendChild(n), "url(#" + e + ")";
    }
    addRect(t, i, e) {
      const s = { x: i[0], y: i[1], width: i[2], height: i[3] };
      this.processCommon(t, s, e), this.dd("rect", s);
    }
    addText(t, i, e) {
      let s = this.textAlign;
      s === "left" ? s = "start" : s === "right" ? s = "end" : s === "center" && (s = "middle");
      const n = { x: i[1], y: i[2], style: "font: " + this.font, "text-anchor": s };
      this.processCommon(t, n, e), this.dd("text", n, i[0]);
    }
    GR(t, i, e) {
      const s = this.HR(t), n = this.pathAttributes;
      if (n.clipPath) {
        this.cc.length > 0 && this.cc[this.cc.length - 1].setAttributeNS(null, "clip-path", 'path("' + s + '")');
        return;
      }
      if (n.d = s, this.processCommon("", n, i), this.currentPath !== null) {
        const r = this.currentPath;
        if (r.nodeName !== "g")
          for (const l in n)
            l !== "transform" && r.setAttributeNS(null, l, n[l]);
        else {
          const l = r.getElementsByTagName("path");
          for (const h in n)
            h !== "transform" && l[e].setAttributeNS(null, h, n[h]);
        }
      } else
        this.dd("path", n);
    }
    HR(t) {
      const i = [];
      for (let e = 0; e < t.length; e++) {
        const s = t[e].slice(), n = [s.shift()];
        if (n[0] === "A")
          n.push(s.shift() + "," + s.shift(), s.shift(), s.shift() + "," + s.shift(), s.shift() + "," + s.shift());
        else
          for (; s.length; )
            n.push(s.shift() + "," + s.shift());
        i.push(n.join(" "));
      }
      return i.join(" ");
    }
    newGroup(t, i, e, s, n, o) {
      const r = new STransform();
      r.m = [t, i, e, s, n, o];
      const l = {};
      this.processCommon("g", l, r);
      const h = this.dd("g", l);
      return this.cc.push(h), h;
    }
    newGroup2(t) {
      const i = {};
      t && (i.class = t);
      const e = this.dd("g", i);
      return this.cc.push(e), e;
    }
    endGroup() {
      return this.cc.pop();
    }
    dummyGroup() {
      return this.newGroup2(), this.endGroup();
    }
    shadowsSet(t, i, e) {
      this.hc = t, this.ac = i, this.Cn = e;
    }
    shadowsOff() {
      this.hl = false, this.shadowOffsetX = 0, this.shadowOffsetY = 0, this.shadowBlur = 0;
    }
    shadowsOn() {
      this.hl = true, this.shadowOffsetX = this.hc, this.shadowOffsetY = this.ac, this.shadowBlur = this.Cn;
    }
    enableDash(t, i) {
      this.Z1 = true, this.jo = t, this.wh = i;
    }
    disableDash() {
      this.Z1 = false;
    }
    clearContextCache(t) {
    }
    setImageSmoothingEnabled(t) {
    }
    rotate(t) {
      this.Je.rotate(t * 57.2958, 0, 0);
    }
    getImageData(t, i, e, s) {
      return null;
    }
    measureText(t) {
      return null;
    }
    removeOldGradient(t, i, e) {
      const s = i.getAttribute(e);
      if (s === null)
        return;
      const n = s.split("#");
      if (n.length === 1)
        return;
      const o = this.svg.getElementById(n[1].slice(0, -1));
      if (o !== null) {
        const r = new RegExp(o.id, "g");
        this.svg.innerHTML.match(r).length === 1 && o.remove();
      }
    }
    removePartFromView(t) {
      t.svg !== null && t.svg.parentNode === this.diagramGroup && t.svg.remove();
    }
  }
  class CanvasSurface {
    constructor(t, i, e, s) {
      __publicField(this, "Bt");
      __publicField(this, "gi");
      __publicField(this, "ga");
      __publicField(this, "$u");
      const n = i === void 0 ? root.document : i;
      this.ga = n, this.$u = null;
      const o = n.createElement("canvas");
      o.tabIndex = 0, this.Bt = o, this.gi = new CanvasSurfaceContext(o, e, s), Diagram2.he.set(o, t);
    }
    resize(t, i, e, s) {
      return this.width !== t || this.height !== i ? (this.width = t, this.height = i, this.style.width = e + "px", this.style.height = s + "px", true) : false;
    }
    toDataURL(t, i) {
      return this.Bt.toDataURL(t, i);
    }
    getBoundingClientRect() {
      return this.Bt.getBoundingClientRect();
    }
    focus() {
      this.Bt.focus();
    }
    get width() {
      return this.Bt.width;
    }
    set width(t) {
      this.Bt.width = t;
    }
    get height() {
      return this.Bt.height;
    }
    set height(t) {
      this.Bt.height = t;
    }
    dispose() {
      Diagram2.he.delete(this.Bt), this.ga = null;
    }
    get style() {
      return this.Bt.style;
    }
  }
  const _CanvasSurfaceContext = class _CanvasSurfaceContext {
    constructor(t, i, e) {
      __publicField(this, "Y");
      __publicField(this, "$1");
      __publicField(this, "Q1");
      __publicField(this, "_1");
      __publicField(this, "tp");
      __publicField(this, "hc");
      __publicField(this, "ac");
      __publicField(this, "Cn");
      __publicField(this, "Ca");
      __publicField(this, "hl");
      __publicField(this, "Fr");
      this.Y = t.getContext ? t.getContext("2d", i) : null, this.Y === null && Util.n("Browser does not support HTML Canvas Element"), this.$1 = "", this.Q1 = "", this._1 = "", this.tp = false, this.hc = 0, this.ac = 0, this.Cn = 0, this.hl = false, this.Ca = new Transform(), this.Fr = !!e;
    }
    setImageSmoothingEnabled(t) {
      this.Y.imageSmoothingEnabled = t;
    }
    get fillStyle() {
      return this.Y.fillStyle;
    }
    set fillStyle(t) {
      this._1 !== t && (this.Y.fillStyle = t, this._1 = t);
    }
    get font() {
      return this.Y.font;
    }
    set font(t) {
      this.$1 !== t && (this.Y.font = t, this.$1 = t);
    }
    get globalAlpha() {
      return this.Y.globalAlpha;
    }
    set globalAlpha(t) {
      this.Y.globalAlpha = t;
    }
    get lineCap() {
      return this.Y.lineCap;
    }
    set lineCap(t) {
      this.Y.lineCap = t;
    }
    get lineDashOffset() {
      return this.Y.lineDashOffset;
    }
    set lineDashOffset(t) {
      this.Y.lineDashOffset = t;
    }
    get lineJoin() {
      return this.Y.lineJoin;
    }
    set lineJoin(t) {
      this.Y.lineJoin = t;
    }
    get lineWidth() {
      return this.Y.lineWidth;
    }
    set lineWidth(t) {
      this.Y.lineWidth = t;
    }
    get miterLimit() {
      return this.Y.miterLimit;
    }
    set miterLimit(t) {
      this.Y.miterLimit = t;
    }
    get shadowBlur() {
      return this.Y.shadowBlur;
    }
    set shadowBlur(t) {
      this.Y.shadowBlur = t;
    }
    get shadowColor() {
      return this.Y.shadowColor;
    }
    set shadowColor(t) {
      this.Y.shadowColor = t;
    }
    get shadowOffsetX() {
      return this.Y.shadowOffsetX;
    }
    set shadowOffsetX(t) {
      this.Y.shadowOffsetX = t;
    }
    get shadowOffsetY() {
      return this.Y.shadowOffsetY;
    }
    set shadowOffsetY(t) {
      this.Y.shadowOffsetY = t;
    }
    get strokeStyle() {
      return this.Y.strokeStyle;
    }
    set strokeStyle(t) {
      this.Q1 !== t && (this.Y.strokeStyle = t, this.Q1 = t);
    }
    get textAlign() {
      return this.Y.textAlign;
    }
    set textAlign(t) {
      this.Y.textAlign = t;
    }
    get imageSmoothingEnabled() {
      return this.Y.imageSmoothingEnabled;
    }
    set imageSmoothingEnabled(t) {
      this.Y.imageSmoothingEnabled = t;
    }
    get filter() {
      return this.Y.filter;
    }
    set filter(t) {
      t === "" ? this.Y.filter = "none" : this.Y.filter = t;
    }
    arc(t, i, e, s, n, o, r, l) {
      this.Y.arc(t, i, e, s, n, o);
    }
    beginPath() {
      this.Y.beginPath();
    }
    endPath() {
    }
    bezierCurveTo(t, i, e, s, n, o) {
      this.Y.bezierCurveTo(t, i, e, s, n, o);
    }
    clearRect(t, i, e, s) {
      this.commitTransform(), this.Y.clearRect(t, i, e, s);
    }
    clip(t) {
      t ? this.Y.clip(t) : this.Y.clip();
    }
    closePath() {
      this.Y.closePath();
    }
    createLinearGradient(t, i, e, s) {
      return this.Y.createLinearGradient(t, i, e, s);
    }
    createPattern(t, i) {
      return this.Y.createPattern(t, i);
    }
    createRadialGradient(t, i, e, s, n, o) {
      return this.Y.createRadialGradient(t, i, e, s, n, o);
    }
    drawImage(t, i, e, s, n, o, r, l, h) {
      s === void 0 ? this.Y.drawImage(t, i, e) : this.Y.drawImage(t, i, e, s, n, o, r, l, h);
    }
    fill(t, i) {
      i ? this.Y.fill(i, t ? "evenodd" : "nonzero") : this.Y.fill(t ? "evenodd" : "nonzero");
    }
    fillRect(t, i, e, s) {
      this.Y.fillRect(t, i, e, s);
    }
    fillBackground(t, i, e, s) {
      this.Y.fillRect(t, i, e, s);
    }
    fillText(t, i, e) {
      this.Y.fillText(t, i, e);
    }
    getImageData(t, i, e, s) {
      return this.Y.getImageData(t, i, e, s);
    }
    lineTo(t, i) {
      this.Y.lineTo(t, i);
    }
    measureText(t) {
      return this.Y.measureText(t);
    }
    moveTo(t, i) {
      this.Y.moveTo(t, i);
    }
    quadraticCurveTo(t, i, e, s) {
      this.Y.quadraticCurveTo(t, i, e, s);
    }
    rect(t, i, e, s) {
      this.Y.rect(t, i, e, s);
    }
    restore() {
      this.Y.restore();
    }
    save() {
      this.commitTransform(), this.Y.save();
    }
    rotate(t) {
      this.Ca.ys(t * 57.2958, 0, 0);
    }
    setTransform(t, i, e, s, n, o) {
      this.Ca.setTo(t, i, e, s, n, o);
    }
    scale(t, i) {
      this.Ca.v(t, i);
    }
    translate(t, i) {
      this.Ca.se(t, i);
    }
    stroke(t) {
      t ? this.Y.stroke(t) : this.Y.stroke();
    }
    transform(t, i, e, s, n, o) {
      if (t === 1 && i === 0 && e === 0 && s === 1 && n === 0 && o === 0)
        return;
      const r = this.Ca, l = r.m11 * t + r.m21 * i, h = r.m12 * t + r.m22 * i, a = r.m11 * e + r.m21 * s, f = r.m12 * e + r.m22 * s;
      r.dx = r.m11 * n + r.m21 * o + r.dx, r.dy = r.m12 * n + r.m22 * o + r.dy, r.m11 = l, r.m12 = h, r.m21 = a, r.m22 = f;
    }
    commitTransform() {
      const t = this.Ca;
      this.Y.setTransform(t.m11, t.m12, t.m21, t.m22, t.dx, t.dy);
    }
    fillContext(t, i, e) {
      this.radialFill(t, i, e) || this.fillOrClip(i, e);
    }
    radialFill(t, i, e) {
      if (!(t instanceof Brush2) || t.type !== 3)
        return false;
      const s = t.nc, n = t.W1;
      return n > s ? (this.scale(s / n, 1), this.translate((n - s) / 2, 0)) : s > n && (this.scale(1, n / s), this.translate(0, (s - n) / 2)), this.fillOrClip(i, e), n > s ? (this.translate(-(n - s) / 2, 0), this.scale(1 / (s / n), 1)) : s > n && (this.translate(0, -(s - n) / 2), this.scale(1, 1 / (n / s))), true;
    }
    strokeContext() {
      this.tp || this.stroke();
    }
    fillOrClip(t, i) {
      this.tp ? this.clip(i) : this.fill(t, i);
    }
    get clipInsteadOfFill() {
      return this.tp;
    }
    set clipInsteadOfFill(t) {
      this.tp = t;
    }
    shadowsSet(t, i, e) {
      this.hc = t, this.ac = i, this.Cn = e;
    }
    shadowsOff() {
      this.hl = false, this.shadowOffsetX = 0, this.shadowOffsetY = 0, this.shadowBlur = 0;
    }
    shadowsOn() {
      this.hl = true, this.shadowOffsetX = this.hc, this.shadowOffsetY = this.ac, this.shadowBlur = this.Cn;
    }
    enableDash(t, i) {
      const e = this.Y;
      e.setLineDash !== void 0 && (e.setLineDash(t), e.lineDashOffset = i);
    }
    disableDash() {
      const t = this.Y;
      t.setLineDash !== void 0 && (t.setLineDash(_CanvasSurfaceContext.EmptyArray), t.lineDashOffset = 0);
    }
    clearContextCache(t) {
      t && (this.$1 = ""), this.Q1 = "", this._1 = "";
    }
    removePartFromView(t) {
    }
  };
  __publicField(_CanvasSurfaceContext, "EmptyArray", Object.freeze([]));
  let CanvasSurfaceContext = _CanvasSurfaceContext;
  var BrushType2 = ((w) => (w[w.Solid = 1] = "Solid", w[w.Linear = 2] = "Linear", w[w.Radial = 3] = "Radial", w[w.Pattern = 4] = "Pattern", w))(BrushType2 || {}), ColorSpace2 = ((w) => (w[w.Lab = 1] = "Lab", w[w.HSL = 2] = "HSL", w[w.Oklch = 3] = "Oklch", w))(ColorSpace2 || {});
  class ColorNumbers {
    constructor() {
      __publicField(this, "n0");
      __publicField(this, "n1");
      __publicField(this, "n2");
      __publicField(this, "n3");
      this.n0 = 0, this.n1 = 0, this.n2 = 0, this.n3 = 0;
    }
  }
  const _Brush = class _Brush {
    constructor(t, i) {
      __publicField(this, "f");
      __publicField(this, "nt");
      __publicField(this, "Aa");
      __publicField(this, "li");
      __publicField(this, "ks");
      __publicField(this, "ip");
      __publicField(this, "ep");
      __publicField(this, "An");
      __publicField(this, "sp");
      __publicField(this, "Pn");
      __publicField(this, "nc");
      __publicField(this, "W1");
      if (GSet2.ji(this), this.f = false, t === void 0)
        this.nt = 1, this.Aa = "black";
      else if (typeof t == "string") {
        const s = Util.Yh(BrushType2, t);
        s !== null ? (this.nt = s, this.Aa = "black") : (this.nt = 1, Debug && !_Brush.isValidColor(t) && Util.n('Color "' + t + '" is not a valid color string for Brush constructor'), this.Aa = t);
      } else
        Debug && Util.it(t, BrushType2, "BrushType"), this.nt = t, this.Aa = "black";
      const e = this.nt;
      if (e === 2 ? (this.li = Spot2.TopCenter, this.ks = Spot2.BottomCenter) : e === 3 ? (this.li = Spot2.Center, this.ks = Spot2.Center) : (this.li = Spot2.None, this.ks = Spot2.None), this.ip = 0, this.ep = NaN, this.An = null, this.sp = null, this.Pn = null, this.nc = 0, this.W1 = 0, i) {
        const s = {};
        for (const n in i)
          isFinite(parseFloat(n)) ? this.addColorStop(parseFloat(n), i[n]) : s[n] = i[n];
        Object.assign(this, s);
      }
    }
    copy() {
      const t = new _Brush();
      return t.nt = this.nt, t.Aa = this.Aa, t.li = this.li.L(), t.ks = this.ks.L(), t.ip = this.ip, t.ep = this.ep, this.An !== null && (t.An = this.An.copy()), t.sp = this.sp, t;
    }
    w() {
      return this.f = true, this.An !== null && this.An.w(), this;
    }
    ut() {
      return Object.isFrozen(this) && Util.n("cannot thaw constant: " + this), this.f = false, this.An !== null && this.An.ut(), this;
    }
    ci(t) {
      t in BrushType2 ? this.type = t : Util.gr(this, t);
    }
    toString() {
      let t = "Brush(";
      if (this.type === 1)
        t += this.color;
      else if (this.type === 2 ? t += "Linear " : this.type === 3 ? t += "Radial " : this.type === 4 ? t += "Pattern " : t += "(unknown) ", t += this.start + " " + this.end, this.colorStops !== null) {
        const i = this.colorStops.iterator;
        for (; i.next(); ) {
          const e = i.key, s = i.value;
          t += " " + e + ":" + s;
        }
      }
      return t += ")", t;
    }
    addColorStop(t, i) {
      return this.f && Util.O(this), (typeof t != "number" || !isFinite(t) || t > 1 || t < 0) && Util.G(t, "0 <= loc <= 1", _Brush, "addColorStop:loc"), Util.t(i, "string", _Brush, "addColorStop:color"), Debug && !_Brush.isValidColor(i) && Util.n('Color "' + i + '" is not a valid color string for Brush.addColorStop'), this.An === null && (this.An = new GMap2()), this.An.add(t, i), this.nt === 1 && (this.type = 2), this.Pn = null, this;
    }
    get type() {
      return this.nt;
    }
    set type(t) {
      this.f && Util.O(this, t), Util.it(t, BrushType2, "BrushType"), this.nt = t, this.start.isNoSpot() && (t === 2 ? this.start = Spot2.TopCenter : t === 3 && (this.start = Spot2.Center)), this.end.isNoSpot() && (t === 2 ? this.end = Spot2.BottomCenter : t === 3 && (this.end = Spot2.Center)), this.Pn = null;
    }
    get color() {
      return this.Aa;
    }
    set color(t) {
      this.f && Util.O(this, t), Debug && !_Brush.isValidColor(t) && Util.n('Color "' + t + '" is not a valid color string for Brush.color'), this.Aa = t, this.Pn = null;
    }
    get start() {
      return this.li;
    }
    set start(t) {
      this.f && Util.O(this, t), Util.s(t, Spot2, _Brush, "start"), this.li = t.L(), this.Pn = null;
    }
    get end() {
      return this.ks;
    }
    set end(t) {
      this.f && Util.O(this, t), Util.s(t, Spot2, _Brush, "end"), this.ks = t.L(), this.Pn = null;
    }
    get startRadius() {
      return this.ip;
    }
    set startRadius(t) {
      this.f && Util.O(this, t), Util.r(t, _Brush, "startRadius"), t < 0 && Util.G(t, ">= zero", _Brush, "startRadius"), this.ip = t, this.Pn = null;
    }
    get endRadius() {
      return this.ep;
    }
    set endRadius(t) {
      this.f && Util.O(this, t), Util.r(t, _Brush, "endRadius"), t < 0 && Util.G(t, ">= zero", _Brush, "endRadius"), this.ep = t, this.Pn = null;
    }
    get colorStops() {
      return this.An;
    }
    set colorStops(t) {
      this.f && Util.O(this, t), Debug && Util.s(t, GMap2, _Brush, "colorStops"), this.An = t, this.Pn = null;
    }
    get pattern() {
      return this.sp;
    }
    set pattern(t) {
      this.f && Util.O(this, t), this.sp = t, this.Pn = null;
    }
    static randomColor(t, i) {
      t === void 0 && (t = 128), Debug && (Util.r(t, _Brush, "randomColor:min"), (t < 0 || t > 255) && Util.G(t, "0 <= min <= 255", _Brush, "randomColor:min")), i === void 0 && (i = Math.max(t, 255)), Debug && (Util.r(i, _Brush, "randomColor:max"), (i < t || i > 255) && Util.G(i, "min <= max <= 255", _Brush, "randomColor:max"));
      const e = Math.abs(i - t);
      let s = Math.floor(t + Math.random() * e).toString(16), n = Math.floor(t + Math.random() * e).toString(16), o = Math.floor(t + Math.random() * e).toString(16);
      return s.length < 2 && (s = "0" + s), n.length < 2 && (n = "0" + n), o.length < 2 && (o = "0" + o), "#" + s + n + o;
    }
    static isValidColor(t) {
      return root.CSS ? root.CSS.supports("color", t) : true;
    }
    static lighten(t) {
      return _Brush.lightenBy(t);
    }
    lightenBy(t, i) {
      this.f && Util.O(this);
      const e = t === void 0 || typeof t != "number" ? 0.2 : t, s = i === void 0 ? 3 : i;
      if (this.type === 1)
        _Brush.Bo(this.color), this.color = _Brush.gd(e, s);
      else if ((this.type === 2 || this.type === 3) && this.colorStops !== null) {
        const n = this.colorStops.iterator;
        for (; n.next(); )
          _Brush.Bo(n.value), this.addColorStop(n.key, _Brush.gd(e, s));
      }
      return this;
    }
    static lightenBy(t, i, e) {
      const s = i === void 0 || typeof i != "number" ? 0.2 : i, n = e === void 0 ? 3 : e;
      return _Brush.Bo(t), _Brush.gd(s, n);
    }
    static darken(t) {
      return _Brush.darkenBy(t);
    }
    darkenBy(t, i) {
      this.f && Util.O(this);
      const e = t === void 0 || typeof t != "number" ? 0.2 : t, s = i === void 0 ? 3 : i;
      if (this.type === 1)
        _Brush.Bo(this.color), this.color = _Brush.gd(-e, s);
      else if ((this.type === 2 || this.type === 3) && this.colorStops !== null) {
        const n = this.colorStops.iterator;
        for (; n.next(); )
          _Brush.Bo(n.value), this.addColorStop(n.key, _Brush.gd(-e, s));
      }
      return this;
    }
    static darkenBy(t, i, e) {
      const s = i === void 0 || typeof i != "number" ? 0.2 : i, n = e === void 0 ? 3 : e;
      return _Brush.Bo(t), _Brush.gd(-s, n);
    }
    static mix(t, i, e) {
      _Brush.Bo(t);
      const s = _Brush.j.n0, n = _Brush.j.n1, o = _Brush.j.n2, r = _Brush.j.n3;
      _Brush.Bo(i), e === void 0 && (e = 0.5);
      const l = Math.round((_Brush.j.n0 - s) * e + s), h = Math.round((_Brush.j.n1 - n) * e + n), a = Math.round((_Brush.j.n2 - o) * e + o), f = Math.round((_Brush.j.n3 - r) * e + r);
      return `rgba(${l}, ${h}, ${a}, ${f})`;
    }
    isDark() {
      if (this.type === 1)
        return _Brush.isDark(this.color);
      if ((this.type === 2 || this.type === 3) && this.colorStops !== null) {
        const t = this.colorStops;
        if (this.type === 3)
          return _Brush.isDark(t.first().value);
        if (t.get(0.5) !== null)
          return _Brush.isDark(t.get(0.5));
        if (t.count === 2) {
          const l = t.toArray();
          return _Brush.isDark(_Brush.mix(l[0].value, l[1].value));
        }
        const i = t.iterator;
        let e = -1, s = -1, n = 1, o = 1;
        for (; i.next(); ) {
          const l = i.key, h = Math.abs(0.5 - i.key);
          n > o && h < n ? (e = l, n = h) : o >= n && h < o && (s = l, o = h);
        }
        if (e > s) {
          let l = e;
          e = s, s = l, l = n, n = o, o = l;
        }
        const r = s - e;
        return _Brush.isDark(_Brush.mix(t.get(e), t.get(s), 1 - o / r));
      }
      return false;
    }
    static isDark(t) {
      return t ? t instanceof _Brush ? t.isDark() : (_Brush.Bo(t), (299 * _Brush.j.n0 + 587 * _Brush.j.n1 + 114 * _Brush.j.n2) / 1e3 < 128) : false;
    }
    static gd(t, i) {
      switch (i) {
        case 1:
          return _Brush.vR(), _Brush.ho.n0 = Math.min(100, Math.max(0, _Brush.ho.n0 + 100 * t)), _Brush.qR(), "rgba(" + _Brush.j.n0 + ", " + _Brush.j.n1 + ", " + _Brush.j.n2 + ", " + _Brush.j.n3 + ")";
        case 2:
          return _Brush.UM(), _Brush.Yi.n2 = Math.min(100, Math.max(0, _Brush.Yi.n2 + 100 * t)), "hsla(" + _Brush.Yi.n0 + ", " + _Brush.Yi.n1 + "%, " + _Brush.Yi.n2 + "%, " + _Brush.Yi.n3 + ")";
        case 3:
          return _Brush.WR(), _Brush.ao.n0 = Math.min(100, Math.max(0, _Brush.ao.n0 + 100 * t)), _Brush.jR(), "rgba(" + _Brush.j.n0 + ", " + _Brush.j.n1 + ", " + _Brush.j.n2 + ", " + _Brush.j.n3 + ")";
        default:
          Util.n("Unknown color space: " + i);
      }
    }
    static Bo(t) {
      const i = _Brush.al;
      if (i === null)
        return;
      i.clearRect(0, 0, 1, 1), i.fillStyle = "#000000";
      const e = i.fillStyle;
      if (i.fillStyle = t, i.fillStyle !== e) {
        i.fillRect(0, 0, 1, 1);
        const s = i.getImageData(0, 0, 1, 1).data;
        _Brush.j.n0 = s[0], _Brush.j.n1 = s[1], _Brush.j.n2 = s[2], _Brush.j.n3 = s[3] / 255;
      } else {
        i.fillStyle = "#FFFFFF";
        const s = i.fillStyle;
        i.fillStyle = t, i.fillStyle === s && Debug && Util.n('Color "' + t + '" is not a valid color string for RGBA color conversion'), _Brush.j.n0 = 0, _Brush.j.n1 = 0, _Brush.j.n2 = 0, _Brush.j.n3 = 1;
      }
    }
    static UM() {
      const t = _Brush.j.n0 / 255, i = _Brush.j.n1 / 255, e = _Brush.j.n2 / 255, s = Math.max(t, i, e), n = Math.min(t, i, e), o = s - n;
      let r, l;
      const h = (s + n) / 2;
      if (o === 0)
        r = l = 0;
      else {
        switch (s) {
          case t:
            r = (i - e) / o % 6;
            break;
          case i:
            r = (e - t) / o + 2;
            break;
          case e:
            r = (t - i) / o + 4;
            break;
        }
        r *= 60, r < 0 && (r += 360), l = o / (1 - Math.abs(2 * h - 1));
      }
      _Brush.Yi.n0 = Math.round(r), _Brush.Yi.n1 = Math.round(l * 100), _Brush.Yi.n2 = Math.round(h * 100), _Brush.Yi.n3 = _Brush.j.n3;
    }
    static dE() {
      const t = _Brush.Yi.n0, i = _Brush.Yi.n1 / 100, e = _Brush.Yi.n2 / 100;
      let s, n, o;
      const r = (1 - Math.abs(2 * e - 1)) * i, l = t / 60, h = r * (1 - Math.abs(l % 2 - 1));
      l >= 0 && l < 1 ? (s = r, n = h, o = 0) : l >= 1 && l < 2 ? (s = h, n = r, o = 0) : l >= 2 && l < 3 ? (s = 0, n = r, o = h) : l >= 3 && l < 4 ? (s = 0, n = h, o = r) : l >= 4 && l < 5 ? (s = h, n = 0, o = r) : l >= 5 && l < 6 && (s = r, n = 0, o = h);
      const a = e - 0.5 * r;
      s += a, n += a, o += a, _Brush.j.n0 = Math.round(s * 255), _Brush.j.n1 = Math.round(n * 255), _Brush.j.n2 = Math.round(o * 255), _Brush.j.n3 = _Brush.Yi.n3;
    }
    static vR() {
      _Brush.mL(), _Brush.JR();
    }
    static qR() {
      _Brush.ZR(), _Brush.pL();
    }
    static C2(t) {
      return t /= 255, t <= 0.04045 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
    }
    static A2(t) {
      return t <= 31308e-7 ? t * 12.92 : 1.055 * Math.pow(t, 1 / 2.4) - 0.055;
    }
    static mL() {
      const t = _Brush.C2(_Brush.j.n0), i = _Brush.C2(_Brush.j.n1), e = _Brush.C2(_Brush.j.n2);
      _Brush.zt.n0 = 0.4124564 * t + 0.3575761 * i + 0.1804375 * e, _Brush.zt.n1 = 0.2126729 * t + 0.7151522 * i + 0.072175 * e, _Brush.zt.n2 = 0.0193339 * t + 0.119192 * i + 0.9503041 * e, _Brush.zt.n3 = _Brush.j.n3;
    }
    static pL() {
      const t = 3.2404542 * _Brush.zt.n0 + -1.5371385 * _Brush.zt.n1 + -0.4985314 * _Brush.zt.n2, i = -0.969266 * _Brush.zt.n0 + 1.8760108 * _Brush.zt.n1 + 0.041556 * _Brush.zt.n2, e = 0.0556434 * _Brush.zt.n0 + -0.2040259 * _Brush.zt.n1 + 1.0572252 * _Brush.zt.n2;
      _Brush.j.n0 = _Brush.A2(t) * 255, _Brush.j.n1 = _Brush.A2(i) * 255, _Brush.j.n2 = _Brush.A2(e) * 255, _Brush.j.n3 = _Brush.zt.n3, _Brush.j.n0 = Math.round(_Brush.j.n0), _Brush.j.n0 > 255 ? _Brush.j.n0 = 255 : _Brush.j.n0 < 0 && (_Brush.j.n0 = 0), _Brush.j.n1 = Math.round(_Brush.j.n1), _Brush.j.n1 > 255 ? _Brush.j.n1 = 255 : _Brush.j.n1 < 0 && (_Brush.j.n1 = 0), _Brush.j.n2 = Math.round(_Brush.j.n2), _Brush.j.n2 > 255 ? _Brush.j.n2 = 255 : _Brush.j.n2 < 0 && (_Brush.j.n2 = 0);
    }
    static T2(t) {
      return t > _Brush.L2 ? Math.pow(t, 1 / 3) : (_Brush.tb * t + 16) / 116;
    }
    static JR() {
      const t = _Brush.T2(_Brush.zt.n0 * 100 / _Brush.md[0]), i = _Brush.T2(_Brush.zt.n1 * 100 / _Brush.md[1]), e = _Brush.T2(_Brush.zt.n2 * 100 / _Brush.md[2]);
      _Brush.ho.n0 = 116 * i - 16, _Brush.ho.n1 = 500 * (t - i), _Brush.ho.n2 = 200 * (i - e), _Brush.ho.n3 = _Brush.zt.n3;
    }
    static yL(t) {
      const i = t * t * t;
      return i > _Brush.L2 ? i : (116 * t - 16) / _Brush.tb;
    }
    static ZR() {
      const t = (_Brush.ho.n0 + 16) / 116, i = _Brush.ho.n1 / 500 + t, e = t - _Brush.ho.n2 / 200;
      _Brush.zt.n0 = _Brush.md[0] / 100 * _Brush.yL(i), _Brush.zt.n1 = _Brush.md[1] / 100 * (_Brush.ho.n0 > _Brush.tb * _Brush.L2 ? Math.pow(t, 3) : _Brush.ho.n0 / _Brush.tb), _Brush.zt.n2 = _Brush.md[2] / 100 * _Brush.yL(e), _Brush.zt.n3 = _Brush.ho.n3;
    }
    static $R() {
      let t = 0.8190224 * _Brush.zt.n0 + 0.3619062 * _Brush.zt.n1 + -0.1288737 * _Brush.zt.n2, i = 0.03298366 * _Brush.zt.n0 + 0.9292868 * _Brush.zt.n1 + 0.03614466 * _Brush.zt.n2, e = 0.04817719 * _Brush.zt.n0 + 0.2642395 * _Brush.zt.n1 + 0.6335478 * _Brush.zt.n2;
      t = Math.cbrt(t), i = Math.cbrt(i), e = Math.cbrt(e), _Brush.mi.n0 = 0.2104542 * t + 0.7936177 * i + -4072046e-9 * e, _Brush.mi.n1 = 1.977998 * t + -2.428592 * i + 0.4505937 * e, _Brush.mi.n2 = 0.02590403 * t + 0.7827717 * i + -0.8086757 * e, _Brush.mi.n3 = _Brush.zt.n3, _Brush.mi.n0 *= 100;
    }
    static QR() {
      _Brush.mi.n0 /= 100;
      let t = 0.9999999 * _Brush.mi.n0 + 0.3963377 * _Brush.mi.n1 + 0.2158037 * _Brush.mi.n2, i = 1.000000009 * _Brush.mi.n0 + -0.1055613 * _Brush.mi.n1 + -0.06385417 * _Brush.mi.n2, e = 1.00000005 * _Brush.mi.n0 + -0.08948418 * _Brush.mi.n1 + -1.291485 * _Brush.mi.n2;
      t = t ** 3, i = i ** 3, e = e ** 3, _Brush.zt.n0 = 1.2268798 * t + -0.5578149 * i + 0.281391 * e, _Brush.zt.n1 = -0.04057576 * t + 1.112286 * i + -0.07171106 * e, _Brush.zt.n2 = -0.07637294 * t + -0.4214933 * i + 1.586924 * e, _Brush.zt.n3 = _Brush.mi.n3;
    }
    static _R() {
      const t = Math.atan2(_Brush.mi.n2, _Brush.mi.n1) * 180 / Math.PI;
      _Brush.ao.n0 = _Brush.mi.n0, _Brush.ao.n1 = Math.sqrt(_Brush.mi.n1 ** 2 + _Brush.mi.n2 ** 2), _Brush.ao.n2 = t >= 0 ? t : t + 360, _Brush.ao.n3 = _Brush.mi.n3;
    }
    static tI() {
      _Brush.mi.n0 = _Brush.ao.n0, _Brush.mi.n1 = _Brush.ao.n1 * Math.cos(_Brush.ao.n2 * Math.PI / 180), _Brush.mi.n2 = _Brush.ao.n1 * Math.sin(_Brush.ao.n2 * Math.PI / 180), _Brush.mi.n3 = _Brush.ao.n3;
    }
    static WR() {
      _Brush.mL(), _Brush.$R(), _Brush._R();
    }
    static jR() {
      _Brush.tI(), _Brush.QR(), _Brush.pL();
    }
    static ud(t, i) {
      typeof t == "string" ? Debug && !_Brush.isValidColor(t) && Util.n('Color "' + t + '" is not a valid color string for ' + i) : t instanceof _Brush || Util.n("Value for " + i + " must be a color string or a Brush, not " + t);
    }
  };
  __publicField(_Brush, "L2", 216 / 24389);
  __publicField(_Brush, "tb", 24389 / 27);
  __publicField(_Brush, "md", [95.047, 100, 108.883]);
  __publicField(_Brush, "Solid", 1);
  __publicField(_Brush, "Linear", 2);
  __publicField(_Brush, "Radial", 3);
  __publicField(_Brush, "Pattern", 4);
  __publicField(_Brush, "Lab", 1);
  __publicField(_Brush, "HSL", 2);
  __publicField(_Brush, "al", Diagram2.isUsingDOM() ? new CanvasSurface(null, void 0, { willReadFrequently: true }).gi : null);
  __publicField(_Brush, "j", new ColorNumbers());
  __publicField(_Brush, "Yi", new ColorNumbers());
  __publicField(_Brush, "zt", new ColorNumbers());
  __publicField(_Brush, "ho", new ColorNumbers());
  __publicField(_Brush, "mi", new ColorNumbers());
  __publicField(_Brush, "ao", new ColorNumbers());
  let Brush2 = _Brush;
  const _PanelLayout = class _PanelLayout {
    constructor() {
      __publicField(this, "Tt", "Base");
    }
    static definePanelLayout(t, i) {
      i.name = t, _PanelLayout.Layouts.add(t, i);
    }
    get name() {
      return this.Tt;
    }
    set name(t) {
      this.Tt = t;
    }
    get classType() {
      return Panel2;
    }
    measure(t, i, e, s, n, o, r) {
    }
    measureElement(t, i, e, s, n) {
      t.wt(i, e, s, n);
    }
    arrange(t, i, e) {
    }
    arrangeElement(t, i, e, s, n, o) {
      t.vt(i, e, s, n, o);
    }
    remeasureObject(t) {
      t.oc();
    }
    Ji(t, i, e) {
    }
  };
  __publicField(_PanelLayout, "Layouts", new GMap2());
  let PanelLayout2 = _PanelLayout;
  class PanelLayoutPosition extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = s.length, h = t.Jo();
      for (let a = 0; a < l; a++) {
        const f = s[a];
        if (!f.visible && f !== h)
          continue;
        const c = f.margin, u = c.right + c.left, d = c.top + c.bottom;
        f.wt(i, e, o, r);
        const m = f.measuredBounds, g = Math.max(m.width + u, 0), p = Math.max(m.height + d, 0);
        let y = f.position.x, x = f.position.y;
        if (isFinite(y) || (y = 0), isFinite(x) || (x = 0), f instanceof Shape2 && f.isGeometryPositioned) {
          const b = f.strokeWidth / 2;
          y -= b, x -= b;
        }
        n.unionNoCheck(y, x, g, p);
      }
    }
    arrange(t, i, e) {
      const s = i.length, n = t.padding, o = e.x - n.left, r = e.y - n.top;
      for (let l = 0; l < s; l++) {
        const h = i[l], a = h.measuredBounds, f = h.margin, c = h.position.x, u = h.position.y;
        let d = isNaN(c) ? -o : c - o, m = isNaN(u) ? -r : u - r;
        if (h instanceof Shape2 && h.isGeometryPositioned) {
          const g = h.strokeWidth / 2;
          d -= g, m -= g;
        }
        h.visible && h.vt(d + f.left, m + f.top, a.width, a.height);
      }
    }
  }
  PanelLayout2.definePanelLayout("Position", new PanelLayoutPosition());
  class PanelLayoutHorizontal extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = s.length, h = Util.ct(), a = t.Jo();
      for (let c = 0; c < l; c++) {
        const u = s[c];
        if (!u.visible && u !== a)
          continue;
        const d = u.qs(false);
        if (d !== 0 && d !== 5) {
          h.push(u);
          continue;
        }
        u.wt(1 / 0, e, 0, r);
        const m = u.margin, g = u.measuredBounds, p = Math.max(g.width + m.right + m.left, 0), y = Math.max(g.height + m.top + m.bottom, 0);
        n.width += p, n.height = Math.max(n.height, y);
      }
      const f = h.length;
      t.desiredSize.height ? e = Math.min(t.desiredSize.height, t.maxSize.height) : n.height !== 0 && (e = Math.min(n.height, t.maxSize.height));
      for (let c = 0; c < f; c++) {
        const u = h[c];
        if (!u.visible && u !== a)
          continue;
        const d = u.margin, m = d.right + d.left, g = d.top + d.bottom;
        u.wt(1 / 0, e, 0, r);
        const p = u.measuredBounds, y = Math.max(p.width + m, 0), x = Math.max(p.height + g, 0);
        n.width += y, n.height = Math.max(n.height, x);
      }
      Util.ot(h);
    }
    arrange(t, i, e) {
      const s = i.length, n = t.padding, o = n.top, r = t.isOpposite;
      let l = r ? e.width : n.left;
      for (let h = 0; h < s; h++) {
        const a = o, f = i[h];
        if (!f.visible)
          continue;
        const c = f.measuredBounds, u = f.margin, d = u.top + u.bottom, m = o + n.bottom;
        let g = c.height;
        const p = f.qs(false);
        (isNaN(f.desiredSize.height) && p === 2 || p === 4) && (g = Math.max(e.height - d - m, 0));
        const y = g + d + m;
        let x = f.alignment;
        x.isDefault() && (x = t.defaultAlignment), x.isSpot() || (x = Spot2.Center), r && (l -= c.width + u.left + u.right), f.vt(l + x.offsetX + u.left, a + x.offsetY + u.top + (e.height * x.y - y * x.y), c.width, g), r || (l += c.width + u.left + u.right);
      }
    }
  }
  PanelLayout2.definePanelLayout("Horizontal", new PanelLayoutHorizontal());
  class PanelLayoutVertical extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = s.length, h = Util.ct(), a = t.Jo();
      for (let c = 0; c < l; c++) {
        const u = s[c];
        if (!u.visible && u !== a)
          continue;
        const d = u.qs(false);
        if (d !== 0 && d !== 4) {
          h.push(u);
          continue;
        }
        const m = u.margin, g = m.right + m.left, p = m.top + m.bottom;
        u.wt(i, 1 / 0, o, 0);
        const y = u.measuredBounds, x = Math.max(y.width + g, 0), b = Math.max(y.height + p, 0);
        n.Do(Math.max(n.width, x), n.height + b);
      }
      const f = h.length;
      if (f !== 0) {
        t.desiredSize.width ? i = Math.min(t.desiredSize.width, t.maxSize.width) : n.width !== 0 && (i = Math.min(n.width, t.maxSize.width));
        for (let c = 0; c < f; c++) {
          const u = h[c];
          if (!u.visible && u !== a)
            continue;
          const d = u.margin, m = d.right + d.left, g = d.top + d.bottom;
          u.wt(i, 1 / 0, o, 0);
          const p = u.measuredBounds, y = Math.max(p.width + m, 0), x = Math.max(p.height + g, 0);
          n.width = Math.max(n.width, y), n.height += x;
        }
        Util.ot(h);
      }
    }
    arrange(t, i, e) {
      const s = i.length, n = t.padding, o = n.left, r = t.isOpposite;
      let l = r ? e.height : n.top;
      for (let h = 0; h < s; h++) {
        const a = o, f = i[h];
        if (!f.visible)
          continue;
        const c = f.measuredBounds, u = f.margin, d = u.left + u.right, m = o + n.right;
        let g = c.width;
        const p = f.qs(false);
        (isNaN(f.desiredSize.width) && p === 2 || p === 5) && (g = Math.max(e.width - d - m, 0));
        const y = g + d + m;
        let x = f.alignment;
        x.isDefault() && (x = t.defaultAlignment), x.isSpot() || (x = Spot2.Center), r && (l -= c.height + u.bottom + u.top), f.vt(a + x.offsetX + u.left + (e.width * x.x - y * x.x), l + x.offsetY + u.top, g, c.height), r || (l += c.height + u.bottom + u.top);
      }
    }
  }
  PanelLayout2.definePanelLayout("Vertical", new PanelLayoutVertical());
  class PanelLayoutSpot extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = s.length;
      if (l === 0)
        return;
      const h = t.findMainElement();
      let a = h.margin, f = 0, c = 0;
      const u = a.right + a.left, d = a.top + a.bottom;
      h.wt(i, e, o, r);
      let m = h.measuredBounds, g = m.width, p = m.height, y = Math.max(g + u, 0), x = Math.max(p + d, 0);
      const b = t.isClipping, k = Rect2.H(-a.left, -a.top, y, x);
      let S = Rect2.H(0, 0, g, p);
      this.D2(h, S, true), g = S.width, p = S.height;
      let M = true;
      const A = t.Jo();
      let C;
      for (let P = 0; P < l; P++) {
        const N = s[P];
        let T = i, L = e;
        if (N === h || !N.visible && N !== A)
          continue;
        a = N.margin;
        let D = a.left, F = a.top;
        switch (f = a.right + a.left, c = a.top + a.bottom, C = N.qs(false), C) {
          case 2:
            T = g, L = p, f = 0, c = 0, D = 0, F = 0;
            break;
          case 5:
            T = g, f = 0, D = 0;
            break;
          case 4:
            L = p, c = 0, F = 0;
            break;
        }
        N.wt(T, L, 0, 0), m = N.measuredBounds, y = Math.max(m.width + f, 0), x = Math.max(m.height + c, 0);
        let R = N.alignment;
        R.isDefault() && (R = t.defaultAlignment), R.isSpot() || (R = Spot2.Center);
        let I = N.alignmentFocus;
        I.isDefault() && (I = Spot2.Center);
        let O = null;
        N instanceof Panel2 && N.fo !== "" && (O = N.findObject(N.fo), O === N && (O = null));
        let B = S.x - D, K = S.y - F;
        if (O !== null) {
          N.vt(0, 0, m.width, m.height);
          const V = O.actualBounds, X = Point2.H(V.x + (I.x * V.width - I.offsetX), V.y + (I.y * V.height - I.offsetY));
          for (O = O.panel; O !== N; )
            O.D.Pt(X), O = O.panel;
          B += R.x * g + R.offsetX - X.x, K += R.y * p + R.offsetY - X.y, Point2.o(X);
        } else
          B += R.x * g + R.offsetX - (I.x * m.width + I.offsetX), K += R.y * p + R.offsetY - (I.y * m.height + I.offsetY);
        M ? (M = false, n.e(B, K, y, x)) : n.unionNoCheck(B, K, y, x);
      }
      switch (M ? n.c(k) : b ? n.intersect(S.x, S.y, S.width, S.height) : n.unionNoCheck(k.x, k.y, k.width, k.height), Rect2.o(k), Rect2.o(S), C = h.stretch, C === 1 && (C = h.qs(false)), C) {
        case 0:
          return;
        case 2:
          if (!isFinite(i) && !isFinite(e))
            return;
          break;
        case 5:
          if (!isFinite(i))
            return;
          break;
        case 4:
          if (!isFinite(e))
            return;
          break;
      }
      m = h.measuredBounds, g = m.width, p = m.height, y = Math.max(g + u, 0), x = Math.max(p + d, 0), a = h.margin, S = Rect2.H(-a.left, -a.top, y, x), this.D2(h, S, true), g = S.width, p = S.height;
      for (let P = 0; P < l; P++) {
        const N = s[P];
        if (N === h || !N.visible && N !== A)
          continue;
        a = N.margin, f = a.right + a.left, c = a.top + a.bottom, m = N.measuredBounds, y = Math.max(m.width + f, 0), x = Math.max(m.height + c, 0);
        let T = N.alignment;
        T.isDefault() && (T = t.defaultAlignment), T.isSpot() || (T = Spot2.Center);
        let L = N.alignmentFocus;
        L.isDefault() && (L = Spot2.Center), M ? (M = false, n.e(T.x * g + T.offsetX - (L.x * m.width + L.offsetX) - a.left, T.y * p + T.offsetY - (L.y * m.height + L.offsetY) - a.top, y, x)) : n.unionNoCheck(T.x * g + T.offsetX - (L.x * m.width + L.offsetX) - a.left, T.y * p + T.offsetY - (L.y * m.height + L.offsetY) - a.top, y, x);
      }
      M ? n.c(k) : b ? n.intersect(S.x, S.y, S.width, S.height) : n.unionNoCheck(k.x, k.y, k.width, k.height), Rect2.o(S);
    }
    arrange(t, i, e) {
      const s = i.length;
      if (s === 0)
        return;
      const n = t.findMainElement(), o = n.measuredBounds, r = o.width, l = o.height, h = t.padding, a = h.left, f = h.top;
      let c = a - e.x, u = f - e.y;
      n.vt(c, u, r, l);
      const d = Rect2.H(0, 0, r, l);
      this.D2(n, d, false);
      for (let m = 0; m < s; m++) {
        const g = i[m];
        if (g === n)
          continue;
        const p = g.measuredBounds, y = p.width, x = p.height;
        let b = g.alignment;
        b.isDefault() && (b = t.defaultAlignment), b.isSpot() || (b = Spot2.Center);
        let k = g.alignmentFocus;
        k.isDefault() && (k = Spot2.Center);
        let S = null;
        if (g instanceof Panel2 && g.fo !== "" && (S = g.findObject(g.fo), S === g && (S = null)), S !== null) {
          const M = S.actualBounds, A = Point2.H(M.x + (k.x * M.width - k.offsetX), M.y + (k.y * M.height - k.offsetY));
          for (S = S.panel; S !== g; )
            S.D.Pt(A), S = S.panel;
          c = b.x * d.width + b.offsetX - A.x, u = b.y * d.height + b.offsetY - A.y, Point2.o(A);
        } else
          c = b.x * d.width + b.offsetX - (k.x * y + k.offsetX), u = b.y * d.height + b.offsetY - (k.y * x + k.offsetY);
        c += d.x - e.x, u += d.y - e.y, g.visible && g.vt(a + c, f + u, y, x);
      }
      Rect2.o(d);
    }
    D2(t, i, e) {
      let s = null;
      if (t instanceof Panel2 && t.fo !== "" && (s = t.findObject(t.fo), s === t && (s = null)), s !== null)
        for (e && t.vt(0, 0, i.width, i.height), i.c(s.actualBounds), s = s.panel; s !== t; )
          s.D.Nw(i), s = s.panel;
    }
  }
  PanelLayout2.definePanelLayout("Spot", new PanelLayoutSpot());
  class PanelLayoutAuto extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = s.length;
      if (l === 0)
        return;
      const h = t.findMainElement();
      let a = h.margin, f = i, c = e;
      const u = a.right + a.left, d = a.top + a.bottom;
      h.wt(i, e, o, r);
      let m = h.measuredBounds, g = 0, p = null;
      h instanceof Shape2 && (p = h, g = p.strokeWidth * p.scale);
      let y = Math.max(m.width + u, 0), x = Math.max(m.height + d, 0), b = t.F2(h);
      const k = b.x * y + b.offsetX, S = b.y * x + b.offsetY;
      let M = t.R2(h);
      const A = M.x * y + M.offsetX, C = M.y * x + M.offsetY;
      isFinite(i) && (f = Math.max(Math.abs(k - A) - g, 0)), isFinite(e) && (c = Math.max(Math.abs(S - C) - g, 0));
      let P = 0, N = 0;
      o > 0 && (P = Math.max(Math.abs(b.x * o + b.offsetX - (M.x * o + M.offsetX)) - g, 0)), r > 0 && (N = Math.max(Math.abs(b.y * r + b.offsetY - (M.y * r + M.offsetY)) - g, 0));
      const T = Size2.a();
      T.e(0, 0);
      const L = t.Jo();
      for (let I = 0; I < l; I++) {
        const O = s[I];
        if (O === h || !O.visible && O !== L)
          continue;
        a = O.margin;
        const B = a.right + a.left, K = a.top + a.bottom;
        O.wt(f, c, P, N), m = O.measuredBounds, y = Math.max(m.width + B, 0), x = Math.max(m.height + K, 0), T.e(Math.max(y, T.width), Math.max(x, T.height));
      }
      if (l === 1) {
        m = h.measuredBounds, n.width = y, n.height = x, Size2.o(T);
        return;
      }
      b = t.F2(h), M = t.R2(h);
      let D = 0, F = 0;
      M.x !== b.x && M.y !== b.y && (D = T.width / Math.abs(M.x - b.x), F = T.height / Math.abs(M.y - b.y)), Size2.o(T), g = 0, p !== null && (g = p.strokeWidth * p.scale, p.lM() === 6 && (D = F = Math.max(D, F))), D += Math.abs(b.offsetX) + Math.abs(M.offsetX) + g, F += Math.abs(b.offsetY) + Math.abs(M.offsetY) + g;
      let R = h.stretch;
      switch (R === 1 && (R = h.qs(false)), R) {
        case 0:
          o = 0, r = 0;
          break;
        case 2:
          isFinite(i) && (D = i), isFinite(e) && (F = e);
          break;
        case 5:
          isFinite(i) && (D = i), r = 0;
          break;
        case 4:
          o = 0, isFinite(e) && (F = e);
          break;
      }
      h.oc(), h.wt(D, F, o, r), n.width = h.measuredBounds.width + u, n.height = h.measuredBounds.height + d;
    }
    arrange(t, i, e) {
      const s = i.length;
      if (s === 0)
        return;
      const n = t.findMainElement(), o = n.measuredBounds, r = Rect2.a();
      r.e(0, 0, 1, 1);
      let l = n.margin;
      const h = l.left, a = l.top, f = t.padding, c = f.left, u = f.top;
      let d = h, m = a, g = o.width, p = o.height;
      n.vt(c + d, u + m, g, p);
      const y = t.F2(n), x = t.R2(n), b = 0 + y.x * o.width + y.offsetX, k = 0 + y.y * o.height + y.offsetY, S = 0 + x.x * o.width + x.offsetX, M = 0 + x.y * o.height + x.offsetY;
      r.x = b, r.y = k, r.unionNoCheck(S, M, 0, 0), r.x += h + c, r.y += a + u;
      for (let A = 0; A < s; A++) {
        const C = i[A];
        if (C === n)
          continue;
        const P = C.measuredBounds;
        l = C.margin;
        const N = Math.max(P.width + l.right + l.left, 0), T = Math.max(P.height + l.top + l.bottom, 0);
        let L = C.alignment;
        L.isDefault() && (L = t.defaultAlignment), L.isSpot() || (L = Spot2.Center), d = r.width * L.x + L.offsetX - N * L.x + l.left + r.x, m = r.height * L.y + L.offsetY - T * L.y + l.top + r.y, g = r.width, p = r.height, C.visible && (Rect2.contains(r.x, r.y, r.width, r.height, d, m, P.width, P.height) ? C.vt(d, m, P.width, P.height) : C.vt(d, m, P.width, P.height, new Rect2(r.x, r.y, r.width, r.height)));
      }
      Rect2.o(r);
    }
  }
  PanelLayout2.definePanelLayout("Auto", new PanelLayoutAuto());
  class PanelLayoutTable extends PanelLayout2 {
    constructor() {
      super(), this.name = "Table";
    }
    measure(t, i, e, s, n, o, r) {
      let l = s.length;
      const h = Util.ct(), a = Util.ct();
      for (let U = 0; U < l; U++) {
        const E = s[U], H = E instanceof Panel2 ? E : null;
        if (H !== null && H.ll() && E.visible) {
          Debug && (H.desiredSize.isReal() && Util.n(H.toString() + " TableRow/TableColumn Panels cannot set a desiredSize: " + H.desiredSize.toString()), H.minSize.equals(Size2.lf) || Util.n(H.toString() + " TableRow/TableColumn Panels cannot set a minSize: " + H.minSize.toString()), H.maxSize.equals(Size2.zk) || Util.n(H.toString() + " TableRow/TableColumn Panels cannot set a maxSize: " + H.maxSize.toString())), a.push(H);
          const Z = H.F.h, et = Z.length;
          for (let _ = 0; _ < et; _++) {
            const tt = Z[_];
            H.type === Panel2.TableRow ? tt.row = E.row : H.type === Panel2.TableColumn && (tt.column = E.column), h.push(tt);
          }
        } else
          h.push(E);
      }
      l = h.length, l === 0 && (t.getRowDefinition(0), t.getColumnDefinition(0));
      const f = [];
      for (let U = 0; U < l; U++) {
        const E = h[U];
        E.visible && (E.ae(true), E.ro(true), f[E.row] || (f[E.row] = []), f[E.row][E.column] || (f[E.row][E.column] = []), f[E.row][E.column].push(E));
      }
      Util.ot(h);
      const c = Util.ct(), u = Util.ct(), d = Util.ct(), m = { count: 0 }, g = { count: 0 };
      let p = i, y = e;
      const x = t.Ze, b = t.$e;
      let k = null;
      l = x.length;
      for (let U = 0; U < l; U++)
        k = x[U], k !== void 0 && (k.actual = 0);
      l = b.length;
      for (let U = 0; U < l; U++)
        k = b[U], k !== void 0 && (k.actual = 0);
      let S = f.length, M = 0;
      for (let U = 0; U < S; U++)
        f[U] && (M = Math.max(M, f[U].length));
      const A = Math.min(t.topIndex, S - 1), C = Math.min(t.leftIndex, M - 1);
      let P = 0, N;
      S = f.length;
      const T = t.Jo();
      for (let U = 0; U < S; U++) {
        if (!f[U])
          continue;
        M = f[U].length;
        const E = t.getRowDefinition(U);
        E.actual = 0, E.Zi = 0;
        for (let H = 0; H < M; H++) {
          if (!f[U][H])
            continue;
          const Z = t.getColumnDefinition(H);
          c[H] === void 0 && (Z.actual = 0, Z.Zi = 0, c[H] = true);
          const et = f[U][H], _ = et.length;
          for (let tt = 0; tt < _; tt++) {
            const it = et[tt];
            if (!it.visible && it !== T)
              continue;
            const ft = it.rowSpan > 1, ot = it.columnSpan > 1;
            (ft || ot) && !(U < A) && !(H < C) && u.push(it);
            const lt = it.margin, st = lt.right + lt.left, nt = lt.top + lt.bottom;
            N = it.F0(E, Z, false);
            const ht = it.desiredSize, $ = !isNaN(ht.width), ct = !isNaN(ht.height);
            if (N !== 0 && !($ && ct) && !(U < A) && !(H < C) && (!ot && m[H] === void 0 && (N === 2 || N === 5) && (m[H] = -1, m.count++), !ft && g[U] === void 0 && (N === 2 || N === 4) && (g[U] = -1, g.count++), !ft && !ot && d.push(it)), it.wt(1 / 0, 1 / 0, 0, 0), U < A || H < C)
              continue;
            const at = it.measuredBounds, ut = Math.max(at.width + st, 0), dt = Math.max(at.height + nt, 0);
            if (it.rowSpan === 1 && (N === 0 || N === 5)) {
              k = t.getRowDefinition(U);
              const gt = k.computeEffectiveSpacing(), mt = k.at === 0;
              P = Math.max(dt - k.actual, 0), P + (mt ? gt : 0) > y && (P = Math.max(y - gt, 0)), k.Zi = k.Zi + P, k.actual = k.at + P, y = Math.max(y - (P + (mt ? gt : 0)), 0);
            }
            if (it.columnSpan === 1 && (N === 0 || N === 4)) {
              k = t.getColumnDefinition(H);
              const gt = k.computeEffectiveSpacing(), mt = k.at === 0;
              P = Math.max(ut - k.actual, 0), P + (mt ? gt : 0) > p && (P = Math.max(p - gt, 0)), k.Zi = k.Zi + P, k.actual = k.at + P, p = Math.max(p - (P + (mt ? gt : 0)), 0);
            }
            (ft || ot) && it.oc();
          }
        }
      }
      Util.ot(c);
      let L = 0, D = 0;
      l = t.columnCount;
      for (let U = 0; U < l; U++) {
        const E = b[U];
        E !== void 0 && (L += isNaN(E.ke) ? E.Zi : E.ke, E.Zi !== 0 && (L += E.computeEffectiveSpacing()));
      }
      l = t.rowCount;
      for (let U = 0; U < l; U++) {
        const E = x[U];
        E !== void 0 && (D += isNaN(E.ke) ? E.Zi : E.ke, E.Zi !== 0 && (D += E.computeEffectiveSpacing()));
      }
      p = Math.max(i - L, 0), y = Math.max(e - D, 0);
      let F = y, R = p;
      l = d.length;
      for (let U = 0; U < l; U++) {
        const E = d[U], H = t.getRowDefinition(E.row), Z = t.getColumnDefinition(E.column), et = E.measuredBounds, _ = E.margin, tt = _.right + _.left, it = _.top + _.bottom;
        Z.Zi === 0 && m[E.column] !== void 0 ? m[E.column] = Math.max(et.width + tt, m[E.column]) : m[E.column] = null, H.Zi === 0 && g[E.row] !== void 0 ? g[E.row] = Math.max(et.height + it, g[E.row]) : g[E.row] = null;
      }
      let I = 0, O = 0, B;
      for (B in g)
        B !== "count" && (I += g[B]);
      for (B in m)
        B !== "count" && (O += m[B]);
      const K = Size2.a();
      for (let U = 0; U < l; U++) {
        const E = d[U];
        if (!E.visible && E !== T)
          continue;
        const H = t.getRowDefinition(E.row), Z = t.getColumnDefinition(E.column);
        let et = 0;
        isFinite(Z.width) ? et = Z.width : (isFinite(p) && m[E.column] !== null ? O === 0 ? et = Z.actual + p : et = m[E.column] / O * R : m[E.column] !== null ? et = p : et = Z.actual || p, et = Math.max(0, et - Z.computeEffectiveSpacing()));
        let _ = 0;
        switch (isFinite(H.height) ? _ = H.height : (isFinite(y) && g[E.row] !== null ? I === 0 ? _ = H.actual + y : _ = g[E.row] / I * F : g[E.row] !== null ? _ = y : _ = H.actual || y, _ = Math.max(0, _ - H.computeEffectiveSpacing())), K.e(Math.max(Z.minimum, Math.min(et, Z.maximum)), Math.max(H.minimum, Math.min(_, H.maximum))), N = E.F0(H, Z, false), N) {
          case 5:
            K.height = Math.max(K.height, H.actual + y);
            break;
          case 4:
            K.width = Math.max(K.width, Z.actual + p);
            break;
        }
        const tt = E.margin, it = tt.right + tt.left, ft = tt.top + tt.bottom;
        E.oc();
        let ot = Z.minimum, lt = H.minimum;
        const st = E.measuredBounds;
        st.width === 0 && m[E.column] !== null && (ot = Math.max(ot, m[E.column])), st.height === 0 && g[E.row] !== null && (lt = Math.max(ot, g[E.row])), E.wt(K.width, K.height, ot, lt);
        const nt = E.measuredBounds;
        let ht = Math.max(nt.width + it, 0), $ = Math.max(nt.height + ft, 0);
        isFinite(p) && (ht = Math.min(ht, K.width)), isFinite(y) && ($ = Math.min($, K.height));
        let ct = 0;
        ct = H.actual, H.actual = Math.max(H.actual, $), H.Zi = Math.max(H.Zi, $), P = H.actual - ct, y = Math.max(y - P, 0), g[E.row] === null && (F = Math.max(F - P, 0)), ct = Z.actual, Z.actual = Math.max(Z.actual, ht), Z.Zi = Math.max(Z.Zi, ht), P = Z.actual - ct, p = Math.max(p - P, 0), m[E.column] === null && (R = Math.max(R - P, 0));
      }
      Util.ot(d);
      const V = Size2.a(), X = Util.ct(), z = Util.ct();
      if (l = u.length, l !== 0)
        for (let U = 0; U < S; U++) {
          if (!f[U])
            continue;
          M = f[U].length;
          const E = t.getRowDefinition(U);
          X[U] = E.actual;
          for (let H = 0; H < M; H++) {
            if (!f[U][H])
              continue;
            const Z = t.getColumnDefinition(H);
            z[H] = Z.actual;
          }
        }
      for (let U = 0; U < l; U++) {
        const E = u[U];
        if (!E.visible && E !== T)
          continue;
        const H = t.getRowDefinition(E.row), Z = t.getColumnDefinition(E.column);
        switch (K.e(Math.max(Z.minimum, Math.min(i, Z.maximum)), Math.max(H.minimum, Math.min(e, H.maximum))), N = E.F0(H, Z, false), N) {
          case 2:
            z[Z.index] !== 0 && (K.width = Math.min(K.width, z[Z.index])), X[H.index] !== 0 && (K.height = Math.min(K.height, X[H.index]));
            break;
          case 5:
            z[Z.index] !== 0 && (K.width = Math.min(K.width, z[Z.index]));
            break;
          case 4:
            X[H.index] !== 0 && (K.height = Math.min(K.height, X[H.index]));
            break;
        }
        isFinite(Z.width) && (K.width = Z.width), isFinite(H.height) && (K.height = H.height), V.e(0, 0);
        let et = Z.minimum, _ = H.minimum;
        for (let $ = 1; $ < E.rowSpan && !(E.row + $ >= t.rowCount); $++)
          k = t.getRowDefinition(E.row + $), P = 0, N === 2 || N === 4 ? P = Math.max(k.minimum, X[E.row + $] === 0 ? k.maximum : Math.min(X[E.row + $], k.maximum)) : P = Math.max(k.minimum, isNaN(k.ke) ? k.maximum : Math.min(k.ke, k.maximum)), V.height += P, _ += k.minimum;
        for (let $ = 1; $ < E.columnSpan && !(E.column + $ >= t.columnCount); $++)
          k = t.getColumnDefinition(E.column + $), P = 0, N === 2 || N === 5 ? P = Math.max(k.minimum, z[E.column + $] === 0 ? k.maximum : Math.min(z[E.column + $], k.maximum)) : P = Math.max(k.minimum, isNaN(k.ke) ? k.maximum : Math.min(k.ke, k.maximum)), V.width += P, et += k.minimum;
        K.width += V.width, K.height += V.height;
        const tt = E.margin, it = tt.right + tt.left, ft = tt.top + tt.bottom;
        E.wt(K.width, K.height, et, _);
        const ot = E.measuredBounds, lt = Math.max(ot.width + it, 0), st = Math.max(ot.height + ft, 0);
        let nt = 0;
        for (let $ = 0; $ < E.rowSpan && !(E.row + $ >= t.rowCount); $++)
          k = t.getRowDefinition(E.row + $), nt += k.total || 0;
        if (nt < st) {
          let $ = st - nt;
          const ct = st - nt;
          if (E.spanAllocation !== null) {
            const rt = E.spanAllocation;
            for (let at = 0; at < E.rowSpan && !($ <= 0 || E.row + at >= t.rowCount); at++) {
              k = t.getRowDefinition(E.row + at);
              const ut = k.at || 0, dt = rt(E, k, ct);
              Debug && typeof dt != "number" && Util.n(E + " spanAllocation does not return a number: " + dt), k.actual = Math.min(k.maximum, ut + dt), k.at !== ut && ($ -= k.at - ut);
            }
          }
          for (; $ > 0; ) {
            const rt = k.at || 0;
            if (isNaN(k.height) && k.maximum > rt && (k.actual = Math.min(k.maximum, rt + $), k.at !== rt && ($ -= k.at - rt)), k.index === 0)
              break;
            k = t.getRowDefinition(k.index - 1);
          }
        }
        let ht = 0;
        for (let $ = 0; $ < E.columnSpan && !(E.column + $ >= t.columnCount); $++)
          k = t.getColumnDefinition(E.column + $), ht += k.total || 0;
        if (ht < lt) {
          let $ = lt - ht;
          const ct = lt - ht;
          if (E.spanAllocation !== null) {
            const rt = E.spanAllocation;
            for (let at = 0; at < E.columnSpan && !($ <= 0 || E.column + at >= t.columnCount); at++) {
              k = t.getColumnDefinition(E.column + at);
              const ut = k.at || 0, dt = rt(E, k, ct);
              Debug && typeof dt != "number" && Util.n(E + " spanAllocation does not return a number: " + dt), k.actual = Math.min(k.maximum, ut + dt), k.at !== ut && ($ -= k.at - ut);
            }
          }
          for (; $ > 0; ) {
            const rt = k.at || 0;
            if (isNaN(k.width) && k.maximum > rt && (k.actual = Math.min(k.maximum, rt + $), k.at !== rt && ($ -= k.at - rt)), k.index === 0)
              break;
            k = t.getColumnDefinition(k.index - 1);
          }
        }
      }
      Util.ot(u), Size2.o(V), Size2.o(K), X !== void 0 && Util.ot(X), z !== void 0 && Util.ot(z);
      let G = 0, v = 0;
      const q = t.desiredSize, J = t.maxSize;
      N = t.qs(true), L = 0, D = 0;
      let Y = 0, j = 0;
      l = t.columnCount;
      for (let U = 0; U < l; U++)
        if (b[U] !== void 0) {
          if (k = t.getColumnDefinition(U), isFinite(k.width)) {
            Y += k.width, Y += k.computeEffectiveSpacing();
            continue;
          } else if (k.ib() === 2) {
            Y += k.at, Y += k.computeEffectiveSpacing();
            continue;
          }
          k.at !== 0 && (L += k.at, L += k.computeEffectiveSpacing());
        }
      isFinite(q.width) ? G = Math.min(q.width, J.width) : N !== 0 && isFinite(i) ? G = i : G = L, G = Math.max(G, isFinite(i) ? Math.min(o, i) : o), G = Math.max(G - Y, 0);
      const W = L === 0 ? 1 : Math.max(G / L, 1);
      for (let U = 0; U < l; U++)
        b[U] !== void 0 && (k = t.getColumnDefinition(U), !isFinite(k.width) && k.ib() !== 2 && (k.actual = k.at * W), k.position = n.width, k.at !== 0 && (n.width += k.at, n.width += k.computeEffectiveSpacing()));
      l = t.rowCount;
      for (let U = 0; U < l; U++)
        if (x[U] !== void 0) {
          if (k = t.getRowDefinition(U), isFinite(k.height)) {
            j += k.height, j += k.computeEffectiveSpacing();
            continue;
          } else if (k.ib() === 2) {
            j += k.at, j += k.computeEffectiveSpacing();
            continue;
          }
          k.at !== 0 && (D += k.at, D += k.computeEffectiveSpacing());
        }
      isFinite(q.height) ? v = Math.min(q.height, J.height) : N !== 0 && isFinite(e) ? v = e : v = D, v = Math.max(v, isFinite(e) ? Math.min(r, e) : r), v = Math.max(v - j, 0);
      const Q = D === 0 ? 1 : Math.max(v / D, 1);
      for (let U = 0; U < l; U++)
        x[U] !== void 0 && (k = t.getRowDefinition(U), !isFinite(k.height) && k.ib() !== 2 && (k.actual = k.at * Q), k.position = n.height, k.at !== 0 && (n.height += k.at, n.height += k.computeEffectiveSpacing()));
      l = a.length;
      for (let U = 0; U < l; U++) {
        const E = a[U];
        let H = 0, Z = 0;
        E.type === Panel2.TableRow ? (H = n.width, k = t.getRowDefinition(E.row), Z = k.actual) : (k = t.getColumnDefinition(E.column), H = k.actual, Z = n.height), E.measuredBounds.e(0, 0, H, Z), E.ae(false);
      }
      Util.ot(a), t.xh = f;
    }
    arrange(t, i, e) {
      const s = i.length, n = t.padding, o = n.left, r = n.top, l = t.xh;
      if (l === null)
        return;
      let h = 0, a = 0;
      const f = l.length;
      let c = 0;
      for (let C = 0; C < f; C++)
        l[C] && (c = Math.max(c, l[C].length));
      const u = t.Ze, d = t.$e;
      let m = 0, g = 0, p = Math.min(t.topIndex, f - 1);
      if (u.length > 0) {
        for (; p !== f && (u[p] === void 0 || u[p].at === 0); )
          p++;
        p = Math.max(Math.min(p, f - 1), 0), m = -u[p].position;
      }
      let y = Math.min(t.leftIndex, c - 1);
      if (d.length > 0) {
        for (; y !== c && (d[y] === void 0 || d[y].at === 0); )
          y++;
        y = Math.max(Math.min(y, c - 1), 0), g = -d[y].position;
      }
      let x = 0, b = 0;
      for (; x !== f && u[x] === void 0; )
        x++;
      for (; b !== f && d[b] === void 0; )
        b++;
      const k = t.part;
      let S = t.getRowDefinition(x), M = t.getColumnDefinition(b);
      for (let C = 0; C < i.length; C++) {
        const P = i[C];
        if (!(P instanceof Panel2 && P.visible && P.ll()))
          continue;
        P.type === Panel2.TableRow ? (S = t.getRowDefinition(P.row), M = t.getColumnDefinition(b)) : (S = t.getRowDefinition(x), M = t.getColumnDefinition(P.column)), a = S.position + m + r, S.at !== 0 && (a += S.computeEffectiveSpacingTop(Math.max(x, p))), h = M.position + g + o, M.at !== 0 && (h += M.computeEffectiveSpacingTop(Math.max(b, y)));
        const N = P.measuredBounds;
        P.hd(), P.actualBounds.ut();
        const T = P.actualBounds, L = Rect2.H(T.x, T.y, T.width, T.height);
        if (T.x = P.type === Panel2.TableRow ? o : h, T.y = P.type === Panel2.TableColumn ? r : a, T.width = N.width, T.height = N.height, P.actualBounds.w(), P.ro(false), L.equalsApproxClose(T)) {
          Rect2.o(L);
          continue;
        }
        k !== null && (k.mh(), P.A0(k)), Rect2.o(L);
      }
      const A = Size2.a();
      for (let C = 0; C < f; C++) {
        if (!l[C])
          continue;
        c = l[C].length;
        const P = t.getRowDefinition(C);
        a = P.position + m + r, P.at !== 0 && (a += P.computeEffectiveSpacingTop(Math.max(x, p)));
        for (let N = 0; N < c; N++) {
          if (!l[C][N])
            continue;
          const T = t.getColumnDefinition(N);
          h = T.position + g + o, T.at !== 0 && (h += T.computeEffectiveSpacingTop(Math.max(b, y)));
          const L = l[C][N], D = L.length;
          for (let F = 0; F < D; F++) {
            const R = L[F], I = R.measuredBounds;
            A.e(0, 0);
            for (let st = 1; st < R.rowSpan && !(C + st >= t.rowCount); st++) {
              const nt = t.getRowDefinition(C + st);
              nt.at !== 0 && (A.height += nt.total);
            }
            for (let st = 1; st < R.columnSpan && !(N + st >= t.columnCount); st++) {
              const nt = t.getColumnDefinition(N + st);
              nt.at !== 0 && (A.width += nt.total);
            }
            const O = T.at + A.width, B = P.at + A.height;
            let K = h, V = a;
            const X = O, z = B, G = h, v = a;
            let q = O, J = B;
            h + O > e.width && (q = Math.max(e.width - h, 0)), a + B > e.height && (J = Math.max(e.height - a, 0));
            let Y = R.alignment, j = 0, W = 0, Q = 0, U = 0;
            if (Y.isDefault()) {
              Y = t.defaultAlignment, Y.isSpot() || (Y = Spot2.Center), j = Y.x, W = Y.y, Q = Y.offsetX, U = Y.offsetY;
              const st = T.alignment, nt = P.alignment;
              st.isSpot() && (j = st.x, Q = st.offsetX), nt.isSpot() && (W = nt.y, U = nt.offsetY);
            } else
              j = Y.x, W = Y.y, Q = Y.offsetX, U = Y.offsetY;
            (isNaN(j) || isNaN(W)) && (j = 0.5, W = 0.5, Q = 0, U = 0);
            let E = I.width, H = I.height;
            const Z = R.margin, et = Z.left + Z.right, _ = Z.top + Z.bottom, tt = R.F0(P, T, false);
            isNaN(R.desiredSize.width) && (tt === 2 || tt === 5) && (E = Math.max(O - et, 0)), isNaN(R.desiredSize.height) && (tt === 2 || tt === 4) && (H = Math.max(B - _, 0));
            const it = R.maxSize, ft = R.minSize;
            E = Math.min(it.width, E), H = Math.min(it.height, H), E = Math.max(ft.width, E), H = Math.max(ft.height, H);
            const ot = E + et, lt = H + _;
            K += X * j - ot * j + Q + Z.left, V += z * W - lt * W + U + Z.top, R.visible && (Rect2.contains(G, v, q, J, K, V, I.width, I.height) ? R.vt(K, V, E, H) : R.vt(K, V, E, H, new Rect2(G, v, q, J)));
          }
        }
      }
      Size2.o(A);
      for (let C = 0; C < s; C++) {
        const P = i[C], N = P instanceof Panel2 ? P : null;
        if (N !== null && N.ll()) {
          const T = P.actualBounds;
          P.naturalBounds.ut(), P.naturalBounds.e(0, 0, T.width, T.height), P.naturalBounds.w();
        }
      }
    }
  }
  PanelLayout2.definePanelLayout("Table", new PanelLayoutTable());
  class PanelLayoutTableRow extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
    }
    arrange(t, i, e) {
    }
  }
  PanelLayout2.definePanelLayout("TableRow", new PanelLayoutTableRow());
  class PanelLayoutTableColumn extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
    }
    arrange(t, i, e) {
    }
  }
  PanelLayout2.definePanelLayout("TableColumn", new PanelLayoutTableColumn());
  class PanelLayoutViewbox extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      s.length > 1 && Util.n("Viewbox Panel cannot contain more than one GraphObject.");
      const h = s[0];
      h.v = 1, h.oc(), h.wt(1 / 0, 1 / 0, o, r);
      let a = h.measuredBounds;
      const f = h.margin, c = f.right + f.left, u = f.top + f.bottom;
      if (isFinite(i) || isFinite(e)) {
        const d = h.scale, m = a.width, g = a.height, p = Math.max(i - c, 0), y = Math.max(e - u, 0);
        let x = 1;
        t.viewboxStretch === 6 ? (m !== 0 && g !== 0 && (x = Math.min(p / m, y / g)), x === 0 && (x = 1e-4), h.v *= x) : (m !== 0 && g !== 0 && (x = Math.max(p / m, y / g)), x === 0 && (x = 1e-4), h.v *= x), d !== h.scale && (h.ae(true), h.wt(1 / 0, 1 / 0, o, r));
      }
      a = h.measuredBounds, n.width = isFinite(i) ? i : Math.max(a.width + c, 0), n.height = isFinite(e) ? e : Math.max(a.height + u, 0);
    }
    arrange(t, i, e) {
      const s = i[0], n = s.measuredBounds, o = s.margin, r = o.right + o.left, l = o.top + o.bottom, h = Math.max(n.width + r, 0), a = Math.max(n.height + l, 0);
      let f = s.alignment;
      f.isDefault() && (f = t.defaultAlignment), f.isSpot() || (f = Spot2.Center), s.vt(e.width * f.x - h * f.x + f.offsetX, e.height * f.y - a * f.y + f.offsetY, n.width, n.height);
    }
  }
  PanelLayout2.definePanelLayout("Viewbox", new PanelLayoutViewbox());
  class PanelLayoutGrid extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      t.Pi === null && (t.Pi = new GridPanelSettings()), this.iI(t), this.eI(t);
    }
    arrange(t, i, e) {
    }
    Ji(t, i, e) {
      const s = t.naturalBounds, n = s.width, o = s.height;
      i.save(), i.beginPath(), i.rect(0, 0, n, o), i.clip(), i.endPath(), this.sI(t, i, e), i.restore(), i.clearContextCache(false);
    }
    sI(t, i, e) {
      let s = t.getDocumentScale() * e.scale;
      s <= 0 && (s = 1);
      const n = t.gridCellSize, o = n.width, r = n.height, l = t.naturalBounds, h = t.actualBounds, a = l.width, f = l.height, c = Math.ceil(a / o), u = Math.ceil(f / r), d = t.gridOrigin, m = d.x, g = d.y, p = t.Pi.np, y = t.F.h, x = y.length;
      for (let b = 0; b < x; b++) {
        const k = y[b];
        if (!k.visible)
          continue;
        const S = k.interval || 1, M = Math.abs(S);
        if (o * M * s < 2)
          continue;
        let A = k.segmentIndex;
        (!isFinite(A) || isNaN(A)) && (A = 0), A < 0 && (A = M - Math.min(-A, M)), A = Math.round(A % M);
        const C = k.opacity;
        let P = 1;
        if (C !== 1) {
          if (C === 0)
            continue;
          P = i.globalAlpha, i.globalAlpha = P * C;
        }
        const N = p[b];
        let T = false;
        const L = k.strokeDashArray;
        if (L !== null && (T = true, i.enableDash(L, k.strokeDashOffset)), k.stroke !== null && k.strokeWidth > 0 && (k.figure === "LineV" || k.figure === "LineH")) {
          if (i.lineWidth = k.strokeWidth, t.bn(i, k.stroke, false, false, l, h), i.beginPath(), k.figure === "LineV") {
            const D = Math.floor((m - o) / o);
            for (let F = D; F <= D + c; F++) {
              const R = F * o + m;
              0 <= R && R <= a && this.eb(F, S, A, N) && (i.moveTo(R, 0), i.lineTo(R, f));
            }
          } else if (k.figure === "LineH") {
            const D = Math.floor((g - r) / r);
            for (let F = D; F <= D + u; F++) {
              const R = F * r + g;
              0 <= R && R <= f && this.eb(F, S, A, N) && (i.moveTo(0, R), i.lineTo(a, R));
            }
          }
          i.stroke(), i.endPath();
        } else if (k.fill !== null) {
          if (t.bn(i, k.fill, true, false, l, h), k.figure === "BarV") {
            let D = k.width;
            isNaN(D) && (D = o);
            const F = Math.floor((m - o) / o);
            for (let R = F; R <= F + c; R++) {
              const I = R * o + m;
              0 <= I + D && I <= a && this.eb(R, S, A, N) && i.fillRect(I, 0, D, f);
            }
          } else if (k.figure === "BarH") {
            let D = k.height;
            isNaN(D) && (D = r);
            const F = Math.floor((g - r) / r);
            for (let R = F; R <= F + u; R++) {
              const I = R * r + g;
              0 <= I + D && I <= f && this.eb(R, S, A, N) && i.fillRect(0, I, a, D);
            }
          }
        }
        T && i.disableDash(), C !== 1 && (i.globalAlpha = P);
      }
    }
    eb(t, i, e, s) {
      if (i < 0)
        return t % i === e;
      if (t % i !== e)
        return false;
      const n = s.length;
      for (let o = 0; o < n; o++) {
        const r = s[o];
        if (t % r === e)
          return false;
      }
      return true;
    }
    eI(t) {
      const i = [], e = t.F.h, s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n], r = [];
        if (i.push(r), !o.visible)
          continue;
        const l = o.interval;
        if (l < 0)
          continue;
        const h = o.figure, a = this.I2(h);
        for (let f = 0; f < s; f++) {
          if (f === n)
            continue;
          const c = e[f];
          if (!c.visible)
            continue;
          const u = c.figure;
          if (this.I2(u) !== a)
            continue;
          const d = c.interval;
          d > l && r.push(d);
        }
      }
      t.Pi.np = i;
    }
    I2(t) {
      return t === "LineV" || t === "BarV";
    }
    iI(t) {
      let i = 1, e = 1;
      const s = t.F.h, n = s.length;
      for (let l = 0; l < n; l++) {
        const h = s[l], a = Math.abs(h.interval);
        a < 2 || (this.I2(h.figure) ? e = e * a / Geo.yC(e, a) : i = i * a / Geo.yC(i, a));
      }
      const o = t.gridCellSize, r = t.Pi;
      r.jf.isReal() ? r.jf.e(e * o.width, i * o.height) : r.jf = new Size2(e * o.width, i * o.height);
    }
  }
  PanelLayout2.definePanelLayout("Grid", new PanelLayoutGrid());
  class PanelLayoutLink extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = s.length;
      if (!(t instanceof Adornment2 || t instanceof Link2))
        return;
      let h = null, a = null;
      if (t instanceof Link2 && (h = t), t instanceof Adornment2 && (a = t, h = a.adornedPart, t.uc === null && (t.uc = [])), !(h instanceof Link2))
        return;
      const f = h;
      if (l === 0) {
        t.naturalBounds.Do(0, 0), t.measuredBounds.e(0, 0, 0, 0);
        return;
      }
      const c = t instanceof Adornment2 ? null : h.path, u = h.routeBounds, d = t.Zo;
      d.e(0, 0, u.width, u.height);
      const m = f.points, g = h.pointsCount;
      a !== null ? a.pd(false) : h !== null && h.pd(false);
      const p = u.width, y = u.height, x = t.uc;
      if (x.length = 0, c !== null) {
        this.measureLinkPath(t, p, y, c);
        const M = c.measuredBounds;
        d.unionRect(M), x.push(M);
      }
      const b = Transform.a(), k = Point2.a(), S = Point2.a();
      for (let M = 0; M < l; M++) {
        const A = s[M];
        if (A === c)
          continue;
        let C = A.measuredBounds;
        if (A.isPanelMain && A instanceof Shape2) {
          this.measureLinkPath(t, p, y, A), C = A.measuredBounds, d.unionRect(C), x.push(C);
          continue;
        }
        if (g < 2) {
          A.wt(1 / 0, 1 / 0, 0, 0), C = A.measuredBounds, d.unionRect(C), x.push(C);
          continue;
        }
        const P = A.segmentIndex, N = A.segmentFraction;
        let T = A.alignmentFocus;
        T.isNoSpot() && (T = Spot2.Center);
        const L = A.segmentOrientation, D = A.segmentOffset;
        let F = 0, R = 0, I = 0, O = 0;
        if (isNaN(P)) {
          const Y = f.yt, j = Util.ct();
          Y.getPointAndAngleAlongPath(N, j);
          const W = Point2.H(j[0], j[1]);
          O = j[2], L !== 0 && (I = f.computeAngle(A, L, O), A.qt = I, A.ae(true), A.ro(true)), F = W.x, R = W.y, Point2.o(W), Util.ot(j);
        } else if (P < -g || P >= g) {
          const Y = Point2.a();
          f.wL(Y), O = f.midAngle, L !== 0 && (I = f.computeAngle(A, L, O), A.qt = I, A.ae(true), A.ro(true)), F = Y.x - u.x, R = Y.y - u.y, Point2.o(Y);
        } else {
          let Y, j, W = 0;
          if (P >= 0 ? (Y = m.elt(P), j = P < g - 1 ? m.elt(P + 1) : Y) : (W = g + P, Y = m.elt(W), j = W > 0 ? m.elt(W - 1) : Y), O = 0, Y.equalsApprox(j)) {
            let Q, U;
            P >= 0 ? (Q = P > 0 ? m.elt(P - 1) : Y, U = P < g - 2 ? m.elt(P + 2) : j) : (Q = W < g - 1 ? m.elt(W + 1) : Y, U = W > 1 ? m.elt(W - 2) : j);
            const E = Q.distanceSquaredPoint(Y), H = j.distanceSquaredPoint(U);
            E > H + 10 ? O = P >= 0 ? Q.directionPoint(Y) : Y.directionPoint(Q) : H > E + 10 ? O = P >= 0 ? j.directionPoint(U) : U.directionPoint(j) : O = P >= 0 ? Q.directionPoint(U) : U.directionPoint(Q);
          } else
            O = P >= 0 ? Y.directionPoint(j) : j.directionPoint(Y);
          L !== 0 && (I = f.computeAngle(A, L, O), A.qt = I, A.ae(true), A.ro(true)), F = Y.x + (j.x - Y.x) * N - u.x, R = Y.y + (j.y - Y.y) * N - u.y;
        }
        A.wt(1 / 0, 1 / 0, 0, 0), C = A.measuredBounds;
        const B = A.naturalBounds;
        let K = 0;
        A instanceof Shape2 && (K = A.strokeWidth);
        const V = B.width + K, X = B.height + K;
        b.ti(), b.se(-C.x, -C.y), b.v(A.scale, A.scale), b.ys(L === 0 ? A.angle : O, V / 2, X / 2), (L === 22 || L === 26) && b.ys(90, V / 2, X / 2), (L === 23 || L === 27) && b.ys(-90, V / 2, X / 2), L === 28 && (O > 45 && O < 135 || O > 225 && O < 315) && b.ys(-O, V / 2, X / 2);
        const z = new Rect2(0, 0, V, X);
        k.setRectSpot(z, T), b.Pt(k);
        const G = -k.x + K / 2 * A.scale, v = -k.y + K / 2 * A.scale;
        S.c(D);
        const q = isNaN(D.x), J = isNaN(D.y);
        if (q || J) {
          const Y = V / 2 + 3, j = X / 2 + 3, W = O >= 45 && O <= 135, Q = O >= 225 && O <= 315;
          L === 0 && (W || Q) ? (S.x = J ? Y : D.y, S.y = q ? j : D.x, W ? P >= 0 || isNaN(P) && N < 0.5 || q && (S.y = -j) : Q && ((P >= 0 || isNaN(P) && N < 0.5) && q && (S.y = -j), J && (S.x = -Y))) : (q && (P >= 0 || isNaN(P) && N < 0.5 ? S.x = Y : S.x = -Y), J && (S.y = -j), S.rotate(O));
        } else
          S.rotate(O);
        F += S.x, R += S.y, z.e(F + G, R + v, C.width, C.height), x.push(z), d.unionRect(z);
      }
      if (h !== null) {
        const M = h.labelNodes;
        for (; M.next(); )
          M.value.wt(1 / 0, 1 / 0);
      }
      t.Zo = d, t.position.e(u.x + d.x, u.y + d.y), n.Do(d.width || 0, d.height || 0), Transform.o(b), Point2.o(k), Point2.o(S);
    }
    arrange(t, i, e) {
      const s = i.length;
      if (!(t instanceof Adornment2 || t instanceof Link2))
        return;
      let n = t, o = null;
      t instanceof Adornment2 && (o = t, n = o.adornedPart);
      const r = t, l = t instanceof Adornment2 ? null : n.path, h = t.uc;
      if (h.length !== 0) {
        let u = 0;
        if (l !== null && u < h.length) {
          const d = h[u];
          u++, l.vt(d.x - r.Zo.x, d.y - r.Zo.y, d.width, d.height);
        }
        for (let d = 0; d < s; d++) {
          const m = i[d];
          if (m !== l && u < h.length) {
            const g = h[u];
            u++, m.vt(g.x - r.Zo.x, g.y - r.Zo.y, g.width, g.height);
          }
        }
      }
      const a = n.points, f = a.count;
      if (f >= 2 && r instanceof Link2) {
        const u = r.labelNodes;
        for (; u.next(); ) {
          const d = u.value;
          r.nI(d, f, a);
        }
      }
      o !== null ? o.pd(false) : n.pd(false);
      const c = t.xL(Point2.a());
      t.location.e(t.position.x + c.x, t.position.y + c.y), Point2.o(c);
    }
    measureLinkPath(t, i, e, s) {
      if (s.Ko() === false)
        return;
      let n = s.strokeWidth;
      if (n === 0 && t instanceof Adornment2 && t.type === Panel2.Link && t.adornedObject instanceof Shape2 && (n = t.adornedObject.strokeWidth), n = n * s.v, t instanceof Link2 && t.yt !== null) {
        const o = t.geometry.bounds;
        s.oo(o.x - n / 2, o.y - n / 2, o.width + n, o.height + n);
      } else if (t instanceof Adornment2 && t.adornedPart.yt !== null) {
        const o = t.adornedPart.yt.bounds;
        s.oo(o.x - n / 2, o.y - n / 2, o.width + n, o.height + n);
      } else
        s.oo(-(n / 2), -(n / 2), i + n, e + n);
      s.oI(), s.ae(false);
    }
  }
  PanelLayout2.definePanelLayout("Link", new PanelLayoutLink());
  class PanelLayoutGraduated extends PanelLayout2 {
    constructor() {
      super();
    }
    measure(t, i, e, s, n, o, r) {
      const l = t.findMainElement();
      t.Qe = [];
      const h = l.margin, a = h.right + h.left, f = h.top + h.bottom;
      l.wt(i, e, o, r);
      const c = l.measuredBounds, u = c.width, d = c.height, m = Math.max(u + a, 0), g = Math.max(d + f, 0), p = new Rect2(-h.left, -h.top, m, g);
      t.Qe.push(p), n.c(p), this.determineGraduatedMarks(t, l);
      const y = t.Cs;
      if (y === null)
        return;
      const x = s.length;
      for (let b = 0; b < x; b++) {
        const k = s[b], S = y[b];
        !k.visible || k === l || S.length === 0 || (k instanceof Shape2 ? this.measureGraduatedTicks(t, k, S, n) : k instanceof TextBlock2 && this.measureGraduatedLabels(t, k, S, n), k.ae(false));
      }
    }
    arrange(t, i, e) {
      if (t.Qe === null)
        return;
      const s = t.findMainElement(), n = t.Cs;
      if (n === null)
        return;
      const o = t.Qe;
      let r = 0, l = o[r];
      r++, s !== null && s.vt(l.x - e.x, l.y - e.y, l.width, l.height);
      const h = i.length;
      for (let a = 0; a < h; a++) {
        const f = i[a], c = n[a];
        !f.visible || f === s || c.length === 0 || (l = o[r], r++, f.vt(l.x - e.x, l.y - e.y, l.width, l.height));
      }
      t.Qe = null;
    }
    measureGraduatedTicks(t, i, e, s) {
      let n = i.alignmentFocus;
      n.isNoSpot() && (n = Spot2.TopCenter);
      const o = i.angle;
      i.qt = 0, i.wt(1 / 0, 1 / 0, 0, 0), i.qt = o;
      const r = i.measuredBounds, l = r.width, h = r.height, a = Rect2.H(0, 0, l, h), f = Point2.a();
      f.setRectSpot(a, n), Rect2.o(a);
      const c = -f.x, u = -f.y, d = new Rect2(), m = e.length;
      for (let g = 0; g < m; g++) {
        const p = e[g], y = p.pt.x, x = p.pt.y, b = p.angle;
        for (let k = 0; k < 4; k++) {
          switch (k) {
            case 0:
              f.e(c, u);
              break;
            case 1:
              f.e(c + l, u);
              break;
            case 2:
              f.e(c, u + h);
              break;
            case 3:
              f.e(c + l, u + h);
              break;
          }
          f.rotate(b + i.angle), f.offset(y, x), g === 0 && k === 0 ? d.e(f.x, f.y, 0, 0) : d.unionPoint(f), f.offset(-y, -x), f.rotate(-b - i.angle);
        }
      }
      Point2.o(f), t.Qe !== null && t.Qe.push(d), s.unionNoCheck(d.x, d.y, d.width, d.height);
    }
    measureGraduatedLabels(t, i, e, s) {
      t.Fe === null && (t.Fe = new TextBlock2());
      const n = t.Fe;
      this.bL(i, n);
      let o = i.alignmentFocus;
      o.isNoSpot() && (o = Spot2.TopCenter);
      const r = i.segmentOrientation, l = i.segmentOffset, h = new Rect2();
      let a = 0, f = 0, c = 0, u = 0, d = 0;
      const m = e.length;
      for (let g = 0; g < m; g++) {
        const p = e[g];
        a = p.pt.x, f = p.pt.y, c = p.angle, u = i.angle, d = i.angle, r !== 0 && (r === 21 || r === 25 ? d = c + i.angle : d = c, u = Link2.computeAngle(r, d)), n.qt = u, n.text = p.text || "", n.wt(1 / 0, 1 / 0, 0, 0);
        const y = n.measuredBounds, x = n.naturalBounds, b = x.width, k = x.height, S = Transform.a();
        S.ti(), S.se(-y.x, -y.y), S.v(n.scale, n.scale), S.ys(d, b / 2, k / 2), (r === 22 || r === 26) && S.ys(90, b / 2, k / 2), (r === 23 || r === 27) && S.ys(-90, b / 2, k / 2), r === 28 && (c > 45 && c < 135 || c > 225 && c < 315) && S.ys(-c, b / 2, k / 2);
        const M = Rect2.H(0, 0, b, k), A = Point2.a();
        A.setRectSpot(M, o), S.Pt(A);
        const C = -A.x, P = -A.y, N = Point2.a();
        N.c(l), isNaN(N.x) && (N.x = b / 2 + 3), isNaN(N.y) && (N.y = -(k / 2 + 3)), N.rotate(c), a += N.x + C, f += N.y + P;
        const T = new Rect2(a, f, y.width, y.height), L = new Rect2(y.x, y.y, y.width, y.height), D = new Rect2(x.x, x.y, x.width, x.height);
        p.labelAngle = u, p.lineCount = n.lineCount, p.lines = n.getMetrics(), p.actualBounds = T, p.measuredBounds = L, p.naturalBounds = D, g === 0 ? h.c(T) : h.unionRect(T), Point2.o(N), Point2.o(A), Rect2.o(M), Transform.o(S);
      }
      t.Qe !== null && t.Qe.push(h), s.unionNoCheck(h.x, h.y, h.width, h.height);
    }
    determineGraduatedMarks(t, i) {
      const e = i.geometry, s = i.strokeWidth, n = e.flattenedSegments, o = e.flattenedLengths, r = e.flattenedTotalLength, l = n.length;
      let h = 0, a = 0;
      const f = Util.ct();
      for (let x = 0; x < l; x++) {
        const b = n[x], k = [];
        h = 0, a = 0;
        const S = b.length;
        for (let M = 0; M < S; M += 2) {
          const A = b[M], C = b[M + 1];
          if (M === 0) {
            h = A, a = C;
            continue;
          }
          let P = Math.atan2(C - a, A - h) * 180 / Math.PI;
          P < 0 && (P += 360), k.push(P), h = A, a = C;
        }
        f.push(k);
      }
      const c = this.rI(t), u = t.F.h, d = u.length;
      let m = 0, g = 0, p = r;
      t.Cs = [];
      let y;
      for (let x = 0; x < d; x++) {
        const b = u[x];
        if (y = [], !b.visible || b === i) {
          t.Cs.push(y);
          continue;
        }
        const k = Math.abs(b.interval), S = t.graduatedTickUnit;
        if (S * k * r / t.graduatedRange < 2 && b.graduatedSkip === null) {
          t.Cs.push(y);
          continue;
        }
        let M = o[0][0], A = 0, C = 0;
        g = r * b.graduatedStart - 1e-4, p = r * b.graduatedEnd + 1e-4;
        const P = S * k;
        let N = t.graduatedTickBase;
        if (N < t.graduatedMin) {
          let F = (t.graduatedMin - N) / P;
          F = F % 1 === 0 ? F : Math.floor(F + 1), N += F * P;
        } else if (N > t.graduatedMin + P) {
          const F = Math.floor((N - t.graduatedMin) / P);
          N -= F * P;
        }
        const T = c[x], L = N, D = t.graduatedMax * 1e-6;
        for (let F = 1; N <= t.graduatedMax + D; F++) {
          if (this.lI(t, N - t.graduatedTickBase, T) && (N > t.graduatedMax && (N = t.graduatedMax), (b.graduatedSkip === null || b instanceof TextBlock2 && !b.graduatedSkip(N, b) || b instanceof Shape2 && !b.graduatedSkip(N, b)) && (m = (N - t.graduatedMin) * r / t.graduatedRange, m > r && (m = r), g <= m && m <= p))) {
            let R = f[A][C], I = o[A][C];
            for (; A < o.length; ) {
              for (; m > M && C < o[A].length - 1; )
                C++, R = f[A][C], I = o[A][C], M += I;
              if (m <= M)
                break;
              A++, C = 0, R = f[A][C], I = o[A][C], M += I;
            }
            const O = n[A], B = O[C * 2], K = O[C * 2 + 1], V = O[C * 2 + 2], X = O[C * 2 + 3], z = (m - (M - I)) / I, G = new Point2(B + (V - B) * z + s / 2 - e.bounds.x, K + (X - K) * z + s / 2 - e.bounds.y);
            if (G.scale(i.scale, i.scale), R = this.hI(R, z, O, f[A], C), b instanceof TextBlock2) {
              let v = "";
              b.graduatedFunction !== null ? (v = b.graduatedFunction(N, b), v = v != null ? v.toString() : "") : v = (+N.toFixed(2)).toString(), v !== "" && y.push({ pt: G, angle: R, text: v });
            } else
              y.push({ pt: G, angle: R });
          }
          N = L + F * P;
        }
        t.Cs.push(y);
      }
      Util.ot(f);
    }
    hI(t, i, e, s, n) {
      if (i < 0.5005 && i > 0.4995)
        return t;
      let o = t;
      if (i < 0.5 ? n > 0 ? o = s[n - 1] : Geo.q(e[0], e[e.length - 2]) && Geo.q(e[1], e[e.length - 1]) && (o = s[s.length - 1]) : i > 0.5 && (n + 1 < s.length ? o = s[n + 1] : Geo.q(e[0], e[e.length - 2]) && Geo.q(e[1], e[e.length - 1]) && (o = s[0])), t !== o) {
        let r = Math.abs(t - o);
        if (r > 180 && (t < o ? t += 360 : o += 360, r = Math.abs(t - o)), i < 5e-4 || i > 0.9995)
          return (t + o) / 2 % 360;
        if (r < 10) {
          const l = 1 - Math.abs(0.5 - i);
          return (t * l + o * (1 - l)) % 360;
        }
      }
      return t;
    }
    rI(t) {
      if (t.cs === null) {
        const i = [], e = t.F.h, s = e.length;
        for (let n = 0; n < s; n++) {
          const o = e[n], r = [];
          if (i.push(r), !o.visible)
            continue;
          const l = o.interval;
          if (!(l < 0))
            for (let h = 0; h < s; h++) {
              if (h === n)
                continue;
              const a = e[h];
              if (!a.visible || o.constructor !== a.constructor)
                continue;
              const f = a.interval;
              f > l && r.push(f);
            }
        }
        t.cs = i;
      }
      return t.cs;
    }
    lI(t, i, e) {
      const s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n] * t.graduatedTickUnit, r = i % o, l = t.graduatedTickUnit * 1e-6;
        if (r < l && r > -l)
          return false;
      }
      return true;
    }
    Ji(t, i, e) {
      const s = e.sa;
      e.sa = true;
      const n = t.naturalBounds, o = n.width, r = n.height, l = i instanceof SVGContext;
      i.save(), i.beginPath(), i.rect(-1, -1, o + 1, r + 1), i.clip(), i.endPath();
      const h = t.findMainElement();
      h.Ji(i, e);
      let a = t.getDocumentScale() * e.scale;
      a <= 0 && (a = 1);
      const f = h.actualBounds, c = t.F.h, u = t.Cs, d = c.length;
      for (let m = 0; m < d; m++) {
        const g = c[m], p = u[m], y = p.length;
        if (!(!g.visible || g === h || p.length === 0)) {
          if (g instanceof Shape2) {
            if (t.graduatedTickUnit * g.interval * h.geometry.flattenedTotalLength / t.graduatedRange * a < 2 && g.graduatedSkip === null)
              continue;
            const x = g.measuredBounds, b = g.strokeWidth * g.scale;
            let k = g.alignmentFocus;
            k.isNoSpot() && (k = Spot2.TopCenter);
            for (let S = 0; S < y; S++) {
              const M = p[S].pt, A = p[S].angle;
              this.aI(g, M, f, A, x, b, k), g.Ji(i, e), l && (t.svg.appendChild(g.svg), g.svg = null), g.nl.ti();
            }
          } else if (g instanceof TextBlock2) {
            t.Fe === null && (t.Fe = new TextBlock2());
            const x = t.Fe;
            this.bL(g, x);
            for (let b = 0; b < y; b++) {
              const k = p[b];
              if (k.actualBounds && k.measuredBounds && k.naturalBounds) {
                x.fI(k);
                const S = k.actualBounds;
                x.vt(S.x, S.y, S.width, S.height), this.cI(x, f, S, k.measuredBounds, k.naturalBounds), x.rl = g.part, x.vs = g.panel, x.Ji(i, e), x.vs = null, x.rl = null, l && (t.svg.appendChild(x.svg), x.svg = null);
              }
            }
          }
        }
      }
      e.sa = s, i.restore(), i.clearContextCache(true);
    }
    aI(t, i, e, s, n, o, r) {
      const l = t.nl;
      l.ti(), l.se(i.x + e.x, i.y + e.y), l.ys(s + t.angle, 0, 0), l.se(-n.width * r.x + r.offsetX + o / 2, -n.height * r.y + r.offsetY + o / 2), l.v(t.scale, t.scale), t.cd(false), t.ch.set(t.nl), t.Qf = t.scale, t.Ma(false);
    }
    cI(t, i, e, s, n) {
      const o = t.nl;
      o.ti(), o.se(e.x + i.x, e.y + i.y), o.se(-s.x, -s.y), t.P0(o, n.x, n.y, n.width, n.height), t.cd(false), t.ch.set(t.nl), t.Qf = t.scale, t.Ma(false);
    }
    bL(t, i) {
      i.uI(t);
    }
  }
  PanelLayout2.definePanelLayout("Graduated", new PanelLayoutGraduated());
  var ViewboxStretch2 = ((w) => (w[w.Uniform = 6] = "Uniform", w[w.UniformToFill = 7] = "UniformToFill", w))(ViewboxStretch2 || {});
  const _Panel = class _Panel extends GraphObject2 {
    constructor(t, i) {
      super();
      __publicField(this, "nt");
      __publicField(this, "F");
      __publicField(this, "ei");
      __publicField(this, "yd");
      __publicField(this, "Jn");
      __publicField(this, "fl");
      __publicField(this, "fo");
      __publicField(this, "Zo");
      __publicField(this, "O2");
      __publicField(this, "B");
      __publicField(this, "wd");
      __publicField(this, "gt");
      __publicField(this, "Pi");
      __publicField(this, "si");
      __publicField(this, "xd");
      __publicField(this, "bh");
      __publicField(this, "Js");
      if (this.nt = null, t === void 0)
        this.nt = _Panel.Position;
      else if (typeof t == "string") {
        const e = PanelLayout2.Layouts.getValue(t);
        e !== null && (this.nt = e);
      } else
        t instanceof PanelLayout2 ? this.nt = t : t && (this.nt = _Panel.Position, i = t);
      this.nt === null && Util.n("Panel type not specified or PanelLayout not loaded: " + t), this.l |= 4194304 | (this.nt === _Panel.Grid ? 1048576 : 0), this.F = new List2(), this.ei = Margin2.qg, this.yd = Spot2.Default, this.Jn = 1, this.fl = null, this.fo = "", this.Zo = new Rect2(NaN, NaN, NaN, NaN), this.O2 = null, this.B = null, this.wd = 6, this.Pi = null, this.gt = null, this.si = null, this.xd = NaN, this.bh = null, this.Js = null, i && Object.assign(this, i);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.nt = this.nt, t.ei = this.ei.L(), t.yd = this.yd.L(), t.Jn = this.Jn, t.fo = this.fo, t.Zo.c(this.Zo), this.B !== null && (t.B = this.B.copy(t)), t.wd = this.wd, this.gt !== null && (t.gt = this.gt.copy()), this.Pi !== null && (t.Pi = this.Pi.copy()), t.si = this.si, t.xd = this.xd, t.bh = this.bh;
    }
    qo(t) {
      super.qo(t), t.F = this.F;
      const i = t.F.h, e = i.length;
      for (let s = 0; s < e; s++) {
        const n = i[s];
        n.vs = t;
      }
      t.fl = null;
    }
    copy() {
      const t = super.copy();
      if (t !== null) {
        const i = this.F.h, e = i.length;
        for (let s = 0; s < e; s++) {
          const o = i[s].copy();
          t.dI(o);
        }
        return t;
      } else
        return null;
    }
    toString() {
      return "Panel(" + this.type.name + ")#" + GSet2.ps(this);
    }
    get type() {
      return this.nt;
    }
    set type(t) {
      const i = this.nt;
      i !== t && (this.nt = t, this.dc = this.nt === _Panel.Grid, this.u(), this.i("type", i, t));
    }
    get elements() {
      return this.F.iterator;
    }
    get naturalBounds() {
      return this.Hi;
    }
    get padding() {
      return this.ei;
    }
    set padding(t) {
      typeof t == "number" ? (t < 0 && Util.G(t, ">= 0", _Panel, "padding"), t = new Margin2(t)) : (Util.s(t, Margin2, _Panel, "padding"), t.left < 0 && Util.G(t.left, ">= 0", _Panel, "padding:value.left"), t.right < 0 && Util.G(t.right, ">= 0", _Panel, "padding:value.right"), t.top < 0 && Util.G(t.top, ">= 0", _Panel, "padding:value.top"), t.bottom < 0 && Util.G(t.bottom, ">= 0", _Panel, "padding:value.bottom"));
      const i = this.ei;
      i.equals(t) || (t = t.L(), this.ei = t, this.u(), this.i("padding", i, t));
    }
    get defaultAlignment() {
      return this.yd;
    }
    set defaultAlignment(t) {
      const i = this.yd;
      i.equals(t) || (Debug && Util.s(t, Spot2, _Panel, "defaultAlignment"), t = t.L(), this.yd = t, this.u(), this.i("defaultAlignment", i, t));
    }
    get defaultStretch() {
      return this.Jn;
    }
    set defaultStretch(t) {
      const i = this.Jn;
      i !== t && (this.Jn = t, this.u(), this.i("defaultStretch", i, t));
    }
    get defaultSeparatorPadding() {
      return this.B !== null ? this.B.op : Margin2.qg;
    }
    set defaultSeparatorPadding(t) {
      typeof t == "number" ? t = new Margin2(t) : Debug && Util.s(t, Margin2, _Panel, "defaultSeparatorPadding");
      const i = this.defaultSeparatorPadding;
      i.equals(t) || (t = t.L(), this.B === null && (this.B = new TablePanelSettings()), this.B.op = t, this.u(), this.i("defaultSeparatorPadding", i, t));
    }
    get defaultRowSeparatorStroke() {
      return this.B !== null ? this.B.rp : null;
    }
    set defaultRowSeparatorStroke(t) {
      const i = this.defaultRowSeparatorStroke;
      i !== t && (t === null || typeof t == "string" || t instanceof Brush2) && (t instanceof Brush2 && t.w(), this.B === null && (this.B = new TablePanelSettings()), this.B.rp = t, this.T(), this.i("defaultRowSeparatorStroke", i, t));
    }
    get defaultRowSeparatorStrokeWidth() {
      return this.B !== null ? this.B.lp : 1;
    }
    set defaultRowSeparatorStrokeWidth(t) {
      const i = this.defaultRowSeparatorStrokeWidth;
      i !== t && isFinite(t) && t >= 0 && (this.B === null && (this.B = new TablePanelSettings()), this.B.lp = t, this.u(), this.i("defaultRowSeparatorStrokeWidth", i, t));
    }
    get defaultRowSeparatorDashArray() {
      return this.B !== null ? this.B.hp : null;
    }
    set defaultRowSeparatorDashArray(t) {
      const i = this.defaultRowSeparatorDashArray;
      if (i !== t) {
        if (t !== null && !Array.isArray(t) && Util.Bi(t, "Array", _Panel, "defaultRowSeparatorDashArray:value"), t !== null) {
          const e = t.length;
          let s = 0;
          for (let n = 0; n < e; n++) {
            const o = t[n];
            (typeof o != "number" || !(o >= 0) || !isFinite(o)) && Util.n("defaultRowSeparatorDashArray value " + o + " at index " + n + " must be a positive number or zero."), s += o;
          }
          if (s === 0) {
            if (i === null)
              return;
            t = null;
          }
        }
        this.B === null && (this.B = new TablePanelSettings()), this.B.hp = t, this.T(), this.i("defaultRowSeparatorDashArray", i, t);
      }
    }
    get defaultColumnSeparatorStroke() {
      return this.B !== null ? this.B.ap : null;
    }
    set defaultColumnSeparatorStroke(t) {
      const i = this.defaultColumnSeparatorStroke;
      i !== t && (t === null || typeof t == "string" || t instanceof Brush2) && (t instanceof Brush2 && t.w(), this.B === null && (this.B = new TablePanelSettings()), this.B.ap = t, this.T(), this.i("defaultColumnSeparatorStroke", i, t));
    }
    get defaultColumnSeparatorStrokeWidth() {
      return this.B !== null ? this.B.fp : 1;
    }
    set defaultColumnSeparatorStrokeWidth(t) {
      const i = this.defaultColumnSeparatorStrokeWidth;
      i !== t && isFinite(t) && t >= 0 && (this.B === null && (this.B = new TablePanelSettings()), this.B.fp = t, this.u(), this.i("defaultColumnSeparatorStrokeWidth", i, t));
    }
    get defaultColumnSeparatorDashArray() {
      return this.B !== null ? this.B.cp : null;
    }
    set defaultColumnSeparatorDashArray(t) {
      const i = this.defaultColumnSeparatorDashArray;
      if (i !== t) {
        if (t !== null && !Array.isArray(t) && Util.Bi(t, "Array", _Panel, "defaultColumnSeparatorDashArray:value"), t !== null) {
          const e = t.length;
          let s = 0;
          for (let n = 0; n < e; n++) {
            const o = t[n];
            (typeof o != "number" || !(o >= 0) || !isFinite(o)) && Util.n("defaultColumnSeparatorDashArray value " + o + " at index " + n + " must be a positive number or zero."), s += o;
          }
          if (s === 0) {
            if (i === null)
              return;
            t = null;
          }
        }
        this.B === null && (this.B = new TablePanelSettings()), this.B.cp = t, this.T(), this.i("defaultColumnSeparatorDashArray", i, t);
      }
    }
    get xh() {
      return this.B !== null ? this.B.xh : null;
    }
    set xh(t) {
      this.B === null && (this.B = new TablePanelSettings()), this.B.xh = t;
    }
    get viewboxStretch() {
      return this.wd;
    }
    set viewboxStretch(t) {
      const i = this.wd;
      i !== t && (this.wd = t, this.u(), this.i("viewboxStretch", i, t));
    }
    get gridCellSize() {
      return this.Pi !== null ? this.Pi.bd : Size2.oC;
    }
    set gridCellSize(t) {
      this.Pi === null && (this.Pi = new GridPanelSettings());
      const i = this.Pi.bd;
      if (!i.equals(t)) {
        (!t.isReal() || t.width === 0 || t.height === 0) && Util.n("Invalid Panel.gridCellSize: " + t), this.Pi.bd = t.L();
        const e = this.diagram;
        e !== null && this === e.grid && e._r(), this.T(), this.i("gridCellSize", i, t);
      }
    }
    get gridOrigin() {
      return this.Pi !== null ? this.Pi.kd : Point2.To;
    }
    set gridOrigin(t) {
      this.Pi === null && (this.Pi = new GridPanelSettings());
      const i = this.Pi.kd;
      if (!i.equals(t)) {
        t.isReal() || Util.n("Invalid Panel.gridOrigin: " + t), this.Pi.kd = t.L();
        const e = this.diagram;
        e !== null && this === e.grid && e._r(), this.T(), this.i("gridOrigin", i, t);
      }
    }
    get graduatedMin() {
      return this.gt !== null ? this.gt.dp : 0;
    }
    set graduatedMin(t) {
      Util.r(t, _Panel, "graduatedMin");
      const i = this.graduatedMin;
      if (i !== t && (this.gt === null && (this.gt = new GradPanelSettings()), this.gt.dp = t, this.u(), this.i("graduatedMin", i, t), this.ic())) {
        const e = this.part;
        e !== null && this.Sa(e, "graduatedRange");
      }
    }
    get graduatedMax() {
      return this.gt !== null ? this.gt.gp : 100;
    }
    set graduatedMax(t) {
      Util.r(t, _Panel, "graduatedMax");
      const i = this.graduatedMax;
      if (i !== t && (this.gt === null && (this.gt = new GradPanelSettings()), this.gt.gp = t, this.u(), this.i("graduatedMax", i, t), this.ic())) {
        const e = this.part;
        e !== null && this.Sa(e, "graduatedRange");
      }
    }
    get graduatedRange() {
      return this.graduatedMax - this.graduatedMin;
    }
    get graduatedTickUnit() {
      return this.gt !== null ? this.gt.mp : 10;
    }
    set graduatedTickUnit(t) {
      Util.r(t, _Panel, "graduatedTickUnit");
      const i = this.graduatedTickUnit;
      i !== t && t > 0 && (this.gt === null && (this.gt = new GradPanelSettings()), this.gt.mp = t, this.u(), this.i("graduatedTickUnit", i, t));
    }
    get graduatedTickBase() {
      return this.gt !== null ? this.gt.pp : 0;
    }
    set graduatedTickBase(t) {
      Util.r(t, _Panel, "graduatedTickBase");
      const i = this.graduatedTickBase;
      i !== t && (this.gt === null && (this.gt = new GradPanelSettings()), this.gt.pp = t, this.u(), this.i("graduatedTickBase", i, t));
    }
    get Cs() {
      return this.gt !== null ? this.gt.Cs : null;
    }
    set Cs(t) {
      this.gt !== null ? this.gt.Cs = t : t !== null && (this.gt = new GradPanelSettings(), this.gt.Cs = t);
    }
    get Qe() {
      return this.gt !== null ? this.gt.Qe : null;
    }
    set Qe(t) {
      this.gt !== null ? this.gt.Qe = t : t !== null && (this.gt = new GradPanelSettings(), this.gt.Qe = t);
    }
    get cs() {
      return this.gt !== null ? this.gt.cs : null;
    }
    set cs(t) {
      this.gt !== null ? this.gt.cs = t : t !== null && (this.gt = new GradPanelSettings(), this.gt.cs = t);
    }
    get Fe() {
      return this.gt !== null ? this.gt.Fe : null;
    }
    set Fe(t) {
      this.gt !== null ? this.gt.Fe = t : t !== null && (this.gt = new GradPanelSettings(), this.gt.Fe = t);
    }
    A0(t) {
      super.A0(t);
      const i = this.F.h, e = i.length;
      for (let s = 0; s < e; s++)
        i[s].A0(t);
    }
    ph(t, i) {
      if (this.nt === _Panel.Grid) {
        t.commitTransform(), this.nt.Ji(this, t, i);
        return;
      }
      if (this.nt === _Panel.Graduated) {
        t.commitTransform(), this.nt.Ji(this, t, i);
        return;
      }
      if (this.nt === _Panel.Table)
        if (t.commitTransform(), t instanceof SVGContext) {
          const r = t.currentElement;
          t.currentElement = t.newGroup2("gojs-ts"), this.E2(t, i), t.endGroup(), t.currentElement = r;
        } else
          this.E2(t, i);
      const e = this.isClipping && this.nt === _Panel.Spot;
      e && t.save();
      const s = this.findMainElement(), n = this.F.h, o = n.length;
      for (let r = 0; r < o; r++) {
        const l = n[r];
        e && l === s && (t.clipInsteadOfFill = true), l.Ji(t, i), e && l === s && (t.clipInsteadOfFill = false);
      }
      e && (t.restore(), t.clearContextCache(true));
    }
    E2(t, i) {
      t.lineCap = "butt";
      const e = this.rowCount > 0 ? this.Ze : null, s = this.columnCount > 0 ? this.$e : null;
      e !== null && this.sb(t, i, true, e, true), s !== null && this.sb(t, i, false, s, true), e !== null && this.kL(t, true, e), s !== null && this.kL(t, false, s), e !== null && this.sb(t, i, true, e, false), s !== null && this.sb(t, i, false, s, false);
    }
    kL(t, i, e) {
      const s = e.length, n = this.actualBounds, o = this.naturalBounds;
      let r = true;
      for (let l = 0; l < s; l++) {
        const h = e[l];
        if (h === void 0 || h.actual === 0)
          continue;
        if (r) {
          r = false;
          continue;
        }
        if (i) {
          if (h.position > o.height)
            continue;
        } else if (h.position > o.width)
          continue;
        let a = h.separatorStrokeWidth;
        isNaN(a) && (a = i ? this.defaultRowSeparatorStrokeWidth : this.defaultColumnSeparatorStrokeWidth);
        let f = h.separatorStroke;
        if (f === null && (f = i ? this.defaultRowSeparatorStroke : this.defaultColumnSeparatorStroke), a === 0 || f === null)
          continue;
        this.bn(t, f, false, false, o, n);
        let c = false, u = h.separatorDashArray;
        u === null && (u = i ? this.defaultRowSeparatorDashArray : this.defaultColumnSeparatorDashArray), u !== null && (c = true, t.enableDash(u, 0)), t.beginPath();
        const d = h.position + a;
        i ? d > o.height && (a -= d - o.height) : d > o.width && (a -= d - o.width);
        let m = h.position + a / 2;
        t.lineWidth = a;
        const g = this.ei;
        if (i) {
          m += g.top;
          const p = g.left, y = o.width - g.right;
          t.moveTo(p, m), t.lineTo(y, m);
        } else {
          m += g.left;
          const p = g.top, y = o.height - g.bottom;
          t.moveTo(m, p), t.lineTo(m, y);
        }
        t.stroke(), t.endPath(), c && t.disableDash();
      }
    }
    sb(t, i, e, s, n) {
      const o = s.length, r = this.actualBounds, l = this.naturalBounds, h = this.SL(true), a = this.SL(false);
      for (let f = 0; f < o; f++) {
        const c = s[f];
        if (c === void 0 || c.background === null || c.coversSeparators === n || c.actual === 0)
          continue;
        const u = e ? r.height : r.width;
        if (c.position > u)
          continue;
        let d = c.computeEffectiveSpacing(), m = c.separatorStrokeWidth;
        isNaN(m) && (m = e ? this.defaultRowSeparatorStrokeWidth : this.defaultColumnSeparatorStrokeWidth);
        let g = c.separatorStroke;
        g === null && (g = e ? this.defaultRowSeparatorStroke : this.defaultColumnSeparatorStroke), (g === null || c.index === (e ? h : a)) && (m = 0), d -= m;
        const p = c.position + m;
        let y = d + c.actual;
        if (p + y > u && (y = u - p), y <= 0)
          continue;
        const x = this.ei;
        this.bn(t, c.background, true, false, l, r), e ? t.fillRect(x.left, p + x.top, r.width - (x.left + x.right), y) : t.fillRect(p + x.left, x.top, y, r.height - (x.top + x.bottom));
      }
    }
    SL(t) {
      const i = t ? this.rowCount : this.columnCount;
      for (let e = 0; e < i; e++) {
        const s = t ? this.Ze[e] : this.$e[e];
        if (s !== void 0)
          return s.index;
      }
      return 0;
    }
    g2() {
      const t = this.F.h, i = t.length;
      for (let e = 0; e < i; e++)
        t[e].g2();
      this.fs(true);
    }
    sc(t, i, e) {
      if (!super.sc(t, i, e))
        return false;
      if (this.type === _Panel.Table) {
        const o = this.svg.getElementsByClassName("gojs-ts"), r = o.length !== 0 ? o[0] : null;
        r !== null && (r.innerHTML = ""), t.currentElement = r, this.E2(t, i), t.currentElement = null;
      } else {
        if (this.nt === _Panel.Grid)
          return this.svg.innerHTML = "", this.svg.remove(), false;
        if (this.nt === _Panel.Graduated)
          return this.svg.innerHTML = "", this.svg.remove(), false;
      }
      const s = this.F.h, n = s.length;
      for (let o = 0; o < n; o++)
        s[o].Ji(t, i);
      return true;
    }
    fd(t) {
      return true;
    }
    T0(t, i, e, s) {
      if (!this.isClipping) {
        if (this.Ws() && t.partClipRect !== null) {
          const n = t.partClipRect, o = this.F.h;
          let r = 0, l = 0;
          for (let h = 0; h < o.length; h++) {
            if (!o[h].isVisibleObject())
              continue;
            const a = o[h].actualBounds;
            r = h === 0 ? a.x : Math.min(a.x, r), l = h === 0 ? a.y : Math.min(a.y, l);
          }
          s.setAttributeNS(null, "clip-path", `path('M ${n.x - e.x - r},${n.y - e.y - l} l ${n.width} 0 l 0 ${n.height} l -${n.width} 0 z')`);
          return;
        }
        super.T0(t, i, e, s);
      }
    }
    ec(t, i, e, s, n) {
      const o = this.Mn(), r = this.D, l = 1 / (r.m11 * r.m22 - r.m12 * r.m21);
      let h = r.m22 * l, a = -r.m12 * l, f = -r.m21 * l, c = r.m11 * l, u = l * (r.m21 * r.dy - r.m22 * r.dx), d = l * (r.m12 * r.dx - r.m11 * r.dy);
      if (this.background !== null) {
        const m = t * h + i * f + u, g = t * a + i * c + d, p = e * h + s * f + u, y = e * a + s * c + d;
        n.e(0, 0);
        const x = this.naturalBounds, b = Geo.Ml(0, 0, x.width, x.height, m, g, p, y, n);
        return n.D(r), b;
      } else {
        o || (h = 1, a = 0, f = 0, c = 1, u = 0, d = 0);
        const m = t * h + i * f + u, g = t * a + i * c + d, p = e * h + s * f + u, y = e * a + s * c + d;
        n.e(p, y);
        let x = (p - m) * (p - m) + (y - g) * (y - g), b = false;
        const k = this.F.h, S = k.length, M = Point2.a();
        let A = null, C = 1 / 0, P = null;
        const N = this.isClipping && this.nt === _Panel.Spot;
        N && (P = Point2.a(), A = this.findMainElement(), b = A.ec(m, g, p, y, P), b && (C = (m - P.x) * (m - P.x) + (g - P.y) * (g - P.y)));
        for (let T = 0; T < S; T++) {
          const L = k[T];
          if (!L.visible || L === A || !L.ec(m, g, p, y, M))
            continue;
          b = true;
          const D = (m - M.x) * (m - M.x) + (g - M.y) * (g - M.y);
          D < x && (x = D, n.set(M));
        }
        return N && (C > x && n.set(P), Point2.o(P)), Point2.o(M), o && n.D(r), b;
      }
    }
    Bu() {
      const t = this.F.h, i = t.length;
      for (let e = 0; e < i; e++)
        t[e].Bu();
      super.Bu();
    }
    u(t) {
      if (this.Ko())
        return;
      super.u(t);
      let i = null;
      (this.nt === _Panel.Auto || this.nt === _Panel.Link) && (i = this.findMainElement());
      const e = this.F.h, s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n];
        if ((o === i || o.isPanelMain) && o.u(true), o.desiredSize.isReal())
          continue;
        const r = o.qs(false);
        !(o instanceof Placeholder2) && !(o instanceof _Panel) && !(o instanceof TextBlock2) && r === 0 || o.u(true);
      }
    }
    oc() {
      if (this.Ko())
        return;
      this.ae(true), this.ro(true);
      const t = this.F.h, i = t.length;
      for (let e = 0; e < i; e++)
        t[e].oc();
    }
    hd() {
      if (this.j1() === false) {
        this.cd(true), this.Ma(true);
        const t = this.F.h, i = t.length;
        for (let e = 0; e < i; e++)
          t[e].m2();
      }
    }
    m2() {
      this.Ma(true);
      const t = this.F.h, i = t.length;
      for (let e = 0; e < i; e++)
        t[e].m2();
    }
    ld(t, i, e, s) {
      const n = this.Zo;
      n.e(0, 0, 0, 0);
      const o = this.desiredSize, r = this.minSize;
      e === void 0 && (e = r.width, s = r.height), e = Math.max(e, r.width), s = Math.max(s, r.height);
      const l = this.maxSize;
      isNaN(o.width) || (t = Math.min(o.width, l.width)), isNaN(o.height) || (i = Math.min(o.height, l.height)), t = Math.max(e, t), i = Math.max(s, i);
      const h = this.ei;
      t = Math.max(t - h.left - h.right, 0), i = Math.max(i - h.top - h.bottom, 0);
      const a = this.F.h;
      this.nt.measure(this, t, i, a, n, e, s);
      let f = n.width + h.left + h.right, c = n.height + h.top + h.bottom;
      isFinite(o.width) && (f = o.width), isFinite(o.height) && (c = o.height), f = Math.min(l.width, f), c = Math.min(l.height, c), f = Math.max(r.width, f), c = Math.max(r.height, c), f = Math.max(e, f), c = Math.max(s, c), n.Do(f, c), this.naturalBounds.Do(f, c), this.oo(0, 0, f, c);
    }
    findMainElement() {
      if (this.fl === null) {
        const t = this.F.h, i = t.length;
        if (i === 0)
          return null;
        for (let e = 0; e < i; e++) {
          const s = t[e];
          if (s.isPanelMain === true)
            return this.fl = s, s;
        }
        this.fl = t[0];
      }
      return this.fl;
    }
    Jo() {
      return this.part !== null ? this.part.locationObject : null;
    }
    get panelLayoutState() {
      return this.O2;
    }
    set panelLayoutState(t) {
      this.O2 = t;
    }
    gh(t, i, e, s) {
      const n = this.F.h;
      if (this.actualBounds.e(t, i, e, s), !this.desiredSize.isReal()) {
        let o = this.qs(true);
        const r = this.measuredBounds, l = r.width, h = r.height, a = this.ol, f = a.left + a.right, c = a.top + a.bottom;
        switch (l === e && h === s && (o = 0), o) {
          case 0:
            (l > e || h > s) && (this.u(), this.wt(l > e ? e : l, h > s ? s : h, 0, 0));
            break;
          case 2:
            this.u(true), this.wt(e + f, s + c, 0, 0);
            break;
          case 5:
            this.u(true), this.wt(e + f, h + c, 0, 0);
            break;
          case 4:
            this.u(true), this.wt(l + f, s + c, 0, 0);
            break;
        }
      }
      this.nt.arrange(this, n, this.Zo);
    }
    dh(t) {
      const i = this.naturalBounds, e = this.Jo();
      if (Rect2.contains(0, 0, i.width, i.height, t.x, t.y)) {
        const s = this.F.h, n = s.length, o = Point2.H(0, 0);
        for (let r = n; r--; ) {
          const l = s[r];
          if (!(!l.visible && l !== e) && (o.set(t).Ge(l.D), l.containsPoint(o)))
            return Point2.o(o), true;
        }
        return Point2.o(o), this.Ft !== null;
      }
      return false;
    }
    M0(t) {
      if (this.so === t)
        return this;
      const i = this.F.h, e = i.length;
      for (let s = 0; s < e; s++) {
        const o = i[s].M0(t);
        if (o !== null)
          return o;
      }
      return null;
    }
    walkVisualTreeFrom(t, i) {
      if (i(this, t), t instanceof _Panel) {
        const e = t.F.h, s = e.length;
        for (let n = 0; n < s; n++)
          this.walkVisualTreeFrom(e[n], i);
      }
    }
    il(t) {
      this.ML(this, t);
    }
    ML(t, i) {
      i(t);
      const e = t.F.h, s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n];
        o instanceof _Panel && this.ML(o, i);
      }
    }
    gI(t) {
      this.PL(this, t);
    }
    PL(t, i) {
      if (i(t), t instanceof _Panel) {
        const e = t.F.h, s = e.length;
        for (let n = 0; n < s; n++)
          this.PL(e[n], i);
      }
    }
    findInVisualTree(t) {
      return this.NL(this, t);
    }
    NL(t, i) {
      if (i(t))
        return t;
      if (t instanceof _Panel) {
        const e = t.F.h, s = e.length;
        for (let n = 0; n < s; n++) {
          const o = this.NL(e[n], i);
          if (o !== null)
            return o;
        }
      }
      return null;
    }
    findObject(t) {
      if (this.name === t)
        return this;
      const i = this.F.h;
      let e = i.length;
      this.mI() && (e = this.yp());
      for (let s = 0; s < e; s++) {
        const n = i[s];
        if (n instanceof _Panel) {
          const o = n.findObject(t);
          if (o !== null)
            return o;
        }
        if (n.name === t)
          return n;
      }
      return null;
    }
    CL() {
      const t = this.F.h, i = t.length;
      let e = 0;
      for (let s = 0; s < i; s++) {
        const n = t[s];
        n instanceof _Panel ? e = Math.max(e, n.CL()) : n instanceof Shape2 && (e = Math.max(e, n.pI()));
      }
      return e;
    }
    Mn() {
      return !(this.type === _Panel.TableRow || this.type === _Panel.TableColumn);
    }
    ll() {
      return this.type === _Panel.TableRow || this.type === _Panel.TableColumn;
    }
    sA(t, i, e) {
      if (this.pickable === false || (i === void 0 && (i = null), e === void 0 && (e = null), this.hs()))
        return null;
      const s = this.naturalBounds, n = 1 / this.getDocumentScale(), o = this.Mn(), r = o ? t : Point2.H(t.x, t.y).Ge(this.D), l = this.diagram;
      let h = 10, a = 5;
      if (l !== null && (h = l.getInputOption("extraTouchArea"), a = h / 2), Rect2.contains(-(a * n), -(a * n), s.width + h * n, s.height + h * n, r.x, r.y)) {
        if (!this.dc) {
          const c = this.F.h, u = c.length, d = Point2.a(), m = this.isClipping && this.nt === _Panel.Spot, g = m ? this.findMainElement() : null;
          if (m && (g.Mn() ? d.set(t).Ge(g.D) : d.set(t), !g.containsPoint(d)))
            return Point2.o(d), o || Point2.o(r), null;
          const p = this.Jo();
          for (let y = u; y--; ) {
            const x = c[y];
            if (!x.visible && x !== p || (x.Mn() ? d.set(t).Ge(x.D) : d.set(t), m && x === g))
              continue;
            let b = null;
            if (x instanceof _Panel ? b = x.sA(d, i, e) : x.pickable === true && x.containsPoint(d) && (b = x), b !== null && (i !== null && (b = i(b)), b !== null && (e === null || e(b))))
              return Point2.o(d), o || Point2.o(r), b;
          }
          Point2.o(d);
        }
        if (this.background === null)
          return o || Point2.o(r), null;
        const f = Rect2.contains(0, 0, s.width, s.height, r.x, r.y) ? this : null;
        return o || Point2.o(r), f;
      }
      return o || Point2.o(r), null;
    }
    nA(t, i, e, s) {
      if (this.pickable === false)
        return false;
      i === void 0 && (i = null), e === void 0 && (e = null);
      const n = this.naturalBounds, o = this.Mn(), r = o ? t : Point2.H(t.x, t.y).Ge(this.D), l = this.ll(), h = Rect2.contains(0, 0, n.width, n.height, r.x, r.y);
      if (l || h) {
        if (!this.dc) {
          const a = this.F.h, f = a.length, c = Point2.a(), u = this.Jo();
          for (let d = f; d--; ) {
            const m = a[d];
            if (!m.visible && m !== u)
              continue;
            m.Mn() ? c.set(t).Ge(m.D) : c.set(t);
            let g = m;
            const p = m instanceof _Panel ? m : null;
            if (p !== null ? p.nA(c, i, e, s) : g.containsPoint(c)) {
              if (g.pickable === false)
                continue;
              i !== null && (g = i(g)), g !== null && (e === null || e(g)) && s.add(g);
            }
          }
          Point2.o(c);
        }
        return o || Point2.o(r), h && this.background !== null;
      }
      return o || Point2.o(r), false;
    }
    Um(t, i, e, s, n, o) {
      if (this.pickable === false)
        return false;
      i === void 0 && (i = null), e === void 0 && (e = null);
      let r = o;
      if (o === void 0 && (r = Transform.a(), r.ti()), r.hf(this.D), this.containedInRect(t, r))
        return this.V2(i, e, n), o === void 0 && Transform.o(r), true;
      if (this.intersectsRect(t, r)) {
        if (!this.dc) {
          const l = this.Jo(), h = this.F.h, a = h.length;
          for (let f = a; f--; ) {
            const c = h[f];
            if (!c.visible && c !== l)
              continue;
            const u = c.actualBounds, d = this.naturalBounds;
            if (u.x > d.width || u.y > d.height || u.x + u.width < 0 || u.y + u.height < 0)
              continue;
            let m = c;
            const g = c instanceof _Panel ? c : null, p = Transform.a();
            p.set(r), (g !== null ? g.Um(t, i, e, s, n, p) : m.eL(t, s, p)) && (i !== null && (m = i(m)), m !== null && (e === null || e(m)) && n.add(m)), Transform.o(p);
          }
        }
        return o === void 0 && Transform.o(r), s;
      }
      return o === void 0 && Transform.o(r), false;
    }
    V2(t, i, e) {
      const s = this.F.h, n = s.length;
      for (let o = n; o--; ) {
        const r = s[o];
        if (!r.visible)
          continue;
        const l = r.actualBounds, h = this.naturalBounds;
        if (l.x > h.width || l.y > h.height || l.x + l.width < 0 || l.y + l.height < 0)
          continue;
        r instanceof _Panel && r.V2(t, i, e);
        let a = r;
        t !== null && (a = t(a)), a !== null && (i === null || i(a)) && e.add(a);
      }
    }
    oA(t, i, e, s, n, o) {
      if (this.pickable === false)
        return false;
      e === void 0 && (e = null), s === void 0 && (s = null);
      const r = this.naturalBounds, l = this.Mn(), h = l ? t : Point2.H(t.x, t.y).Ge(this.D), a = l ? i : Point2.H(i.x, i.y).Ge(this.D), f = h.distanceSquaredPoint(a), c = h.x > 0 && h.x < r.width && h.y > 0 && h.y < r.height || Point2.distanceLineSegmentSquared(h.x, h.y, 0, 0, 0, r.height) <= f || Point2.distanceLineSegmentSquared(h.x, h.y, 0, r.height, r.width, r.height) <= f || Point2.distanceLineSegmentSquared(h.x, h.y, r.width, r.height, r.width, 0) <= f || Point2.distanceLineSegmentSquared(h.x, h.y, r.width, 0, 0, 0) <= f, u = h.distanceSquared(0, 0) <= f && h.distanceSquared(0, r.height) <= f && h.distanceSquared(r.width, 0) <= f && h.distanceSquared(r.width, r.height) <= f;
      if (l || (Point2.o(h), Point2.o(a)), c) {
        if (!this.dc) {
          const d = Point2.a(), m = Point2.a(), g = this.Jo(), p = this.F.h, y = p.length;
          for (let x = y; x--; ) {
            const b = p[x];
            if (!b.visible && b !== g)
              continue;
            const k = b.actualBounds, S = this.naturalBounds;
            if (l && (k.x > S.width || k.y > S.height || k.x + k.width < 0 || k.y + k.height < 0))
              continue;
            if (b.Mn()) {
              const C = b.D;
              d.set(t).Ge(C), m.set(i).Ge(C);
            } else
              d.set(t), m.set(i);
            let M = b;
            const A = b instanceof _Panel ? b : null;
            (A !== null ? A.oA(d, m, e, s, n, o) : M.sL(d, m, n)) && (e !== null && (M = e(M)), M !== null && (s === null || s(M)) && o.add(M));
          }
          Point2.o(d), Point2.o(m);
        }
        return n ? c : u;
      }
      return false;
    }
    F2(t) {
      let i = null;
      if (t instanceof Shape2) {
        i = t.spot1, i === Spot2.Default && (i = null);
        const e = t.geometry;
        e !== null && i === null && (i = e.spot1);
      }
      return i === null && (i = Spot2.TopLeft), i;
    }
    R2(t) {
      let i = null;
      if (t instanceof Shape2) {
        i = t.spot2, i === Spot2.Default && (i = null);
        const e = t.geometry;
        e !== null && i === null && (i = e.spot2);
      }
      return i === null && (i = Spot2.BottomRight), i;
    }
    add(...t) {
      for (let i = 0; i < t.length; i++)
        this.insertAt(this.F.count, t[i]);
      return this;
    }
    elt(t) {
      return this.F.elt(t);
    }
    insertAt(t, i) {
      i instanceof Part2 && Util.n("Cannot add a Part to a Panel: " + i + "; use a Panel instead"), (this === i || this.isContainedBy(i)) && (this === i && Util.n("Cannot make a Panel contain itself: " + this.toString()), Util.n("Cannot make a Panel indirectly contain itself: " + this.toString() + " already contains " + i.toString()));
      const e = i.panel;
      if (e !== null && e !== this && Util.n("Cannot add a GraphObject that already belongs to another Panel to this Panel: " + i.toString() + ", already contained by " + e.toString() + ", cannot be shared by this Panel: " + this.toString()), this.nt === _Panel.Grid && !(i instanceof Shape2) && Util.n("Can only add Shapes to a Grid Panel, not: " + i), this.nt === _Panel.Graduated && !(i instanceof Shape2 || i instanceof TextBlock2) && Util.n("Can only add Shapes or TextBlocks to a Graduated Panel, not: " + i), i.Pa(this), i.rl = null, this.itemArray !== null) {
        const r = i.data;
        r !== null && typeof r == "object" && (this.Js === null && (this.Js = new GMap2()), this.Js.add(r, i));
      }
      const s = this.F;
      let n = -1;
      if (e === this) {
        let r = -1;
        const l = this.F.h, h = l.length;
        for (let a = 0; a < h; a++)
          if (l[a] === i) {
            r = a;
            break;
          }
        if (r !== -1) {
          if (r === t || r + 1 >= s.count && t >= s.count)
            return;
          s.removeAt(r), n = r;
        } else
          Util.n("element " + i.toString() + " has panel " + e.toString() + " but is not contained by it.");
      }
      (t < 0 || t > s.count) && (t = s.count), s.insertAt(t, i), (t === 0 || i.isPanelMain) && (this.fl = null), this.Ko() || this.u(), i.u(false), i.portId !== null ? this.Nn = true : i instanceof _Panel && i.Nn === true && (this.Nn = true), this.cs = null, this.isEnabledObject() || this.nb(i, false);
      const o = this.part;
      if (o !== null) {
        o.V0(), o.gc(), this.Nn && o instanceof Node2 && (o.Nn = true), o.Nn && o instanceof Node2 && (o.ue = null);
        const r = this.diagram;
        if (r !== null && r.undoManager.isUndoingRedoing)
          return;
        n !== -1 && o.raiseChangedEvent(4, "elements", this, i, null, n, null), o.raiseChangedEvent(3, "elements", this, null, i, null, t);
      }
    }
    get Nn() {
      return (this.l & 8388608) !== 0;
    }
    set Nn(t) {
      (this.l & 8388608) !== 0 !== t && (this.l = this.l ^ 8388608);
    }
    f2() {
      return (this.l & 16777216) !== 0;
    }
    B2(t) {
      t ? this.l |= 16777216 : this.l &= -16777217;
    }
    dI(t) {
      t.Pa(this), t.rl = null;
      const i = this.F, e = i.count;
      i.insertAt(e, t);
      const s = this.part;
      if (s !== null) {
        s.V0(), t.portId !== null && s instanceof Node2 && (s.Nn = true);
        const n = this.diagram;
        if (n !== null && n.undoManager.isUndoingRedoing)
          return;
        s.raiseChangedEvent(3, "elements", this, null, t, null, e);
      }
    }
    ER(t) {
      const i = this.F.h, e = i.length;
      let s = -1;
      for (let n = 0; n < e; n++)
        if (i[n] === t) {
          s = n;
          break;
        }
      return s;
    }
    remove(t) {
      Util.s(t, GraphObject2, _Panel, "remove:element");
      const i = this.F.h, e = i.length;
      let s = -1;
      for (let n = 0; n < e; n++)
        if (i[n] === t) {
          s = n;
          break;
        }
      s !== -1 && this.re(s, true);
    }
    removeAt(t) {
      Debug && Util.r(t, _Panel, "removeAt:idx"), t >= 0 && this.re(t, true);
    }
    re(t, i) {
      const e = this.F, s = e.elt(t);
      if (s.rl = null, s.Pa(null), this.Js !== null) {
        const o = s.data;
        typeof o == "object" && this.Js.remove(o);
      }
      e.removeAt(t), this.ae(false), this.u(), this.fl === s && (this.fl = null), this.cs = null;
      const n = this.part;
      if (n !== null) {
        n.V0(), n.gc(), n.invalidateAdornments(), n instanceof Node2 && (s instanceof _Panel ? s.walkVisualTreeFrom(s, (r, l) => n.k2(l, i)) : n.k2(s, i));
        const o = this.diagram;
        if (o !== null && o.undoManager.isUndoingRedoing)
          return;
        n.raiseChangedEvent(4, "elements", this, s, null, t, null);
      }
    }
    get Ze() {
      return this.B === null && (this.B = new TablePanelSettings()), this.B.Ze;
    }
    get rowCount() {
      return this.B === null ? 0 : this.Ze.length;
    }
    getRowDefinition(t) {
      Debug && Util.r(t, _Panel, "getRowDefinition:idx"), t < 0 && Util.G(t, ">= 0", _Panel, "getRowDefinition:idx"), t = Math.round(t);
      const i = this.Ze;
      if (i[t] === void 0) {
        const e = new RowColumnDefinition2();
        e.Pa(this), e.isRow = true, e.index = t, i[t] = e, this.raiseChangedEvent(3, "rowdefs", this, null, e, null, t);
      }
      return i[t];
    }
    removeRowDefinition(t) {
      if (Debug && Util.r(t, _Panel, "removeRowDefinition:idx"), t < 0 && Util.G(t, ">= 0", _Panel, "removeRowDefinition:idx"), this.rowCount === 0)
        return;
      t = Math.round(t);
      const i = this.Ze, e = i[t];
      if (e) {
        i[t] = void 0;
        let s = i.length - 1;
        for (; s >= 0 && i[s--] === void 0; )
          i.length--;
        this.raiseChangedEvent(4, "rowdefs", this, e, null, t, null), this.u();
      }
    }
    IA(t, i) {
      const e = this.Ze;
      if (!(t < 0)) {
        if (e[t] = i instanceof RowColumnDefinition2 ? i : void 0, !i) {
          let s = e.length - 1;
          for (; s >= 0 && e[s--] === void 0; )
            e.length--;
        }
        this.u();
      }
    }
    get $e() {
      return this.B === null && (this.B = new TablePanelSettings()), this.B.$e;
    }
    get columnCount() {
      return this.B === null ? 0 : this.$e.length;
    }
    getColumnDefinition(t) {
      Debug && Util.r(t, _Panel, "getColumnDefinition:idx"), t < 0 && Util.G(t, ">= 0", _Panel, "getColumnDefinition:idx"), t = Math.round(t);
      const i = this.$e;
      if (i[t] === void 0) {
        const e = new RowColumnDefinition2();
        e.Pa(this), e.isRow = false, e.index = t, i[t] = e, this.raiseChangedEvent(3, "coldefs", this, null, e, null, t);
      }
      return i[t];
    }
    removeColumnDefinition(t) {
      if (Debug && Util.r(t, _Panel, "removeColumnDefinition:idx"), t < 0 && Util.G(t, ">= 0", _Panel, "removeColumnDefinition:idx"), this.columnCount === 0)
        return;
      t = Math.round(t);
      const i = this.$e, e = i[t];
      if (e) {
        i[t] = void 0;
        let s = i.length - 1;
        for (; s >= 0 && i[s--] === void 0; )
          i.length--;
        this.raiseChangedEvent(4, "coldefs", this, e, null, t, null), this.u();
      }
    }
    OA(t, i) {
      const e = this.$e;
      if (!(t < 0)) {
        if (e[t] = i instanceof RowColumnDefinition2 ? i : void 0, !i) {
          let s = e.length - 1;
          for (; s >= 0 && e[s--] === void 0; )
            e.length--;
        }
        this.u();
      }
    }
    addRowColumnDefinition(t) {
      let i = null;
      return t.isRow ? i = this.getRowDefinition(t.index) : t.isRow || (i = this.getColumnDefinition(t.index)), i && i.J1(t), this;
    }
    addRowDefinition(t, i) {
      const e = this.getRowDefinition(t);
      return e && e.J1(new RowColumnDefinition2(i)), this;
    }
    addColumnDefinition(t, i) {
      const e = this.getColumnDefinition(t);
      return e && e.J1(new RowColumnDefinition2(i)), this;
    }
    get rowSizing() {
      return this.B !== null ? this.B.wp : 3;
    }
    set rowSizing(t) {
      const i = this.rowSizing;
      i !== t && (Debug && t !== 3 && t !== 2 && Util.n("Panel.rowSizing must be ProportionalExtra or None, not: " + t), this.B === null && (this.B = new TablePanelSettings()), this.B.wp = t, this.u(), this.i("rowSizing", i, t));
    }
    get columnSizing() {
      return this.B !== null ? this.B.xp : 3;
    }
    set columnSizing(t) {
      const i = this.columnSizing;
      i !== t && (Debug && t !== 3 && t !== 2 && Util.n("Panel.columnSizing must be ProportionalExtra or None, not: " + t), this.B === null && (this.B = new TablePanelSettings()), this.B.xp = t, this.u(), this.i("columnSizing", i, t));
    }
    get topIndex() {
      return this.B !== null ? this.B.bp : 0;
    }
    set topIndex(t) {
      const i = this.topIndex;
      i !== t && ((!isFinite(t) || t < 0) && Util.n("Panel.topIndex must be greater than zero and a real number, not: " + t), this.B === null && (this.B = new TablePanelSettings()), this.B.bp = t, this.u(), this.i("topIndex", i, t));
    }
    get leftIndex() {
      return this.B !== null ? this.B.kp : 0;
    }
    set leftIndex(t) {
      const i = this.leftIndex;
      i !== t && ((!isFinite(t) || t < 0) && Util.n("Panel.leftIndex must be greater than zero and a real number, not: " + t), this.B === null && (this.B = new TablePanelSettings()), this.B.kp = t, this.u(), this.i("leftIndex", i, t));
    }
    findRowForLocalY(t) {
      if (t < 0 || this.type !== _Panel.Table || this.rowCount === 0)
        return -1;
      let i = 0;
      const e = this.Ze, s = e.length;
      let n = this.topIndex;
      for (; n < s; n++) {
        const o = e[n];
        if (o !== void 0 && (i += o.total, t < i))
          return n;
      }
      return n;
    }
    findColumnForLocalX(t) {
      if (t < 0 || this.type !== _Panel.Table || this.columnCount === 0)
        return -1;
      let i = 0;
      const e = this.$e, s = e.length;
      let n = this.leftIndex;
      for (; n < s; n++) {
        const o = e[n];
        if (o !== void 0 && (i += o.total, t < i))
          return n;
      }
      return n;
    }
    graduatedPointForValue(t, i) {
      if (i === void 0 && (i = new Point2(NaN, NaN)), this.type !== _Panel.Graduated)
        return i.e(NaN, NaN), i;
      t = Math.min(Math.max(t, this.graduatedMin), this.graduatedMax);
      const e = this.findMainElement();
      return e.geometry.getPointAlongPath((t - this.graduatedMin) / this.graduatedRange, i), e.D.Pt(i);
    }
    graduatedValueForPoint(t) {
      if (this.type !== _Panel.Graduated)
        return NaN;
      const i = this.findMainElement();
      return i.D.rs(t), i.geometry.getFractionForPoint(t) * this.graduatedRange + this.graduatedMin;
    }
    get data() {
      return this.si;
    }
    set data(t) {
      const i = this.si;
      if (i !== t) {
        const e = this instanceof Part2 && !(this instanceof Adornment2);
        e && Util.t(t, "object", _Panel, "data"), this.ui(), this.si = t;
        const s = this.diagram;
        if (s !== null)
          if (e)
            s.partManager.yI(this, i, t);
          else {
            const n = this.panel;
            n !== null && n.Js !== null && (i !== null && n.Js.remove(i), t !== null && n.Js.add(t, this));
          }
        if (this.i("data", i, t), s !== null && s.undoManager.isUndoingRedoing)
          return;
        t !== null && this.updateTargetBindings();
      }
    }
    get itemIndex() {
      return this.xd;
    }
    set itemIndex(t) {
      const i = this.xd;
      i !== t && (this.xd = t, this.i("itemIndex", i, t));
    }
    get js() {
      return this.g !== null ? this.g.js : null;
    }
    set js(t) {
      this.Ii !== t && (this.g === null && (this.g = new GraphObjectTemplateSettings()), this.g.js = t);
    }
    S2() {
      return this.js !== null;
    }
    dL() {
      const t = this.js;
      return t !== null && t.f;
    }
    ui() {
      let t = this.js;
      if (t === null)
        this.data !== null && Util.n("Template cannot have .data be non-null: " + this), this.js = t = new List2();
      else if (t.f)
        return this;
      const i = new List2();
      this.B2(false), this.walkVisualTreeFrom(this, (n, o) => {
        o.uh();
        const r = o.Ii;
        if (r !== null) {
          o.p2(false);
          const l = r.iterator;
          for (; l.next(); ) {
            const h = l.value;
            h.mode === 2 && o.p2(true);
            const a = h.sourceName;
            if (h.isToObject) {
              a === "/" && n.B2(true);
              const f = h.iL(n, o);
              f !== null && (i.add(f), f.no === null && (f.no = new List2()), f.no.add(h));
            }
            t.add(h);
          }
        }
        if (o instanceof _Panel && o.type === _Panel.Table) {
          if (o.rowCount > 0) {
            const l = o.Ze, h = l.length;
            for (let a = 0; a < h; a++) {
              const f = l[a];
              if (f !== void 0 && f.Zs !== null) {
                const c = f.Zs.iterator;
                for (; c.next(); ) {
                  const u = c.value;
                  u.Te = f, u.Sd = 2, u.mc = f.index, t.add(u);
                }
              }
            }
          }
          if (o.columnCount > 0) {
            const l = o.$e, h = l.length;
            for (let a = 0; a < h; a++) {
              const f = l[a];
              if (f !== void 0 && f.Zs !== null) {
                const c = f.Zs.iterator;
                for (; c.next(); ) {
                  const u = c.value;
                  u.Te = f, u.Sd = 1, u.mc = f.index, t.add(u);
                }
              }
            }
          }
        }
      });
      const e = i.iterator;
      for (; e.next(); ) {
        const n = e.value;
        if (n.no !== null) {
          n.p2(true);
          const o = n.no.iterator;
          for (; o.next(); ) {
            const r = o.value;
            n.Ii === null && (n.Ii = new List2()), n.Ii.add(r);
          }
        }
        n.no = null;
      }
      let s = t.iterator;
      for (; s.next(); ) {
        const n = s.value;
        let o = n.Te;
        if (o !== null) {
          n.Te = null;
          const r = n.targetProperty, l = r.indexOf(".");
          if (l > 0 && o instanceof _Panel) {
            const h = r.substring(0, l), a = r.substring(l + 1), f = o.findObject(h);
            f !== null ? (o = f, n.targetProperty = a) : (Util.ft('Warning: unable to find GraphObject named "' + h + '" for Binding: ' + n.toString()), o = null);
          }
          if (o instanceof RowColumnDefinition2) {
            const h = GSet2.ps(o.panel);
            n.targetId = h === void 0 ? -1 : h, o.panel.so = n.targetId;
          } else if (o instanceof GraphObject2) {
            const h = GSet2.ps(o);
            n.targetId = h === void 0 ? -1 : h, o.so = n.targetId;
          } else
            Util.n("Unknown type of binding target: " + o);
          n.check(o);
        }
      }
      return t.w(), this instanceof Part2 && (this.De() && this.ensureBounds(), Debug && !_Panel.AL && this.walkVisualTreeFrom(this, (n, o) => {
        if (o instanceof _Panel && (o.type === _Panel.Auto || o.type === _Panel.Spot || o.type === _Panel.Graduated) && o.elements.count <= 1 && !(o instanceof Part2)) {
          let r = false;
          if (o.elements.count === 1 && (r = o.itemArray !== null, !r)) {
            for (s = t.iterator; s.next(); )
              if (s.value.targetProperty === "itemArray") {
                r = true;
                break;
              }
          }
          r || (Util.ft("Auto, Spot, or Graduated Panel should not have zero or one elements: " + o.toString() + " in " + n.toString()), _Panel.AL = true);
        }
      })), this;
    }
    copyTemplate(t) {
      t === void 0 && (t = false);
      const i = this.copy();
      return i.gI((e) => {
        e instanceof _Panel && (e.js = null, e.si = null);
        const s = e.Ii;
        s !== null && (e.Ii = null, s.each((o) => e.bind(o.copy())));
        const n = e.Ns;
        n !== null && (e.Ns = null, n.each((o) => e.trigger(o.value.copy())));
      }), t && i.ui(), i;
    }
    updateTargetBindings(t) {
      const i = this.js;
      if (i === null)
        return;
      t === void 0 && (t = "");
      const e = i.iterator;
      for (; e.next(); ) {
        const s = e.value, n = this.LL(s, t);
        if (n === null)
          continue;
        const { data: o, elt: r } = n;
        s.isToTheme && this.diagram === null || r !== void 0 && s.updateTarget(r, o);
      }
    }
    Uo() {
      if (this.diagram !== null)
        if (this.S2()) {
          const t = this.js.iterator;
          for (; t.next(); ) {
            const i = t.value;
            if (!i.isToTheme)
              continue;
            const e = this.LL(i);
            if (e === null)
              continue;
            const { data: s, elt: n } = e;
            n !== void 0 && i.updateTarget(n, s);
          }
        } else {
          const t = this.F.h, i = t.length;
          for (let e = 0; e < i; e++)
            t[e].Uo();
        }
    }
    LL(t, i = "") {
      const e = t.sourceProperty;
      if (i !== "" && e !== "" && e !== i)
        return null;
      const s = t.targetProperty;
      if (t.converter === null && s === "")
        return null;
      let o = this.data;
      const r = t.sourceName;
      if (t.isToObject) {
        if (o = this.tL(r), o === null)
          return null;
      } else if (t.isToModel) {
        const f = this.diagram;
        if (f === null)
          return null;
        o = f.model.modelData;
      }
      let l = this;
      const h = t.targetId;
      if (h !== -1) {
        if (l = this.M0(h), l === null)
          return null;
      } else
        t.Te !== null && (l = t.Te);
      r === "/" ? o = l.part : r === "." ? o = l : r === ".." && (o = l.panel);
      const a = t.Sd;
      if (a !== 0) {
        if (!(l instanceof _Panel))
          return null;
        a === 1 ? l = l.getColumnDefinition(t.mc) : a === 2 && (l = l.getRowDefinition(t.mc));
      }
      return { data: o, elt: l };
    }
    get itemArray() {
      return this.bh;
    }
    set itemArray(t) {
      Debug && t !== null && !Array.isArray(t) && Util.n("Panel.itemArray must be an Array-like object or null, not: " + t);
      const i = this.bh;
      if (i !== t || t !== null && this.wI(t)) {
        const e = this.diagram;
        if (i !== t && (e !== null && i !== null && e.partManager.TP(this, e), this.bh = t, e !== null && t !== null && e.partManager.LP(this, e)), this.i("itemArray", i, t), e !== null && e.undoManager.isUndoingRedoing)
          return;
        this.TL(i, t);
      }
    }
    findItemPanelForData(t) {
      return t == null || this.Js === null ? null : (Util.t(t, "object", _Panel, "findItemPanelForData"), this.Js.getValue(t));
    }
    wI(t) {
      const i = this.F.h, e = i.length, s = t.length;
      let n = 0, o = null;
      for (; n < e && (o = i[n], !(o instanceof _Panel) || o.data === null); )
        n++, o = i[n];
      if (e - n !== s)
        return true;
      if (o === null)
        return s > 0;
      let r = 0;
      for (; n < e && r < s; ) {
        if (o = i[n], !(o instanceof _Panel) || o.data !== t[r])
          return true;
        n++, r++;
      }
      return false;
    }
    yp() {
      if (this.type === _Panel.Spot || this.type === _Panel.Auto)
        return Math.min(this.F.length, 1);
      if (this.type === _Panel.Link) {
        const t = this.F, i = t.length;
        let e = 0;
        for (; e < i; e++) {
          const s = t.elt(e);
          if (!(s instanceof Shape2) || !s.isPanelMain)
            return e;
        }
        return e;
      }
      if (this.type === _Panel.Table && this.F.length > 0) {
        const i = this.F.elt(0);
        if (i.isPanelMain && i instanceof _Panel && i.ll())
          return 1;
      }
      return 0;
    }
    rebuildItemElements() {
      const t = this.yp();
      for (; this.F.length > t; )
        this.re(this.F.length - 1, false);
      this.TL(null, this.itemArray);
    }
    TL(t, i) {
      const e = this.yp(), s = i;
      if (s === null || s.length === 0) {
        for (; this.F.length > e; )
          this.re(this.F.length - 1, false);
        return;
      }
      if (this.F.length <= e) {
        const n = s.length;
        for (let o = 0; o < n; o++)
          this.ob(s[o], o, true);
      } else {
        let n = e;
        for (let r = 0; r < s.length; r++, n++) {
          const l = s[r], h = n < this.F.length ? this.F.elt(n) : null;
          if (h instanceof _Panel) {
            if (h.data !== l) {
              const a = this.z2(h.data, r), f = this.z2(l, r);
              let c = f !== a;
              if (!c) {
                const u = this.X2(h.data, r, a);
                c = this.X2(l, r, f) !== u;
              }
              c ? (this.re(n, false), this.ob(l, r, false)) : h.data = l;
            }
          } else
            this.ob(l, r, false);
        }
        for (; n < this.F.length; )
          this.re(n, false);
        this.fl = null, this.Y2(e, 0), this.Ko() || this.u(), this.cs = null, this.isEnabledObject() || this.nb(this, false);
        const o = this.part;
        o !== null && (o.V0(), o.gc(), this.Nn && o instanceof Node2 && (o.Nn = true), o.Nn && o instanceof Node2 && (o.ue = null));
      }
    }
    ob(t, i, e) {
      if (t == null || i < 0)
        return null;
      const s = this.z2(t, i), n = this.X2(t, i, s);
      if (n !== null) {
        n.ui();
        const o = n.copy();
        if (o.f2()) {
          const l = this.findBindingPanel();
          l !== null && l.B2(true);
        }
        typeof t == "object" && (this.Js === null && (this.Js = new GMap2()), this.Js.add(t, o));
        const r = i + this.yp();
        return this.insertAt(r, o), e && (o.si = t, this.Y2(r, i), o.si = null), o.data = t, o;
      }
      return null;
    }
    xI(t) {
      if (t < 0)
        return;
      const i = t + this.yp();
      this.re(i, true), this.Y2(i, t);
    }
    Y2(t, i) {
      const e = this.F;
      let s = t, n = i;
      for (; s < e.length; ) {
        const o = e.elt(s);
        o instanceof _Panel && o.bI(s, n), s++, n++;
      }
    }
    bI(t, i) {
      this.type === _Panel.TableRow ? this.row = t : this.type === _Panel.TableColumn && (this.column = t), this.itemIndex = i;
    }
    mI() {
      return this.bh !== null || this.itemTemplateMap !== null;
    }
    get itemTemplate() {
      return this.itemTemplateMap === null ? null : this.itemTemplateMap.getValue("");
    }
    set itemTemplate(t) {
      if (this.itemTemplateMap === null) {
        if (t === null)
          return;
        this.itemTemplateMap = new GMap2();
      }
      const i = this.itemTemplateMap.getValue("");
      if (i !== t) {
        Util.s(t, _Panel, _Panel, "itemTemplate"), (t instanceof Part2 || t.isPanelMain) && Util.n("Panel.itemTemplate must not be a Part or be Panel.isPanelMain: " + t), this.itemTemplateMap.add("", t), this.i("itemTemplate", i, t);
        const e = this.diagram;
        if (e !== null && e.undoManager.isUndoingRedoing)
          return;
        this.rebuildItemElements();
      }
    }
    get itemTemplateMap() {
      return this.g !== null ? this.g.Q0 : null;
    }
    set itemTemplateMap(t) {
      const i = this.itemTemplateMap;
      if (i !== t) {
        Util.s(t, GMap2, _Panel, "itemTemplateMap");
        const e = t.iterator;
        for (; e.next(); ) {
          const n = e.value;
          Debug && (n instanceof Part2 || n.isPanelMain) && Util.n("Template in Panel.itemTemplateMap must not be a Part or be Panel.isPanelMain: " + n);
        }
        this.Zt(), this.g.Q0 = t, this.i("itemTemplateMap", i, t);
        const s = this.diagram;
        if (s !== null && s.undoManager.isUndoingRedoing)
          return;
        this.rebuildItemElements();
      }
    }
    get itemCategoryProperty() {
      return this.g !== null ? this.g._0 : "category";
    }
    set itemCategoryProperty(t) {
      const i = this.itemCategoryProperty;
      i !== t && (typeof t != "string" && typeof t != "function" && Util.Bi(t, "string or function", _Panel, "itemCategoryProperty"), this.Zt(), this.g._0 = t, this.i("itemCategoryProperty", i, t));
    }
    z2(t, i) {
      if (t === null)
        return "";
      const e = this.itemCategoryProperty;
      let s = "";
      if (typeof e == "function")
        s = e(t);
      else if (typeof e == "string" && typeof t == "object") {
        if (e === "")
          return "";
        s = Model2.Xt(t, e);
      } else
        return "";
      if (s === void 0)
        return "";
      if (typeof s == "string")
        return s;
      Util.n("Panel.getCategoryForItemData found a non-string category for " + t + ": " + s);
    }
    X2(t, i, e) {
      const s = this.itemTemplateMap;
      let n = null;
      return s !== null && (n = s.getValue(e)), n === null && (s !== null && (n = s.getValue("")), n === null && (_Panel.DL || (_Panel.DL = true, Util.ft('No item template Panel found for category "' + e + '" on ' + this), Util.ft("  Using default item template."), _Panel.FL = new _Panel().add(new TextBlock2().bind("text", "", Util.toString).theme("stroke", "text"))), n = _Panel.FL)), n;
    }
    get dc() {
      return (this.l & 1048576) !== 0;
    }
    set dc(t) {
      const i = (this.l & 1048576) !== 0;
      i !== t && (Util.t(t, "boolean", _Panel, "isAtomic"), this.l = this.l ^ 1048576, this.i("isAtomic", i, t));
    }
    get isClipping() {
      return (this.l & 2097152) !== 0;
    }
    set isClipping(t) {
      const i = (this.l & 2097152) !== 0;
      i !== t && (Debug && (Util.t(t, "boolean", _Panel, "isClipping"), t && this.type !== _Panel.Spot && !(this instanceof Group2) && Util.ft("Warning: Panel.isClipping set on non-Spot Panel: " + this.toString())), this.l = this.l ^ 2097152, this instanceof Group2 && (this.hi = null), this.u(), this.i("isClipping", i, t));
    }
    get isOpposite() {
      return (this.l & 33554432) !== 0;
    }
    set isOpposite(t) {
      const i = (this.l & 33554432) !== 0;
      i !== t && (Util.t(t, "boolean", _Panel, "isOpposite"), this.l = this.l ^ 33554432, this.u(), this.i("isOpposite", i, t));
    }
    get isEnabled() {
      return (this.l & 4194304) !== 0;
    }
    set isEnabled(t) {
      const i = (this.l & 4194304) !== 0;
      if (i !== t) {
        Util.t(t, "boolean", _Panel, "isEnabled");
        const e = this.panel === null || this.panel.isEnabledObject();
        this.l = this.l ^ 4194304, this.i("isEnabled", i, t);
        const s = this.diagram;
        if (s !== null && s.undoManager.isUndoingRedoing)
          return;
        e && this.nb(this, t);
      }
    }
    nb(t, i) {
      const e = t.enabledChanged;
      if (e !== null && e(t, i), t instanceof _Panel) {
        const s = t.F.h, n = s.length;
        for (let o = 0; o < n; o++) {
          const r = s[o];
          i && r instanceof _Panel && !r.isEnabled || this.nb(r, i);
        }
      }
    }
    get alignmentFocusName() {
      return this.fo;
    }
    set alignmentFocusName(t) {
      const i = this.fo;
      i !== t && (Debug && Util.t(t, "string", _Panel, "alignmentFocusName"), this.fo = t, this.u(), this.i("alignmentFocusName", i, t));
    }
    static definePanelLayout(t, i) {
      PanelLayout2.definePanelLayout(t, i);
    }
  };
  __publicField(_Panel, "AL", false);
  __publicField(_Panel, "DL", false);
  __publicField(_Panel, "FL", null);
  __publicField(_Panel, "Position", PanelLayout2.Layouts.getValue("Position"));
  __publicField(_Panel, "Horizontal", PanelLayout2.Layouts.getValue("Horizontal"));
  __publicField(_Panel, "Vertical", PanelLayout2.Layouts.getValue("Vertical"));
  __publicField(_Panel, "Spot", PanelLayout2.Layouts.getValue("Spot"));
  __publicField(_Panel, "Auto", PanelLayout2.Layouts.getValue("Auto"));
  __publicField(_Panel, "Table", PanelLayout2.Layouts.getValue("Table"));
  __publicField(_Panel, "Viewbox", PanelLayout2.Layouts.getValue("Viewbox"));
  __publicField(_Panel, "TableRow", PanelLayout2.Layouts.getValue("TableRow"));
  __publicField(_Panel, "TableColumn", PanelLayout2.Layouts.getValue("TableColumn"));
  __publicField(_Panel, "Link", PanelLayout2.Layouts.getValue("Link"));
  __publicField(_Panel, "Grid", PanelLayout2.Layouts.getValue("Grid"));
  __publicField(_Panel, "Graduated", PanelLayout2.Layouts.getValue("Graduated"));
  let Panel2 = _Panel;
  Panel2.definePanelLayout = Panel2.definePanelLayout;
  class GradPanelSettings {
    constructor() {
      __publicField(this, "dp");
      __publicField(this, "gp");
      __publicField(this, "mp");
      __publicField(this, "pp");
      __publicField(this, "Cs");
      __publicField(this, "Qe");
      __publicField(this, "cs");
      __publicField(this, "Fe");
      this.dp = 0, this.gp = 100, this.mp = 10, this.pp = 0, this.Cs = null, this.Qe = null, this.cs = null, this.Fe = null;
    }
    copy() {
      const t = new GradPanelSettings();
      return t.dp = this.dp, t.gp = this.gp, t.mp = this.mp, t.pp = this.pp, t.Cs = this.Cs, t.Qe = this.Qe, t.cs = this.cs, t.Fe = this.Fe, t;
    }
  }
  class GridPanelSettings {
    constructor() {
      __publicField(this, "bd");
      __publicField(this, "kd");
      __publicField(this, "jf");
      __publicField(this, "np");
      this.bd = Size2.oC, this.kd = Point2.To, this.jf = Size2.xw, this.np = [];
    }
    copy() {
      const t = new GridPanelSettings();
      return t.bd = this.bd.copy(), t.kd = this.kd.copy(), t.jf = this.jf.copy(), t.np = this.np, t;
    }
  }
  class TablePanelSettings {
    constructor() {
      __publicField(this, "Ze");
      __publicField(this, "$e");
      __publicField(this, "wp");
      __publicField(this, "xp");
      __publicField(this, "bp");
      __publicField(this, "kp");
      __publicField(this, "op");
      __publicField(this, "lp");
      __publicField(this, "rp");
      __publicField(this, "hp");
      __publicField(this, "fp");
      __publicField(this, "ap");
      __publicField(this, "cp");
      __publicField(this, "xh");
      this.Ze = [], this.$e = [], this.wp = 3, this.xp = 3, this.bp = 0, this.kp = 0, this.op = Margin2.qg, this.lp = 1, this.rp = null, this.hp = null, this.fp = 1, this.ap = null, this.cp = null, this.xh = null;
    }
    copy(t) {
      const i = new TablePanelSettings(), e = this.Ze, s = e.length, n = i.Ze;
      for (let h = 0; h < s; h++) {
        if (e[h] === void 0)
          continue;
        const a = e[h].copy();
        a.Pa(t), n[h] = a;
      }
      const o = this.$e, r = o.length, l = i.$e;
      for (let h = 0; h < r; h++) {
        if (o[h] === void 0)
          continue;
        const a = o[h].copy();
        a.Pa(t), l[h] = a;
      }
      return i.wp = this.wp, i.xp = this.xp, i.bp = this.bp, i.kp = this.kp, i.op = this.op.L(), i.lp = this.lp, i.rp = this.rp, i.hp = this.hp, i.fp = this.fp, i.ap = this.ap, i.cp = this.cp, i.xh = this.xh, i;
    }
  }
  var Sizing2 = ((w) => (w[w.Default = 1] = "Default", w[w.None = 2] = "None", w[w.ProportionalExtra = 3] = "ProportionalExtra", w))(Sizing2 || {});
  const _RowColumnDefinition = class _RowColumnDefinition {
    constructor(t) {
      __publicField(this, "vs");
      __publicField(this, "Sp");
      __publicField(this, "Vt");
      __publicField(this, "La");
      __publicField(this, "Ta");
      __publicField(this, "fi");
      __publicField(this, "lt");
      __publicField(this, "Md");
      __publicField(this, "lo");
      __publicField(this, "$o");
      __publicField(this, "Pd");
      __publicField(this, "Nd");
      __publicField(this, "Da");
      __publicField(this, "Ft");
      __publicField(this, "Cd");
      __publicField(this, "Zs");
      __publicField(this, "at");
      __publicField(this, "Zi");
      __publicField(this, "ke");
      GSet2.ji(this), this.vs = null, this.Sp = true, this.Vt = 0, this.ke = NaN, this.La = 0, this.Ta = 1 / 0, this.fi = Spot2.Default, this.at = 0, this.Zi = 0, this.lt = 0, this.Zs = null, this.Md = 1, this.lo = 1, this.$o = null, this.Pd = null, this.Nd = NaN, this.Da = null, this.Ft = null, this.Cd = false, t && (Object.assign(this, t), t.column !== void 0 ? (this.isRow = false, this.index = t.column) : t.row !== void 0 && (this.isRow = true, this.index = t.row));
    }
    copy() {
      const t = new _RowColumnDefinition();
      return t.Sp = this.Sp, t.Vt = this.Vt, t.ke = this.ke, t.La = this.La, t.Ta = this.Ta, t.fi = this.fi, t.at = this.at, t.Zi = this.Zi, t.lt = this.lt, t.lo = this.lo, t.Md = this.Md, this.$o === null ? t.$o = null : t.$o = this.$o.L(), t.Pd = this.Pd, t.Nd = this.Nd, t.Da = null, this.Da !== null && (t.separatorDashArray = this.separatorDashArray.slice()), t.Ft = this.Ft, t.Cd = this.Cd, t.Zs = this.Zs, t;
    }
    J1(t) {
      t.isRow ? this.height = t.height : this.width = t.width, this.minimum = t.minimum, this.maximum = t.maximum, this.alignment = t.alignment, this.stretch = t.stretch, this.sizing = t.sizing, this.$o = t.separatorPadding === null ? null : t.separatorPadding.L(), this.separatorStroke = t.separatorStroke, this.separatorStrokeWidth = t.separatorStrokeWidth, this.Da = null, t.separatorDashArray && (this.Da = t.separatorDashArray.slice()), this.background = t.background, this.coversSeparators = t.coversSeparators, this.Zs = t.Zs;
    }
    ci(t) {
      t in Sizing2 ? this.sizing = t : Util.gr(this, t);
    }
    toString() {
      return "RowColumnDefinition " + (this.isRow ? "(Row " : "(Column ") + this.index + ") #" + GSet2.ps(this);
    }
    Pa(t) {
      this.vs = t;
    }
    computeEffectiveSpacingTop(t) {
      let i = 0;
      const e = this.vs;
      if (this.index !== t) {
        let n = this.separatorStroke;
        n === null && e !== null && (n = this.isRow ? e.defaultRowSeparatorStroke : e.defaultColumnSeparatorStroke), n !== null && (i = this.separatorStrokeWidth, isNaN(i) && (e !== null ? i = this.isRow ? e.defaultRowSeparatorStrokeWidth : e.defaultColumnSeparatorStrokeWidth : i = 0));
      }
      let s = this.$o;
      if (s === null)
        if (e !== null)
          s = e.defaultSeparatorPadding;
        else
          return i;
      return i + (this.isRow ? s.top : s.left);
    }
    computeEffectiveSpacing() {
      let t = 0;
      const i = this.vs;
      let e = 0;
      const s = this.isRow;
      if (i !== null && i.type === Panel2.Table) {
        const o = s ? i.Ze.length : i.$e.length;
        for (let r = 0; r < o; r++) {
          const l = s ? i.Ze[r] : i.$e[r];
          if (l !== void 0 && l.at !== 0) {
            e = l.index;
            break;
          }
        }
      }
      if (this.index !== e) {
        let o = this.separatorStroke;
        o === null && i !== null && (o = s ? i.defaultRowSeparatorStroke : i.defaultColumnSeparatorStroke), o !== null && (t = this.separatorStrokeWidth, isNaN(t) && (i !== null ? t = s ? i.defaultRowSeparatorStrokeWidth : i.defaultColumnSeparatorStrokeWidth : t = 0));
      }
      let n = this.$o;
      if (n === null)
        if (i !== null)
          n = i.defaultSeparatorPadding;
        else
          return t;
      return t + (this.isRow ? n.top + n.bottom : n.left + n.right);
    }
    i(t, i, e, s, n) {
      const o = this.vs;
      if (o !== null && (o.raiseChangedEvent(2, t, this, i, e, s, n), this.Zs !== null)) {
        const r = o.diagram;
        if (r !== null && !r.xe) {
          const l = o.findBindingPanel();
          if (l !== null) {
            const h = l.data;
            if (h !== null) {
              const a = this.Zs.iterator;
              for (; a.next(); )
                a.value.updateSource(this, h, t, l);
            }
          }
        }
      }
    }
    get panel() {
      return this.vs;
    }
    get isRow() {
      return this.Sp;
    }
    set isRow(t) {
      this.Sp = t;
    }
    get index() {
      return this.Vt;
    }
    set index(t) {
      this.Vt = t;
    }
    get height() {
      return this.ke;
    }
    set height(t) {
      const i = this.ke;
      i !== t && (Debug && Util.t(t, "number", _RowColumnDefinition, "height"), t < 0 && Util.G(t, ">= 0", _RowColumnDefinition, "height"), this.ke = t, this.actual = this.at, this.panel !== null && this.panel.u(), this.i("height", i, t));
    }
    get width() {
      return this.ke;
    }
    set width(t) {
      const i = this.ke;
      i !== t && (Debug && Util.t(t, "number", _RowColumnDefinition, "width"), t < 0 && Util.G(t, ">= 0", _RowColumnDefinition, "width"), this.ke = t, this.actual = this.at, this.panel !== null && this.panel.u(), this.i("width", i, t));
    }
    get minimum() {
      return this.La;
    }
    set minimum(t) {
      const i = this.La;
      i !== t && (Debug && Util.t(t, "number", _RowColumnDefinition, "minimum"), (t < 0 || !isFinite(t)) && Util.G(t, ">= 0", _RowColumnDefinition, "minimum"), this.La = t, this.actual = this.at, this.panel !== null && this.panel.u(), this.i("minimum", i, t));
    }
    get maximum() {
      return this.Ta;
    }
    set maximum(t) {
      const i = this.Ta;
      i !== t && (Debug && Util.t(t, "number", _RowColumnDefinition, "maximum"), t < 0 && Util.G(t, ">= 0", _RowColumnDefinition, "maximum"), this.Ta = t, this.actual = this.at, this.panel !== null && this.panel.u(), this.i("maximum", i, t));
    }
    get alignment() {
      return this.fi;
    }
    set alignment(t) {
      const i = this.fi;
      i.equals(t) || (Debug && Util.s(t, Spot2, _RowColumnDefinition, "alignment"), this.fi = t.L(), this.panel !== null && this.panel.u(), this.i("alignment", i, t));
    }
    get stretch() {
      return this.lo;
    }
    set stretch(t) {
      const i = this.lo;
      i !== t && (this.lo = t, this.panel !== null && this.panel.u(), this.i("stretch", i, t));
    }
    get separatorPadding() {
      return this.$o;
    }
    set separatorPadding(t) {
      typeof t == "number" ? t = new Margin2(t) : t !== null && Debug && Util.s(t, Margin2, _RowColumnDefinition, "separatorPadding");
      const i = this.$o;
      (t === null || i === null || !i.equals(t)) && (t !== null && (t = t.L()), this.$o = t, this.panel !== null && this.panel.u(), this.i("separatorPadding", i, t));
    }
    get separatorStroke() {
      return this.Pd;
    }
    set separatorStroke(t) {
      const i = this.Pd;
      i !== t && (t !== null && Brush2.ud(t, "RowColumnDefinition.separatorStroke"), t instanceof Brush2 && t.w(), this.Pd = t, this.panel !== null && this.panel.u(), this.i("separatorStroke", i, t));
    }
    get separatorStrokeWidth() {
      return this.Nd;
    }
    set separatorStrokeWidth(t) {
      const i = this.Nd;
      i !== t && (this.Nd = t, this.panel !== null && this.panel.u(), this.i("separatorStrokeWidth", i, t));
    }
    get separatorDashArray() {
      return this.Da;
    }
    set separatorDashArray(t) {
      const i = this.Da;
      if (i !== t) {
        if (t !== null && !Array.isArray(t) && Util.Bi(t, "Array", _RowColumnDefinition, "separatorDashArray:value"), t !== null) {
          const e = t.length;
          let s = 0;
          for (let n = 0; n < e; n++) {
            const o = t[n];
            (typeof o != "number" || !(o >= 0) || !isFinite(o)) && Util.n("separatorDashArray value " + o + " at index " + n + " must be a positive number or zero."), s += o;
          }
          if (s === 0) {
            if (i === null)
              return;
            t = null;
          }
        }
        this.Da = t, this.panel !== null && this.panel.T(), this.i("separatorDashArray", i, t);
      }
    }
    get background() {
      return this.Ft;
    }
    set background(t) {
      const i = this.Ft;
      i !== t && (t !== null && Brush2.ud(t, "RowColumnDefinition.background"), t instanceof Brush2 && t.w(), this.Ft = t, this.panel !== null && this.panel.T(), this.i("background", i, t));
    }
    get coversSeparators() {
      return this.Cd;
    }
    set coversSeparators(t) {
      const i = this.Cd;
      i !== t && (Util.t(t, "boolean", _RowColumnDefinition, "coversSeparators"), this.Cd = t, this.panel !== null && this.panel.T(), this.i("coversSeparators", i, t));
    }
    get sizing() {
      return this.Md;
    }
    set sizing(t) {
      const i = this.Md;
      i !== t && (Debug && Util.it(t, Sizing2, "Sizing"), this.Md = t, this.panel !== null && this.panel.u(), this.i("sizing", i, t));
    }
    ib() {
      if (this.sizing === 1) {
        const t = this.vs;
        return this.isRow ? t.rowSizing : t.columnSizing;
      }
      return this.sizing;
    }
    get actual() {
      return this.at;
    }
    set actual(t) {
      isNaN(this.ke) ? this.at = Math.max(Math.min(this.Ta, t), this.La) : this.at = Math.max(Math.min(this.Ta, this.ke), this.La);
    }
    get measured() {
      return this.Zi;
    }
    set measured(t) {
      this.Zi = t;
    }
    get total() {
      return this.at + this.computeEffectiveSpacing();
    }
    get position() {
      return this.lt;
    }
    set position(t) {
      this.lt = t;
    }
    bind(t, i, e, s) {
      return this.lc(t, i, e, s), this;
    }
    bindTwoWay(t, i, e, s) {
      const n = this.lc(t, i, e, s);
      return s === void 0 && n.makeTwoWay(), this;
    }
    theme(t, i, e, s, n) {
      return this.yh(t, i, e, s, n), this;
    }
    themeData(t, i, e, s, n) {
      return this.yh(t, i, e, s, n).ofData(), this;
    }
    themeObject(t, i, e, s, n, o) {
      return this.yh(t, i, e, s, n).ofObject(o), this;
    }
    themeModel(t, i, e, s, n) {
      return this.yh(t, i, e, s, n).ofModel(), this;
    }
    lc(t, i, e, s) {
      let n = null;
      return typeof t == "string" ? n = new Binding2(t, i, e, s) : n = t, this.Z0(n), n;
    }
    yh(t, i, e, s, n) {
      let o = null;
      return typeof t == "string" ? o = new ThemeBinding2(t, i, e, s, n) : o = t, this.Z0(o), o;
    }
    Z0(t) {
      t.Te = this;
      const i = this.panel;
      if (i !== null) {
        const e = i.findBindingPanel();
        e !== null && e.dL() && Util.n("Cannot add a Binding to a RowColumnDefinition that is already frozen: " + t + " on " + i);
      }
      this.Zs === null && (this.Zs = new List2()), this.Zs.add(t);
    }
  };
  __publicField(_RowColumnDefinition, "Default", 1);
  __publicField(_RowColumnDefinition, "None", 2);
  __publicField(_RowColumnDefinition, "ProportionalExtra", 3);
  let RowColumnDefinition2 = _RowColumnDefinition;
  const _Shape = class _Shape extends GraphObject2 {
    constructor(t, i) {
      super();
      __publicField(this, "yt");
      __publicField(this, "As");
      __publicField(this, "Ad");
      __publicField(this, "Fa");
      __publicField(this, "$i");
      __publicField(this, "Qo");
      __publicField(this, "jo");
      __publicField(this, "Rt");
      __publicField(this, "Ld");
      __publicField(this, "Td");
      __publicField(this, "tt");
      this.yt = null, this.As = null, this.Ad = "None", this.Fa = "black", this.$i = "black", this.Qo = 1, this.jo = null, this.Rt = null, this.Ld = NaN, this.Td = NaN, this.tt = null, typeof t == "string" ? this.figure = t : t && Object.assign(this, t), i && Object.assign(this, i);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.yt = this.yt, t.As = this.As, t.Ad = this.Ad, t.Fa = this.Fa, t.$i = this.$i, t.Qo = this.Qo, this.jo !== null && (t.jo = this.jo.slice()), this.Rt !== null && (this.Rt.xi ? t.Rt = this.Rt : t.Rt = this.Rt.copy()), t.Ld = this.Ld, t.Td = this.Td, this.tt !== null && (t.tt = this.tt.copy());
    }
    Ra() {
      this.Rt === null ? this.Rt = new ShapeTemplateSettings() : this.Rt.xi && (this.Rt = this.Rt.copy());
    }
    uh() {
      super.uh(), this.Rt !== null && (this.Rt.xi = true);
    }
    ci(t) {
      t in GeometryStretch2 ? this.geometryStretch = t : super.ci(t);
    }
    toString() {
      return "Shape(" + (this.figure !== "None" ? this.figure : this.toArrow !== "None" ? this.toArrow : this.fromArrow) + ")#" + GSet2.ps(this);
    }
    kI(t, i) {
      const e = this.pathPattern;
      e.wt(1 / 0, 1 / 0);
      const s = e.measuredBounds;
      e.vt(0, 0, s.width, s.height);
      const n = this.geometry;
      t.save(), t.beginPath();
      const o = Util.ct();
      if (n.type === 1)
        o.push(n.startX), o.push(n.startY), o.push(n.endX), o.push(n.endY), this.Dd(t, i, o, e);
      else if (n.type === 4) {
        const r = n.figures.iterator;
        for (; r.next(); ) {
          const l = r.value;
          o.length = 0, o.push(l.startX), o.push(l.startY);
          let h = l.startX, a = l.startY, f = h, c = a;
          const u = l.segments.h, d = u.length;
          for (let m = 0; m < d; m++) {
            const g = u[m];
            switch (g.type) {
              case 1:
                this.Dd(t, i, o, e), o.length = 0, o.push(g.endX), o.push(g.endY), h = g.endX, a = g.endY, f = h, c = a;
                break;
              case 2:
                o.push(g.endX), o.push(g.endY), h = g.endX, a = g.endY;
                break;
              case 3:
                Geo.Hn(h, a, g.point1X, g.point1Y, g.point2X, g.point2Y, g.endX, g.endY, 0.5, o), h = g.endX, a = g.endY;
                break;
              case 4:
                Geo.Wg(h, a, g.point1X, g.point1Y, g.endX, g.endY, 0.5, o), h = g.endX, a = g.endY;
                break;
              case 5: {
                const p = g.Fo(l), y = p.length;
                if (y === 0) {
                  o.push(g.centerX), o.push(g.centerY), h = g.centerX, a = g.centerY;
                  break;
                }
                for (let x = 0; x < y; x++) {
                  const b = p[x];
                  Geo.Hn(h, a, b[2], b[3], b[4], b[5], b[6], b[7], 0.5, o), h = b[6], a = b[7];
                }
                break;
              }
              case 6: {
                const p = g.Kh(l, h, a), y = p.length;
                if (y === 0) {
                  o.push(g.endX), o.push(g.endY), h = g.endX, a = g.endY;
                  break;
                }
                for (let x = 0; x < y; x++) {
                  const b = p[x];
                  Geo.Hn(h, a, b[2], b[3], b[4], b[5], b[6], b[7], 0.5, o), h = b[6], a = b[7];
                }
                break;
              }
              default:
                Util.n("Segment not of valid type: " + g.type);
            }
            g.isClosed && (o.push(f), o.push(c), this.Dd(t, i, o, e));
          }
          this.Dd(t, i, o, e);
        }
      } else if (n.type === 2)
        o.push(n.startX), o.push(n.startY), o.push(n.endX), o.push(n.startY), o.push(n.endX), o.push(n.endY), o.push(n.startX), o.push(n.endY), o.push(n.startX), o.push(n.startY), this.Dd(t, i, o, e);
      else if (n.type === 3) {
        const r = new PathFigure2();
        r.startX = n.endX, r.startY = (n.startY + n.endY) / 2;
        const l = new PathSegment2(5);
        l.startAngle = 0, l.sweepAngle = 360, l.centerX = (n.startX + n.endX) / 2, l.centerY = (n.startY + n.endY) / 2, l.radiusX = Math.abs(n.startX - n.endX) / 2, l.radiusY = Math.abs(n.startY - n.endY) / 2, r.add(l);
        const h = l.Fo(r), a = h.length;
        if (a === 0)
          o.push(l.centerX), o.push(l.centerY);
        else {
          let f = r.startX, c = r.startY;
          for (let u = 0; u < a; u++) {
            const d = h[u];
            Geo.Hn(f, c, d[2], d[3], d[4], d[5], d[6], d[7], 0.5, o), f = d[6], c = d[7];
          }
        }
        this.Dd(t, i, o, e);
      }
      Util.ot(o), t.restore(), t.clearContextCache(false);
    }
    SI(t) {
      let i = t.measuredBounds.width;
      return t instanceof _Shape && (i -= t.strokeWidth), i < 1 && (i = 1), i;
    }
    Dd(t, i, e, s) {
      const n = e.length;
      if (n < 4)
        return;
      const o = s.measuredBounds, r = Math.max(1, o.width), l = o.height;
      let h = e[0], a = e[1], f = 0, c = 0, u = 0, d = 0, m = 0, g = 0, p = 0, y = 0;
      const x = Util.ct();
      for (let N = 2; N < n; N += 2)
        f = e[N], c = e[N + 1], u = f - h, d = c - a, u === 0 && (u = 1e-3), m = d / u, g = Math.atan2(d, u), p = Math.sqrt(u * u + d * d), x.push([u, g, m, p]), y += p, h = f, a = c;
      h = e[0], a = e[1];
      const b = this.SI(s);
      let k = b;
      const S = r / 2;
      let M = S !== 0, A = 0, C = x[A];
      u = C[0], g = C[1], m = C[2], p = C[3];
      let P = 0;
      for (; y >= 0.1; ) {
        if (P === 0 && (M ? (k = b, k -= S, y -= S, M = false) : k = b, k === 0 && (k = 1)), k > y) {
          k = y, Util.ot(x);
          return;
        }
        k > p ? (P = k - p, k = p) : P = 0;
        let N = Math.sqrt(k * k / (1 + m * m));
        if (u < 0 && (N = -N), h += N, a += m * N, t.translate(h, a), t.rotate(g), t.translate(-(r / 2), -(l / 2)), P === 0 && s.ph(t, i), t.translate(r / 2, l / 2), t.rotate(-g), t.translate(-h, -a), y -= k, p -= k, P !== 0) {
          if (A++, A === x.length) {
            Util.ot(x);
            return;
          }
          C = x[A], u = C[0], g = C[1], m = C[2], p = C[3], k = P;
        }
      }
      Util.ot(x);
    }
    ph(t, i) {
      const e = t instanceof SVGContext;
      let s = this.$i;
      const n = this.Fa;
      if (s === null && n === null)
        return;
      const o = this.yt;
      if (o === null)
        return;
      t.commitTransform();
      const r = this.actualBounds, l = this.naturalBounds;
      n !== null && this.bn(t, n, true, false, l, r);
      const h = this.part;
      let a = this.Qo;
      s !== null && a === 0 && h !== null && (this.isPanelMain || h.findMainElement() === this) && (a = h.MI()), a === 0 && (s = null), s !== null && a !== 0 && (this.bn(t, s, false, false, l, r), t.lineWidth = a, t.lineJoin = this.strokeJoin, t.lineCap = this.strokeCap, t.miterLimit = this.strokeMiterLimit);
      let f = false;
      h && i.getRenderingHint("drawShadows") && (f = h.isShadowed), t.hl === false && (f = false);
      let c = true;
      s !== null && (n === null || n === "transparent") && (c = false);
      let u = false;
      const d = this.strokeDashArray;
      if (d !== null && (u = true, t.enableDash(d, this.strokeDashOffset)), o.type === 1)
        t.beginPath(), t.moveTo(o.startX, o.startY), t.lineTo(o.endX, o.endY), s !== null && t.strokeContext(), t.endPath();
      else if (o.type === 2) {
        const m = o.startX, g = o.startY, p = o.endX, y = o.endY, x = Math.min(m, p), b = Math.min(g, y), k = Math.abs(p - m), S = Math.abs(y - g);
        t.beginPath(), t.rect(x, b, k, S), n !== null && t.fillContext(n, false, null), s !== null && (c && f && t.shadowsOff(), t.strokeContext(), c && f && t.shadowsOn()), t.endPath();
      } else if (o.type === 3) {
        const m = o.startX, g = o.startY, p = o.endX, y = o.endY, x = Math.abs(p - m) / 2, b = Math.abs(y - g) / 2, k = Math.min(m, p) + x, S = Math.min(g, y) + b;
        t.beginPath(), t.moveTo(k, S - b), t.bezierCurveTo(k + Geo.Gn * x, S - b, k + x, S - Geo.Gn * b, k + x, S), t.bezierCurveTo(k + x, S + Geo.Gn * b, k + Geo.Gn * x, S + b, k, S + b), t.bezierCurveTo(k - Geo.Gn * x, S + b, k - x, S + Geo.Gn * b, k - x, S), t.bezierCurveTo(k - x, S - Geo.Gn * b, k - Geo.Gn * x, S - b, k, S - b), t.closePath(), n !== null && t.fillContext(n, false, null), s !== null && (c && f && t.shadowsOff(), t.strokeContext(), c && f && t.shadowsOn()), t.endPath();
      } else if (o.type === 4) {
        const m = o.figures, g = m.length;
        for (let p = 0; p < g; p++) {
          const y = m.h[p];
          e ? this.buildPath(t, y) : y.ve === null && (y.ve = new Path2D(), this.buildPath(y.ve, y));
          const x = y.isFilled;
          f ? y.isShadowed ? (x === true && n !== "transparent" && n !== null && t.fillContext(n, y.isEvenOdd, y.ve), s !== null && (x && c && t.shadowsOff(), t.stroke(y.ve), x && c && t.shadowsOn())) : (t.shadowsOff(), x && n !== "transparent" && n !== null && t.fillContext(n, y.isEvenOdd, y.ve), s !== null && t.stroke(y.ve), t.shadowsOn()) : (x && n !== null && t.fillContext(n, y.isEvenOdd, y.ve), s !== null && t.stroke(y.ve)), t.endPath(p);
        }
      }
      u && t.disableDash(), this.pathPattern !== null && this.kI(t, i);
    }
    buildPath(t, i) {
      t instanceof Path2D || t.beginPath(), t.moveTo(i.startX, i.startY);
      const s = i.segments.h, n = s.length;
      let o = null;
      for (let r = 0; r < n; r++) {
        const l = s[r];
        switch (l.type) {
          case 1:
            t.moveTo(l.endX, l.endY);
            break;
          case 2:
            t.lineTo(l.endX, l.endY);
            break;
          case 3:
            t.bezierCurveTo(l.point1X, l.point1Y, l.point2X, l.point2Y, l.endX, l.endY);
            break;
          case 4:
            t.quadraticCurveTo(l.point1X, l.point1Y, l.endX, l.endY);
            break;
          case 5:
            if (l.radiusX === l.radiusY) {
              const h = o !== null ? o.endX : i.startX, a = o !== null ? o.endY : i.startY, f = Math.PI / 180;
              t.arc(l.point1X, l.point1Y, l.radiusX, l.startAngle * f, (l.startAngle + l.sweepAngle) * f, l.sweepAngle < 0, h, a);
            } else {
              const h = l.Fo(i), a = h.length;
              if (a === 0) {
                t.lineTo(l.centerX, l.centerY);
                break;
              }
              for (let f = 0; f < a; f++) {
                const c = h[f];
                f === 0 && t.lineTo(c[0], c[1]), t.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
              }
            }
            break;
          case 6: {
            let h = 0, a = 0, f;
            if (o !== null && o.type === 5) {
              f = o.Fo(i);
              const u = f.length;
              if (u === 0) {
                t.lineTo(l.endX, l.endY);
                break;
              }
              const d = f[u - 1] || null;
              d !== null && (h = d[6], a = d[7]);
            } else
              h = o !== null ? o.endX : i.startX, a = o !== null ? o.endY : i.startY;
            f = l.Kh(i, h, a);
            const c = f.length;
            if (c === 0) {
              t.lineTo(l.endX, l.endY);
              break;
            }
            for (let u = 0; u < c; u++) {
              const d = f[u];
              t.bezierCurveTo(d[2], d[3], d[4], d[5], d[6], d[7]);
            }
            break;
          }
        }
        l.isClosed && t.closePath(), o = l;
      }
    }
    sc(t, i, e) {
      if (!super.sc(t, i, e) || this.$i === null && this.Fa === null || this.yt === null || this.pathPattern !== null)
        return false;
      const s = this.svg.getElementsByTagName("path");
      return this.geometry.figures.length !== s.length ? false : (t.currentPath = this.svg, this.ph(t, i), t.currentPath = null, true);
    }
    fd(t) {
      return this.geometry !== null && this.geometry.figures.length > 1 || this.pathPattern !== null ? true : super.fd(t);
    }
    d2(t, i) {
      if (t.nodeName !== "g")
        t.setAttributeNS(null, "filter", i);
      else {
        const e = t.getElementsByTagName("path");
        for (let s = 0; s < e.length; s++)
          e[s].setAttributeNS(null, "filter", i);
      }
    }
    getDocumentPoint(t, i) {
      if (i === void 0 && (i = new Point2()), t instanceof Spot2) {
        const e = t;
        e.isNoSpot() && Util.n("getDocumentPoint Spot must be a real, specific Spot, not: " + e.toString());
        const s = this.naturalBounds, n = this.strokeWidth;
        return i.e(e.x * (s.width + n) - n / 2 + s.x + e.offsetX, e.y * (s.height + n) - n / 2 + s.y + e.offsetY), this.Ms.Pt(i), i;
      } else
        return i.set(t), this.Ms.Pt(i), i;
    }
    getDocumentBounds(t) {
      t === void 0 && (t = new Rect2());
      const i = this.naturalBounds, e = this.Ms, s = Rect2.H(i.x, i.y, i.width, i.height), n = this.strokeWidth;
      s.inflate(n / 2, n / 2);
      const o = Point2.H(s.x, s.y).D(e);
      return t.e(o.x, o.y, 0, 0), o.e(s.right, s.y).D(e), t.unionNoCheck(o.x, o.y, 0, 0), o.e(s.right, s.bottom).D(e), t.unionNoCheck(o.x, o.y, 0, 0), o.e(s.x, s.bottom).D(e), t.unionNoCheck(o.x, o.y, 0, 0), Rect2.o(s), Point2.o(o), t;
    }
    dh(t, i) {
      const e = this.geometry;
      if (e === null || this.fill === null && this.stroke === null)
        return false;
      const s = e.bounds;
      let n = this.strokeWidth / 2;
      e.type === 1 && !i && (n += 2);
      const o = Rect2.a();
      if (o.c(s), o.inflate(n + 2, n + 2), !o.containsPoint(t))
        return Rect2.o(o), false;
      const r = n + 1e-4;
      if (e.type === 1) {
        if (this.stroke === null)
          return false;
        const l = (e.startX - e.endX) * (t.x - e.endX) + (e.startY - e.endY) * (t.y - e.endY), h = (e.endX - e.startX) * (t.x - e.startX) + (e.endY - e.startY) * (t.y - e.startY);
        return l < 0 || h < 0 ? false : (Rect2.o(o), Geo.zi(e.startX, e.startY, e.endX, e.endY, n, t.x, t.y));
      } else if (e.type === 2) {
        const l = e.startX, h = e.startY, a = e.endX, f = e.endY;
        if (o.x = Math.min(l, a), o.y = Math.min(h, f), o.width = Math.abs(a - l), o.height = Math.abs(f - h), this.fill === null) {
          if (o.inflate(-r, -r), o.containsPoint(t))
            return Rect2.o(o), false;
          o.inflate(r, r);
        }
        this.stroke !== null && o.inflate(n, n);
        const c = o.containsPoint(t);
        return Rect2.o(o), c;
      } else if (e.type === 3) {
        const l = e.startX, h = e.startY, a = e.endX, f = e.endY;
        let c = Math.min(l, a), u = Math.min(h, f);
        const d = Math.abs(a - l), m = Math.abs(f - h);
        let g = d / 2, p = m / 2;
        if (c = t.x - (c + g), u = t.y - (u + p), this.fill === null) {
          if (g -= r, p -= r, g <= 0 || p <= 0)
            return Rect2.o(o), false;
          if (c * c / (g * g) + u * u / (p * p) <= 1)
            return Rect2.o(o), false;
          g += r, p += r;
        }
        return this.stroke !== null && (g += r, p += r), Rect2.o(o), g <= 0 || p <= 0 ? false : c * c / (g * g) + u * u / (p * p) <= 1;
      } else {
        if (e.type === 4)
          return Rect2.o(o), this.fill === null ? e.MC(t.x, t.y, n) : e.jk(t, n, this.strokeWidth > 1, i);
        Util.n("Unknown Geometry type: " + e.type);
      }
    }
    ld(t, i, e, s) {
      const n = this.desiredSize, o = this.Qo;
      t = Math.max(t, 0), i = Math.max(i, 0);
      let r;
      if (this.As !== null)
        r = this.geometry.bounds;
      else {
        const g = this.figure;
        let p = _Shape.K2[g];
        if (p === void 0) {
          let y = Geo.qn[g];
          typeof y == "string" && (y = Geo.qn[y]), typeof y == "function" ? (p = y(null, 100, 100), _Shape.K2[g] = p) : Util.n("Unsupported Figure: " + g);
        }
        r = p.bounds;
      }
      let l = r.width, h = r.height, a = r.width, f = r.height;
      switch (this.qs(true)) {
        case 0:
          e = 0, s = 0;
          break;
        case 2:
          a = Math.max(t - o, 0), f = Math.max(i - o, 0);
          break;
        case 5:
          a = Math.max(t - o, 0), s = 0;
          break;
        case 4:
          e = 0, f = Math.max(i - o, 0);
          break;
      }
      isFinite(n.width) && (a = n.width), isFinite(n.height) && (f = n.height);
      const u = this.maxSize, d = this.minSize;
      e = Math.max(e - o, d.width), s = Math.max(s - o, d.height), a = Math.min(u.width, a), f = Math.min(u.height, f), a = isFinite(a) ? Math.max(e, a) : Math.max(l, e), f = isFinite(f) ? Math.max(s, f) : Math.max(h, s);
      const m = this.lM();
      switch (m) {
        case 0:
          break;
        case 2:
          l = a, h = f;
          break;
        case 6: {
          let g = Math.min(a / l, f / h);
          isFinite(g) || (g = 1), l = l * g, h = h * g;
          break;
        }
        default:
          Util.n(m + " is not a valid geometryStretch.");
      }
      if (this.As !== null) {
        l === 0 && (l = 1e-3), h === 0 && (h = 1e-3);
        const p = (this.As !== null ? this.As : this.yt).qD(l, h);
        Debug && p.w(), this.yt = p;
      } else
        (this.yt === null || !Geo.q(this.yt.ff, t - o) || !Geo.q(this.yt.cf, i - o)) && (this.yt = _Shape.NI(this, l, h));
      r = this.yt.bounds, t === 1 / 0 || i === 1 / 0 ? this.oo(r.x - o / 2, r.y - o / 2, t === 0 && l === 0 ? 0 : r.width + o, i === 0 && h === 0 ? 0 : r.height + o) : this.oo(-(o / 2), -(o / 2), a + o, f + o), n.isReal() ? (a = n.width, f = n.height, a = Math.min(u.width, a), f = Math.min(u.height, f), a = Math.max(d.width, a), f = Math.max(d.height, f), this.Hi.e(0, 0, a, f)) : this.Hi.c(r);
    }
    lM() {
      const t = this.geometryStretch;
      return this.As !== null ? t === 1 ? 2 : t : t === 1 ? _Shape.K2[this.figure].defaultStretch : t;
    }
    gh(t, i, e, s) {
      this.commonArrange(t, i, e, s);
    }
    getNearestIntersectionPoint(t, i, e) {
      return this.ec(t.x, t.y, i.x, i.y, e);
    }
    ec(t, i, e, s, n) {
      const o = this.D, r = 1 / (o.m11 * o.m22 - o.m12 * o.m21), l = o.m22 * r, h = -o.m12 * r, a = -o.m21 * r, f = o.m11 * r, c = r * (o.m21 * o.dy - o.m22 * o.dx), u = r * (o.m12 * o.dx - o.m11 * o.dy), d = t * l + i * a + c, m = t * h + i * f + u, g = e * l + s * a + c, p = e * h + s * f + u, y = this.Qo / 2;
      let x = this.yt;
      x === null && (this.wt(1 / 0, 1 / 0), x = this.yt);
      const b = x.bounds;
      let k = false;
      if (x.type === 1)
        if (this.strokeWidth <= 1.5)
          k = Geo.vn(x.startX, x.startY, x.endX, x.endY, d, m, g, p, n);
        else {
          let S = 0, M = 0;
          if (x.startX === x.endX)
            S = y, M = 0;
          else {
            const T = (x.endY - x.startY) / (x.endX - x.startX);
            M = y / Math.sqrt(1 + T * T), S = M * T;
          }
          const A = Util.ct();
          let C = new Point2();
          Geo.vn(x.startX + S, x.startY + M, x.endX + S, x.endY + M, d, m, g, p, C) && A.push(C), C = new Point2(), Geo.vn(x.startX - S, x.startY - M, x.endX - S, x.endY - M, d, m, g, p, C) && A.push(C), C = new Point2(), Geo.vn(x.startX + S, x.startY + M, x.startX - S, x.startY - M, d, m, g, p, C) && A.push(C), C = new Point2(), Geo.vn(x.endX + S, x.endY + M, x.endX - S, x.endY - M, d, m, g, p, C) && A.push(C);
          const P = A.length;
          if (P === 0)
            return Util.ot(A), false;
          k = true;
          let N = 1 / 0;
          for (let T = 0; T < P; T++) {
            const L = A[T], D = (L.x - d) * (L.x - d) + (L.y - m) * (L.y - m);
            D < N && (N = D, n.x = L.x, n.y = L.y);
          }
          Util.ot(A);
        }
      else if (x.type === 2)
        k = Geo.Ml(b.x - y, b.y - y, b.x + b.width + y, b.y + b.height + y, d, m, g, p, n);
      else if (x.type === 3) {
        const S = Rect2.H(b.x, b.y, b.width, b.height).inflate(y, y);
        k = this.CI(S, d, m, g, p, n), Rect2.o(S);
      } else if (x.type === 4) {
        let S = 0, M = 0, A = 0, C = 0;
        const P = Point2.a();
        let N = g - d, T = p - m, L = N * N + T * T, D = d, F = m;
        if (L > 0 && b.contains(D, F) && (P.x = D, P.y = F, this.containsPoint(P)))
          for (N !== 0 && Math.abs(N) < 0.5 ? (T *= 0.5 / N, N = 0.5) : T !== 0 && Math.abs(T) < 0.5 && (N *= 0.5 / T, T = 0.5), D -= N, F -= T; b.contains(D, F); )
            D -= N, F -= T;
        const R = 0.6;
        n.x = g, n.y = p;
        for (let K = 0; K < x.figures.count; K++) {
          const V = x.figures.h[K], X = V.isFilled ? D : d, z = V.isFilled ? F : m, G = V.segments;
          S = V.startX, M = V.startY;
          let v = S, q = M;
          for (let J = 0; J < G.count; J++) {
            const Y = G.h[J], j = Y.type;
            A = Y.endX, C = Y.endY;
            let W = false;
            switch (j) {
              case 1:
                v = A, q = C;
                break;
              case 2:
                W = this.rb(S, M, A, C, X, z, g, p, P);
                break;
              case 3: {
                W = Geo.jg(S, M, Y.point1X, Y.point1Y, Y.point2X, Y.point2Y, A, C, X, z, g, p, R, P);
                break;
              }
              case 4: {
                W = Geo.jg(S, M, S + 2 / 3 * (Y.point1X - S), M + 2 / 3 * (Y.point1Y - M), A + 2 / 3 * (Y.point1X - A), C + 2 / 3 * (Y.point1Y - C), A, C, X, z, g, p, R, P);
                break;
              }
              case 5:
              case 6: {
                const Q = Y.type === 5 ? Y.Fo(V) : Y.Kh(V, S, M), U = Q.length;
                if (U === 0) {
                  W = this.rb(S, M, Y.type === 5 ? Y.centerX : Y.endX, Y.type === 5 ? Y.centerY : Y.endY, X, z, g, p, P);
                  break;
                }
                let E = null;
                for (let H = 0; H < U; H++) {
                  if (E = Q[H], H === 0 && this.rb(S, M, E[0], E[1], X, z, g, p, P)) {
                    const Z = this.lb(X, z, P, L, n);
                    Z < L && (L = Z, k = true);
                  }
                  if (Geo.jg(E[0], E[1], E[2], E[3], E[4], E[5], E[6], E[7], X, z, g, p, R, P)) {
                    const Z = this.lb(X, z, P, L, n);
                    Z < L && (L = Z, k = true);
                  }
                }
                A = E[6], C = E[7];
                break;
              }
              default:
                Util.n("Unknown Segment type: " + j);
            }
            if (S = A, M = C, W) {
              const Q = this.lb(X, z, P, L, n);
              Q < L && (L = Q, k = true);
            }
            if (Y.isClosed && (A = v, C = q, this.rb(S, M, A, C, X, z, g, p, P))) {
              const Q = this.lb(X, z, P, L, n);
              Q < L && (L = Q, k = true);
            }
          }
        }
        let I = e - t, O = s - i;
        const B = Math.sqrt(I * I + O * O);
        B !== 0 && (I /= B, O /= B), n.x -= I * y, n.y -= O * y, Point2.o(P);
      } else
        Util.n("Unknown Geometry type: " + x.type);
      return k ? (this.D.Pt(n), true) : false;
    }
    lb(t, i, e, s, n) {
      const o = e.x - t, r = e.y - i, l = o * o + r * r;
      return l < s ? (n.x = e.x, n.y = e.y, l) : s;
    }
    rb(t, i, e, s, n, o, r, l, h) {
      if (Geo.q(t, e) && Geo.q(i, s) || Geo.q(n, r) && Geo.q(o, l))
        return false;
      let a = false;
      const f = (n - r) * (i - s) - (o - l) * (t - e);
      if (f === 0)
        return false;
      if (h.x = ((n * l - o * r) * (t - e) - (n - r) * (t * s - i * e)) / f, h.y = ((n * l - o * r) * (i - s) - (o - l) * (t * s - i * e)) / f, (t > e ? t - e : e - t) < (i > s ? i - s : s - i)) {
        const c = i < s ? i : s, u = i < s ? s : i;
        (h.y > c || Geo.q(h.y, c)) && (h.y < u || Geo.q(h.y, u)) && (a = true);
      } else {
        const c = t < e ? t : e, u = t < e ? e : t;
        (h.x > c || Geo.q(h.x, c)) && (h.x < u || Geo.q(h.x, u)) && (a = true);
      }
      return a;
    }
    AI(t, i, e) {
      return this.pickable === false ? false : (e.hf(this.D), i ? this.LI(t, e) : this.containedInRect(t, e));
    }
    containedInRect(t, i) {
      if (i === void 0)
        return t.containsRect(this.actualBounds);
      let e = this.yt;
      e === null && (this.wt(1 / 0, 1 / 0), e = this.yt);
      const s = e.bounds, n = this.strokeWidth / 2;
      let o = false;
      const r = Point2.a();
      return r.e(s.x - n, s.y - n), t.containsPoint(i.Pt(r)) && (r.e(s.x - n, s.bottom + n), t.containsPoint(i.Pt(r)) && (r.e(s.right + n, s.bottom + n), t.containsPoint(i.Pt(r)) && (r.e(s.right + n, s.y - n), t.containsPoint(i.Pt(r)) && (o = true)))), Point2.o(r), o;
    }
    intersectsRect(t, i) {
      if (this.containedInRect(t, i) || i === void 0 && (i = this.D, t.containsRect(this.actualBounds)))
        return true;
      const e = Transform.a();
      e.set(i), e.Mw();
      const s = t.left, n = t.right, o = t.top, r = t.bottom, l = Point2.a();
      if (l.e(s, o), e.Pt(l), this.dh(l, true))
        return Point2.o(l), true;
      if (l.e(n, o), e.Pt(l), this.dh(l, true))
        return Point2.o(l), true;
      if (l.e(s, r), e.Pt(l), this.dh(l, true))
        return Point2.o(l), true;
      if (l.e(n, r), e.Pt(l), this.dh(l, true))
        return Point2.o(l), true;
      const h = Point2.a(), a = Point2.a();
      e.set(i), e.uC(this.D), e.Mw(), h.x = n, h.y = o, h.D(e), l.x = s, l.y = o, l.D(e);
      let f = false;
      return this.Ia(l, h, a) ? f = true : (l.x = n, l.y = r, l.D(e), this.Ia(l, h, a) ? f = true : (h.x = s, h.y = r, h.D(e), this.Ia(l, h, a) ? f = true : (l.x = s, l.y = o, l.D(e), this.Ia(l, h, a) && (f = true)))), Point2.o(l), Transform.o(e), Point2.o(h), Point2.o(a), f;
    }
    Ia(t, i, e) {
      if (!this.getNearestIntersectionPoint(t, i, e))
        return false;
      const s = t.x, n = t.y, o = i.x, r = i.y, l = e.x, h = e.y;
      if (s === o) {
        let a = 0, f = 0;
        return n < r ? (a = n, f = r) : (a = r, f = n), h >= a && h <= f;
      } else {
        let a = 0, f = 0;
        return s < o ? (a = s, f = o) : (a = o, f = s), l >= a && l <= f;
      }
    }
    LI(t, i) {
      if (this.containedInRect(t, i) || i === void 0 && (i = this.D, t.containsRect(this.actualBounds)))
        return true;
      const e = t.left, s = t.right, n = t.top, o = t.bottom, r = Point2.a(), l = Point2.a(), h = Point2.a(), a = Transform.a();
      a.set(i), a.uC(this.D), a.Mw(), l.x = s, l.y = n, l.D(a), r.x = e, r.y = n, r.D(a);
      let f = false;
      return this.Ia(r, l, h) ? f = true : (r.x = s, r.y = o, r.D(a), this.Ia(r, l, h) ? f = true : (l.x = e, l.y = o, l.D(a), this.Ia(r, l, h) ? f = true : (r.x = e, r.y = n, r.D(a), this.Ia(r, l, h) && (f = true)))), Transform.o(a), Point2.o(r), Point2.o(l), Point2.o(h), f;
    }
    sL(t, i, e) {
      if (e && this.fill !== null && this.dh(t, true))
        return true;
      let s = t.distanceSquaredPoint(i);
      const n = s;
      this.strokeWidth > 1.5 && (s = this.strokeWidth / 2 + Math.sqrt(s), s *= s);
      let o = this.yt;
      if (o === null && (this.wt(1 / 0, 1 / 0), o = this.yt, o === null))
        return false;
      if (!e) {
        const c = o.bounds, u = c.x, d = c.y, m = c.x + c.width, g = c.y + c.height;
        if (Point2.distanceSquared(t.x, t.y, u, d) <= s && Point2.distanceSquared(t.x, t.y, m, d) <= s && Point2.distanceSquared(t.x, t.y, u, g) <= s && Point2.distanceSquared(t.x, t.y, m, g) <= s)
          return true;
      }
      function r(c, u) {
        const d = c.length;
        for (let m = 0; m < d; m += 2)
          if (u.distanceSquared(c[m], c[m + 1]) > s)
            return true;
        return false;
      }
      const l = o.startX, h = o.startY, a = o.endX, f = o.endY;
      if (o.type === 1) {
        const c = Point2.distanceLineSegmentSquared(t.x, t.y, l, h, a, f), u = (a - l) * (t.x - l) + (f - h) * (t.y - h), d = (l - a) * (t.x - a) + (h - f) * (t.y - f), m = u >= 0 && d >= 0 ? s : n;
        return c <= m;
      } else if (o.type === 2) {
        let c = false;
        return e && (c = Point2.distanceLineSegmentSquared(t.x, t.y, l, h, l, f) <= s || Point2.distanceLineSegmentSquared(t.x, t.y, l, h, a, h) <= s || Point2.distanceLineSegmentSquared(t.x, t.y, a, h, a, f) <= s || Point2.distanceLineSegmentSquared(t.x, t.y, l, f, a, f) <= s), c;
      } else if (o.type === 3) {
        const c = (l + a) / 2, u = (h + f) / 2, d = t.x - c, m = t.y - u, g = Math.abs(a - l) / 2, p = Math.abs(f - h) / 2;
        if (g === 0 || p === 0)
          return Point2.distanceLineSegmentSquared(t.x, t.y, l, h, a, f) <= s;
        if (e) {
          const y = Geo.BD(g, p, d, m);
          return y * y <= s;
        } else
          return !(Point2.distanceSquared(d, m, -g, 0) >= s || Point2.distanceSquared(d, m, 0, -p) >= s || Point2.distanceSquared(d, m, 0, p) >= s || Point2.distanceSquared(d, m, g, 0) >= s);
      } else if (o.type === 4) {
        const c = o.bounds, u = c.x, d = c.y, m = c.x + c.width, g = c.y + c.height;
        if (t.x > m && t.x < u && t.y > g && t.y < d && Point2.distanceLineSegmentSquared(t.x, t.y, u, d, u, g) > s && Point2.distanceLineSegmentSquared(t.x, t.y, u, d, m, d) > s && Point2.distanceLineSegmentSquared(t.x, t.y, m, g, u, g) > s && Point2.distanceLineSegmentSquared(t.x, t.y, m, g, m, d) > s)
          return false;
        const p = Math.sqrt(s);
        if (e) {
          if (this.fill === null ? o.MC(t.x, t.y, p) : o.jk(t, p, true, false))
            return true;
        } else {
          const y = o.figures;
          for (let x = 0; x < y.count; x++) {
            const b = y.h[x];
            let k = b.startX, S = b.startY;
            if (t.distanceSquared(k, S) > s)
              return false;
            const M = b.segments.h, A = M.length;
            for (let C = 0; C < A; C++) {
              const P = M[C];
              switch (P.type) {
                case 1:
                case 2:
                  if (k = P.endX, S = P.endY, t.distanceSquared(k, S) > s)
                    return false;
                  break;
                case 3: {
                  const N = Util.ct();
                  Geo.Hn(k, S, P.point1X, P.point1Y, P.point2X, P.point2Y, P.endX, P.endY, 0.8, N);
                  const T = r(N, t);
                  if (Util.ot(N), T || (k = P.endX, S = P.endY, t.distanceSquared(k, S) > s))
                    return false;
                  break;
                }
                case 4: {
                  const N = Util.ct();
                  Geo.Wg(k, S, P.point1X, P.point1Y, P.endX, P.endY, 0.8, N);
                  const T = r(N, t);
                  if (Util.ot(N), T || (k = P.endX, S = P.endY, t.distanceSquared(k, S) > s))
                    return false;
                  break;
                }
                case 5:
                case 6: {
                  const N = P.type === 5 ? P.Fo(b) : P.Kh(b, k, S), T = N.length;
                  if (T === 0) {
                    if (k = P.type === 5 ? P.centerX : P.endX, S = P.type === 5 ? P.centerY : P.endY, t.distanceSquared(k, S) > s)
                      return false;
                    break;
                  }
                  let L = null;
                  const D = Util.ct();
                  for (let F = 0; F < T; F++)
                    if (L = N[F], D.length = 0, Geo.Hn(L[0], L[1], L[2], L[3], L[4], L[5], L[6], L[7], 0.8, D), r(D, t))
                      return Util.ot(D), false;
                  Util.ot(D), L !== null && (k = L[6], S = L[7]);
                  break;
                }
                default:
                  Util.n("Unknown Segment type: " + P.type);
              }
            }
          }
          return true;
        }
      }
      return false;
    }
    CI(t, i, e, s, n, o) {
      if (t.width === 0)
        return Geo.vn(t.x, t.y, t.x, t.y + t.height, i, e, s, n, o);
      if (t.height === 0)
        return Geo.vn(t.x, t.y, t.x + t.width, t.y, i, e, s, n, o);
      {
        const r = t.width / 2, l = t.height / 2, h = t.x + r, a = t.y + l;
        let f = 9999;
        if (i !== s && (f = (e - n) / (i - s)), Math.abs(f) < 9999) {
          const c = e - a - f * (i - h);
          if (r * r * (f * f) + l * l - c * c < 0)
            return o.x = NaN, o.y = NaN, false;
          const u = Math.sqrt(r * r * (f * f) + l * l - c * c), d = (-(r * r * f * c) + r * l * u) / (l * l + r * r * (f * f)) + h, m = (-(r * r * f * c) - r * l * u) / (l * l + r * r * (f * f)) + h, g = f * (d - h) + c + a, p = f * (m - h) + c + a, y = Math.abs((i - d) * (i - d)) + Math.abs((e - g) * (e - g)), x = Math.abs((i - m) * (i - m)) + Math.abs((e - p) * (e - p));
          y < x ? (o.x = d, o.y = g) : (o.x = m, o.y = p);
        } else {
          const c = l * l, u = r * r, d = i - h, m = c - c / u * (d * d);
          if (m < 0)
            return o.x = NaN, o.y = NaN, false;
          const g = Math.sqrt(m), p = a + g, y = a - g, x = Math.abs(p - e), b = Math.abs(y - e);
          x < b ? (o.x = i, o.y = p) : (o.x = i, o.y = y);
        }
        return true;
      }
    }
    pI() {
      return this.Qo / 2 * this.strokeMiterLimit * this.getDocumentScale();
    }
    get geometry() {
      return this.yt !== null ? this.yt : this.As;
    }
    set geometry(t) {
      const i = this.yt, e = this.As;
      if (i === t)
        return;
      t !== null ? (Debug && Util.s(t, Geometry2, _Shape, "geometry"), this.yt = t.w(), this.As = this.yt) : (this.yt = null, this.As = null);
      const s = this.part;
      if (s !== null && s.gc(), this.u(), this.i("geometry", i || e, t), this.ic()) {
        const n = this.part;
        n !== null && this.Sa(n, "geometryString");
      }
    }
    get geometryString() {
      return this.geometry === null ? "" : this.geometry.toString();
    }
    set geometryString(t) {
      const i = Geometry2.parse(t), e = i.normalize();
      this.geometry = i;
      const s = Point2.H(-e.x, -e.y);
      this.position = s, Point2.o(s);
    }
    get isGeometryPositioned() {
      return (this.l & 1048576) !== 0;
    }
    set isGeometryPositioned(t) {
      const i = (this.l & 1048576) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Shape, "isGeometryPositioned"), this.l = this.l ^ 1048576, this.u(), this.i("isGeometryPositioned", i, t));
    }
    fe() {
      this.yt = null;
    }
    get fill() {
      return this.Fa;
    }
    set fill(t) {
      const i = this.Fa;
      i !== t && (t !== null && Brush2.ud(t, "Shape.fill"), t instanceof Brush2 && t.w(), this.Fa = t, this.T(), this.i("fill", i, t));
    }
    get stroke() {
      return this.$i;
    }
    set stroke(t) {
      const i = this.$i;
      i !== t && (t !== null && Brush2.ud(t, "Shape.stroke"), t instanceof Brush2 && t.w(), this.$i = t, this.T(), this.i("stroke", i, t));
    }
    get strokeWidth() {
      return this.Qo;
    }
    set strokeWidth(t) {
      const i = this.Qo;
      if (i !== t)
        if (Debug && Util.r(t, _Shape, "strokeWidth"), t >= 0) {
          this.Qo = t, this.u();
          const e = this.part;
          e !== null && e.gc(), this.i("strokeWidth", i, t);
        } else
          Util.G(t, "value >= 0", _Shape, "strokeWidth:value");
    }
    K1() {
      return this.Qo;
    }
    get strokeCap() {
      return this.Rt !== null ? this.Rt.Mp : "butt";
    }
    set strokeCap(t) {
      const i = this.strokeCap;
      i !== t && (typeof t == "string" && (t === "butt" || t === "round" || t === "square") ? (this.Ra(), this.Rt.Mp = t, this.T(), this.i("strokeCap", i, t)) : Util.G(t, '"butt", "round", or "square"', _Shape, "strokeCap"));
    }
    get strokeJoin() {
      return this.Rt !== null ? this.Rt.Pp : "miter";
    }
    set strokeJoin(t) {
      const i = this.strokeJoin;
      i !== t && (typeof t == "string" && (t === "miter" || t === "bevel" || t === "round") ? (this.Ra(), this.Rt.Pp = t, this.T(), this.i("strokeJoin", i, t)) : Util.G(t, '"miter", "bevel", or "round"', _Shape, "strokeJoin"));
    }
    get strokeMiterLimit() {
      return this.Rt !== null ? this.Rt.Np : 10;
    }
    set strokeMiterLimit(t) {
      const i = this.strokeMiterLimit;
      if (i !== t)
        if (Debug && Util.r(t, _Shape, "strokeMiterLimit"), t >= 1) {
          this.Ra(), this.Rt.Np = t, this.T();
          const e = this.part;
          e !== null && e.gc(), this.i("strokeMiterLimit", i, t);
        } else
          Debug && Util.G(t, "value >= 1", _Shape, "strokeWidth:value");
    }
    get strokeDashArray() {
      return this.jo;
    }
    set strokeDashArray(t) {
      const i = this.jo;
      if (i !== t) {
        if (t !== null && !Array.isArray(t) && Util.Bi(t, "Array", _Shape, "strokeDashArray:value"), t !== null) {
          const e = t.length;
          let s = 0;
          for (let n = 0; n < e; n++) {
            const o = t[n];
            (Debug && typeof o != "number" || !(o >= 0) || !isFinite(o)) && Util.n("strokeDashArray:value " + o + " at index " + n + " must be a positive number or zero."), s += o;
          }
          if (s === 0) {
            if (i === null)
              return;
            t = null;
          }
        }
        this.jo = t, this.T(), this.i("strokeDashArray", i, t);
      }
    }
    get strokeDashOffset() {
      return this.Rt !== null ? this.Rt.wh : 0;
    }
    set strokeDashOffset(t) {
      const i = this.strokeDashOffset;
      i !== t && (Debug && Util.r(t, _Shape, "strokeDashOffset"), t >= 0 && (this.Ra(), this.Rt.wh = t, this.T(), this.i("strokeDashOffset", i, t)));
    }
    get figure() {
      return this.Ad;
    }
    set figure(t) {
      const i = this.Ad;
      if (i !== t) {
        Debug && Util.t(t, "string", _Shape, "figure");
        let e = Geo.qn[t];
        if (typeof e == "function" ? e = t : (e = Geo.qn[t.toLowerCase()], e || Util.n("Unknown Shape.figure: " + t)), i !== e) {
          const s = this.part;
          s !== null && s.gc(), this.Ad = e, this.As = null, this.fe(), this.u(), this.i("figure", i, e);
        }
      }
    }
    get toArrow() {
      return this.Ut !== null ? this.Ut.Cp : "None";
    }
    set toArrow(t) {
      const i = this.toArrow;
      if (t === true ? t = "Standard" : t === false && (t = ""), i !== t) {
        Debug && Util.t(t, "string", _Shape, "toArrow");
        const e = _Shape.RL(t);
        e === null ? Util.n("Unknown Shape.toArrow: " + t) : i !== e && (this.Ut === null && (this.Ut = new LinkElementSettings()), this.Ut.Cp = e, this.As = null, this.fe(), this.u(), this.IL(e), this.i("toArrow", i, e));
      }
    }
    get fromArrow() {
      return this.Ut !== null ? this.Ut.Ap : "None";
    }
    set fromArrow(t) {
      const i = this.fromArrow;
      if (t === true ? t = "Standard" : t === false && (t = ""), i !== t) {
        Debug && Util.t(t, "string", _Shape, "fromArrow");
        const e = _Shape.RL(t);
        e === null ? Util.n("Unknown Shape.fromArrow: " + t) : i !== e && (this.Ut === null && (this.Ut = new LinkElementSettings()), this.Ut.Ap = e, this.As = null, this.fe(), this.u(), this.IL(e), this.i("fromArrow", i, e));
      }
    }
    IL(t) {
      const i = this.diagram;
      if (i !== null && i.undoManager.isUndoingRedoing)
        return;
      this.XR();
      const e = Spot2.MiddleRight;
      this.toArrow !== "None" ? (this.segmentIndex = -1, this.alignmentFocus = e) : this.fromArrow !== "None" && (this.segmentIndex = 0, this.alignmentFocus = new Spot2(1 - e.x, e.y));
    }
    get spot1() {
      return this.Rt !== null ? this.Rt.Wn : Spot2.Default;
    }
    set spot1(t) {
      Util.s(t, Spot2, _Shape, "spot1");
      const i = this.spot1;
      i.equals(t) || (t = t.L(), this.Ra(), this.Rt.Wn = t, this.u(), this.i("spot1", i, t));
    }
    get spot2() {
      return this.Rt !== null ? this.Rt.jn : Spot2.Default;
    }
    set spot2(t) {
      Util.s(t, Spot2, _Shape, "spot2");
      const i = this.spot2;
      i.equals(t) || (t = t.L(), this.Ra(), this.Rt.jn = t, this.u(), this.i("spot2", i, t));
    }
    get parameter1() {
      return this.Ld;
    }
    set parameter1(t) {
      const i = this.Ld;
      i !== t && (this.Ld = t, this.fe(), this.u(), this.i("parameter1", i, t));
    }
    get parameter2() {
      return this.Td;
    }
    set parameter2(t) {
      const i = this.Td;
      i !== t && (this.Td = t, this.fe(), this.u(), this.i("parameter2", i, t));
    }
    get naturalBounds() {
      return this.Hi;
    }
    oI() {
      const t = this.desiredSize;
      if (!t.isReal() && this.yt !== null) {
        const i = this.yt.bounds;
        this.Hi.c(i);
      } else
        this.Hi.e(0, 0, t.width, t.height);
    }
    get pathPattern() {
      return this.Rt !== null ? this.Rt.Lp : null;
    }
    set pathPattern(t) {
      const i = this.pathPattern;
      i !== t && (Debug && t !== null && Util.s(t, GraphObject2, _Shape, "pathPattern"), this.Ra(), this.Rt.Lp = t, this.T(), this.i("pathPattern", i, t));
    }
    get geometryStretch() {
      return this.Rt !== null ? this.Rt.Tp : 1;
    }
    set geometryStretch(t) {
      const i = this.geometryStretch;
      i !== t && (Util.it(t, GeometryStretch2, "GeometryStretch"), this.Ra(), this.Rt.Tp = t, this.u(), this.i("geometryStretch", i, t));
    }
    get interval() {
      return this.tt !== null ? this.tt.pc : 1;
    }
    set interval(t) {
      const i = this.interval;
      if (Debug && Util.r(t, _Shape, "interval"), t = Math.round(t), i !== t && t !== 0 && isFinite(t)) {
        this.tt === null && (this.tt = new GradElementSettings()), this.tt.pc = t;
        const e = this.diagram;
        e !== null && this.panel === e.grid && e._r(), this.u();
        const s = this.panel;
        s !== null && (s.cs = null), this.i("interval", i, t);
      }
    }
    get graduatedStart() {
      return this.tt !== null ? this.tt.yc : 0;
    }
    set graduatedStart(t) {
      const i = this.graduatedStart;
      Debug && Util.r(t, _Shape, "graduatedStart"), i !== t && (t < 0 ? t = 0 : t > 1 && (t = 1), this.tt === null && (this.tt = new GradElementSettings()), this.tt.yc = t, this.u(), this.i("graduatedStart", i, t));
    }
    get graduatedEnd() {
      return this.tt !== null ? this.tt.wc : 1;
    }
    set graduatedEnd(t) {
      const i = this.graduatedEnd;
      Debug && Util.r(t, _Shape, "graduatedEnd"), i !== t && (t < 0 ? t = 0 : t > 1 && (t = 1), this.tt === null && (this.tt = new GradElementSettings()), this.tt.wc = t, this.u(), this.i("graduatedEnd", i, t));
    }
    get graduatedSkip() {
      return this.tt !== null ? this.tt.xc : null;
    }
    set graduatedSkip(t) {
      const i = this.graduatedSkip;
      i !== t && (t !== null && Util.t(t, "function", _Shape, "graduatedSkip"), this.tt === null && (this.tt = new GradElementSettings()), this.tt.xc = t, this.u(), this.i("graduatedSkip", i, t));
    }
    static NI(t, i, e) {
      let n = null;
      if (t.toArrow !== "None")
        n = _Shape.co[t.toArrow];
      else if (t.fromArrow !== "None")
        n = _Shape.co[t.fromArrow];
      else {
        let o = Geo.qn[t.figure];
        typeof o == "string" && (o = Geo.qn[o]), o === void 0 && Util.n("Unknown Shape.figure: " + t.figure), n = o(t, i, e), n.ff = i, n.cf = e;
      }
      if (n === null) {
        const o = Geo.qn.Rectangle;
        typeof o == "function" && (n = o(t, i, e));
      }
      return Debug && (n.bounds.width > i + 1e-5 || n.bounds.height > e + 1e-5) && Util.n('Geometry made with figure "' + t.figure + '" has bounds ' + n.bounds.toString() + " that are too large for the given size (" + i + "," + e + "). See documentation for Shape.defineFigureGenerator."), n;
    }
    static getFigureGenerators() {
      const t = new GMap2();
      for (const i in Geo.qn) {
        if (i === i.toLowerCase())
          continue;
        const e = Geo.qn[i];
        t.add(i, e);
      }
      return t.w(), t;
    }
    static defineFigureGenerator(t, i) {
      Util.t(t, "string", _Shape, "defineFigureGenerator:name"), typeof i == "string" ? Debug && (i === "" || !Geo.qn[i]) && Util.n("Shape.defineFigureGenerator synonym must not be empty or None or not a defined figure name: " + i) : Util.t(i, "function", _Shape, "defineFigureGenerator:func");
      const e = t.toLowerCase();
      Debug && (t === "" || t === e) && Util.n("Shape.defineFigureGenerator name must not be empty or all-lower-case: " + t);
      const s = Geo.qn;
      s[t] = i, s[e] = t;
    }
    static getArrowheadGeometries() {
      const t = new GMap2();
      for (const i in Geo.$g)
        if (_Shape.co[i] === void 0) {
          const e = Geometry2.parse(Geo.$g[i], false);
          _Shape.co[i] = e;
          const s = i.toLowerCase();
          s !== i && (_Shape.co[s] = i);
        }
      for (const i in _Shape.co) {
        if (i === i.toLowerCase())
          continue;
        const e = _Shape.co[i];
        e instanceof Geometry2 && t.add(i, e);
      }
      return t.w(), t;
    }
    static defineArrowheadGeometry(t, i) {
      Util.t(t, "string", _Shape, "defineArrowheadGeometry:name");
      let e = null;
      typeof i == "string" ? (Util.t(i, "string", _Shape, "defineArrowheadGeometry:pathstr"), e = Geometry2.parse(i, false)) : (Util.s(i, Geometry2, _Shape, "defineArrowheadGeometry:pathstr"), e = i);
      const s = t.toLowerCase();
      (Debug && t === "" || s === "none" || t === s) && Util.n("Shape.defineArrowheadGeometry name must not be empty or None or all-lower-case: " + t);
      const n = _Shape.co;
      n[t] = e, n[s] = t;
    }
    static RL(t) {
      let i = _Shape.co[t];
      if (i === void 0) {
        const e = t.toLowerCase();
        if (e === "none")
          return "None";
        if (i = _Shape.co[e], i === void 0) {
          let s = null;
          for (const n in Geo.$g)
            if (n.toLowerCase() === e) {
              s = n;
              break;
            }
          if (s !== null) {
            const n = Geometry2.parse(Geo.$g[s], false);
            return _Shape.co[s] = n, e !== s && (_Shape.co[e] = s), s;
          }
        }
      }
      return typeof i == "string" ? i : i instanceof Geometry2 ? t : null;
    }
  };
  __publicField(_Shape, "co", new PropertyCollection());
  __publicField(_Shape, "K2", new PropertyCollection());
  let Shape2 = _Shape;
  class ShapeTemplateSettings {
    constructor() {
      __publicField(this, "xi");
      __publicField(this, "Mp");
      __publicField(this, "Pp");
      __publicField(this, "Np");
      __publicField(this, "wh");
      __publicField(this, "Lp");
      __publicField(this, "Tp");
      __publicField(this, "Wn");
      __publicField(this, "jn");
      this.xi = false, this.Mp = "butt", this.Pp = "miter", this.Np = 10, this.wh = 0, this.Lp = null, this.Tp = 1, this.Wn = Spot2.Default, this.jn = Spot2.Default;
    }
    copy() {
      const t = new ShapeTemplateSettings();
      return t.Mp = this.Mp, t.Pp = this.Pp, t.Np = this.Np, t.wh = this.wh, t.Lp = this.Lp, t.Tp = this.Tp, t.Wn = this.Wn.L(), t.jn = this.jn.L(), t;
    }
  }
  var Wrap2 = ((w) => (w[w.None = 0] = "None", w[w.Fit = 1] = "Fit", w[w.DesiredSize = 2] = "DesiredSize", w[w.BreakAll = 3] = "BreakAll", w))(Wrap2 || {}), TextOverflow2 = ((w) => (w[w.Clip = 0] = "Clip", w[w.Ellipsis = 1] = "Ellipsis", w))(TextOverflow2 || {}), TextFormat2 = ((w) => (w[w.Trim = 0] = "Trim", w[w.None = 1] = "None", w))(TextFormat2 || {});
  const _TextBlock = class _TextBlock extends GraphObject2 {
    constructor(t, i) {
      super();
      __publicField(this, "di");
      __publicField(this, "$i");
      __publicField(this, "Ln");
      __publicField(this, "Oe");
      __publicField(this, "bi");
      __publicField(this, "C0");
      __publicField(this, "Fd");
      __publicField(this, "tt");
      __publicField(this, "_");
      __publicField(this, "Bl");
      __publicField(this, "uo");
      __publicField(this, "Tn");
      __publicField(this, "Ee");
      __publicField(this, "Ei");
      __publicField(this, "Dn");
      return this.l |= 2097152, this.di = "", this.$i = "black", this.Ln = "13px sans-serif", this.Oe = 0, this.bi = 0, this.C0 = 0, this.Fd = null, this.tt = null, this._ = null, this.Bl = 0, this.uo = null, this.Tn = 0, this.Ee = null, this.Ei = null, this.Dn = null, typeof t == "string" ? this.text = t : t && Object.assign(this, t), i && Object.assign(this, i), this;
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.di = this.di, t.$i = this.$i, t.Ln = this.Ln, t.Oe = this.Oe, t.bi = this.bi, t.C0 = this.C0, t.Fd = this.Fd, this.tt !== null && (t.tt = this.tt.copy()), this._ !== null && (this._.xi ? t._ = this._ : t._ = this._.copy()), t.Bl = this.Bl, t.uo = this.uo, t.Tn = this.Tn, t.Ee = this.Ee, t.Ei = this.Ei, t.Dn = this.Dn;
    }
    Fn() {
      this._ === null ? this._ = new TextBlockTemplateSettings() : this._.xi && (this._ = this._.copy());
    }
    uh() {
      super.uh(), this._ !== null && (this._.xi = true);
    }
    uI(t) {
      this.l = t.l | 2048 | 4096, this._t = t.opacity, this.Ft = t.background, this.We = t.desiredSize.L(), this.minSize = t.minSize.L(), this.maxSize = t.maxSize.L(), t.Ni !== null ? this.Ni = t.Ni.copy() : this.Ni = null, this.v = t.scale, this.qt = t.angle, this.stretch = t.stretch, this.ol = t.margin.L(), this.fi = t.alignment.L(), this._f = t.alignmentFocus.L(), this.segmentFraction = t.segmentFraction, this.segmentOffset = t.segmentOffset.L(), this.segmentOrientation = t.segmentOrientation, t.hi !== null && (this.hi = t.hi.copy()), this.shadowVisible = t.shadowVisible, this.di = t.di, this.$i = t.$i, this.Ln = t.Ln, this.tt !== null && (this.tt = t.tt.copy()), t._ !== null && (t._.xi ? this._ = t._ : this._ = t._.copy()), this.Bl = t.Bl;
    }
    fI(t) {
      if (this.di = t.text || "", this.qt = t.labelAngle || 0, this.Oe = t.lineCount || 0, this.TI(t.lines), t.naturalBounds && (this.Hi = t.naturalBounds), t.actualBounds) {
        const i = t.actualBounds;
        this.vt(i.x, i.y, i.width, i.height);
      }
    }
    ci(t) {
      t in Wrap2 ? this.wrap = t : super.ci(t);
    }
    toString() {
      return this.di.length > 22 ? 'TextBlock("' + this.di.substring(0, 20) + '"...)' : 'TextBlock("' + this.di + '")';
    }
    static getEllipsis() {
      return _TextBlock.Dp;
    }
    static setEllipsis(t) {
      _TextBlock.Dp = t, _TextBlock.hb = new PropertyCollection(), _TextBlock.U2 = 0;
    }
    static getBaseline() {
      return _TextBlock.ab;
    }
    static setBaseline(t) {
      _TextBlock.ab = t;
    }
    static getUnderline() {
      return _TextBlock.fb;
    }
    static setUnderline(t) {
      _TextBlock.fb = t;
    }
    u() {
      super.u();
    }
    get font() {
      return this.Ln;
    }
    set font(t) {
      const i = this.Ln;
      i !== t && (Debug && (Util.t(t, "string", _TextBlock, "font"), _TextBlock.isValidFont(t) || Util.n('Not a valid font: "' + t + '"')), this.Ln = t, this.uo = null, this.u(), this.i("font", i, t));
    }
    static isValidFont(t) {
      return root.CSS ? root.CSS.supports("font", t) : true;
    }
    get text() {
      return this.di;
    }
    set text(t) {
      const i = this.di;
      t != null ? t = t.toString() : t = "", i !== t && (this.di = t, this.u(), this.i("text", i, t), this.fs(true));
    }
    get textAlign() {
      return this._ !== null ? this._.Fp : "start";
    }
    set textAlign(t) {
      const i = this.textAlign;
      i !== t && (Debug && Util.t(t, "string", _TextBlock, "textAlign"), t === "start" || t === "end" || t === "left" || t === "right" || t === "center" ? (this.Fn(), this._.Fp = t, this.T(), this.i("textAlign", i, t)) : Debug && Util.G(t, '"start", "end", "left", "right", or "center"', _TextBlock, "textAlign"));
    }
    get flip() {
      return this._ !== null ? this._.go : 0;
    }
    set flip(t) {
      const i = this.flip;
      i !== t && (Util.it(t, Flip2, "Flip"), this.Fn(), this._.go = t, this.T(), this.i("flip", i, t));
    }
    get verticalAlignment() {
      return this._ !== null ? this._.cl : Spot2.Top;
    }
    set verticalAlignment(t) {
      const i = this.verticalAlignment;
      i.equals(t) || (Debug && (Util.s(t, Spot2, _TextBlock, "verticalAlignment"), t.isNoSpot() && Util.n("TextBlock.verticalAlignment for " + this + " must be a real Spot, not:" + t)), t = t.L(), this.Fn(), this._.cl = t, this.rc(), this.i("verticalAlignment", i, t));
    }
    get naturalBounds() {
      if (!this.Hi.isReal()) {
        const t = Size2.a();
        this.G2(this.di, 999999, t);
        let i = t.width;
        Size2.o(t);
        let e = this.OL(i);
        const s = this.desiredSize;
        isNaN(s.width) || (i = s.width), isNaN(s.height) || (e = s.height), this.Hi.Do(i, e);
      }
      return this.Hi;
    }
    get isMultiline() {
      return (this.l & 2097152) !== 0;
    }
    set isMultiline(t) {
      const i = (this.l & 2097152) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _TextBlock, "isMultiline"), this.l = this.l ^ 2097152, this.u(), this.i("isMultiline", i, t));
    }
    get isUnderline() {
      return (this.l & 4194304) !== 0;
    }
    set isUnderline(t) {
      const i = (this.l & 4194304) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _TextBlock, "isUnderline"), this.l = this.l ^ 4194304, this.fs(true), this.T(), this.i("isUnderline", i, t));
    }
    get isStrikethrough() {
      return (this.l & 8388608) !== 0;
    }
    set isStrikethrough(t) {
      const i = (this.l & 8388608) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _TextBlock, "isStrikethrough"), this.l = this.l ^ 8388608, this.fs(true), this.T(), this.i("isStrikethrough", i, t));
    }
    get wrap() {
      return this._ !== null ? this._.Rp : 2;
    }
    set wrap(t) {
      const i = this.wrap;
      i !== t && (Debug && Util.it(t, Wrap2, "Wrap"), this.Fn(), this._.Rp = t, this.u(), this.i("wrap", i, t));
    }
    get overflow() {
      return this._ !== null ? this._.Ip : 0;
    }
    set overflow(t) {
      const i = this.overflow;
      i !== t && (Debug && Util.it(t, TextOverflow2, "Overflow"), this.Fn(), this._.Ip = t, this.u(), this.i("overflow", i, t));
    }
    get isOverflowed() {
      return (this.l & 16777216) !== 0;
    }
    H2(t) {
      t ? this.l |= 16777216 : this.l &= -16777217;
    }
    get stroke() {
      return this.$i;
    }
    set stroke(t) {
      const i = this.$i;
      i !== t && (t !== null && Brush2.ud(t, "TextBlock.stroke"), t instanceof Brush2 && t.w(), this.$i = t, this.T(), this.i("stroke", i, t));
    }
    get lineCount() {
      return this.Oe;
    }
    get lineHeight() {
      return this.Op();
    }
    get editable() {
      return (this.l & 1048576) !== 0;
    }
    set editable(t) {
      const i = (this.l & 1048576) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _TextBlock, "editable"), this.l = this.l ^ 1048576, this.i("editable", i, t));
    }
    get textEditor() {
      return this._ !== null ? this._.Ep : null;
    }
    set textEditor(t) {
      const i = this.textEditor;
      i !== t && (Debug && !(t instanceof HTMLInfo2) && Util.n("TextBlock.textEditor must be an HTMLInfo."), this.Fn(), this._.Ep = t, this.i("textEditor", i, t));
    }
    get errorFunction() {
      return this._ !== null ? this._.us : null;
    }
    set errorFunction(t) {
      const i = this.errorFunction;
      i !== t && (t !== null && Util.t(t, "function", _TextBlock, "errorFunction"), this.Fn(), this._.us = t, this.i("errorFunction", i, t));
    }
    get interval() {
      return this.tt !== null ? this.tt.pc : 1;
    }
    set interval(t) {
      const i = this.interval;
      if (Debug && Util.r(t, _TextBlock, "interval"), t = Math.round(t), i !== t && t !== 0 && isFinite(t)) {
        this.tt === null && (this.tt = new GradElementSettings()), this.tt.pc = t, this.u();
        const e = this.panel;
        e !== null && (e.cs = null), this.i("interval", i, t);
      }
    }
    get graduatedStart() {
      return this.tt !== null ? this.tt.yc : 0;
    }
    set graduatedStart(t) {
      const i = this.graduatedStart;
      Debug && Util.r(t, _TextBlock, "graduatedStart"), i !== t && (t < 0 ? t = 0 : t > 1 && (t = 1), this.tt === null && (this.tt = new GradElementSettings()), this.tt.yc = t, this.u(), this.i("graduatedStart", i, t));
    }
    get graduatedEnd() {
      return this.tt !== null ? this.tt.wc : 1;
    }
    set graduatedEnd(t) {
      const i = this.graduatedEnd;
      Debug && Util.r(t, _TextBlock, "graduatedEnd"), i !== t && (t < 0 ? t = 0 : t > 1 && (t = 1), this.tt === null && (this.tt = new GradElementSettings()), this.tt.wc = t, this.u(), this.i("graduatedEnd", i, t));
    }
    get graduatedFunction() {
      return this.tt !== null ? this.tt.Vp : null;
    }
    set graduatedFunction(t) {
      const i = this.graduatedFunction;
      i !== t && (t !== null && Util.t(t, "function", _TextBlock, "graduatedFunction"), this.tt === null && (this.tt = new GradElementSettings()), this.tt.Vp = t, this.u(), this.i("graduatedFunction", i, t));
    }
    get graduatedSkip() {
      return this.tt !== null ? this.tt.xc : null;
    }
    set graduatedSkip(t) {
      const i = this.graduatedSkip;
      i !== t && (t !== null && Util.t(t, "function", _TextBlock, "graduatedSkip"), this.tt === null && (this.tt = new GradElementSettings()), this.tt.xc = t, this.u(), this.i("graduatedSkip", i, t));
    }
    ph(t, i) {
      if (this.$i === null || this.di.length === 0 || this.Ln === null)
        return;
      const e = this.naturalBounds, s = this.actualBounds, n = e.width, o = e.height, r = this.Op();
      let l = t.textAlign = this.textAlign;
      const h = i.ju;
      l === "start" ? l = h ? "right" : "left" : l === "end" && (l = h ? "left" : "right");
      const a = this.isUnderline, f = this.isStrikethrough;
      this.bn(t, this.$i, true, false, e, s), (a || f) && this.bn(t, this.$i, false, false, e, s);
      const c = 0;
      let u = 0;
      const d = n;
      let m = false;
      const g = this.Ms, p = g.dx - (r * g.m21 + g.dx), y = g.dy - (r * g.m22 + g.dy);
      let x = p * p + y * y;
      const b = i.scale;
      x = x * b * b, x < 8 && (m = true), i.ai !== t && (m = false), i.ai instanceof SVGContext && (m = false), i.getRenderingHint("textGreeking") === false && (m = false);
      const k = this.spacingAbove, S = this.spacingBelow;
      switch (this.flip) {
        case 0:
          break;
        case 2:
          t.translate(n, 0), t.scale(-1, 1);
          break;
        case 1:
          t.translate(0, o), t.scale(1, -1);
          break;
        case 3:
          t.translate(n, o), t.scale(-1, -1);
          break;
      }
      t.commitTransform();
      const M = this.Oe, C = (k + r + S) * M;
      if (o > C) {
        const P = this.verticalAlignment;
        u = P.y * o - P.y * C + P.offsetY;
      }
      if (M === 1 && this.Dn !== null) {
        let P = this.bi;
        P > d && (P = d), u += k, this.EL(this.Dn, t, c, u, d, r, P, m, l, a, f);
      } else if (this.Ee !== null && this.Ei !== null)
        for (let P = 0; P < M; P++) {
          let N = this.Ee[P];
          N > d && (N = d), u += k, this.EL(this.Ei[P], t, c, u, d, r, N, m, l, a, f), u += r + S;
        }
      switch (this.flip) {
        case 0:
          break;
        case 2:
          t.scale(-1, 1), t.translate(-n, 0);
          break;
        case 1:
          t.scale(1, -1), t.translate(0, -o);
          break;
        case 3:
          t.scale(-1, -1), t.translate(-n, -o);
          break;
      }
    }
    EL(t, i, e, s, n, o, r, l, h, a, f) {
      let c = 0;
      if (l) {
        h === "left" ? c = 0 : h === "right" ? c = n - r : h === "center" && (c = (n - r) / 2), i.fillRect(e + c, s + o * 0.25, r, 1);
        return;
      }
      h === "left" ? c = 0 : h === "right" ? c = n : h === "center" && (c = n / 2);
      const u = _TextBlock.ab !== null ? _TextBlock.ab(this, o) : o * 0.75;
      i.fillText(t, e + c, s + u);
      let d = o / 20 | 0;
      if (d === 0 && (d = 1), h === "right" ? c -= r : h === "center" && (c -= r / 2), a) {
        const m = _TextBlock.fb !== null ? _TextBlock.fb(this, o) : o * 0.8;
        this.VL(e + c, s + m, e + c + r, s + m, d, i), i instanceof SVGContext && i.lastCreatedElement.classList.add("gojs-td");
      }
      if (f) {
        let m = s + o - o / 2.2 | 0;
        d % 2 !== 0 && (m += 0.5), this.VL(e + c, m, e + c + r, m, d, i), i instanceof SVGContext && i.lastCreatedElement.classList.add("gojs-td");
      }
    }
    VL(t, i, e, s, n, o) {
      o.beginPath(), o.lineWidth = n, o.moveTo(t, i), o.lineTo(e, s), o.stroke(), o.endPath();
    }
    sc(t, i, e) {
      if (!super.sc(t, i, e))
        return false;
      if (this.bn(t, this.$i, true, false, this.naturalBounds, this.actualBounds), e) {
        if (this.svg.getElementsByTagName("text").length === 0)
          return true;
        const n = this.svg.getElementsByClassName("gojs-td");
        for (let o = 0; o < n.length; o++)
          t.setFillOrStrokeInPlace(n[o], false);
      } else
        this.DI(this.svg, this.text, t);
      return true;
    }
    DI(t, i, e) {
      t.innerHTML = i, e.setFillOrStrokeInPlace(t, true);
    }
    fd(t) {
      return this.lineCount > 1 || this.isUnderline || this.isStrikethrough ? true : super.fd(t);
    }
    d2(t, i) {
      if (t.nodeName !== "g")
        t.setAttributeNS(null, "filter", i);
      else {
        const e = t.getElementsByTagName("text");
        for (let s = 0; s < e.length; s++)
          e[s].setAttributeNS(null, "filter", i);
      }
    }
    FI() {
      this.Tn = 0, this.bi = 0, this.uo = null, this.Ee = null, this.Ei = null, this.Dn = null;
    }
    ld(t, i, e, s) {
      const n = this.Oe;
      this.Bl = t, this.H2(false);
      const o = this.Ln;
      _TextBlock.al !== null && _TextBlock.BL !== o && (_TextBlock.al.font = o, _TextBlock.BL = o), this.FI();
      let r = 0, l = 0;
      isNaN(this.desiredSize.width) ? (r = this.RI(), r = Math.min(r, t / this.scale)) : r = this.desiredSize.width, this.panel !== null && (r = Math.min(r, this.panel.maxSize.width)), l = this.OL(r), isNaN(this.desiredSize.height) ? l = Math.min(l, i / this.scale) : l = this.desiredSize.height, this.II(t, l), (this.wrap === 1 || isNaN(this.desiredSize.width)) && (r = isNaN(t) ? this.bi : Math.min(t, this.bi)), r = Math.max(e, r), l = Math.max(s, l), this.Hi.Do(r, l), this.oo(0, 0, r, l), this.svg !== null && n !== this.Oe && this.fs(true);
    }
    gh(t, i, e, s) {
      this.commonArrange(t, i, e, s);
    }
    Rn(t, i) {
      this.Dn === null ? (this.Dn = t, this.bi = i) : ((this.Ei === null || this.Ee === null) && (this.Ei = [], this.Ee = [], this.Ei.push(this.Dn), this.Ee.push(this.bi)), this.Ei.push(t), this.Ee.push(i), this.Ei.length > this.maxLines && (this.l |= 16777216));
    }
    G2(t, i, e) {
      const s = this.formatting === 0;
      s && (t = t.trim());
      let n = 0, o = 0, r = 0;
      const l = this.Ln, h = this.spacingAbove + this.spacingBelow, a = Math.max(0, this.Op() + h), f = this.overflow === 1 ? this.zL(l) : 0;
      if (this.Oe >= this.maxLines) {
        e !== null && e.e(0, a);
        return;
      }
      let c = t;
      if (this.wrap === 0) {
        if (this.Tn = 1, o = this.getStringWidth(t), f === 0 || o <= i) {
          this.bi = Math.max(this.bi, o), this.Rn(t, this.bi), e !== null && e.e(o, a);
          return;
        }
        let d = this.Rd(c);
        c = c.substring(d.length);
        let m = this.Rd(c);
        for (o = this.getStringWidth(d + m), r = 0; m.length > 0 && o <= i; ) {
          d += m, c = c.substring(m.length), m = this.Rd(c), r = o;
          let g = d + m;
          s && (g = g.trim()), o = this.getStringWidth(g);
        }
        for (s && (m = m.trim()), d += m, i = Math.max(1, i - f); this.getStringWidth(d) > i && d.length > 1; )
          d = d.substring(0, d.length - 1);
        this.H2(true), d += _TextBlock.Dp, r = this.getStringWidth(d), this.bi = r, this.Rn(d, r), e !== null && e.e(r, a);
        return;
      }
      let u = 0;
      for (c.length === 0 && (u = 1, this.Rn(c, 0)); c.length > 0; ) {
        let d = this.Rd(c);
        for (c = c.substring(d.length); this.getStringWidth(d) > i; ) {
          let p = 1;
          for (o = this.getStringWidth(d.substring(0, p)), r = 0; o <= i; )
            p++, r = o, o = this.getStringWidth(d.substring(0, p));
          let y = 0;
          p === 1 ? (y = o, n = Math.max(n, o)) : (y = r, n = Math.max(n, r)), p--, p < 1 && (p = 1);
          const x = d.substring(0, p);
          if (this.Rn(x, y), u++, d = d.substring(p), this.Oe + u > this.maxLines)
            break;
        }
        let m = this.Rd(c);
        for (o = this.getStringWidth(d + m), r = 0; m.length > 0 && o <= i; ) {
          d += m, c = c.substring(m.length), m = this.Rd(c), r = o;
          let p = d + m;
          s && (p = p.trim()), o = this.getStringWidth(p);
        }
        if (s && (d = d.trim()), d === "")
          continue;
        d[d.length - 1] === "­" && (d = d.substring(0, d.length - 1) + "‐");
        let g = 0;
        if (m.length === 0 ? (g = o, n = Math.max(n, o)) : (r = this.getStringWidth(d), g = r, n = Math.max(n, r)), this.Rn(d, g), u++, this.Oe + u > this.maxLines)
          break;
      }
      this.Tn = Math.min(this.maxLines, u), this.bi = Math.max(this.bi, n), e !== null && e.e(this.bi, a * this.Tn);
    }
    II(t, i) {
      if (this.bi === 0 || this.Ee === null || this.Ei === null || this.overflow !== 1)
        return;
      const e = this.Ln, s = this.overflow === 1 ? this.zL(e) : 0, n = this.spacingAbove + this.spacingBelow, o = Math.max(0, this.Op() + n), r = Math.min(this.maxLines - 1, Math.max(Math.floor(i / o + 0.01) - 1, 0));
      if (r + 1 >= this.Ei.length)
        return;
      this.H2(true);
      let l = this.Ei[r];
      const h = Math.max(1, t - s);
      for (; this.getStringWidth(l) > h && l.length > 1; )
        l = l.substring(0, l.length - 1);
      l += _TextBlock.Dp;
      const a = this.getStringWidth(l);
      this.Ei[r] = l, this.Ei = this.Ei.slice(0, r + 1), this.Ee[r] = a, this.Ee = this.Ee.slice(0, r + 1), this.Tn = this.Ei.length, this.bi = Math.max(this.bi, a), this.Oe = this.Tn, this.Oe === 1 && (this.Dn = this.Ei[0]);
    }
    Rd(t) {
      if (this.wrap === 3)
        return t.substring(0, 1);
      let i = t.length, e = 0;
      const s = _TextBlock.OI;
      for (; e < i && !s.test(t.charAt(e)); )
        e++;
      for (this.formatting === 1 && (i = Math.min(i, e + 1)); e < i && s.test(t.charAt(e)); )
        e++;
      return e >= t.length ? t : t.substring(0, e);
    }
    getStringWidth(t) {
      return _TextBlock.al === null ? t.length * 8 : _TextBlock.al.measureText(t).width;
    }
    Op() {
      if (this.uo !== null)
        return this.uo;
      const t = this.Ln;
      let i = 0;
      return _TextBlock.al === null ? (i = 16, this.uo = i, i) : (_TextBlock.v2[t] !== void 0 && _TextBlock.XL < 5e3 ? i = _TextBlock.v2[t] : (i = _TextBlock.al.measureText("M").width * 1.3, _TextBlock.v2[t] = i, _TextBlock.XL++), this.uo = i, i);
    }
    zL(t) {
      if (_TextBlock.al === null)
        return 6;
      let i = 0;
      return _TextBlock.hb[t] !== void 0 && _TextBlock.U2 < 5e3 ? i = _TextBlock.hb[t] : (i = _TextBlock.al.measureText(_TextBlock.Dp).width, _TextBlock.hb[t] = i, _TextBlock.U2++), i;
    }
    cb(t, i) {
      return t.indexOf(`
`, i);
    }
    OL(t) {
      let i = this.di.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
      const e = this.spacingAbove + this.spacingBelow, s = Math.max(0, this.Op() + e);
      if (i.length === 0)
        return this.bi = 0, this.Oe = 1, s;
      if (!this.isMultiline) {
        const h = this.cb(i, 0);
        h >= 0 && (i = i.substring(0, h));
      }
      let n = 0;
      this.Oe = 0;
      let o = 0, r = -1, l = false;
      for (; !l; ) {
        if (r = this.cb(i, o), r === -1 && (r = i.length, l = true), o <= r) {
          const h = i.substring(o, r);
          if (this.wrap !== 0) {
            this.Tn = 0;
            const a = Size2.a();
            this.G2(h, t, a), n += a.height, Size2.o(a), this.Oe += this.Tn;
          } else
            this.G2(h, t, null), n += s, this.Oe++;
          this.Oe === this.maxLines && (l = true);
        }
        o = r + 1;
      }
      return this.C0 = n, n;
    }
    RI() {
      let t = this.di.replace(/\r\n/g, `
`).replace(/\r/g, `
`);
      if (t.length === 0)
        return 8;
      if (this.isMultiline) {
        let i = 0, e = 0, s = false;
        for (; !s; ) {
          let n = this.cb(t, e);
          n === -1 && (n = t.length, s = true);
          let o = t.substring(e, n);
          this.formatting === 0 && (o = o.trim()), i = Math.max(i, this.getStringWidth(o)), e = n + 1;
        }
        return i;
      } else {
        const i = this.cb(t, 0);
        return i >= 0 && (t = t.substring(0, i)), this.getStringWidth(t);
      }
    }
    get textValidation() {
      return this._ !== null ? this._.Vl : null;
    }
    set textValidation(t) {
      const i = this.textValidation;
      i !== t && (t !== null && Util.t(t, "function", _TextBlock, "textValidation"), this.Fn(), this._.Vl = t, this.i("textValidation", i, t));
    }
    get textEdited() {
      return this._ !== null ? this._.Bp : null;
    }
    set textEdited(t) {
      const i = this.textEdited;
      i !== t && (t !== null && Util.t(t, "function", _TextBlock, "textEdited"), this.Fn(), this._.Bp = t, this.i("textEdited", i, t));
    }
    get spacingAbove() {
      return this._ !== null ? this._.zp : 0;
    }
    set spacingAbove(t) {
      const i = this.spacingAbove;
      i !== t && (Debug && Util.t(t, "number", _TextBlock, "spacingAbove"), this.Fn(), this._.zp = t, this.u(), this.i("spacingAbove", i, t));
    }
    get spacingBelow() {
      return this._ !== null ? this._.Xp : 0;
    }
    set spacingBelow(t) {
      const i = this.spacingBelow;
      i !== t && (Debug && Util.t(t, "number", _TextBlock, "spacingBelow"), this.Fn(), this._.Xp = t, this.u(), this.i("spacingBelow", i, t));
    }
    get formatting() {
      return this._ !== null ? this._.Yp : 0;
    }
    set formatting(t) {
      const i = this.formatting;
      i !== t && (Util.it(t, TextFormat2, "formatting"), this.Fn(), this._.Yp = t, this.u(), this.i("formatting", i, t));
    }
    get maxLines() {
      return this._ !== null ? this._.Kp : 1 / 0;
    }
    set maxLines(t) {
      const i = this.maxLines;
      i !== t && (Debug && Util.t(t, "number", _TextBlock, "maxLines"), t = Math.floor(t), t <= 0 && Util.G(t, "> 0", _TextBlock, "maxLines"), this.Fn(), this._.Kp = t, this.u(), this.i("maxLines", i, t));
    }
    getMetrics() {
      return [this.bi, this.Bl, this.uo, this.Tn, this.Ee, this.Ei, this.Dn];
    }
    TI(t) {
      t !== void 0 && (this.bi = t[0], this.Bl = t[1], this.uo = t[2], this.Tn = t[3], this.Ee = t[4], this.Ei = t[5], this.Dn = t[6]);
    }
    get metrics() {
      return { arrSize: this.Ee !== null ? this.Ee : [this.bi], arrText: this.Ei !== null ? this.Ei : [this.Dn], maxLineWidth: this.bi, fontHeight: this.uo };
    }
    get choices() {
      return this.Fd;
    }
    set choices(t) {
      const i = this.Fd;
      i !== t && (Debug && t !== null && !Array.isArray(t) && Util.Bi(t, "Array", _TextBlock, "choices:value"), this.Fd = t, this.i("choices", i, t));
    }
  };
  __publicField(_TextBlock, "ab", null);
  __publicField(_TextBlock, "fb", null);
  __publicField(_TextBlock, "None", 0);
  __publicField(_TextBlock, "WrapFit", 1);
  __publicField(_TextBlock, "WrapDesiredSize", 2);
  __publicField(_TextBlock, "WrapBreakAll", 3);
  __publicField(_TextBlock, "OverflowClip", 0);
  __publicField(_TextBlock, "OverflowEllipsis", 1);
  __publicField(_TextBlock, "FormatTrim", 0);
  __publicField(_TextBlock, "FormatNone", 1);
  __publicField(_TextBlock, "OI", new RegExp("[ ​­]"));
  __publicField(_TextBlock, "v2", new PropertyCollection());
  __publicField(_TextBlock, "XL", 0);
  __publicField(_TextBlock, "hb", new PropertyCollection());
  __publicField(_TextBlock, "U2", 0);
  __publicField(_TextBlock, "Dp", "...");
  __publicField(_TextBlock, "BL", "");
  __publicField(_TextBlock, "al", Diagram2.isUsingDOM() ? new CanvasSurface(null).gi : null);
  let TextBlock2 = _TextBlock;
  class TextBlockTemplateSettings {
    constructor() {
      __publicField(this, "xi");
      __publicField(this, "us");
      __publicField(this, "go");
      __publicField(this, "Yp");
      __publicField(this, "Kp");
      __publicField(this, "Ip");
      __publicField(this, "zp");
      __publicField(this, "Xp");
      __publicField(this, "Fp");
      __publicField(this, "Bp");
      __publicField(this, "Ep");
      __publicField(this, "Vl");
      __publicField(this, "cl");
      __publicField(this, "Rp");
      this.xi = false, this.us = null, this.go = 0, this.Yp = 0, this.Kp = 1 / 0, this.Ip = 0, this.zp = 0, this.Xp = 0, this.Fp = "start", this.Bp = null, this.Ep = null, this.Vl = null, this.cl = Spot2.Top, this.Rp = 2;
    }
    copy() {
      const t = new TextBlockTemplateSettings();
      return t.us = this.us, t.go = this.go, t.Yp = this.Yp, t.Kp = this.Kp, t.Ip = this.Ip, t.zp = this.zp, t.Xp = this.Xp, t.Fp = this.Fp, t.Bp = this.Bp, t.Ep = this.Ep, t.Vl = this.Vl, t.cl = this.cl, t.Rp = this.Rp, t;
    }
  }
  class GradElementSettings {
    constructor() {
      __publicField(this, "pc");
      __publicField(this, "yc");
      __publicField(this, "wc");
      __publicField(this, "Vp");
      __publicField(this, "xc");
      this.pc = 1, this.yc = 0, this.wc = 1, this.Vp = null, this.xc = null;
    }
    copy() {
      const t = new GradElementSettings();
      return t.pc = this.pc, t.yc = this.yc, t.wc = this.wc, t.Vp = this.Vp, t.xc = this.xc, t;
    }
  }
  var ImageStretch2 = ((w) => (w[w.None = 0] = "None", w[w.Fill = 2] = "Fill", w[w.Uniform = 6] = "Uniform", w[w.UniformToFill = 7] = "UniformToFill", w))(ImageStretch2 || {});
  const _Picture = class _Picture extends GraphObject2 {
    constructor(t, i) {
      super();
      __publicField(this, "ul");
      __publicField(this, "St");
      __publicField(this, "dl");
      __publicField(this, "bc");
      __publicField(this, "us");
      __publicField(this, "gl");
      __publicField(this, "kc");
      __publicField(this, "go");
      __publicField(this, "Sc");
      __publicField(this, "Mc");
      __publicField(this, "q1");
      this.l |= 2097152, this.ul = null, this.St = "", this.dl = Rect2.RD, this.bc = 2, this.us = null, this.gl = null, this.kc = Spot2.Center, this.go = 0, this.Sc = null, this.Mc = null, this.q1 = null, typeof t == "string" ? this.source = t : t && Object.assign(this, t), i && Object.assign(this, i);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.St = this.St, t.element = this.ul, t.dl = this.dl.L(), t.bc = this.bc, t.go = this.go, t.us = this.us, t.gl = this.gl, t.kc = this.kc.L(), t.Mc = this.Mc;
    }
    ci(t) {
      t in ImageStretch2 ? this.imageStretch = t : super.ci(t);
    }
    toString() {
      return "Picture(" + this.source + ")#" + GSet2.ps(this);
    }
    get Pc() {
      return (this.l & 1048576) !== 0;
    }
    set Pc(t) {
      this.Pc !== t && (this.l = this.l ^ 1048576);
    }
    get Oa() {
      return (this.l & 2097152) !== 0;
    }
    set Oa(t) {
      this.Oa !== t && (this.l = this.l ^ 2097152);
    }
    get Sn() {
      return (this.l & 4194304) !== 0;
    }
    set Sn(t) {
      this.Sn !== t && (this.l = this.l ^ 4194304);
    }
    static clearCache(t) {
      t === void 0 && (t = ""), Util.t(t, "string", _Picture, "clearCache:url"), t !== "" ? _Picture.Up[t] && (delete _Picture.Up[t], _Picture.ub--) : (_Picture.Up = new PropertyCollection(), _Picture.ub = 0);
    }
    static BA(t, i) {
      i.YL || (i.db = (e) => {
        _Picture.EI(i, e), t.desiredSize.isReal() || (t.ae(false), t.u());
      }, i.gb = (e) => _Picture.VI(i, e), i.addEventListener("load", i.db), i.addEventListener("error", i.gb), i.YL = true);
    }
    static MR(t) {
      t.db && t.removeEventListener("load", t.db), t.gb && t.removeEventListener("error", t.gb), delete t.db, delete t.gb, delete t.YL;
    }
    get element() {
      return this.ul;
    }
    set element(t) {
      const i = this.ul;
      if (this.fs(true), i !== t) {
        this.Pc = t instanceof HTMLCanvasElement;
        const e = t instanceof HTMLImageElement;
        t !== null && !(e || t instanceof HTMLVideoElement || this.Pc) && Util.n("Picture.element must be an instance of Image, Canvas, or Video, not: " + t);
        const s = this.diagram;
        s !== null && s.EP(this), this.ul = t, t !== null && e && t.as === void 0 && (t.as = new GSet2()), s !== null && e && s.OP(this), this.i("element", i, t), this.T();
      }
    }
    kR() {
      const t = this.ul;
      t !== null && ((this.Pc || t.complete === true) && (t.w0 && (t.Gp instanceof Event && this.us !== null ? this.us(this, t.Gp) : t.Sn === true && !t.Gp && this.gl !== null && t.q2 && this.gl(this, t.q2)), t.Sn = true, this.desiredSize.isReal() || (this.ae(false), this.u())), t.Sn === true && this.diagram !== null && this.diagram.Wu.add(this));
    }
    BI() {
      if (this.ul === null) {
        this.Sc = false;
        return;
      }
      const t = new CanvasSurface(null).gi;
      try {
        t.drawImage(this.ul, 0, 0);
      } catch (i) {
        Debug && this.Oa && Util.ft(i.toString()), this.Oa = false;
      }
      try {
        t.getImageData(0, 0, 1, 1).data[3] && (this.Sc = false), this.Sc = false;
      } catch {
        this.Sc = true;
      }
    }
    get source() {
      return this.St;
    }
    set source(t) {
      const i = this.St;
      if (i !== t) {
        this.fs(true), Util.t(t, "string", _Picture, "source"), this.St = t;
        let e = _Picture.Up;
        if (!Diagram2.isUsingDOM()) {
          this.i("source", i, t);
          return;
        }
        let s = null;
        if (e[t] !== void 0)
          s = e[t];
        else if (t !== "") {
          _Picture.ub > 30 && (_Picture.clearCache(), e = _Picture.Up), s = Util.hn("img"), s.w0 = true, _Picture.BA(this, s);
          const n = this.Mc;
          n !== null && (s.crossOrigin = n(this)), s.src = t, e[t] = s, _Picture.ub++;
        }
        this.element = s, s !== null && s.__goCache === void 0 && (s.__goCache = new PictureCacheArray()), this.u(), this.T(), this.i("source", i, t);
      }
    }
    static EI(t, i) {
      t.Sn = true, t.Gp = false;
      let e;
      const s = t.as.copy();
      if (s == null)
        return;
      const n = s.iterator;
      for (; n.next(); ) {
        const o = n.value;
        o.T();
        const r = t.getAttribute("src") || "", l = o.eh.getValue(r);
        if (l === null)
          continue;
        const h = l.length;
        for (let a = 0; a < h; a++)
          e = l[a], o.Wu.add(e), e.fs(true), o.requestUpdate(), t.w0 && (t.q2 === void 0 && (t.q2 = i), e.gl !== null && e.gl(e, i));
      }
      t.as.clear();
    }
    static VI(t, i) {
      t.Gp = i;
      let e;
      const s = t.as.copy();
      if (s == null)
        return;
      const n = s.iterator;
      for (; n.next(); ) {
        const o = n.value, r = t.getAttribute("src") || "", l = o.eh.getValue(r);
        if (l === null)
          continue;
        const h = l.length, a = Util.ct();
        for (let f = 0; f < h; f++)
          a.push(l[f]);
        if (t.w0)
          for (let f = 0; f < h; f++)
            e = a[f], e.us !== null && e.us(e, i);
        Util.ot(a);
      }
      t.as.clear();
    }
    reloadSource() {
      if (this.source === "")
        return;
      _Picture.clearCache(this.source);
      const t = this.source;
      this.source = "", this.source = t;
    }
    redraw() {
      this.T(), this.fs(true);
    }
    get sourceCrossOrigin() {
      return this.Mc;
    }
    set sourceCrossOrigin(t) {
      if (this.Mc !== t && (t !== null && Util.t(t, "function", _Picture, "sourceCrossOrigin"), this.Mc = t, this.element !== null)) {
        const e = this.element.getAttribute("src");
        t === null && typeof e == "string" ? this.element.crossOrigin = null : t !== null && (this.element.crossOrigin = t(this)), this.element.src = e;
      }
    }
    get sourceRect() {
      return this.dl;
    }
    set sourceRect(t) {
      const i = this.dl;
      i.equals(t) || (Util.s(t, Rect2, _Picture, "sourceRect"), t = t.L(), this.dl = t, this.T(), this.i("sourceRect", i, t));
    }
    get imageStretch() {
      return this.bc;
    }
    set imageStretch(t) {
      const i = this.bc;
      i !== t && (Util.it(t, ImageStretch2, "ImageStretch"), this.bc = t, this.T(), this.i("imageStretch", i, t));
    }
    get flip() {
      return this.go;
    }
    set flip(t) {
      const i = this.go;
      i !== t && (Util.it(t, Flip2, "Flip"), this.go = t, this.T(), this.i("flip", i, t));
    }
    get imageAlignment() {
      return this.kc;
    }
    set imageAlignment(t) {
      Util.s(t, Spot2, _Picture, "imageAlignment");
      const i = this.kc;
      i.equals(t) || (t = t.L(), this.kc = t, this.T(), this.i("imageAlignment", i, t));
    }
    get errorFunction() {
      return this.us;
    }
    set errorFunction(t) {
      const i = this.us;
      i !== t && (t !== null && Util.t(t, "function", _Picture, "errorFunction"), this.us = t, this.i("errorFunction", i, t));
    }
    get successFunction() {
      return this.gl;
    }
    set successFunction(t) {
      const i = this.gl;
      i !== t && (t !== null && Util.t(t, "function", _Picture, "successFunction"), this.gl = t, this.i("successFunction", i, t));
    }
    ph(t, i) {
      const e = this.ul;
      if (e === null)
        return;
      const s = e.getAttribute("src");
      if (e instanceof HTMLImageElement && (s === null || s === "") || e.Gp instanceof Event && t instanceof CanvasSurfaceContext)
        return;
      const n = t instanceof SVGContext, o = this.naturalBounds;
      let r = 0, l = 0;
      const h = this.Pc;
      let a = h ? +e.width : e.naturalWidth, f = h ? +e.height : e.naturalHeight;
      if (a === void 0 && e.videoWidth && (a = e.videoWidth), f === void 0 && e.videoHeight && (f = e.videoHeight), a === 0 || f === 0)
        return;
      const c = a, u = f;
      this.sourceRect.isReal() && (r = this.dl.x, l = this.dl.y, a = this.dl.width, f = this.dl.height);
      let d = a, m = f;
      const g = this.bc, p = this.kc;
      switch (g) {
        case 0:
          if (this.sourceRect.isReal())
            break;
          d >= o.width && (r = r + p.offsetX + (d * p.x - o.width * p.x)), m >= o.height && (l = l + p.offsetY + (m * p.y - o.height * p.y)), a = Math.min(o.width, d), f = Math.min(o.height, m);
          break;
        case 2:
          d = o.width, m = o.height;
          break;
        case 6:
        case 7:
          let L = 0;
          g === 6 ? (L = Math.min(o.height / m, o.width / d), d *= L, m *= L) : g === 7 && (L = Math.max(o.height / m, o.width / d), d *= L, m *= L, d >= o.width && (r = (r + p.offsetX + (d * p.x - o.width * p.x) / d) * a), m >= o.height && (l = (l + p.offsetY + (m * p.y - o.height * p.y) / m) * f), a *= 1 / (d / o.width), f *= 1 / (m / o.height), d = o.width, m = o.height);
          break;
      }
      const y = a * f, x = this.getDocumentScale() * i.scale, b = d * x, k = m * x, S = b * k, M = y / S, A = e.__goCache;
      let C = null;
      const P = _Picture.zI;
      if (!n) {
        if (e.Sn && A !== void 0 && S > 4 && M > P * P) {
          A.Yt === null && (A.KL(4, c, u, e), A.KL(16, c, u, e));
          const L = A.Yt, D = L.length;
          for (let F = 0; F < D && L[F].Id * L[F].Id < M; F++)
            C = L[F];
        }
        if (!i.qu && (this.Sc === null && this.BI(), this.Sc))
          return;
      }
      const N = d < o.width ? p.offsetX + (o.width * p.x - d * p.x) : 0, T = m < o.height ? p.offsetY + (o.height * p.y - m * p.y) : 0;
      switch (this.flip) {
        case 0:
          break;
        case 2:
          t.translate(Math.min(o.width, d), 0), t.scale(-1, 1);
          break;
        case 1:
          t.translate(0, Math.min(o.height, m)), t.scale(1, -1);
          break;
        case 3:
          t.translate(Math.min(o.width, d), Math.min(o.height, m)), t.scale(-1, -1);
          break;
      }
      if (t.commitTransform(), i.getRenderingHint("pictureRatioOptimization") && !i.sa && A !== void 0 && C !== null && C.Id !== 1) {
        t.save();
        const L = C.Id;
        try {
          t.drawImage(C.St, r / L, l / L, Math.min(C.St.width, a / L), Math.min(C.St.height, f / L), N, T, Math.min(o.width, d), Math.min(o.height, m)), t instanceof SVGContext && (this.q1 = [r / L, l / L, Math.min(C.St.width, a / L), Math.min(C.St.height, f / L), N, T, Math.min(o.width, d), Math.min(o.height, m)]);
        } catch (D) {
          Debug && this.Oa && Util.ft(D.toString()), this.Oa = false;
        }
        t.restore();
      } else
        try {
          t.drawImage(e, r, l, a, f, N, T, Math.min(o.width, d), Math.min(o.height, m)), t instanceof SVGContext && (this.q1 = [r, l, a, f, N, T, Math.min(o.width, d), Math.min(o.height, m)]);
        } catch (L) {
          Debug && this.Oa && Util.ft(L.toString()), this.Oa = false;
        }
      switch (this.flip) {
        case 0:
          break;
        case 2:
          t.scale(-1, 1), t.translate(-Math.min(o.width, d), 0);
          break;
        case 1:
          t.scale(1, -1), t.translate(0, -Math.min(o.height, m));
          break;
        case 3:
          t.scale(-1, -1), t.translate(-Math.min(o.width, d), -Math.min(o.height, m));
          break;
      }
    }
    get naturalBounds() {
      return this.Hi;
    }
    ld(t, i, e, s) {
      const n = this.desiredSize, o = this.qs(true), r = this.ul, l = this.Pc;
      let h = 0, a = 0;
      (l || !this.Sn && r && r.complete) && (this.Sn = true), r === null ? (isFinite(n.width) || (t = e), isFinite(n.height) || (i = s)) : (h = l ? +r.width : r.naturalWidth, a = l ? +r.height : r.naturalHeight), !isFinite(n.width) && o !== 2 && o !== 5 ? r !== null && this.Sn !== false && (this.sourceRect.isReal() ? t = this.sourceRect.width : t = h) : (isFinite(t) || (this.sourceRect.isReal() ? t = this.sourceRect.width : r !== null && (t = h)), e = 0), !isFinite(n.height) && o !== 2 && o !== 4 ? r !== null && this.Sn !== false && (this.sourceRect.isReal() ? i = this.sourceRect.height : i = a) : (isFinite(i) || (this.sourceRect.isReal() ? i = this.sourceRect.height : r !== null && (i = a)), s = 0), isFinite(n.width) && (t = n.width), isFinite(n.height) && (i = n.height);
      const f = this.maxSize, c = this.minSize;
      e = Math.max(e || 0, c.width), s = Math.max(s || 0, c.height), t = Math.min(f.width, t), i = Math.min(f.height, i), t = Math.max(e, t), i = Math.max(s, i), r !== null && !r.complete && (isFinite(t) || (t = 0), isFinite(i) || (i = 0)), this.Hi.Do(t, i), this.oo(0, 0, t, i);
    }
    gh(t, i, e, s) {
      this.commonArrange(t, i, e, s);
    }
  };
  __publicField(_Picture, "Up", new PropertyCollection());
  __publicField(_Picture, "ub", 0);
  __publicField(_Picture, "zI", 4);
  let Picture2 = _Picture;
  class PictureCacheArray {
    constructor() {
      __publicField(this, "Yt");
      this.Yt = null;
    }
    KL(t, i, e, s) {
      this.Yt === null && (this.Yt = []);
      const n = new CanvasSurface(null), o = n.gi, r = 1 / t;
      if (n.width = i / t, n.height = e / t, n.width === 0 || n.height === 0)
        return;
      const l = new PictureCacheInstance(n.Bt, t);
      let h = s, a = 1;
      if (this.Yt.length > 0) {
        const f = this.Yt[this.Yt.length - 1];
        h = f.St, a = f.Id;
      }
      o.setTransform(r * a, 0, 0, r * a, 0, 0), o.commitTransform(), o.drawImage(h, 0, 0), this.Yt.push(l);
    }
  }
  class PictureCacheInstance {
    constructor(t, i) {
      __publicField(this, "St");
      __publicField(this, "Id");
      this.St = t, this.Id = i;
    }
  }
  const _GeoStream = class _GeoStream {
    constructor() {
      __publicField(this, "Ai");
      __publicField(this, "em");
      this.em = new Geometry2(), this.Ai = null;
    }
    ti(t) {
      t !== null ? (t.ut(), this.em = t, t.figures.clear()) : this.em = new Geometry2(), this.Ai = null;
    }
    yu(t, i, e, s, n, o) {
      if (s !== void 0 && s === true) {
        const r = new PathSegment2(1);
        r.endX = t, r.endY = i, this.Ai.segments.add(r);
      } else
        this.Ai = new PathFigure2(), this.Ai.startX = t, this.Ai.startY = i, this.Ai.isFilled = e, this.Ai.isEvenOdd = o || false, this.em.figures.add(this.Ai);
      n !== void 0 && (this.Ai.isShadowed = n);
    }
    UD() {
      const t = this.Ai.segments.length;
      t > 0 && this.Ai.segments.elt(t - 1).close();
    }
    GD() {
      this.Ai.segments.length > 0 && (this.Ai.isFilled = true);
    }
    HD(t) {
      this.Ai.isShadowed = t;
    }
    gE(t) {
      this.Ai.isEvenOdd = t;
    }
    XD(t, i, e) {
      e === void 0 && (e = false);
      const s = new PathSegment2(1);
      s.endX = t, s.endY = i, e && s.close(), this.Ai.segments.add(s);
    }
    xr(t, i, e) {
      e === void 0 && (e = false);
      const s = new PathSegment2(2);
      s.endX = t, s.endY = i, e && s.close(), this.Ai.segments.add(s);
    }
    br(t, i, e, s, n, o, r) {
      r === void 0 && (r = false);
      const l = new PathSegment2(3);
      l.point1X = t, l.point1Y = i, l.point2X = e, l.point2Y = s, l.endX = n, l.endY = o, r && l.close(), this.Ai.segments.add(l);
    }
    Dw(t, i, e, s, n) {
      n === void 0 && (n = false);
      const o = new PathSegment2(4);
      o.point1X = t, o.point1Y = i, o.endX = e, o.endY = s, n && o.close(), this.Ai.segments.add(o);
    }
    YD(t, i, e, s, n, o, r) {
      o === void 0 && (o = 0), r === void 0 && (r = false);
      const l = new PathSegment2(5);
      l.startAngle = t, l.sweepAngle = i, l.centerX = e, l.centerY = s, l.radiusX = n, o !== 0 ? l.radiusY = o : l.radiusY = n, r && l.close(), this.Ai.segments.add(l);
    }
    KD(t, i, e, s, n, o, r, l) {
      l === void 0 && (l = false);
      const h = new PathSegment2(6, o, r, t, i, e, s, n);
      l && h.close(), this.Ai.segments.add(h);
    }
    static xC(t) {
      const i = _GeoStream.W2;
      if (i !== null)
        return _GeoStream.W2 = null, i.ti(t), i;
      {
        const e = new _GeoStream();
        return e.ti(t), e;
      }
    }
    static bC(t) {
      _GeoStream.W2 = t;
    }
  };
  __publicField(_GeoStream, "W2", null);
  let GeoStream = _GeoStream;
  {
    const w = function(n, o) {
      const r = n.toLowerCase(), l = Geo.qn;
      l[n] = o, l[r] = n;
    };
    w("Rectangle", (n, o, r) => {
      const l = "r" + o + "," + r;
      let h = Geo.yr[l];
      return h !== void 0 || (h = new Geometry2(2), h.endX = o, h.endY = r, Geo.wr < Geo.Qg && (Geo.yr[l] = h, Geo.wr++)), h;
    }), w("Square", (n, o, r) => {
      const l = "s" + o + "," + r;
      let h = Geo.yr[l];
      return h !== void 0 || (h = new Geometry2(2), h.endX = o, h.endY = r, h.defaultStretch = 6, Geo.wr < Geo.Qg && (Geo.yr[l] = h, Geo.wr++)), h;
    });
    const t = (n, o, r, l, h) => {
      (isNaN(l) || l < 0) && (l = 5), isNaN(h) && (h = 15);
      const a = "rr" + o + "," + r + "," + l + "," + h;
      let f = Geo.yr[a];
      if (f !== void 0)
        return f;
      let c = l;
      (h & 1) === 1 ? (c = Math.min(c, (h & 2) === 2 ? o / 3 : o), c = Math.min(c, (h & 8) === 8 ? r / 3 : r)) : c = 0;
      const u = new PathFigure2(c, 0, true);
      f = new Geometry2().add(u);
      const d = Spot2.TopLeft.copy(), m = Spot2.BottomRight.copy();
      if ((h & 2) === 2) {
        let g = l;
        g = Math.min(g, (h & 1) === 1 ? o / 3 : o), g = Math.min(g, (h & 4) === 4 ? r / 3 : r);
        const p = g * Geo.Gn;
        u.add(new PathSegment2(2, o - g, 0)).add(new PathSegment2(3, o, g, o - p, 0, o, p)), d.offsetY = p, m.offsetX = -p;
      } else
        u.add(new PathSegment2(2, o, 0));
      if ((h & 4) === 4) {
        let g = l;
        g = Math.min(g, (h & 8) === 8 ? o / 3 : o), g = Math.min(g, (h & 2) === 2 ? r / 3 : r);
        const p = g * Geo.Gn;
        u.add(new PathSegment2(2, o, r - g)).add(new PathSegment2(3, o - g, r, o, r - p, o - p, r)), m.offsetX = -p, m.offsetY = -p;
      } else
        u.add(new PathSegment2(2, o, r));
      if ((h & 8) === 8) {
        let g = l;
        g = Math.min(g, (h & 4) === 4 ? o / 3 : o), g = Math.min(g, (h & 1) === 1 ? r / 3 : r);
        const p = g * Geo.Gn;
        u.add(new PathSegment2(2, g, r)).add(new PathSegment2(3, 0, r - g, p, r, 0, r - p)), d.offsetX = p, m.offsetY = -p;
      } else
        u.add(new PathSegment2(2, 0, r));
      if ((h & 1) === 1) {
        const g = c * Geo.Gn;
        u.add(new PathSegment2(2, 0, c)).add(new PathSegment2(3, c, 0, 0, g, g, 0).close()), d.offsetX = g, d.offsetY = g;
      } else
        u.add(new PathSegment2(2, 0, 0).close());
      return f.spot1 = d, f.spot2 = m, Geo.wr < Geo.Qg && (Geo.yr[a] = f, Geo.wr++), f;
    };
    w("RoundedRectangle", (n, o, r) => {
      const l = n ? n.parameter1 : NaN, h = n ? n.parameter2 : NaN;
      return t(n, o, r, l, h);
    }), w("Border", "RoundedRectangle"), w("RoundedTopRectangle", (n, o, r) => {
      const l = n ? n.parameter1 : NaN;
      return t(n, o, r, l, 3);
    }), w("RoundedBottomRectangle", (n, o, r) => {
      const l = n ? n.parameter1 : NaN;
      return t(n, o, r, l, 12);
    }), w("RoundedLeftRectangle", (n, o, r) => {
      const l = n ? n.parameter1 : NaN;
      return t(n, o, r, l, 9);
    }), w("RoundedRightRectangle", (n, o, r) => {
      const l = n ? n.parameter1 : NaN;
      return t(n, o, r, l, 6);
    }), w("Ellipse", (n, o, r) => {
      const l = "e" + o + "," + r;
      let h = Geo.yr[l];
      return h !== void 0 || (h = new Geometry2(3), h.endX = o, h.endY = r, h.spot1 = Spot2.Kk, h.spot2 = Spot2.Uk, Geo.wr < Geo.Qg && (Geo.yr[l] = h, Geo.wr++)), h;
    }), w("Circle", (n, o, r) => {
      const l = "c" + o + "," + r;
      let h = Geo.yr[l];
      return h !== void 0 || (h = new Geometry2(3), h.endX = o, h.endY = r, h.spot1 = Spot2.Kk, h.spot2 = Spot2.Uk, h.defaultStretch = 6, Geo.wr < Geo.Qg && (Geo.yr[l] = h, Geo.wr++)), h;
    }), w("TriangleRight", (n, o, r) => new Geometry2().add(new PathFigure2(0, 0).add(new PathSegment2(2, o, 0.5 * r)).add(new PathSegment2(2, 0, r).close())).setSpots(0, 0.25, 0.5, 0.75)), w("TriangleDown", (n, o, r) => new Geometry2().add(new PathFigure2(0, 0).add(new PathSegment2(2, o, 0)).add(new PathSegment2(2, 0.5 * o, r).close())).setSpots(0.25, 0, 0.75, 0.5)), w("TriangleLeft", (n, o, r) => new Geometry2().add(new PathFigure2(o, r).add(new PathSegment2(2, 0, 0.5 * r)).add(new PathSegment2(2, o, 0).close())).setSpots(0.5, 0.25, 1, 0.75)), w("TriangleUp", (n, o, r) => new Geometry2().add(new PathFigure2(o, r).add(new PathSegment2(2, 0, r)).add(new PathSegment2(2, 0.5 * o, 0).close())).setSpots(0.25, 0.5, 0.75, 1)), w("Triangle", "TriangleUp"), w("Diamond", (n, o, r) => new Geometry2().add(new PathFigure2(0.5 * o, 0).add(new PathSegment2(2, 0, 0.5 * r)).add(new PathSegment2(2, 0.5 * o, r)).add(new PathSegment2(2, o, 0.5 * r).close())).setSpots(0.25, 0.25, 0.75, 0.75)), w("LineH", (n, o, r) => {
      const l = new Geometry2(1);
      return l.startX = 0, l.startY = r / 2, l.endX = o, l.endY = r / 2, l;
    }), w("LineV", (n, o, r) => {
      const l = new Geometry2(1);
      return l.startX = o / 2, l.startY = 0, l.endX = o / 2, l.endY = r, l;
    }), w("None", "Rectangle"), w("BarH", "Rectangle"), w("BarV", "Rectangle"), w("MinusLine", "LineH"), w("PlusLine", (n, o, r) => new Geometry2().add(new PathFigure2(0, r / 2, false).add(new PathSegment2(2, o, r / 2)).add(new PathSegment2(1, o / 2, 0)).add(new PathSegment2(2, o / 2, r)))), w("XLine", (n, o, r) => new Geometry2().add(new PathFigure2(0, r, false).add(new PathSegment2(2, o, 0)).add(new PathSegment2(1, 0, 0)).add(new PathSegment2(2, o, r)))), w("LineRight", (n, o, r) => new Geometry2().add(new PathFigure2(0.25 * o, 0, false).add(new PathSegment2(2, 0.75 * o, 0.5 * r)).add(new PathSegment2(2, 0.25 * o, r)))), w("LineDown", (n, o, r) => new Geometry2().add(new PathFigure2(0, 0.25 * r, false).add(new PathSegment2(2, 0.5 * o, 0.75 * r)).add(new PathSegment2(2, o, 0.25 * r)))), w("LineLeft", (n, o, r) => new Geometry2().add(new PathFigure2(0.75 * o, 0, false).add(new PathSegment2(2, 0.25 * o, 0.5 * r)).add(new PathSegment2(2, 0.75 * o, r)))), w("LineUp", (n, o, r) => new Geometry2().add(new PathFigure2(0, 0.75 * r, false).add(new PathSegment2(2, 0.5 * o, 0.25 * r)).add(new PathSegment2(2, o, 0.75 * r)))), w("Capsule", (n, o, r) => {
      const l = new Geometry2();
      if (o < r) {
        const h = new PathFigure2(0, o / 2, true);
        return l.add(h), h.add(new PathSegment2(5, 180, 180, o / 2, o / 2, o / 2, o / 2)), h.add(new PathSegment2(2, o, r - o / 2)), h.add(new PathSegment2(5, 0, 180, o / 2, r - o / 2, o / 2, o / 2)), h.add(new PathSegment2(2, 0, o / 2)), l.spot1 = new Spot2(0.156, 0, 0, o * 0.156), l.spot2 = new Spot2(0.844, 1, 0, -o * 0.156), l;
      } else if (o > r) {
        const h = new PathFigure2(r / 2, 0, true);
        return l.add(h), h.add(new PathSegment2(2, o - r / 2, 0)), h.add(new PathSegment2(5, 270, 180, o - r / 2, r / 2, r / 2, r / 2)), h.add(new PathSegment2(2, r / 2, r)), h.add(new PathSegment2(5, 90, 180, r / 2, r / 2, r / 2, r / 2)), l.spot1 = new Spot2(0, 0.156, r * 0.156, 0), l.spot2 = new Spot2(1, 0.844, -r * 0.156, 0), l;
      } else
        return l.type = 3, l.endX = o, l.endY = r, l.spot1 = Spot2.Kk, l.spot2 = Spot2.Uk, l;
    });
    const i = (n, o) => new PathFigure2(n, o, false, false), e = (n, o, r) => n.add(new PathSegment2(2, o, r)), s = (n, o, r) => n.add(new PathSegment2(1, o, r));
    w("Borders", (n, o, r) => {
      let l = n ? n.parameter1 : NaN;
      isNaN(l) ? l = 10 : l = l & 15;
      const h = new Geometry2();
      let a;
      return l === 10 ? (a = i(o, 0), e(a, o, r), s(a, 0, r), e(a, 0, 0)) : l === 5 ? (a = i(0, 0), e(a, o, 0), s(a, o, r), e(a, 0, r)) : l === 1 ? (a = i(0, 0), e(a, o, 0), s(a, o, r)) : l === 2 ? (a = i(o, 0), e(a, o, r)) : l === 4 ? (a = i(o, r), e(a, 0, r)) : l === 8 ? (a = i(0, r), e(a, 0, 0), s(a, o, r)) : l === 3 ? (a = i(0, 0), e(a, o, 0), e(a, o, r)) : l === 6 ? (a = i(o, 0), e(a, o, r), e(a, 0, r)) : l === 12 ? (a = i(o, r), e(a, 0, r), e(a, 0, 0)) : l === 9 ? (a = i(0, r), e(a, 0, 0), e(a, o, 0)) : l === 7 ? (a = i(0, 0), e(a, o, 0), e(a, o, r), e(a, 0, r)) : l === 14 ? (a = i(o, 0), e(a, o, r), e(a, 0, r), e(a, 0, 0)) : l === 13 ? (a = i(o, r), e(a, 0, r), e(a, 0, 0), e(a, o, 0)) : l === 11 ? (a = i(0, r), e(a, 0, 0), e(a, o, 0), e(a, o, r)) : l === 15 ? (a = i(0, 0), e(a, o, 0), e(a, o, r), e(a, 0, r), a.add(new PathSegment2(2, 0, 0).close())) : (a = i(0, 0), s(a, o, r)), h.add(a), h;
    });
  }
  Geo.$g = { "": "", Standard: "F1 m 0,0 l 8,4 -8,4 2,-4 z", Backward: "F1 m 8,0 l -2,4 2,4 -8,-4 z", Triangle: "F1 m 0,0 l 8,4.62 -8,4.62 z", BackwardTriangle: "F1 m 8,4 l 0,4 -8,-4 8,-4 0,4 z", Boomerang: "F1 m 0,0 l 8,4 -8,4 4,-4 -4,-4 z", BackwardBoomerang: "F1 m 8,0 l -8,4 8,4 -4,-4 4,-4 z", SidewaysV: "m 0,0 l 8,4 -8,4 0,-1 6,-3 -6,-3 0,-1 z", BackwardV: "m 8,0 l -8,4 8,4 0,-1 -6,-3 6,-3 0,-1 z", OpenTriangle: "m 0,0 l 8,4 -8,4", BackwardOpenTriangle: "m 8,0 l -8,4 8,4", OpenTriangleLine: "m 0,0 l 8,4 -8,4 m 8.5,0 l 0,-8", BackwardOpenTriangleLine: "m 8,0 l  -8,4 8,4 m -8.5,0 l 0,-8", OpenTriangleTop: "m 0,0 l 8,4 m 0,4", BackwardOpenTriangleTop: "m 8,0 l -8,4 m 0,4", OpenTriangleBottom: "m 0,8 l 8,-4", BackwardOpenTriangleBottom: "m 0,4 l 8,4", HalfTriangleTop: "F1 m 0,0 l 0,4 8,0 z m 0,8", BackwardHalfTriangleTop: "F1 m 8,0 l 0,4 -8,0 z m 0,8", HalfTriangleBottom: "F1 m 0,4 l 0,4 8,-4 z", BackwardHalfTriangleBottom: "F1 m 8,4 l 0,4 -8,-4 z", ForwardSemiCircle: "m 4,0 b 270 180 0 4 4", BackwardSemiCircle: "m 4,8 b 90 180 0 -4 4", Feather: "m 0,0 l 3,4 -3,4", BackwardFeather: "m 3,0 l -3,4 3,4", DoubleFeathers: "m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4", BackwardDoubleFeathers: "m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4", TripleFeathers: "m 0,0 l 3,4 -3,4 m 3,-8 l 3,4 -3,4 m 3,-8 l 3,4 -3,4", BackwardTripleFeathers: "m 3,0 l -3,4 3,4 m 3,-8 l -3,4 3,4 m 3,-8 l -3,4 3,4", ForwardSlash: "m 0,8 l 5,-8", BackSlash: "m 0,0 l 5,8", DoubleForwardSlash: "m 0,8 l 4,-8 m -2,8 l 4,-8", DoubleBackSlash: "m 0,0 l 4,8 m -2,-8 l 4,8", TripleForwardSlash: "m 0,8 l 4,-8 m -2,8 l 4,-8 m -2,8 l 4,-8", TripleBackSlash: "m 0,0 l 4,8 m -2,-8 l 4,8 m -2,-8 l 4,8", Fork: "m 0,4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4", BackwardFork: "m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4", LineFork: "m 0,0 l 0,8 m 0,-4 l 8,0 m -8,0 l 8,-4 m -8,4 l 8,4", BackwardLineFork: "m 8,4 l -8,0 m 8,0 l -8,-4 m 8,4 l -8,4 m 8,-8 l 0,8", CircleFork: "F1 m 6,4 b 0 360 -3 0 3 z m 0,0 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4", BackwardCircleFork: "F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 6,0 b 0 360 -3 0 3", CircleLineFork: "F1 m 6,4 b 0 360 -3 0 3 z m 1,-4 l 0,8 m 0,-4 l 6,0 m -6,0 l 6,-4 m -6,4 l 6,4", BackwardCircleLineFork: "F1 m 0,4 l 6,0 m -6,-4 l 6,4 m -6,4 l 6,-4 m 0,-4 l 0,8 m 7,-4 b 0 360 -3 0 3", Circle: "F1 m 8,4 b 0 360 -4 0 4 z", Block: "F1 m 0,0 l 0,8 8,0 0,-8 z", StretchedDiamond: "F1 m 0,3 l 5,-3 5,3 -5,3 -5,-3 z", Diamond: "F1 m 0,4 l 4,-4 4,4 -4,4 -4,-4 z", Chevron: "F1 m 0,0 l 5,0 3,4 -3,4 -5,0 3,-4 -3,-4 z", StretchedChevron: "F1 m 0,0 l 8,0 3,4 -3,4 -8,0 3,-4 -3,-4 z", NormalArrow: "F1 m 0,2 l 4,0 0,-2 4,4 -4,4 0,-2 -4,0 z", X: "m 0,0 l 8,8 m 0,-8 l -8,8", TailedNormalArrow: "F1 m 0,0 l 2,0 1,2 3,0 0,-2 2,4 -2,4 0,-2 -3,0 -1,2 -2,0 1,-4 -1,-4 z", DoubleTriangle: "F1 m 0,0 l 4,4 -4,4 0,-8 z  m 4,0 l 4,4 -4,4 0,-8 z", BigEndArrow: "F1 m 0,0 l 5,2 0,-2 3,4 -3,4 0,-2 -5,2 0,-8 z", ConcaveTailArrow: "F1 m 0,2 h 4 v -2 l 4,4 -4,4 v -2 h -4 l 2,-2 -2,-2 z", RoundedTriangle: "F1 m 0,1 a 1,1 0 0 1 1,-1 l 7,3 a 0.5,1 0 0 1 0,2 l -7,3 a 1,1 0 0 1 -1,-1 l 0,-6 z", SimpleArrow: "F1 m 1,2 l -1,-2 2,0 1,2 -1,2 -2,0 1,-2 5,0 0,-2 2,2 -2,2 0,-2 z", AccelerationArrow: "F1 m 0,0 l 0,8 0.2,0 0,-8 -0.2,0 z m 2,0 l 0,8 1,0 0,-8 -1,0 z m 3,0 l 2,0 2,4 -2,4 -2,0 0,-8 z", BoxArrow: "F1 m 0,0 l 4,0 0,2 2,0 0,-2 2,4 -2,4 0,-2 -2,0 0,2 -4,0 0,-8 z", TriangleLine: "F1 m 8,4 l -8,-4 0,8 8,-4 z m 0.5,4 l 0,-8", CircleEndedArrow: "F1 m 10,4 l -2,-3 0,2 -2,0 0,2 2,0 0,2 2,-3 z m -4,0 b 0 360 -3 0 3 z", DynamicWidthArrow: "F1 m 0,3 l 2,0 2,-1 2,-2 2,4 -2,4 -2,-2 -2,-1 -2,0 0,-2 z", EquilibriumArrow: "m 0,3 l 8,0 -3,-3 m 3,5 l -8,0 3,3", FastForward: "F1 m 0,0 l 3.5,4 0,-4 3.5,4 0,-4 1,0 0,8 -1,0 0,-4 -3.5,4 0,-4 -3.5,4 0,-8 z", Kite: "F1 m 0,4 l 2,-4 6,4 -6,4 -2,-4 z", HalfArrowTop: "F1 m 0,0 l 4,4 4,0 -8,-4 z m 0,8", HalfArrowBottom: "F1 m 0,8 l 4,-4 4,0 -8,4 z", OpposingDirectionDoubleArrow: "F1 m 0,4 l 2,-4 0,2 4,0 0,-2 2,4 -2,4 0,-2 -4,0 0,2 -2,-4 z", PartialDoubleTriangle: "F1 m 0,0 4,3 0,-3 4,4 -4,4 0,-3 -4,3 0,-8 z", LineCircle: "F1 m 0,0 l 0,8 m 7 -4 b 0 360 -3 0 3 z", DoubleLineCircle: "F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z", TripleLineCircle: "F1 m 0,0 l 0,8 m 2,-8 l 0,8 m 2,-8 l 0,8 m 7 -4 b 0 360 -3 0 3 z", CircleLine: "F1 m 6 4 b 0 360 -3 0 3 z m 1,-4 l 0,8", DiamondCircle: "F1 m 8,4 l -4,4 -4,-4 4,-4 4,4 m 8,0 b 0 360 -4 0 4 z", PlusCircle: "F1 m 8,4 b 0 360 -4 0 4 l -8 0 z m -4 -4 l 0 8", OpenRightTriangleTop: "m 8,0 l 0,4 -8,0 m 0,4", OpenRightTriangleBottom: "m 8,8 l 0,-4 -8,0", Line: "m 0,0 l 0,8", DoubleLine: "m 0,0 l 0,8 m 2,0 l 0,-8", TripleLine: "m 0,0 l 0,8 m 2,0 l 0,-8 m 2,0 l 0,8", PentagonArrow: "F1 m 8,4 l -4,-4 -4,0 0,8 4,0 4,-4 z" };
  var LayoutConditions2 = ((w) => (w[w.None = 0] = "None", w[w.Added = 1] = "Added", w[w.Removed = 2] = "Removed", w[w.Shown = 4] = "Shown", w[w.Hidden = 8] = "Hidden", w[w.NodeSized = 16] = "NodeSized", w[w.GroupLayout = 32] = "GroupLayout", w[w.NodeReplaced = 64] = "NodeReplaced", w[w.Standard = 127] = "Standard", w[w.All = 16777215] = "All", w))(LayoutConditions2 || {});
  const _Part = class _Part extends Panel2 {
    constructor(t, i) {
      var __super = (...args2) => {
        super(...args2);
        __publicField(this, "N");
        __publicField(this, "_o");
        __publicField(this, "E");
        __publicField(this, "ml");
        __publicField(this, "pl");
        __publicField(this, "tr");
        __publicField(this, "di");
        __publicField(this, "ir");
        __publicField(this, "kh");
        __publicField(this, "$s");
        __publicField(this, "er");
        __publicField(this, "Od");
        __publicField(this, "vM");
        __publicField(this, "UL");
        __publicField(this, "Hp");
        __publicField(this, "vp");
        return this;
      };
      t === void 0 || t instanceof PanelLayout2 || typeof t == "number" || typeof t == "string" ? __super(t) : (__super(), t && (i = t)), this.N = 2408959, this._o = "", this.E = null, this.ml = "", this.pl = null, this.tr = null, this.di = "", this.ir = null, this.kh = null, this.$s = new Point2(NaN, NaN).w(), this.er = null, this.Od = NaN, this.vM = -1, this.UL = new Rect2(), this.Hp = null, this.vp = NaN, i && Object.assign(this, i);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.N = this.N & -4097 | 16384 | 32768, t._o = this._o, this.E !== null && (this.E.xi ? t.E = this.E : t.E = this.E.copy()), t.ml = this.ml, t.tr = null, t.di = this.di, t.$s.c(this.$s), t.Od = this.Od;
    }
    qo(t) {
      super.qo(t), t.mh(), t.pl = null, t.er = null, t.Hp = null;
    }
    toString() {
      let t = Util.an(this.constructor) + "#" + GSet2.ps(this);
      return this.data !== null && (t += "(" + Util.toString(this.data) + ")"), t;
    }
    Qi() {
      this.E === null ? this.E = new PartTemplateSettings() : this.E.xi && (this.E = this.E.copy());
    }
    uh() {
      super.uh(), this.E !== null && (this.E.xi = true);
    }
    tc(t, i, e, s, n, o, r) {
      const l = this.diagram;
      l !== null && (t === 3 && i === "elements" ? n instanceof Panel2 ? n.il((h) => {
        l.partManager.LP(h, l);
      }) : n instanceof Picture2 && l.OP(n) : t === 4 && i === "elements" && (n instanceof Panel2 ? n.il((h) => l.partManager.TP(h, l)) : n instanceof Picture2 && l.EP(n)), l.raiseChangedEvent(t, i, e, s, n, o, r));
    }
    updateTargetBindings(t) {
      if (super.updateTargetBindings(t), this.data === null)
        return;
      const i = this.F.h, e = i.length;
      for (let n = 0; n < e; n++) {
        const o = i[n];
        o instanceof Panel2 && o.il((r) => {
          r.data !== null && r.updateTargetBindings();
        });
      }
      const s = this.adornments;
      for (; s.next(); )
        s.value.updateTargetBindings(t);
    }
    Uo() {
      if (super.Uo(), this.S2()) {
        const i = this.F.h, e = i.length;
        for (let s = 0; s < e; s++) {
          const n = i[s];
          n instanceof Panel2 && n.il((o) => o.Uo());
        }
      }
      const t = this.adornments;
      for (; t.next(); )
        t.value.Uo();
    }
    updateRelationshipsFromData() {
      var _a;
      this.data !== null && ((_a = this.diagram) == null ? void 0 : _a.partManager.updateRelationshipsFromData(this));
    }
    get key() {
      const t = this.diagram;
      if (t !== null)
        return t.model.getKeyForNodeData(this.data);
    }
    get adornments() {
      return this.tr === null ? EmptyIterator.instance : this.tr.iteratorValues;
    }
    findAdornment(t) {
      Debug && Util.t(t, "string", _Part, "findAdornment:category");
      const i = this.tr;
      return i === null ? null : i.getValue(t);
    }
    addAdornment(t, i) {
      if (i === null)
        return;
      Debug && (Util.t(t, "string", _Part, "addAdornment:category"), Util.s(i, Adornment2, _Part, "addAdornment:ad"));
      let e = null, s = this.tr;
      if (s !== null && (e = s.getValue(t)), e !== i) {
        if (e !== null) {
          const o = e.diagram;
          o !== null && o.remove(e);
        }
        s === null && (s = new GMap2(), this.tr = s), i._o !== t && (i.category = t), s.add(t, i);
        const n = this.diagram;
        if (n !== null) {
          n.add(i);
          const o = i.adornedObject;
          if (o !== null) {
            const r = o.findBindingPanel();
            r !== null && (i.data = r.data);
          }
        }
      }
    }
    removeAdornment(t) {
      Debug && Util.t(t, "string", _Part, "removeAdornment:category");
      const i = this.tr;
      if (i === null)
        return;
      const e = i.getValue(t);
      if (e !== null) {
        const s = e.diagram;
        s !== null && (s.remove(e), e.data = null);
      }
      i.remove(t), i.count === 0 && (this.tr = null);
    }
    clearAdornments() {
      const t = this.tr;
      if (t === null)
        return;
      const i = Util.ct(), e = t.iterator;
      for (; e.next(); ) {
        const n = e.key;
        i.push(n);
      }
      const s = i.length;
      for (let n = 0; n < s; n++)
        this.removeAdornment(i[n]);
      Util.ot(i);
    }
    updateAdornments() {
      const t = this.diagram;
      if (t === null)
        return;
      this.XI(t), this.YI(t);
      let i = this.adornments;
      for (; i.next(); ) {
        const e = i.value;
        e.u(), e.hasPlaceholder() && e.placeholder.u();
      }
      for (i = this.adornments; i.next(); )
        i.value.updateTargetBindings();
    }
    invalidateAdornments() {
      const t = this.diagram;
      t !== null && (t.oh(), this.GL() !== true && this.HL(true));
    }
    qM() {
      this.GL() !== false && (this.updateAdornments(), this.HL(false));
    }
    XI(t) {
      const i = "Selection";
      if (this.isSelected && this.selectionAdorned) {
        const e = this.selectionObject;
        if (e !== null && this.actualBounds.isReal() && this.isVisible() && e.isVisibleObject() && e.actualBounds.isReal()) {
          let s = this.findAdornment(i);
          if (s === null) {
            let n = this.selectionAdornmentTemplate;
            if (n === null && (this.Il() ? n = t.linkSelectionAdornmentTemplate : this instanceof Group2 ? n = t.groupSelectionAdornmentTemplate : n = t.nodeSelectionAdornmentTemplate), !(n instanceof Adornment2))
              return;
            n.ui(), s = n.copy(), s !== null && (this.Il() && this.selectionObject === this.path && (s.type = Panel2.Link), s.adornedObject = e);
          }
          if (s !== null) {
            s.type === Panel2.Link && s.u(), this.addAdornment(i, s);
            return;
          }
        }
      }
      this.removeAdornment(i);
    }
    YI(t) {
      const i = this;
      t.toolManager.mouseDownTools.each((e) => {
        e.isEnabled && e.updateAdornments(i);
      }), t.toolManager.updateAdornments(i);
    }
    GM(t) {
      this.ir = t, t === null && this.VR();
    }
    get layer() {
      return this.ir;
    }
    get diagram() {
      const t = this.ir;
      return t == null ? null : t.diagram;
    }
    get layerName() {
      return this.ml;
    }
    set layerName(t) {
      const i = this.ml;
      if (i === t)
        return;
      Util.t(t, "string", _Part, "layerName");
      let e = this.diagram;
      if (e !== null && (e.findLayer(t) === null || e.partManager.addsToTemporaryLayer))
        return;
      this.ml = t, e !== null && e.invalidateDocumentBounds(), this.i("layerName", i, t);
      const s = this.layer;
      if (s === null || s.name === t || (e = s.diagram, e === null))
        return;
      const n = e.findLayer(t);
      if (n === null || n === s)
        return;
      let o = s.re(-1, this, true);
      o >= 0 && e.raiseChangedEvent(4, "parts", s, this, null, o, true), o = n.Qh(99999999, this, true), s.visible !== n.visible && this.Ki(n.visible), o >= 0 && e.raiseChangedEvent(3, "parts", n, null, this, true, o);
      const r = this.layerChanged;
      if (r === null)
        return;
      const l = e.W;
      e.W = true, r(this, s, n), e.W = l;
    }
    get layerChanged() {
      return this.E !== null ? this.E.qp : null;
    }
    set layerChanged(t) {
      const i = this.layerChanged;
      i !== t && (t !== null && Util.t(t, "function", _Part, "layerChanged"), this.Qi(), this.E.qp = t, this.i("layerChanged", i, t));
    }
    get zOrder() {
      return this.Od;
    }
    set zOrder(t) {
      const i = this.Od;
      if (i === t)
        return;
      Util.t(t, "number", _Part, "zOrder"), this.Od = t;
      const e = this.layer;
      e !== null && e.Nx(-1, this), this.i("zOrder", i, t);
      const s = this.diagram;
      s !== null && s.T();
    }
    KI() {
      const t = this.layer;
      t !== null && t.Nx(-1, this);
    }
    mb() {
      if (this.rh() !== false)
        return;
      this.j2(true), this.hd();
      const t = this.diagram;
      t !== null && (t.d0(this), t.requestUpdate());
    }
    vL() {
      if (this.N |= 2097152, this.rh() === false)
        return;
      const t = this.position, i = this.location;
      (!i.isReal() || !t.isReal()) && this.qL(t, i);
      const e = this.Ri, s = Rect2.a().c(e);
      e.ut(), e.x = t.x, e.y = t.y, e.w(), this.ad(s, e), Rect2.o(s), this.j2(false);
    }
    oo(t, i, e, s) {
      const n = this.ce;
      n.e(t, i, e, s), this.Ni === null && (this.Ni = new Transform());
      const o = this.Ni;
      o.ti(), this.P0(o, t, i, e, s), this.Ni = o, o.Gk() || o.Nw(n);
    }
    P0(t, i, e, s, n) {
      if (this.v !== 1 && t.v(this.v), this.qt === 0)
        return;
      let o = Spot2.Center;
      this.locationSpot.isSpot() && (o = this.locationSpot);
      const r = Point2.a();
      if (this.locationObject !== this) {
        const l = this.locationObject, h = l.naturalBounds;
        r.setSpot(h.x, h.y, h.width, h.height, o), l.Ni !== null && l.Ni.Pt(r), r.offset(-l.measuredBounds.x, -l.measuredBounds.y);
        let a = l.panel;
        for (; a !== null && a !== this; )
          a.Ni !== null && a.Ni.Pt(r), r.offset(-a.measuredBounds.x, -a.measuredBounds.y), a = a.panel;
      } else
        r.setSpot(i, e, s, n, o);
      t.ys(this.qt, r.x, r.y), Point2.o(r);
    }
    get locationObject() {
      if (this.er === null)
        if (this instanceof Adornment2 && this.type !== Panel2.Link && this.hasPlaceholder())
          this.er = this.placeholder;
        else {
          const t = this.locationObjectName;
          if (t !== "") {
            const i = this.findObject(t);
            i !== null ? this.er = i : this.er = this;
          } else
            this.er = this;
        }
      return this.er.visible ? this.er : this;
    }
    get minLocation() {
      return this.E !== null ? this.E.Wp : Point2.iC;
    }
    set minLocation(t) {
      const i = this.minLocation;
      i.equals(t) || (Debug && Util.s(t, Point2, _Part, "minLocation"), t = t.L(), this.Qi(), this.E.Wp = t, this.i("minLocation", i, t));
    }
    get maxLocation() {
      return this.E !== null ? this.E.jp : Point2.eC;
    }
    set maxLocation(t) {
      const i = this.maxLocation;
      i.equals(t) || (Debug && Util.s(t, Point2, _Part, "maxLocation"), t = t.L(), this.Qi(), this.E.jp = t, this.i("maxLocation", i, t));
    }
    get locationObjectName() {
      return this.E !== null ? this.E.Jp : "";
    }
    set locationObjectName(t) {
      const i = this.locationObjectName;
      i !== t && (Debug && Util.t(t, "string", _Part, "locationObjectName"), this.Qi(), this.E.Jp = t, this.er = null, this.u(), this.i("locationObjectName", i, t));
    }
    get locationSpot() {
      return this.E !== null ? this.E.Zp : Spot2.TopLeft;
    }
    set locationSpot(t) {
      const i = this.locationSpot;
      i.equals(t) || (Debug && (Util.s(t, Spot2, _Part, "locationSpot"), t.isSpot() || Util.n("Part.locationSpot must be a specific Spot value, not: " + t)), t = t.L(), this.Qi(), this.E.Zp = t, this.u(), this.i("locationSpot", i, t));
    }
    move(t, i) {
      i === true ? this.location = t : this.position = t;
    }
    moveTo(t, i, e) {
      const s = Point2.H(t, i);
      this.move(s, e), Point2.o(s);
    }
    isVisible() {
      if (!this.visible)
        return false;
      const t = this.layer;
      if (t !== null) {
        if (!t.visible)
          return false;
        const e = t.diagram;
        if (e !== null && e.animationManager.ux(this))
          return true;
      }
      const i = this.containingGroup;
      return !(i !== null && (!i.isSubGraphExpanded || !i.isVisible()));
    }
    Ki(t) {
      const i = this.diagram;
      t ? (this.invalidateLayout(4), this.invalidateAdornments(), i !== null && i.d0(this)) : (this.invalidateLayout(8), this.clearAdornments()), this.mh(), i !== null && (i.invalidateDocumentBounds(), i.T());
    }
    findObject(t) {
      if (this.name === t)
        return this;
      let i = this.Hp;
      if (i === null && (this.Hp = i = new GMap2()), i.getValue(t) !== null)
        return i.getValue(t);
      const e = super.findObject(t);
      return e !== null ? (i.set(t, e), e) : (i.set(t, null), null);
    }
    V0() {
      this.Hp = null;
    }
    getRelativePoint(t, i, e) {
      e === void 0 && (e = new Point2());
      const s = i.isNoSpot() ? Spot2.Center : i, n = t.naturalBounds;
      if (e.e(n.width * s.x + s.offsetX, n.height * s.y + s.offsetY), t === null || t === this)
        return e;
      t.D.Pt(e);
      let o = t.panel;
      for (; o !== null && o !== this; )
        o.D.Pt(e), o = o.panel;
      return this.Ni !== null && this.Ni.Pt(e), e.offset(-this.ce.x, -this.ce.y), e;
    }
    getDocumentBounds(t) {
      return t === void 0 && (t = new Rect2()), t.c(this.actualBounds);
    }
    ensureBounds() {
      this.wt(1 / 0, 1 / 0), this.vt();
    }
    xL(t) {
      const i = this.locationSpot, e = this.locationObject, s = e.naturalBounds, n = e instanceof Shape2 ? e.strokeWidth : 0;
      if (t.setSpot(0, 0, s.width + n, s.height + n, i), e !== this) {
        t.offset(-n / 2, -n / 2), e.D.Pt(t);
        let o = e.panel;
        for (; o !== null && o !== this; )
          o.D.Pt(t), o = o.panel;
      }
      return this.Ni !== null && this.Ni.Pt(t), t.offset(-this.ce.x, -this.ce.y), t;
    }
    $h(t, i) {
      const e = i === void 0 ? this.UL : i, s = this.UI(), n = s * 2;
      if (!this.isShadowed)
        return e.e(t.x - 1 - s, t.y - 1 - s, t.width + 2 + n, t.height + 2 + n), e;
      let o = t.x, r = t.y, l = t.width, h = t.height;
      const a = this.shadowBlur, f = this.shadowOffset;
      return l += a, h += a, o -= a / 2, r -= a / 2, f.x > 0 ? l += f.x : (o += f.x, l -= f.x), f.y > 0 ? h += f.y : (r += f.y, h -= f.y), e.e(o - 1, r - 1, l + 2, h + 2), e;
    }
    MI() {
      return this.type === Panel2.Link && this instanceof Adornment2 && this.category === "Selection" && this.adornedObject instanceof Shape2 && this.adornedPart.findMainElement() === this.adornedObject ? this.adornedObject.strokeWidth : 0;
    }
    UI() {
      return isNaN(this.vp) && (this.vp = this.CL()), this.vp;
    }
    gc() {
      this.vp = NaN;
    }
    vt() {
      if (this.hs() === false) {
        this.vL();
        return;
      }
      this.ro(false);
      const t = this.Ri, i = Rect2.a();
      i.c(t);
      const e = this.Rl();
      this.gh(0, 0, this.ce.width, this.ce.height);
      const s = this.position;
      this.qL(s, this.location), t.ut(), t.x = s.x, t.y = s.y, t.w(), this.ad(i, t), i.equals(t) ? this.Gs(e) : this.De() && (!Geo.p(i.width, t.width) || !Geo.p(i.height, t.height)) && this.vM >= 0 && this.invalidateLayout(16), Rect2.o(i), this.j2(false);
    }
    ad(t, i) {
      const e = this.diagram;
      if (e === null)
        return;
      let s = false;
      if (e.ea === false && t.isReal()) {
        const n = Rect2.a();
        n.c(e.documentBounds), n.subtractMargin(e.padding), t.x > n.x && t.y > n.y && t.right < n.right && t.bottom < n.bottom && i.x > n.x && i.y > n.y && i.right < n.right && i.bottom < n.bottom && (s = true), Rect2.o(n);
      }
      (this.GI() === true || !t.equals(i)) && this.AA(s, e), e.T(), !(!t.isReal() && !i.isReal() || t.equalsApproxClose(i)) && (this instanceof Node2 && !e.undoManager.isUndoingRedoing && this.invalidateConnectedLinks(), this.mh());
    }
    get location() {
      return this.$s;
    }
    set location(t) {
      Debug && Util.s(t, Point2, _Part, "location");
      const i = t.x, e = t.y, s = this.$s;
      (s.x !== i && (!isNaN(s.x) || !isNaN(i)) || s.y !== e && (!isNaN(s.y) || !isNaN(e))) && (t = t.copy(), this.HI(t, s) && this.i("location", s, t.copy()));
    }
    HI(t, i) {
      if (this.Il())
        return false;
      if (this.$s = t, this.N |= 2097152, this.hs() === false) {
        this.mb();
        const e = this.lt;
        if (e.isReal()) {
          const s = this.diagram;
          if (s === null || s.animationManager.isTicking || !s.undoManager.isUndoingRedoing) {
            const n = e.copy();
            e.e(e.x + (t.x - i.x), e.y + (t.y - i.y)), this.WL(s, e, n.x, n.y), this.i("position", n, e.copy());
          }
        }
      }
      return true;
    }
    w2(t, i, e) {
      if (this.Il() || !t.isReal())
        return false;
      const s = this.diagram;
      if (s !== null && this.WL(s, t, i, e), this.lt = t, this.N &= -2097153, this.$s.isReal() && (s === null || s.animationManager.isTicking || !s.undoManager.isUndoingRedoing)) {
        const n = this.$s;
        this.$s = new Point2(n.x + (t.x - i), n.y + (t.y - e)), this.i("location", n, this.$s.copy());
      }
      return this.rh() === false && this.hs() === false && (this.mb(), this.vL()), true;
    }
    WL(t, i, e, s) {
      if (t === null || this instanceof Adornment2)
        return;
      const n = t.animationManager;
      n.Mi && n.$C(this, new Point2(e, s), i, false);
    }
    Nf(t, i, e) {
      const s = this.$s, n = this.lt;
      if (e) {
        if (s.x === t && s.y === i)
          return;
        this.rh() || this.hs() ? n.e(NaN, NaN) : n.e(n.x + t - s.x, n.y + i - s.y), s.e(t, i);
      } else {
        if (n.x === t && n.y === i)
          return;
        s.e(s.x + t - n.x, s.y + i - n.y), n.e(t, i);
      }
      this.mb();
    }
    b2() {
      this.N &= -2097153, this.mb();
    }
    qL(t, i) {
      const e = this.xL(Point2.a()), s = this.diagram, n = i.isReal(), o = t.isReal();
      n && o ? this.N & 2097152 ? this.jL(t, i, s, e) : this.JL(t, i, s, e) : n ? this.jL(t, i, s, e) : o && this.JL(t, i, s, e), this.N |= 2097152, Point2.o(e), this.hd();
    }
    jL(t, i, e, s) {
      const n = t.x, o = t.y;
      if (t.e(i.x - s.x, i.y - s.y), e !== null) {
        const r = e.animationManager, l = r.defaultAnimation.isAnimating;
        !l && r.Mi && !(this instanceof Adornment2) && r.$C(this, new Point2(n, o), t, false), !l && !(t.x === n && t.y === o) && this.i("position", new Point2(n, o), t.copy());
      }
    }
    JL(t, i, e, s) {
      const n = i.copy();
      i.e(t.x + s.x, t.y + s.y), !i.equals(n) && e !== null && this.i("location", n, i.copy());
    }
    AA(t, i) {
      this.c2(false), this instanceof Node2 && i.KP(this), !this.layer.isTemporary && !t && i.invalidateDocumentBounds();
      const e = this.Ri, s = i.viewportBounds;
      s.isReal() ? this.Rl() ? (e.intersectsRectPlus(s, 10) || this.Gs(false), this.updateAdornments()) : this.isVisible() && e.intersectsRect(s) ? (this.Gs(true), this.updateAdornments()) : this.invalidateAdornments() : i.Kf = true;
    }
    tl() {
      return true;
    }
    De() {
      return true;
    }
    Il() {
      return false;
    }
    Ws() {
      return true;
    }
    hasPlaceholder() {
      return false;
    }
    get category() {
      return this._o;
    }
    set category(t) {
      const i = this._o;
      if (i === t)
        return;
      this.svg !== null && (this.svg.remove(), this.fs(true)), Util.t(t, "string", _Part, "category");
      const e = this.diagram, s = this.data;
      let n = null;
      if (e !== null && s !== null && !(this instanceof Adornment2)) {
        const o = e.model.undoManager;
        o.isEnabled && !o.isUndoingRedoing && (n = this.clone(), n.F.addAll(this.F));
      }
      if (this._o = t, this.i("category", i, t), e !== null && s !== null && !(this instanceof Adornment2)) {
        const o = e.model;
        if (o.undoManager.isUndoingRedoing)
          return;
        if (this.Il()) {
          e.partManager.setLinkCategoryForData(s, t);
          const r = e.partManager.findLinkTemplateForCategory(t);
          if (r !== null) {
            r.ui();
            const l = r.copy();
            l !== null && this.J2(l, i, t);
          }
        } else {
          o !== null && o.setCategoryForNodeData(s, t);
          const r = e.partManager.findTemplateForNodeData(s, t);
          if (r !== null) {
            r.ui();
            const l = r.copy();
            if (l !== null && !(l instanceof Link2)) {
              const h = this.location.copy();
              this.J2(l, i, t), this.location.isReal() || (this.location = h);
            }
          }
        }
        if (n !== null) {
          const r = this.clone();
          r.F.addAll(this.F), this.i("self", n, r);
        }
      } else if (this instanceof Adornment2) {
        const o = this.adornedPart;
        if (o !== null) {
          const r = o.tr;
          r !== null && r.remove(i), o.addAdornment(this.category, this);
        }
      }
    }
    get self() {
      return this;
    }
    set self(t) {
      this.J2(t, this.category, t.category);
    }
    J2(t, i, e) {
      t.constructor !== this.constructor && (_Part.ZL || (_Part.ZL = true, Util.ft('Should not change the class of the Part when changing category from "' + i + '" to "' + e + '"'), Util.ft("  Old class: " + Util.an(this.constructor) + ", new class: " + Util.an(t.constructor) + ", part: " + this.toString()))), this.clearAdornments();
      const s = this.data, n = this.layerName, o = this.isSelected, r = this.isHighlighted;
      let l = true, h = true, a = false;
      this instanceof Node2 && (l = this.isTreeLeaf, h = this.isTreeExpanded, a = this.wasTreeExpanded), t.qo(this), t.cloneProtected(this), this._o = e, this.svg !== null && (this.svg.remove(), this.svg = null, this.fs(true)), this.u(), this.T();
      const f = this.diagram;
      let c = true;
      f !== null && (c = f.skipsUndoManager, f.skipsUndoManager = true), this.si = s, this.N = o ? this.N | 4096 : this.N & -4097, this.N = r ? this.N | 524288 : this.N & -524289, this instanceof Node2 && (this.z = l ? this.z | 4 : this.z & -5, this.z = h ? this.z | 1 : this.z & -2, this.z = a ? this.z | 2 : this.z & -3), s !== null && this.updateTargetBindings();
      const u = this.layerName;
      u !== n && (this.ml = n, this.layerName = u), f !== null && (f.skipsUndoManager = c), this.De() && this.invalidateLayout(64);
    }
    canCopy() {
      if (!this.copyable)
        return false;
      const t = this.layer;
      if (t === null)
        return true;
      if (!t.allowCopy)
        return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowCopy;
    }
    canDelete() {
      if (!this.deletable)
        return false;
      const t = this.layer;
      if (t === null)
        return true;
      if (!t.allowDelete)
        return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowDelete;
    }
    canEdit() {
      if (!this.textEditable)
        return false;
      const t = this.layer;
      if (t === null)
        return true;
      if (!t.allowTextEdit)
        return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowTextEdit;
    }
    canGroup() {
      if (!this.groupable)
        return false;
      const t = this.layer;
      if (t === null)
        return true;
      if (!t.allowGroup)
        return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowGroup;
    }
    canMove() {
      if (!this.movable)
        return false;
      const t = this.layer;
      if (t === null)
        return true;
      if (!t.allowMove)
        return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowMove;
    }
    canReshape() {
      if (!this.reshapable)
        return false;
      const t = this.layer;
      if (t === null)
        return true;
      if (!t.allowReshape)
        return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowReshape;
    }
    canResize() {
      if (!this.resizable)
        return false;
      const t = this.layer;
      if (t === null)
        return true;
      if (!t.allowResize)
        return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowResize;
    }
    canRotate() {
      if (!this.rotatable)
        return false;
      const t = this.layer;
      if (t === null)
        return true;
      if (!t.allowRotate)
        return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowRotate;
    }
    canSelect() {
      if (!this.selectable)
        return false;
      const t = this.layer;
      if (t === null)
        return true;
      if (!t.allowSelect)
        return false;
      const i = t.diagram;
      return i === null ? true : !!i.allowSelect;
    }
    get copyable() {
      return (this.N & 1) !== 0;
    }
    set copyable(t) {
      const i = (this.N & 1) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "copyable"), this.N = this.N ^ 1, this.i("copyable", i, t));
    }
    get deletable() {
      return (this.N & 2) !== 0;
    }
    set deletable(t) {
      const i = (this.N & 2) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "deletable"), this.N = this.N ^ 2, this.i("deletable", i, t));
    }
    get textEditable() {
      return (this.N & 4) !== 0;
    }
    set textEditable(t) {
      const i = (this.N & 4) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "textEditable"), this.N = this.N ^ 4, this.i("textEditable", i, t), this.invalidateAdornments());
    }
    get groupable() {
      return (this.N & 8) !== 0;
    }
    set groupable(t) {
      const i = (this.N & 8) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "groupable"), this.N = this.N ^ 8, this.i("groupable", i, t));
    }
    get movable() {
      return (this.N & 16) !== 0;
    }
    set movable(t) {
      const i = (this.N & 16) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "movable"), this.N = this.N ^ 16, this.i("movable", i, t));
    }
    get selectionAdorned() {
      return (this.N & 32) !== 0;
    }
    set selectionAdorned(t) {
      const i = (this.N & 32) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "selectionAdorned"), this.N = this.N ^ 32, this.i("selectionAdorned", i, t), this.invalidateAdornments());
    }
    get isInDocumentBounds() {
      return (this.N & 64) !== 0;
    }
    set isInDocumentBounds(t) {
      const i = (this.N & 64) !== 0;
      if (i !== t) {
        Debug && Util.t(t, "boolean", _Part, "isInDocumentBounds"), this.N = this.N ^ 64;
        const e = this.diagram;
        e !== null && e.invalidateDocumentBounds(), this.i("isInDocumentBounds", i, t);
      }
    }
    get isLayoutPositioned() {
      return (this.N & 128) !== 0;
    }
    set isLayoutPositioned(t) {
      const i = (this.N & 128) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "isLayoutPositioned"), this.N = this.N ^ 128, this.i("isLayoutPositioned", i, t), this.invalidateLayout(t ? 4 : 8));
    }
    get selectable() {
      return (this.N & 256) !== 0;
    }
    set selectable(t) {
      const i = (this.N & 256) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "selectable"), this.N = this.N ^ 256, this.i("selectable", i, t), this.invalidateAdornments());
    }
    get reshapable() {
      return (this.N & 512) !== 0;
    }
    set reshapable(t) {
      const i = (this.N & 512) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "reshapable"), this.N = this.N ^ 512, this.i("reshapable", i, t), this.invalidateAdornments());
    }
    get resizable() {
      return (this.N & 1024) !== 0;
    }
    set resizable(t) {
      const i = (this.N & 1024) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "resizable"), this.N = this.N ^ 1024, this.i("resizable", i, t), this.invalidateAdornments());
    }
    get rotatable() {
      return (this.N & 2048) !== 0;
    }
    set rotatable(t) {
      const i = (this.N & 2048) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "rotatable"), this.N = this.N ^ 2048, this.i("rotatable", i, t), this.invalidateAdornments());
    }
    get isSelected() {
      return (this.N & 4096) !== 0;
    }
    set isSelected(t) {
      const i = (this.N & 4096) !== 0;
      if (i !== t) {
        Debug && Util.t(t, "boolean", _Part, "isSelected");
        const e = this.diagram;
        if (t) {
          if (!this.canSelect())
            return;
          if (e !== null) {
            const o = e.maxSelectionCount;
            if (e.selection.count >= o)
              return;
          }
        }
        this.N = this.N ^ 4096;
        let s = false;
        if (e !== null) {
          s = e.skipsUndoManager, e.skipsUndoManager = true;
          const o = e.selection;
          o.ut(), t ? o.add(this) : o.remove(this), o.w();
        }
        this.i("isSelected", i, t), this.invalidateAdornments();
        const n = this.selectionChanged;
        n !== null && n(this), e !== null && (e.requestUpdate(), e.skipsUndoManager = s);
      }
    }
    get isHighlighted() {
      return (this.N & 524288) !== 0;
    }
    set isHighlighted(t) {
      const i = (this.N & 524288) !== 0;
      if (i !== t) {
        Debug && Util.t(t, "boolean", _Part, "isHighlighted"), this.N = this.N ^ 524288;
        const e = this.diagram;
        if (e !== null) {
          const n = e.highlighteds;
          n.ut(), t ? n.add(this) : n.remove(this), n.w();
        }
        this.i("isHighlighted", i, t), this.T();
        const s = this.highlightedChanged;
        s !== null && s(this);
      }
    }
    get isShadowed() {
      return (this.N & 8192) !== 0;
    }
    set isShadowed(t) {
      const i = (this.N & 8192) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "isShadowed"), this.N = this.N ^ 8192, this.fs(true), this.i("isShadowed", i, t), this.T());
    }
    GL() {
      return (this.N & 16384) !== 0;
    }
    HL(t) {
      t ? this.N |= 16384 : this.N &= -16385;
    }
    rh() {
      return (this.N & 32768) !== 0;
    }
    j2(t) {
      t ? this.N |= 32768 : this.N &= -32769;
    }
    GI() {
      return (this.N & 65536) !== 0;
    }
    c2(t) {
      t ? this.N |= 65536 : this.N &= -65537;
    }
    Rl() {
      return (this.N & 131072) !== 0;
    }
    Gs(t) {
      t ? this.N |= 131072 : this.N &= -131073;
    }
    $L() {
      return (this.N & 1048576) !== 0;
    }
    pb(t) {
      t ? this.N |= 1048576 : this.N &= -1048577;
    }
    get isAnimated() {
      return (this.N & 262144) !== 0;
    }
    set isAnimated(t) {
      const i = (this.N & 262144) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Part, "isAnimated"), this.N = this.N ^ 262144, this.i("isAnimated", i, t));
    }
    get highlightedChanged() {
      return this.E !== null ? this.E.$p : null;
    }
    set highlightedChanged(t) {
      const i = this.highlightedChanged;
      i !== t && (t !== null && Util.t(t, "function", _Part, "highlightedChanged"), this.Qi(), this.E.$p = t, this.i("highlightedChanged", i, t));
    }
    get selectionObjectName() {
      return this.E !== null ? this.E.Qp : "";
    }
    set selectionObjectName(t) {
      const i = this.selectionObjectName;
      i !== t && (Debug && Util.t(t, "string", _Part, "selectionObjectName"), this.Qi(), this.E.Qp = t, this.pl = null, this.i("selectionObjectName", i, t));
    }
    get selectionAdornmentTemplate() {
      return this.E !== null ? this.E._p : null;
    }
    set selectionAdornmentTemplate(t) {
      const i = this.selectionAdornmentTemplate;
      i !== t && (Debug && Util.s(t, Adornment2, _Part, "selectionAdornmentTemplate"), this.Qi(), this.E._p = t, this.i("selectionAdornmentTemplate", i, t));
    }
    get selectionObject() {
      if (this.pl === null) {
        const t = this.selectionObjectName;
        if (t !== null && t !== "") {
          const i = this.findObject(t);
          i !== null ? this.pl = i : this.pl = this;
        } else if (this instanceof Link2) {
          const i = this.path;
          i !== null ? this.pl = i : this.pl = this;
        } else
          this.pl = this;
      }
      return this.pl;
    }
    get selectionChanged() {
      return this.E !== null ? this.E.ty : null;
    }
    set selectionChanged(t) {
      const i = this.selectionChanged;
      i !== t && (t !== null && Util.t(t, "function", _Part, "selectionChanged"), this.Qi(), this.E.ty = t, this.i("selectionChanged", i, t));
    }
    get resizeAdornmentTemplate() {
      return this.E !== null ? this.E.iy : null;
    }
    set resizeAdornmentTemplate(t) {
      const i = this.resizeAdornmentTemplate;
      i !== t && (Debug && Util.s(t, Adornment2, _Part, "resizeAdornmentTemplate"), this.Qi(), this.E.iy = t, this.i("resizeAdornmentTemplate", i, t));
    }
    get resizeObjectName() {
      return this.E !== null ? this.E.ey : "";
    }
    set resizeObjectName(t) {
      const i = this.resizeObjectName;
      i !== t && (Debug && Util.t(t, "string", _Part, "resizeObjectName"), this.Qi(), this.E.ey = t, this.i("resizeObjectName", i, t));
    }
    get resizeObject() {
      const t = this.resizeObjectName;
      if (t !== "") {
        const i = this.findObject(t);
        if (i !== null)
          return i;
      }
      return this;
    }
    get resizeCellSize() {
      return this.E !== null ? this.E.sy : Size2.xw;
    }
    set resizeCellSize(t) {
      const i = this.resizeCellSize;
      i.equals(t) || (Debug && Util.s(t, Size2, _Part, "resizeCellSize"), t = t.L(), this.Qi(), this.E.sy = t, this.i("resizeCellSize", i, t));
    }
    get rotateAdornmentTemplate() {
      return this.E !== null ? this.E.ny : null;
    }
    set rotateAdornmentTemplate(t) {
      const i = this.rotateAdornmentTemplate;
      i !== t && (Debug && Util.s(t, Adornment2, _Part, "rotateAdornmentTemplate"), this.Qi(), this.E.ny = t, this.i("rotateAdornmentTemplate", i, t));
    }
    get rotateObjectName() {
      return this.E !== null ? this.E.oy : "";
    }
    set rotateObjectName(t) {
      const i = this.rotateObjectName;
      i !== t && (Debug && Util.t(t, "string", _Part, "rotateObjectName"), this.Qi(), this.E.oy = t, this.i("rotateObjectName", i, t));
    }
    get rotateObject() {
      const t = this.rotateObjectName;
      if (t !== "") {
        const i = this.findObject(t);
        if (i !== null)
          return i;
      }
      return this;
    }
    get rotationSpot() {
      return this.E !== null ? this.E.ry : Spot2.Default;
    }
    set rotationSpot(t) {
      const i = this.rotationSpot;
      i.equals(t) || (Debug && (Util.s(t, Spot2, _Part, "rotationSpot"), t !== Spot2.Default && !t.isSpot() && Util.n("Part.rotationSpot must be a specific Spot value or Spot.Default, not: " + t)), t = t.L(), this.Qi(), this.E.ry = t, this.i("rotationSpot", i, t));
    }
    get text() {
      return this.di;
    }
    set text(t) {
      const i = this.di;
      i !== t && (Debug && Util.t(t, "string", _Part, "text"), this.di = t, this.i("text", i, t));
    }
    get containingGroup() {
      return this.kh;
    }
    set containingGroup(t) {
      if (this.De()) {
        const i = this.kh;
        if (i !== t) {
          Debug && t !== null && Util.s(t, Group2, _Part, "containingGroup"), t !== null && (this === t || t.isMemberOf(this)) && (this === t && Util.n("Cannot make a Group a member of itself: " + this.toString()), Util.n("Cannot make a Group indirectly contain itself: " + this.toString() + " already contains " + t.toString())), this.invalidateLayout(2);
          const e = this.diagram;
          if (i !== null ? i.Z2(this) : this instanceof Group2 && e !== null && e.Zr.remove(this), this.kh = t, t !== null ? t.$2(this) : this instanceof Group2 && e !== null && e.Zr.add(this), this.invalidateLayout(1), e !== null && e.W) {
            const n = this.data, o = e.model;
            if (n !== null && o.ma()) {
              const r = t !== null ? t.data : null;
              o.setGroupForData(n, o.getKeyForNodeData(r));
            }
          }
          const s = this.containingGroupChanged;
          if (s !== null) {
            let n = true;
            e !== null && (n = e.W, e.W = true), s(this, i, t), e !== null && (e.W = n);
          }
          if (this instanceof Group2) {
            const n = new GSet2();
            _Part.ah(n, this, true, 0, true);
            const o = n.iterator;
            for (; o.next(); ) {
              const r = o.value;
              if (r instanceof Node2) {
                const l = r.linksConnected;
                for (; l.next(); )
                  l.value.Ed();
              }
            }
          }
          if (this instanceof Node2) {
            const n = this.linksConnected;
            for (; n.next(); )
              n.value.Ed();
            const o = this.labeledLink;
            o !== null && o.Ed();
          }
          this.i("containingGroup", i, t), t !== null && t.KI();
        }
      } else
        Util.n("cannot set the Part.containingGroup of a Link or Adornment");
    }
    mh() {
      const t = this.containingGroup;
      t !== null && (t.hasPlaceholder() && t.placeholder.u(), t.u(), t.invalidateConnectedLinks());
    }
    T() {
      const t = this.diagram;
      t !== null && !this.hs() && !this.rh() && this.isVisible() && this.Ri.isReal() && t.T(this.$h(this.Ri));
    }
    u() {
      if (this.Ko())
        return;
      super.u();
      const t = this.diagram;
      t !== null && (t.d0(this), this instanceof Node2 && this.labeledLink !== null && this.labeledLink.rc(), t.requestUpdate(true));
    }
    rc(t) {
      if (this.hs())
        return;
      const i = this.diagram;
      i !== null && (i.d0(this), this instanceof Node2 && this.invalidateConnectedLinks(), i.requestUpdate()), this.ro(true);
    }
    vm(t) {
      if (!t) {
        const i = this.kh;
        i !== null && i.$2(this);
      }
    }
    qm(t) {
      if (!t) {
        const i = this.kh;
        i !== null && i.Z2(this);
      }
    }
    Wf() {
      const t = this.data;
      if (t !== null) {
        const i = this.diagram;
        if (i !== null) {
          const e = i.model;
          e !== null && e.removeNodeData(t);
        }
      }
    }
    get containingGroupChanged() {
      return this.E !== null ? this.E.ly : null;
    }
    set containingGroupChanged(t) {
      const i = this.containingGroupChanged;
      i !== t && (t !== null && Util.t(t, "function", _Part, "containingGroupChanged"), this.Qi(), this.E.ly = t, this.i("containingGroupChanged", i, t));
    }
    findSubGraphLevel() {
      return this.Q2(this);
    }
    Q2(t) {
      const i = t.containingGroup;
      if (i !== null)
        return 1 + this.Q2(i);
      if (t instanceof Node2) {
        const e = t.labeledLink;
        if (e !== null)
          return this.Q2(e);
      }
      return 0;
    }
    findTopLevelPart() {
      return this._2(this);
    }
    _2(t) {
      const i = t.containingGroup;
      if (i !== null)
        return this._2(i);
      if (t instanceof Node2) {
        const e = t.labeledLink;
        if (e !== null)
          return this._2(e);
      }
      return t;
    }
    get isTopLevel() {
      return !(this.containingGroup !== null || this instanceof Node2 && this.labeledLink !== null);
    }
    isMemberOf(t) {
      return t instanceof Group2 ? this.tN(this, t) : false;
    }
    tN(t, i) {
      if (t === i || i === null)
        return false;
      const e = t.containingGroup;
      if (e !== null && (e === i || this.tN(e, i)))
        return true;
      if (t instanceof Node2) {
        const s = t.labeledLink;
        if (s !== null)
          return this.tN(s, i);
      }
      return false;
    }
    findCommonContainingGroup(t) {
      if (t === null)
        return null;
      if (Debug && Util.s(t, _Part, _Part, "findCommonContainingGroup:other"), this === t)
        return this.containingGroup;
      let i = this;
      for (; i !== null; ) {
        if (i instanceof Group2 && i.pb(true), i instanceof Node2) {
          const s = i.labeledLink;
          s !== null && (i = s);
        }
        i = i.containingGroup;
      }
      let e = null;
      for (i = t; i !== null; ) {
        if (i.$L()) {
          e = i;
          break;
        }
        if (i instanceof Node2) {
          const s = i.labeledLink;
          s !== null && (i = s);
        }
        i = i.containingGroup;
      }
      for (i = this; i !== null; ) {
        if (i instanceof Group2 && i.pb(false), i instanceof Node2) {
          const s = i.labeledLink;
          s !== null && (i = s);
        }
        i = i.containingGroup;
      }
      return e;
    }
    get layoutConditions() {
      return this.E !== null ? this.E.hy : 127;
    }
    set layoutConditions(t) {
      const i = this.layoutConditions;
      i !== t && (Debug && Util.t(t, "number", _Part, "layoutConditions"), this.Qi(), this.E.hy = t, this.i("layoutConditions", i, t));
    }
    canLayout() {
      if (!this.isLayoutPositioned || !this.isVisible())
        return false;
      const t = this.layer;
      return !(t !== null && t.isTemporary || this instanceof Node2 && this.isLinkLabel);
    }
    vI(t) {
      if (!this.isLayoutPositioned || !(t & this.layoutConditions))
        return false;
      const i = this.layer;
      if (i !== null && i.isTemporary || this instanceof Node2 && this.isLinkLabel)
        return false;
      const e = this.diagram;
      return !(e !== null && e.undoManager.isUndoingRedoing);
    }
    invalidateLayout(t) {
      if (t === void 0 && (t = 16777215), !this.vI(t))
        return;
      const i = this.kh;
      if (i !== null) {
        const e = i.layout;
        e !== null ? e.invalidateLayout() : i.invalidateLayout(t);
      } else {
        const e = this.diagram;
        if (e !== null) {
          const s = e.layout;
          s !== null && s.invalidateLayout();
        }
      }
    }
    LA() {
      if (!this.isVisible())
        return false;
      const t = this.layer;
      return !(t !== null && t.isTemporary);
    }
    static ah(t, i, e, s, n, o) {
      if (o === void 0 && (o = null), !t.contains(i) && !(o !== null && !o(i)) && !(i instanceof Adornment2)) {
        if (t.add(i), i instanceof Node2) {
          if (e && i instanceof Group2) {
            const r = i.memberParts;
            for (; r.next(); ) {
              const l = r.value;
              _Part.ah(t, l, e, s, n, o);
            }
          }
          if (n !== false) {
            const r = i.linksConnected;
            for (; r.next(); ) {
              const l = r.value;
              if (t.contains(l))
                continue;
              const h = l.fromNode, a = l.toNode, f = h === null || t.contains(h), c = a === null || t.contains(a);
              (n ? f && c : f || c) && _Part.ah(t, l, e, s, n, o);
            }
          }
          if (s > 1) {
            const r = i.findTreeChildrenNodes();
            for (; r.next(); ) {
              const l = r.value;
              _Part.ah(t, l, e, s - 1, n, o);
            }
          }
        } else if (i instanceof Link2) {
          const r = i.labelNodes;
          for (; r.next(); ) {
            const l = r.value;
            _Part.ah(t, l, e, s, n, o);
          }
        }
      }
    }
    get dragComputation() {
      return this.E !== null ? this.E.ay : null;
    }
    set dragComputation(t) {
      const i = this.dragComputation;
      i !== t && (t !== null && Util.t(t, "function", _Part, "dragComputation"), this.Qi(), this.E.ay = t, this.i("dragComputation", i, t));
    }
    get shadowOffset() {
      return this.E !== null ? this.E.fy : Point2.sC;
    }
    set shadowOffset(t) {
      const i = this.shadowOffset;
      i.equals(t) || (Debug && Util.s(t, Point2, _Part, "shadowOffset"), t = t.L(), this.Qi(), this.E.fy = t, this.T(), this.i("shadowOffset", i, t));
    }
    get shadowColor() {
      return this.E !== null ? this.E.cy : "gray";
    }
    set shadowColor(t) {
      const i = this.shadowColor;
      i !== t && (Debug && Util.t(t, "string", _Part, "shadowColor"), this.Qi(), this.E.cy = t, this.T(), this.i("shadowColor", i, t));
    }
    get shadowBlur() {
      return this.E !== null ? this.E.Cn : 4;
    }
    set shadowBlur(t) {
      const i = this.shadowBlur;
      i !== t && (Debug && Util.t(t, "number", _Part, "shadowBlur"), this.Qi(), this.E.Cn = t, this.T(), this.i("shadowBlur", i, t));
    }
  };
  __publicField(_Part, "LayoutNone", 0);
  __publicField(_Part, "LayoutAdded", 1);
  __publicField(_Part, "LayoutRemoved", 2);
  __publicField(_Part, "LayoutShown", 4);
  __publicField(_Part, "LayoutHidden", 8);
  __publicField(_Part, "LayoutNodeSized", 16);
  __publicField(_Part, "LayoutGroupLayout", 32);
  __publicField(_Part, "LayoutNodeReplaced", 64);
  __publicField(_Part, "LayoutStandard", 127);
  __publicField(_Part, "LayoutAll", 16777215);
  __publicField(_Part, "ZL", false);
  let Part2 = _Part;
  class PartTemplateSettings {
    constructor() {
      __publicField(this, "xi");
      __publicField(this, "qp");
      __publicField(this, "ly");
      __publicField(this, "_p");
      __publicField(this, "Qp");
      __publicField(this, "ty");
      __publicField(this, "$p");
      __publicField(this, "iy");
      __publicField(this, "ey");
      __publicField(this, "sy");
      __publicField(this, "ny");
      __publicField(this, "oy");
      __publicField(this, "ry");
      __publicField(this, "Jp");
      __publicField(this, "Zp");
      __publicField(this, "Wp");
      __publicField(this, "jp");
      __publicField(this, "ay");
      __publicField(this, "hy");
      __publicField(this, "fy");
      __publicField(this, "cy");
      __publicField(this, "Cn");
      this.xi = false, this.qp = null, this.ly = null, this._p = null, this.Qp = "", this.ty = null, this.$p = null, this.iy = null, this.ey = "", this.sy = Size2.xw, this.ny = null, this.oy = "", this.ry = Spot2.Default, this.Jp = "", this.Zp = Spot2.TopLeft, this.Wp = Point2.iC, this.jp = Point2.eC, this.ay = null, this.hy = 127, this.fy = Point2.sC, this.cy = "gray", this.Cn = 4;
    }
    copy() {
      const t = new PartTemplateSettings();
      return t.qp = this.qp, t.ly = this.ly, t._p = this._p, t.Qp = this.Qp, t.ty = this.ty, t.$p = this.$p, t.iy = this.iy, t.ey = this.ey, t.sy = this.sy.L(), t.ny = this.ny, t.oy = this.oy, t.ry = this.ry.L(), t.Jp = this.Jp, t.Zp = this.Zp.L(), t.Wp = this.Wp.L(), t.jp = this.jp.L(), t.ay = this.ay, t.hy = this.hy, t.fy = this.fy.L(), t.cy = this.cy, t.Cn = this.Cn, t;
    }
  }
  class Adornment2 extends Part2 {
    constructor(t, i) {
      var __super = (...args3) => {
        super(...args3);
        __publicField(this, "xs");
        __publicField(this, "Et");
        __publicField(this, "sM");
        __publicField(this, "nM");
        __publicField(this, "uc");
        return this;
      };
      t === void 0 || t instanceof PanelLayout2 || typeof t == "number" || typeof t == "string" ? __super(t) : (__super(), t && (i = t)), this.N &= -257, this.ml = "Adornment", this.xs = null, this.sM = 0, this.nM = false, this.Et = null, this.uc = null, i && Object.assign(this, i);
    }
    toString() {
      const t = this.adornedPart;
      return "Adornment(" + this.category + ")" + (t !== null ? t.toString() : "");
    }
    updateRelationshipsFromData() {
    }
    pd(t) {
      const i = this.adornedObject, e = i == null ? void 0 : i.part;
      if (!(e instanceof Link2) || !(i instanceof Shape2))
        return;
      const s = e.path;
      let n = s.geometry;
      e.pd(t), n = s.geometry;
      const o = this.F.h, r = o.length;
      for (let l = 0; l < r; l++) {
        const h = o[l];
        h.isPanelMain && h instanceof Shape2 && (h.yt = n);
      }
    }
    hasPlaceholder() {
      return this.Et !== null && this.Et.isVisibleObject();
    }
    get placeholder() {
      return this.Et;
    }
    get adornedObject() {
      return this.xs;
    }
    set adornedObject(t) {
      Debug && t !== null && Util.s(t, GraphObject2, Part2, "adornedObject:value");
      const i = this.adornedPart;
      let e = null;
      t !== null && (e = t.part), i !== null && (t === null || i !== e) && i.removeAdornment(this.category), this.xs = t, e !== null && e.addAdornment(this.category, this);
    }
    get adornedPart() {
      const t = this.xs;
      return t !== null ? t.part : null;
    }
    tl() {
      const t = this.xs;
      if (t === null)
        return true;
      const i = t.part;
      return i === null || !i.hs();
    }
    De() {
      return false;
    }
    get containingGroup() {
      return null;
    }
    tc(t, i, e, s, n, o, r) {
      if (t === 3 && i === "elements") {
        if (n instanceof Placeholder2)
          this.Et === null ? this.Et = n : Debug && this.Et !== n && Util.n("Cannot insert a second Placeholder into the visual tree of an Adornment.");
        else if (n instanceof Panel2) {
          const l = n.findInVisualTree((h) => h instanceof Placeholder2);
          l instanceof Placeholder2 && (this.Et === null ? this.Et = l : Debug && this.Et !== l && Util.n("Cannot insert a second Placeholder into the visual tree of an Adornment."));
        }
      } else
        t === 4 && i === "elements" && this.Et !== null && (s === this.Et ? this.Et = null : s instanceof Panel2 && this.Et.isContainedBy(s) && (this.Et = null));
      super.tc(t, i, e, s, n, o, r);
    }
    updateAdornments() {
    }
    Wf() {
    }
  }
  var PortSpreading2 = ((w) => (w[w.None = 0] = "None", w[w.Evenly = 1] = "Evenly", w[w.Packed = 2] = "Packed", w))(PortSpreading2 || {});
  const _Node = class _Node extends Part2 {
    constructor(t, i) {
      var __super = (...args4) => {
        super(...args4);
        __publicField(this, "z");
        __publicField(this, "bt");
        __publicField(this, "Nc");
        __publicField(this, "yl");
        __publicField(this, "Sh");
        __publicField(this, "ue");
        __publicField(this, "ni");
        return this;
      };
      t === void 0 || t instanceof PanelLayout2 || typeof t == "number" || typeof t == "string" ? __super(t) : (__super(), t && (i = t)), this.z = 13, this.bt = null, this.ni = new List2(), this.Nc = null, this.yl = null, this.ue = null, this.Sh = false, i && Object.assign(this, i);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.z = this.z, this.bt !== null && (this.bt.xi ? t.bt = this.bt : t.bt = this.bt.copy());
    }
    qo(t) {
      super.qo(t), t.invalidateConnectedLinks(), t.yl = this.yl, t.ue = null;
    }
    wl() {
      this.bt === null ? this.bt = new NodeTemplateSettings() : this.bt.xi && (this.bt = this.bt.copy());
    }
    uh() {
      super.uh(), this.bt !== null && (this.bt.xi = true);
    }
    QL(t) {
      t !== null && (this.yl === null && (this.yl = new GSet2()), this.yl.add(t));
    }
    _L(t) {
      t !== null && this.yl !== null && this.yl.remove(t);
    }
    tT(t, i, e) {
      if (t === null || this.yl === null)
        return null;
      const s = this.yl.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n.uy === this && n.yb === t && n.iN === i && n.eN === e || n.uy === t && n.yb === this && n.iN === e && n.eN === i)
          return n;
      }
      return null;
    }
    invalidateLinkBundle(t, i, e) {
      i == null && (i = ""), e == null && (e = "");
      const s = this.tT(t, i, e);
      s !== null && s.Vd();
    }
    tc(t, i, e, s, n, o, r) {
      t === 3 && i === "elements" ? this.ue = null : t === 4 && i === "elements" && (this.ue = null), super.tc(t, i, e, s, n, o, r);
    }
    invalidateConnectedLinks(t) {
      const i = this.linksConnected;
      for (; i.next(); ) {
        const e = i.value;
        t !== void 0 && t.contains(e) || (this.Se(e.fromPort), this.Se(e.toPort), e.invalidateRoute());
      }
    }
    nL(t) {
      const i = this.linksConnected;
      for (; i.next(); ) {
        const e = i.value;
        e.fromPort !== t && e.toPort !== t || (this.Se(e.fromPort), this.Se(e.toPort), e.invalidateRoute());
      }
    }
    Se(t) {
      if (t === null)
        return;
      const i = t.nd;
      i !== null && i.Vd();
      const e = t.part, s = e.containingGroup;
      s !== null && !e.isVisible() && s.Se(s.port);
    }
    tl() {
      return true;
    }
    get portSpreading() {
      return this.bt !== null ? this.bt.gy : 1;
    }
    set portSpreading(t) {
      const i = this.portSpreading;
      if (i !== t) {
        Debug && t !== 0 && t !== 1 && t !== 2 && Util.n("Node.portSpreading can only be set to PortSpreading.None, PortSpreading.Evenly, or PortSpreading.Packed, not: " + t), this.wl(), this.bt.gy = t, this.i("portSpreading", i, t);
        const e = this.diagram;
        if (e !== null && e.undoManager.isUndoingRedoing)
          return;
        this.invalidateConnectedLinks();
      }
    }
    get avoidable() {
      return (this.z & 8) !== 0;
    }
    set avoidable(t) {
      const i = (this.z & 8) !== 0;
      if (i !== t) {
        Debug && Util.t(t, "boolean", _Node, "avoidable"), this.z = this.z ^ 8;
        const e = this.diagram;
        e !== null && e.KP(this), this.i("avoidable", i, t);
      }
    }
    get avoidableMargin() {
      return this.bt !== null ? this.bt.my : Margin2.aC;
    }
    set avoidableMargin(t) {
      typeof t == "number" ? t = new Margin2(t) : Util.s(t, Margin2, _Node, "avoidableMargin");
      const i = this.avoidableMargin;
      if (!i.equals(t)) {
        t = t.L(), this.wl(), this.bt.my = t;
        const e = this.diagram;
        e !== null && e.KP(this), this.i("avoidableMargin", i, t);
      }
    }
    canAvoid() {
      return this.avoidable && !this.isLinkLabel;
    }
    getAvoidableRect(t) {
      return t.set(this.actualBounds), t.addMargin(this.avoidableMargin), t;
    }
    findVisibleNode() {
      let t = this;
      for (; t !== null && !t.isVisible(); )
        t = t.containingGroup;
      return t;
    }
    isVisible() {
      if (!super.isVisible())
        return false;
      let t = true, i = 1;
      const e = this.diagram;
      if (e !== null) {
        if (e.animationManager.ux(this))
          return true;
        t = e.isTreePathToChildren, i = e.treeCollapsePolicy;
      }
      if (i === 1) {
        const n = this.findTreeParentNode();
        if (n !== null && !n.isTreeExpanded)
          return false;
      } else if (i === 2) {
        const n = t ? this.findLinksInto() : this.findLinksOutOf();
        let o = false, r = false;
        for (; n.next(); ) {
          const l = n.value;
          if (l.isTreeLink) {
            o = true;
            const h = t ? l.fromNode : l.toNode;
            if (h && h.isTreeExpanded) {
              r = true;
              break;
            }
          }
        }
        if (o && !r)
          return false;
      } else if (i === 3) {
        const n = t ? this.findLinksInto() : this.findLinksOutOf();
        let o = false, r = false;
        for (; n.next(); ) {
          const l = n.value;
          if (l.isTreeLink) {
            o = true;
            const h = t ? l.fromNode : l.toNode;
            if (h && !h.isTreeExpanded) {
              r = true;
              break;
            }
          }
        }
        if (o && r)
          return false;
      }
      const s = this.labeledLink;
      return s !== null ? s.isVisible() : true;
    }
    Ki(t) {
      super.Ki(t);
      const i = this.linksConnected;
      for (; i.next(); ) {
        const e = i.value;
        if (t && this.containingGroup !== null) {
          const s = e.getOtherNode(this);
          s !== null && !s.isMemberOf(this.containingGroup) && e.invalidateRoute();
        }
        e.Ki(t);
      }
    }
    get linksConnected() {
      return this.ni.iterator;
    }
    findExternalTreeLinksConnected() {
      const t = new GSet2(), i = new GSet2();
      return this.iT(this, t, i), i.iterator;
    }
    iT(t, i, e) {
      if (t === null || i.has(t))
        return;
      i.add(t);
      let s = true;
      const n = this.diagram;
      n !== null && (s = n.isTreePathToChildren), t.linksConnected.each((o) => {
        o.isTreeLink ? (s ? o.fromNode === t : o.toNode === t) && this.iT(s ? o.toNode : o.fromNode, i, e) : e.add(o);
      });
    }
    findLinksConnected(t) {
      if (t === void 0 && (t = null), t === null)
        return this.ni.iterator;
      Debug && Util.t(t, "string", _Node, "findLinksConnected:pid");
      const i = new ListIterator(this.ni), e = this;
      return i.predicate = (s) => s.fromNode === e && s.fromPortId === t || s.toNode === e && s.toPortId === t, i;
    }
    findLinksOutOf(t) {
      t === void 0 && (t = null), Debug && t !== null && Util.t(t, "string", _Node, "findLinksOutOf:pid");
      const i = new ListIterator(this.ni), e = this;
      return i.predicate = (s) => s.fromNode !== e ? false : t === null ? true : s.fromPortId === t, i;
    }
    findLinksInto(t) {
      t === void 0 && (t = null), Debug && t !== null && Util.t(t, "string", _Node, "findLinksInto:pid");
      const i = new ListIterator(this.ni), e = this;
      return i.predicate = (s) => s.toNode !== e ? false : t === null ? true : s.toPortId === t, i;
    }
    findNodesConnected(t) {
      t === void 0 && (t = null), Debug && t !== null && Util.t(t, "string", _Node, "findNodesConnected:pid");
      let i = null, e = null;
      const s = this.ni.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n.fromNode === this) {
          if (t === null || n.fromPortId === t) {
            const o = n.toNode;
            i !== null ? i.add(o) : e !== null && e !== o ? (i = new GSet2(), i.add(e), i.add(o)) : e = o;
          }
        } else if (n.toNode === this && (t === null || n.toPortId === t)) {
          const o = n.fromNode;
          i !== null ? i.add(o) : e !== null && e !== o ? (i = new GSet2(), i.add(e), i.add(o)) : e = o;
        }
      }
      return i !== null ? i.iterator : e !== null ? new SingletonIterator(e) : EmptyIterator.instance;
    }
    findNodesOutOf(t) {
      t === void 0 && (t = null), Debug && t !== null && Util.t(t, "string", _Node, "findNodesOutOf:pid");
      let i = null, e = null;
      const s = this.ni.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n.fromNode === this && (t === null || n.fromPortId === t)) {
          const o = n.toNode;
          i !== null ? i.add(o) : e !== null && e !== o ? (i = new GSet2(), i.add(e), i.add(o)) : e = o;
        }
      }
      return i !== null ? i.iterator : e !== null ? new SingletonIterator(e) : EmptyIterator.instance;
    }
    findNodesInto(t) {
      t === void 0 && (t = null), Debug && t !== null && Util.t(t, "string", _Node, "findNodesInto:pid");
      let i = null, e = null;
      const s = this.ni.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n.toNode === this && (t === null || n.toPortId === t)) {
          const o = n.fromNode;
          i !== null ? i.add(o) : e !== null && e !== o ? (i = new GSet2(), i.add(e), i.add(o)) : e = o;
        }
      }
      return i !== null ? i.iterator : e !== null ? new SingletonIterator(e) : EmptyIterator.instance;
    }
    findLinksBetween(t, i, e) {
      i === void 0 && (i = null), e === void 0 && (e = null), Debug && (Util.s(t, _Node, _Node, "findLinksBetween:othernode"), i !== null && Util.t(i, "string", _Node, "findLinksBetween:pid"), e !== null && Util.t(e, "string", _Node, "findLinksBetween:otherpid"));
      const s = new ListIterator(this.ni), n = this;
      return s.predicate = (o) => o.fromNode === n && o.toNode === t && (i === null || o.fromPortId === i) && (e === null || o.toPortId === e) || o.fromNode === t && o.toNode === n && (e === null || o.fromPortId === e) && (i === null || o.toPortId === i), s;
    }
    findLinksTo(t, i, e) {
      i === void 0 && (i = null), e === void 0 && (e = null), Debug && (Util.s(t, _Node, _Node, "findLinksTo:othernode"), i !== null && Util.t(i, "string", _Node, "findLinksTo:pid"), e !== null && Util.t(e, "string", _Node, "findLinksTo:otherpid"));
      const s = new ListIterator(this.ni), n = this;
      return s.predicate = (o) => !(o.fromNode !== n || o.toNode !== t || i !== null && o.fromPortId !== i || e !== null && o.toPortId !== e), s;
    }
    get linkConnected() {
      return this.bt !== null ? this.bt.py : null;
    }
    set linkConnected(t) {
      const i = this.linkConnected;
      i !== t && (t !== null && Util.t(t, "function", _Node, "linkConnected"), this.wl(), this.bt.py = t, this.i("linkConnected", i, t));
    }
    get linkDisconnected() {
      return this.bt !== null ? this.bt.yy : null;
    }
    set linkDisconnected(t) {
      const i = this.linkDisconnected;
      i !== t && (t !== null && Util.t(t, "function", _Node, "linkDisconnected"), this.wl(), this.bt.yy = t, this.i("linkDisconnected", i, t));
    }
    get linkValidation() {
      return this.bt !== null ? this.bt.Fl : null;
    }
    set linkValidation(t) {
      const i = this.linkValidation;
      i !== t && (t !== null && Util.t(t, "function", _Node, "linkValidation"), this.wl(), this.bt.Fl = t, this.i("linkValidation", i, t));
    }
    wb(t, i) {
      this.Se(i);
      const e = this.ni.contains(t);
      if (e || this.ni.add(t), !e || t.fromNode === t.toNode) {
        const s = this.linkConnected;
        if (s !== null) {
          let n = true;
          const o = this.diagram;
          o !== null && (n = o.W, o.W = true), s(this, t, i), o !== null && (o.W = n);
        }
      }
      if (!e) {
        if (!t.isTreeLink)
          return;
        const s = t.fromNode, n = t.toNode;
        if (s !== null && n !== null && s !== n) {
          let o = true;
          const r = this.diagram;
          r !== null && (o = r.isTreePathToChildren);
          const l = o ? n : s, h = o ? s : n;
          if (l.Sh || (l.Sh = h), h.isTreeLeaf) {
            if (r !== null && r.undoManager.isUndoingRedoing)
              return;
            o ? s === h && (h.isTreeLeaf = false) : n === h && (h.isTreeLeaf = false);
          }
        }
      }
    }
    xb(t, i) {
      this.Se(i);
      const e = this.ni.remove(t);
      let s = null;
      if (e || t.toNode === t.fromNode) {
        const n = this.linkDisconnected;
        if (s = this.diagram, n !== null) {
          let o = true;
          s !== null && (o = s.W, s.W = true), n(this, t, i), s !== null && (s.W = o);
        }
      }
      if (e) {
        if (!t.isTreeLink)
          return;
        let n = true;
        s !== null && (n = s.isTreePathToChildren);
        const o = n ? t.toNode : t.fromNode, r = n ? t.fromNode : t.toNode;
        if (o !== null && (o.Sh = false), r !== null && !r.isTreeLeaf)
          if (r.ni.count === 0) {
            if (r.Sh = null, s !== null && s.undoManager.isUndoingRedoing)
              return;
            r.isTreeLeaf = true;
          } else
            r.x0();
      }
    }
    x0() {
      if (this.Sh = false, this.ni.count === 0)
        return;
      let t = true;
      const i = this.diagram;
      if (i !== null && i.undoManager.isUndoingRedoing)
        return;
      i !== null && (t = i.isTreePathToChildren);
      const e = this.ni.iterator;
      for (; e.next(); ) {
        const s = e.value;
        if (s.isTreeLink) {
          if (t) {
            if (s.fromNode === this) {
              this.isTreeLeaf = false;
              return;
            }
          } else if (s.toNode === this) {
            this.isTreeLeaf = false;
            return;
          }
        }
      }
      this.isTreeLeaf = true;
    }
    updateRelationshipsFromData() {
      const t = this.diagram;
      t !== null && t.partManager.updateRelationshipsFromData(this);
    }
    vm(t) {
      if (super.vm(t), !t) {
        this.x0();
        const i = this.Nc;
        i !== null && i.eT(this);
      }
    }
    qm(t) {
      if (super.qm(t), !t) {
        const i = this.Nc;
        i !== null && i.sT(this);
      }
    }
    Wf() {
      if (this.ni.count > 0) {
        const t = this.diagram;
        if (t !== null) {
          const i = t.commandHandler !== null ? t.commandHandler.deletesConnectedLinks : true, s = this.ni.copy().iterator;
          for (; s.next(); ) {
            const n = s.value;
            i ? t.remove(n) : (n.fromNode === this && (n.fromNode = null), n.toNode === this && (n.toNode = null));
          }
        }
      }
      this.labeledLink = null, super.Wf();
    }
    get isLinkLabel() {
      return this.Nc !== null;
    }
    get labeledLink() {
      return this.Nc;
    }
    set labeledLink(t) {
      const i = this.Nc;
      if (i !== t) {
        Debug && t !== null && Util.s(t, Link2, _Node, "labeledLink");
        const e = this.diagram, s = this.data;
        if (i !== null) {
          if (i.sT(this), e !== null && s !== null && !e.undoManager.isUndoingRedoing) {
            const n = i.data, o = e.model;
            if (n !== null && o.Ea()) {
              const r = o.getKeyForNodeData(s);
              r !== void 0 && o.removeLabelKeyForLinkData(n, r);
            }
          }
          this.containingGroup = null;
        }
        if (this.Nc = t, t !== null) {
          if (t.eT(this), e !== null && s !== null && !e.undoManager.isUndoingRedoing) {
            const n = t.data, o = e.model;
            if (n !== null && o.Ea()) {
              const r = o.getKeyForNodeData(s);
              r !== void 0 && o.addLabelKeyForLinkData(n, r);
            }
          }
          this.containingGroup = t.containingGroup;
        }
        this.rc(), this.i("labeledLink", i, t);
      }
    }
    findVisiblePort(t) {
      let i = t;
      for (; i !== null && (!i.actualBounds.isReal() || !i.isVisibleObject()); )
        i = i.panel;
      return i === null ? this.port : i;
    }
    findPort(t) {
      if (Debug && Util.t(t, "string", _Node, "findPort:pid"), this.ue === null) {
        if (t === "" && this.Nn === false)
          return this;
        this.nT();
      }
      let i = this.ue.getValue(t);
      return i !== null || t !== "" && (i = this.ue.getValue(""), i !== null) ? i : this;
    }
    get port() {
      return this.findPort("");
    }
    get ports() {
      return this.ue === null && this.nT(), this.ue.iteratorValues;
    }
    nT() {
      this.ue === null ? this.ue = new GMap2() : this.ue.clear(), this.walkVisualTreeFrom(this, (t, i) => t.uL(i)), this.ue.count === 0 && this.ue.add("", this);
    }
    uL(t) {
      const i = t.portId;
      i !== null && this.ue !== null && this.ue.add(i, t);
    }
    k2(t, i) {
      const e = t.portId;
      if (e !== null) {
        this.ue !== null && this.ue.remove(e);
        const s = this.diagram;
        if (s !== null && i) {
          let n = null;
          const o = this.findLinksConnected(e);
          for (; o.next(); ) {
            const r = o.value;
            n === null && (n = Util.ct()), n.push(r);
          }
          if (n !== null) {
            for (let r = 0; r < n.length; r++) {
              const l = n[r];
              s.remove(l);
            }
            Util.ot(n);
          }
        }
      }
    }
    isInTreeOf(t) {
      if (t === null || t === this)
        return false;
      let i = true;
      const e = this.diagram;
      e !== null && (i = e.isTreePathToChildren);
      let s = this;
      const n = t;
      let o;
      if (i)
        for (; s !== n; ) {
          o = null;
          const r = s.ni.iterator;
          for (; r.next(); ) {
            const l = r.value;
            if (l.isTreeLink && (o = l.fromNode, o !== s && o !== this))
              break;
          }
          if (o === this || o === null || o === s)
            return false;
          s = o;
        }
      else
        for (; s !== n; ) {
          o = null;
          const r = s.ni.iterator;
          for (; r.next(); ) {
            const l = r.value;
            if (l.isTreeLink && (o = l.toNode, o !== s && o !== this))
              break;
          }
          if (o === this || o === null || o === s)
            return false;
          s = o;
        }
      return true;
    }
    findTreeRoot() {
      let t = true;
      const i = this.diagram;
      i !== null && (t = i.isTreePathToChildren);
      let e = this, s;
      if (t)
        for (; ; ) {
          s = null;
          const n = e.ni.iterator;
          for (; n.next(); ) {
            const o = n.value;
            if (o.isTreeLink && (s = o.fromNode, s !== e && s !== this))
              break;
          }
          if (s === this)
            return this;
          if (s === null || s === e)
            return e;
          e = s;
        }
      else
        for (; ; ) {
          s = null;
          const n = e.ni.iterator;
          for (; n.next(); ) {
            const o = n.value;
            if (o.isTreeLink && (s = o.toNode, s !== e && s !== this))
              break;
          }
          if (s === this)
            return this;
          if (s === null || s === e)
            return e;
          e = s;
        }
    }
    findCommonTreeParent(t) {
      if (t === null)
        return null;
      if (Debug && Util.s(t, _Node, _Node, "findCommonTreeParent:other"), this === t)
        return this;
      let i = this;
      for (; i !== null; )
        i.pb(true), i = i.findTreeParentNode();
      let e = null;
      for (i = t; i !== null; ) {
        if (i.$L()) {
          e = i;
          break;
        }
        i = i.findTreeParentNode();
      }
      for (i = this; i !== null; )
        i.pb(false), i = i.findTreeParentNode();
      return e;
    }
    findTreeParentLink() {
      let t = true;
      const i = this.diagram;
      i !== null && (t = i.isTreePathToChildren);
      const e = this.ni.iterator;
      if (t)
        for (; e.next(); ) {
          const s = e.value;
          if (s.isTreeLink && s.fromNode !== this)
            return s;
        }
      else
        for (; e.next(); ) {
          const s = e.value;
          if (s.isTreeLink && s.toNode !== this)
            return s;
        }
      return null;
    }
    findTreeParentNode() {
      const t = this.Sh;
      if (t === null)
        return null;
      if (t instanceof _Node)
        return t;
      const i = this.diagram, e = i !== null ? i.isTreePathToChildren : true, s = this.ni.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (!n.isTreeLink)
          continue;
        const o = e ? n.fromNode : n.toNode;
        if (o !== this)
          return this.Sh = o, o;
      }
      return this.Sh = null, null;
    }
    findTreeParentChain() {
      function t(e, s) {
        s.add(e);
        const n = e.findTreeParentLink();
        if (n !== null) {
          s.add(n);
          const o = e.findTreeParentNode();
          if (o === null)
            return;
          t(o, s);
        }
      }
      const i = new GSet2();
      return t(this, i), i;
    }
    findTreeLevel() {
      return this.qI(this);
    }
    qI(t) {
      let i = 0, e = t.findTreeParentNode();
      for (; e !== null && e !== t; )
        e = e.findTreeParentNode(), i++;
      return i;
    }
    findTreeChildrenLinks() {
      let t = true;
      const i = this.diagram;
      i !== null && (t = i.isTreePathToChildren);
      const e = new ListIterator(this.ni), s = this;
      return t ? e.predicate = (n) => !(!n.isTreeLink || n.fromNode !== s) : e.predicate = (n) => !(!n.isTreeLink || n.toNode !== s), e;
    }
    findTreeChildrenNodes() {
      let t = true;
      const i = this.diagram;
      i !== null && (t = i.isTreePathToChildren);
      let e = null, s = null;
      const n = this.ni.iterator;
      if (t)
        for (; n.next(); ) {
          const o = n.value;
          if (o.isTreeLink && o.fromNode === this) {
            const r = o.toNode;
            e !== null ? e.add(r) : s !== null && s !== r ? (e = new List2(), e.add(s), e.add(r)) : s = r;
          }
        }
      else
        for (; n.next(); ) {
          const o = n.value;
          if (o.isTreeLink && o.toNode === this) {
            const r = o.fromNode;
            e !== null ? e.add(r) : s !== null && s !== r ? (e = new List2(), e.add(s), e.add(r)) : s = r;
          }
        }
      return e !== null ? e.iterator : s !== null ? new SingletonIterator(s) : EmptyIterator.instance;
    }
    findTreeParts(t) {
      t === void 0 && (t = 1 / 0), Util.t(t, "number", _Node, "findTreeParts:level");
      const i = new GSet2();
      return Part2.ah(i, this, false, t, true), i;
    }
    collapseTree(t) {
      t === void 0 && (t = 1), Util.r(t, _Node, "collapseTree:level"), t < 1 && (t = 1);
      const i = this.diagram;
      if (i === null || i.isCollapsingExpanding)
        return;
      i.isCollapsingExpanding = true;
      const e = new GSet2();
      e.add(this), this.oT(e, i.isTreePathToChildren, t, i, this, i.treeCollapsePolicy === 1), i.isCollapsingExpanding = false;
    }
    oT(t, i, e, s, n, o) {
      if (e > 1) {
        const r = i ? this.findLinksOutOf() : this.findLinksInto();
        for (; r.next(); ) {
          const l = r.value;
          if (!l.isTreeLink)
            continue;
          const h = l.getOtherNode(this);
          h !== null && h !== this && !t.contains(h) && (t.add(h), h.oT(t, i, e - 1, s, n, o));
        }
      } else
        this.rT(t, i, s, n, o);
    }
    rT(t, i, e, s, n) {
      const o = s === this ? true : this.isTreeExpanded, r = i ? this.findLinksOutOf() : this.findLinksInto();
      for (; r.next(); ) {
        const l = r.value;
        if (!l.isTreeLink)
          continue;
        const h = l.getOtherNode(this);
        if (h !== null && h !== this) {
          const a = t.contains(h);
          if (a || t.add(h), o) {
            const f = i ? h.findNodesInto() : h.findNodesOutOf(), c = this;
            f.all((u) => u === c || !u.isTreeExpanded) && e.Rf(h, s), h.mh(), h.Ki(false);
          }
          h.isTreeExpanded && (h.wasTreeExpanded = h.isTreeExpanded, a || h.rT(t, i, e, s, n));
        }
      }
      this.isTreeExpanded = false;
    }
    expandTree(t) {
      t === void 0 && (t = 2), Util.r(t, _Node, "expandTree:level"), t < 2 && (t = 2);
      const i = this.diagram;
      if (i === null || i.isCollapsingExpanding)
        return;
      i.isCollapsingExpanding = true;
      const e = new GSet2();
      e.add(this), this.lT(e, i.isTreePathToChildren, t, i, this, i.treeCollapsePolicy === 1), i.isCollapsingExpanding = false;
    }
    lT(t, i, e, s, n, o) {
      const r = n === this ? false : this.isTreeExpanded, l = i ? this.findLinksOutOf() : this.findLinksInto();
      for (; l.next(); ) {
        const h = l.value;
        if (!h.isTreeLink)
          continue;
        r || h.Re || h.invalidateRoute();
        const a = h.getOtherNode(this);
        if (a !== null && a !== this && !t.contains(a)) {
          if (t.add(a), !r) {
            a.Ki(true), a.mh();
            const f = i ? a.findNodesInto() : a.findNodesOutOf(), c = this;
            f.all((u) => u === c || !u.isTreeExpanded) && s.Ff(a, n);
          }
          (e > 2 || a.wasTreeExpanded) && (a.wasTreeExpanded = false, a.lT(t, i, e - 1, s, n, o));
        }
      }
      this.isTreeExpanded = true;
    }
    get isTreeExpanded() {
      return (this.z & 1) !== 0;
    }
    set isTreeExpanded(t) {
      const i = (this.z & 1) !== 0;
      if (i !== t) {
        Debug && Util.t(t, "boolean", _Node, "isTreeExpanded"), this.z = this.z ^ 1;
        const e = this.diagram;
        this.i("isTreeExpanded", i, t);
        const s = this.treeExpandedChanged;
        if (s !== null) {
          let n = true;
          e !== null && (n = e.W, e.W = true), s(this), e !== null && (e.W = n);
        }
        if (e !== null && e.undoManager.isUndoingRedoing) {
          this.Ki(t);
          return;
        }
        t ? this.expandTree() : this.collapseTree();
      }
    }
    get wasTreeExpanded() {
      return (this.z & 2) !== 0;
    }
    set wasTreeExpanded(t) {
      const i = (this.z & 2) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Node, "wasTreeExpanded"), this.z = this.z ^ 2, this.i("wasTreeExpanded", i, t));
    }
    get treeExpandedChanged() {
      return this.bt !== null ? this.bt.wy : null;
    }
    set treeExpandedChanged(t) {
      const i = this.treeExpandedChanged;
      i !== t && (t !== null && Util.t(t, "function", _Node, "treeExpandedChanged"), this.wl(), this.bt.wy = t, this.i("treeExpandedChanged", i, t));
    }
    get isTreeLeaf() {
      return (this.z & 4) !== 0;
    }
    set isTreeLeaf(t) {
      const i = (this.z & 4) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Node, "isTreeLeaf"), this.z = this.z ^ 4, this.i("isTreeLeaf", i, t));
    }
    get isTreeRoot() {
      return this.findTreeParentLink() === null;
    }
  };
  __publicField(_Node, "SpreadingNone", 0);
  __publicField(_Node, "SpreadingEvenly", 1);
  __publicField(_Node, "SpreadingPacked", 2);
  let Node2 = _Node;
  class NodeTemplateSettings {
    constructor() {
      __publicField(this, "xi");
      __publicField(this, "py");
      __publicField(this, "yy");
      __publicField(this, "Fl");
      __publicField(this, "wy");
      __publicField(this, "my");
      __publicField(this, "gy");
      __publicField(this, "xy");
      __publicField(this, "by");
      __publicField(this, "hh");
      __publicField(this, "ky");
      this.xi = false, this.py = null, this.yy = null, this.Fl = null, this.wy = null, this.my = Margin2.aC, this.gy = 1, this.xy = null, this.by = null, this.hh = null, this.ky = null;
    }
    copy() {
      const t = new NodeTemplateSettings();
      return t.py = this.py, t.yy = this.yy, t.Fl = this.Fl, t.wy = this.wy, t.my = this.my.L(), t.gy = this.gy, t.xy = this.xy, t.by = this.by, t.hh = this.hh, t.ky = this.ky, t;
    }
  }
  var LinkAdjusting2 = ((w) => (w[w.None = 0] = "None", w[w.End = 17] = "End", w[w.Scale = 18] = "Scale", w[w.Stretch = 19] = "Stretch", w))(LinkAdjusting2 || {}), Routing2 = ((w) => (w[w.Normal = 1] = "Normal", w[w.Orthogonal = 2] = "Orthogonal", w[w.AvoidsNodes = 6] = "AvoidsNodes", w[w.AvoidsNodesStraight = 7] = "AvoidsNodesStraight", w))(Routing2 || {}), Curve2 = ((w) => (w[w.None = 0] = "None", w[w.Bezier = 9] = "Bezier", w[w.JumpGap = 10] = "JumpGap", w[w.JumpOver = 11] = "JumpOver", w))(Curve2 || {});
  const _Link = class _Link extends Part2 {
    constructor(t) {
      super(Panel2.Link);
      __publicField(this, "Dt");
      __publicField(this, "mo");
      __publicField(this, "po");
      __publicField(this, "Bd");
      __publicField(this, "yo");
      __publicField(this, "wo");
      __publicField(this, "zd");
      __publicField(this, "Cc");
      __publicField(this, "Xd");
      __publicField(this, "Yd");
      __publicField(this, "Kd");
      __publicField(this, "Va");
      __publicField(this, "Ud");
      __publicField(this, "Qs");
      __publicField(this, "Ci");
      __publicField(this, "Ve");
      __publicField(this, "Dr");
      __publicField(this, "Ac");
      __publicField(this, "sr");
      __publicField(this, "sN");
      __publicField(this, "nN");
      __publicField(this, "bb");
      __publicField(this, "oN");
      __publicField(this, "rN");
      __publicField(this, "Sy");
      __publicField(this, "kb");
      __publicField(this, "yt");
      __publicField(this, "nr");
      __publicField(this, "uc");
      __publicField(this, "lN");
      __publicField(this, "hN");
      this.Dt = 8, this.mo = null, this.po = "", this.Bd = null, this.yo = null, this.wo = "", this.zd = null, this.Cc = 0, this.Xd = 0, this.Yd = 0, this.Kd = NaN, this.Va = 1, this.Ud = 0.5, this.Qs = null, this.Ci = new List2().w(), this.Ve = null, this.Dr = null, this.Ac = new Rect2(), this.yt = new Geometry2(), this.sr = null, this.nr = null, this.sN = null, this.nN = null, this.lN = 0, this.hN = 0, this.bb = new Point2(), this.oN = null, this.rN = null, this.Sy = null, this.kb = NaN, this.$ = null, this.uc = [], t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Dt = this.Dt & -113, t.po = this.po, t.Bd = this.Bd, t.wo = this.wo, t.zd = this.zd, t.Cc = this.Cc, t.Xd = this.Xd, t.Yd = this.Yd, t.Kd = this.Kd, t.Va = this.Va, t.Ud = this.Ud, this.$ !== null && (t.$ = this.$.copy());
    }
    qo(t) {
      super.qo(t), this.po = t.po, this.wo = t.wo, t.Ve = null, t.invalidateRoute(), t.nr = this.nr;
      const i = t.fromPort;
      i !== null && t.fromNode.Se(i);
      const e = t.toPort;
      e !== null && t.toNode.Se(e);
    }
    ci(t) {
      t in Routing2 || t in Curve2 || t in LinkAdjusting2 ? _Link.aN(t) ? this.routing = t : t === 9 || t === 10 || t === 11 ? this.curve = t : t === 17 || t === 18 || t === 19 ? this.adjusting = t : t === 1 || t === 0 || Util.n("Unknown Link enum value for a Link property: " + t) : super.ci(t);
    }
    je() {
      this.$ === null && (this.$ = new LinkSettings());
    }
    nI(t, i, e) {
      const s = t.segmentIndex, n = t.segmentFraction;
      let o = t.alignmentFocus;
      const r = t.segmentOrientation, l = t.segmentOffset;
      let h = 0, a = 0, f = 0, c = 0;
      if (isNaN(s)) {
        const C = this.yt, P = Util.ct();
        C.getPointAndAngleAlongPath(n, P);
        const N = Point2.H(P[0], P[1]);
        if (N.add(this.getPoint(0)), C.type === 1)
          N.offset(-C.startX, -C.startY);
        else {
          const T = C.figures.first();
          N.offset(-T.startX, -T.startY);
        }
        c = P[2], r !== 0 && (f = this.computeAngle(t, r, c), t.angle = f), h = N.x, a = N.y, Point2.o(N), Util.ot(P);
      } else if (s < -i || s >= i) {
        const C = Point2.a();
        this.wL(C), c = this.midAngle, r !== 0 && (f = this.computeAngle(t, r, c), t.angle = f), h = C.x, a = C.y, Point2.o(C);
      } else {
        let C, P, N = 0;
        if (s >= 0 ? (C = e.h[s], P = s < i - 1 ? e.h[s + 1] : C) : (N = i + s, C = e.h[N], P = N > 0 ? e.h[N - 1] : C), C.equalsApprox(P)) {
          let T, L;
          s >= 0 ? (T = s > 0 ? e.h[s - 1] : C, L = s < i - 2 ? e.h[s + 2] : P) : (T = N < i - 1 ? e.h[N + 1] : C, L = N > 1 ? e.h[N - 2] : P);
          const D = T.distanceSquaredPoint(C), F = P.distanceSquaredPoint(L);
          D > F + 10 ? c = s >= 0 ? T.directionPoint(C) : C.directionPoint(T) : F > D + 10 ? c = s >= 0 ? P.directionPoint(L) : L.directionPoint(P) : c = s >= 0 ? T.directionPoint(L) : L.directionPoint(T);
        } else
          c = s >= 0 ? C.directionPoint(P) : P.directionPoint(C);
        r !== 0 && (f = this.computeAngle(t, r, c), t.angle = f), h = C.x + (P.x - C.x) * n, a = C.y + (P.y - C.y) * n;
      }
      if (o.isNone()) {
        t.location = new Point2(h, a);
        return;
      } else
        o.isNoSpot() && (o = Spot2.Center);
      const u = Transform.a();
      u.ti(), u.v(t.scale, t.scale), u.ys(t.angle, 0, 0);
      const d = t.naturalBounds, m = Rect2.H(0, 0, d.width, d.height), g = Point2.a();
      g.setRectSpot(m, o), u.Pt(g);
      let p = -g.x, y = -g.y;
      const x = d.width, b = d.height, k = Point2.a();
      k.c(l);
      const S = isNaN(l.x), M = isNaN(l.y);
      if (S || M) {
        const C = x / 2 + 3, P = b / 2 + 3, N = c >= 45 && c <= 135, T = c >= 225 && c <= 315;
        r === 0 && (N || T) ? (k.x = M ? C : l.y, k.y = S ? P : l.x, N ? s >= 0 || isNaN(s) && n < 0.5 || S && (k.y = -P) : T && ((s >= 0 || isNaN(s) && n < 0.5) && S && (k.y = -P), M && (k.x = -C))) : (S && (s >= 0 || isNaN(s) && n < 0.5 ? k.x = C : k.x = -C), M && (k.y = -P), k.rotate(c));
      } else
        k.rotate(c);
      h += k.x, a += k.y, u.Nw(m), p += m.x, y += m.y;
      const A = Point2.H(h + p, a + y);
      t.move(A), Point2.o(A), Point2.o(k), Point2.o(g), Rect2.o(m), Transform.o(u);
    }
    tl() {
      let t = this.fromNode;
      if (t !== null) {
        const e = t.findVisibleNode();
        if (e !== null && (t = e), t.hs() || t.rh())
          return false;
      }
      let i = this.toNode;
      if (i !== null) {
        const e = i.findVisibleNode();
        if (e !== null && (i = e), i.hs() || i.rh())
          return false;
      }
      return true;
    }
    w2(t, i, e) {
      return false;
    }
    b2() {
    }
    De() {
      return false;
    }
    computeAngle(t, i, e) {
      return _Link.computeAngle(i, e);
    }
    static computeAngle(t, i) {
      let e = 0;
      switch (t) {
        default:
        case 0:
          e = 0;
          break;
        case 21:
          e = i;
          break;
        case 22:
          e = i + 90;
          break;
        case 23:
          e = i - 90;
          break;
        case 24:
          e = i + 180;
          break;
        case 25:
          e = Geo.Zg(i), e > 90 && e < 270 && (e -= 180);
          break;
        case 26:
          e = Geo.Zg(i + 90), e > 90 && e < 270 && (e -= 180);
          break;
        case 27:
          e = Geo.Zg(i - 90), e > 90 && e < 270 && (e -= 180);
          break;
        case 28:
          if (e = Geo.Zg(i), e > 45 && e < 135 || e > 225 && e < 315)
            return 0;
          e > 90 && e < 270 && (e -= 180);
          break;
      }
      return Geo.Zg(e);
    }
    get fromNode() {
      return this.mo;
    }
    set fromNode(t) {
      const i = this.mo;
      if (i !== t) {
        Debug && t !== null && Util.s(t, Node2, _Link, "fromNode");
        const e = this.fromPort;
        i !== null && (this.yo !== i && i.xb(this, e), this.My(), this.invalidateLayout(2)), this.mo = t, t !== null && this.Ki(t.isVisible()), this.sr = null, this.invalidateRoute();
        const s = this.diagram;
        s !== null && s.W && s.partManager.setFromNodeForLink(this, t, i);
        const n = this.fromPort, o = this.fromPortChanged;
        if (o !== null) {
          let r = true;
          s !== null && (r = s.W, s.W = true), o(this, e, n), s !== null && (s.W = r);
        }
        t !== null && (this.yo !== t && t.wb(this, n), this.Py(), this.invalidateLayout(1)), this.i("fromNode", i, t), this.Ed();
      }
    }
    get fromPortId() {
      return this.po;
    }
    set fromPortId(t) {
      const i = this.po;
      if (i !== t) {
        Debug && Util.t(t, "string", _Link, "fromPortId");
        const e = this.fromPort;
        e !== null && this.fromNode.Se(e), this.My(), this.po = t;
        const s = this.fromPort;
        s !== null && this.fromNode.Se(s);
        const n = this.diagram;
        if (n !== null) {
          const o = this.data, r = n.model;
          o !== null && r.Ea() && r.setFromPortIdForLinkData(o, t);
        }
        if (e !== s) {
          this.sr = null, this.invalidateRoute();
          const o = this.fromPortChanged;
          if (o !== null) {
            let r = true;
            n !== null && (r = n.W, n.W = true), o(this, e, s), n !== null && (n.W = r);
          }
        }
        this.Py(), this.i("fromPortId", i, t);
      }
    }
    get fromPort() {
      const t = this.mo;
      if (t === null)
        return null;
      const i = this.po;
      return t.findPort(i);
    }
    get fromPortChanged() {
      return this.Bd;
    }
    set fromPortChanged(t) {
      const i = this.Bd;
      i !== t && (t !== null && Util.t(t, "function", _Link, "fromPortChanged"), this.Bd = t, this.i("fromPortChanged", i, t));
    }
    get toNode() {
      return this.yo;
    }
    set toNode(t) {
      const i = this.yo;
      if (i !== t) {
        Debug && t !== null && Util.s(t, Node2, _Link, "toNode");
        const e = this.toPort;
        i !== null && (this.mo !== i && i.xb(this, e), this.My(), this.invalidateLayout(2)), this.yo = t, t !== null && this.Ki(t.isVisible()), this.sr = null, this.invalidateRoute();
        const s = this.diagram;
        s !== null && s.W && s.partManager.setToNodeForLink(this, t, i);
        const n = this.toPort, o = this.toPortChanged;
        if (o !== null) {
          let r = true;
          s !== null && (r = s.W, s.W = true), o(this, e, n), s !== null && (s.W = r);
        }
        t !== null && (this.mo !== t && t.wb(this, n), this.Py(), this.invalidateLayout(1)), this.i("toNode", i, t), this.Ed();
      }
    }
    get toPortId() {
      return this.wo;
    }
    set toPortId(t) {
      const i = this.wo;
      if (i !== t) {
        Debug && Util.t(t, "string", _Link, "toPortId");
        const e = this.toPort;
        e !== null && this.toNode.Se(e), this.My(), this.wo = t;
        const s = this.toPort;
        s !== null && this.toNode.Se(s);
        const n = this.diagram;
        if (n !== null) {
          const o = this.data, r = n.model;
          o !== null && r.Ea() && r.setToPortIdForLinkData(o, t);
        }
        if (e !== s) {
          this.sr = null, this.invalidateRoute();
          const o = this.toPortChanged;
          if (o !== null) {
            let r = true;
            n !== null && (r = n.W, n.W = true), o(this, e, s), n !== null && (n.W = r);
          }
        }
        this.Py(), this.i("toPortId", i, t);
      }
    }
    get toPort() {
      const t = this.yo;
      if (t === null)
        return null;
      const i = this.wo;
      return t.findPort(i);
    }
    get toPortChanged() {
      return this.zd;
    }
    set toPortChanged(t) {
      const i = this.zd;
      i !== t && (t !== null && Util.t(t, "function", _Link, "toPortChanged"), this.zd = t, this.i("toPortChanged", i, t));
    }
    get fromSpot() {
      return this.$ !== null ? this.$.pa : Spot2.Default;
    }
    set fromSpot(t) {
      const i = this.fromSpot;
      if (!i.equals(t)) {
        if (Debug && Util.s(t, Spot2, _Link, "fromSpot"), t = t.L(), this.je(), this.$.pa = t, this.i("fromSpot", i, t), i.isSide() || t.isSide()) {
          const e = this.fromNode;
          e !== null && e.Se(this.fromPort);
        }
        this.invalidateRoute();
      }
    }
    get fromEndSegmentLength() {
      return this.$ !== null ? this.$.wa : NaN;
    }
    set fromEndSegmentLength(t) {
      const i = this.fromEndSegmentLength;
      i !== t && (Debug && Util.t(t, "number", _Link, "fromEndSegmentLength"), t < 0 && Util.G(t, ">= 0", _Link, "fromEndSegmentLength"), this.je(), this.$.wa = t, this.i("fromEndSegmentLength", i, t), this.invalidateRoute());
    }
    get fromShortLength() {
      return this.$ !== null ? this.$.ba : NaN;
    }
    set fromShortLength(t) {
      const i = this.fromShortLength;
      i !== t && (Debug && Util.t(t, "number", _Link, "fromShortLength"), this.je(), this.$.ba = t, this.fe(), this.i("fromShortLength", i, t));
    }
    get toSpot() {
      return this.$ !== null ? this.$.ya : Spot2.Default;
    }
    set toSpot(t) {
      const i = this.toSpot;
      if (!i.equals(t)) {
        if (Debug && Util.s(t, Spot2, _Link, "toSpot"), t = t.L(), this.je(), this.$.ya = t, this.i("toSpot", i, t), i.isSide() || t.isSide()) {
          const e = this.toNode;
          e !== null && e.Se(this.toPort);
        }
        this.invalidateRoute();
      }
    }
    get toEndSegmentLength() {
      return this.$ !== null ? this.$.xa : NaN;
    }
    set toEndSegmentLength(t) {
      const i = this.toEndSegmentLength;
      i !== t && (Debug && Util.t(t, "number", _Link, "toEndSegmentLength"), t < 0 && Util.G(t, ">= 0", _Link, "toEndSegmentLength"), this.je(), this.$.xa = t, this.i("toEndSegmentLength", i, t), this.invalidateRoute());
    }
    get toShortLength() {
      return this.$ !== null ? this.$.ka : NaN;
    }
    set toShortLength(t) {
      const i = this.toShortLength;
      i !== t && (Debug && Util.t(t, "number", _Link, "toShortLength"), this.je(), this.$.ka = t, this.fe(), this.i("toShortLength", i, t));
    }
    Ed() {
      const t = this.fromNode, i = this.toNode;
      let e = null;
      if (t !== null ? i !== null ? e = t.findCommonContainingGroup(i) : e = t.containingGroup : i !== null ? e = i.containingGroup : e = null, this.ZI(e), this.isLabeledLink) {
        const s = this.labelNodes;
        for (; s.next(); ) {
          const n = s.value;
          n.containingGroup = e;
        }
      }
    }
    ZI(t) {
      const i = this.kh;
      if (i !== t) {
        i !== null && i.Z2(this), this.kh = t, t !== null && t.$2(this);
        const e = this.containingGroupChanged;
        if (e !== null) {
          let s = true;
          const n = this.diagram;
          n !== null && (s = n.W, n.W = true), e(this, i, t), n !== null && (n.W = s);
        }
        this.Re && (this.oN === i || this.rN === i) && this.invalidateRoute();
      }
    }
    mh() {
      const t = this.containingGroup;
      t !== null && this.fromNode !== t && this.toNode !== t && t.computesBoundsIncludingLinks && super.mh();
    }
    getOtherNode(t) {
      Debug && Util.s(t, Node2, _Link, "getOtherNode:node");
      const i = this.fromNode;
      return t === i ? this.toNode : i;
    }
    getOtherPort(t) {
      Debug && Util.s(t, GraphObject2, _Link, "getOtherPort:port");
      const i = this.fromPort;
      return t === i ? this.toPort : i;
    }
    get isLabeledLink() {
      return this.Qs === null ? false : this.Qs.count > 0;
    }
    get labelNodes() {
      return this.Qs === null ? EmptyIterator.instance : this.Qs.iterator;
    }
    eT(t) {
      this.Qs === null && (this.Qs = new GSet2()), this.Qs.add(t), this.u();
    }
    sT(t) {
      this.Qs !== null && (this.Qs.remove(t), this.u());
    }
    vm(t) {
      if (super.vm(t), this.Ya() && this.invalidateOtherJumpOvers(this.actualBounds), !t) {
        const i = this.mo;
        let e = null;
        i !== null && (e = this.fromPort, i.wb(this, e));
        const s = this.yo;
        let n = null;
        s !== null && (n = this.toPort, (s !== i || n !== e) && s.wb(this, n)), this.Py();
      }
    }
    qm(t) {
      if (super.qm(t), this.Ya() && this.invalidateOtherJumpOvers(this.actualBounds), !t) {
        const i = this.mo;
        let e = null;
        i !== null && (e = this.fromPort, i.xb(this, e));
        const s = this.yo;
        let n = null;
        s !== null && (n = this.toPort, (s !== i || n !== e) && s.xb(this, n)), this.My();
      }
    }
    Wf() {
      if (this.Re = true, this.Qs !== null) {
        const i = this.diagram;
        if (i !== null) {
          const s = this.Qs.copy().iterator;
          for (; s.next(); ) {
            const n = s.value;
            i.remove(n);
          }
        }
      }
      if (this.data !== null) {
        const i = this.diagram;
        i !== null && i.partManager.fN(this);
      }
    }
    updateRelationshipsFromData() {
      if (this.data === null)
        return;
      const i = this.diagram;
      i !== null && i.partManager.updateRelationshipsFromData(this);
    }
    move(t, i) {
      const e = i ? this.location : this.position;
      let s = e.x;
      isNaN(s) && (s = 0);
      let n = e.y;
      isNaN(n) && (n = 0);
      const o = t.x - s, r = t.y - n;
      if (i === true)
        super.move(t, false);
      else {
        const h = Point2.H(e.x + o, e.y + r);
        super.move(h, false), Point2.o(h);
      }
      this.Mr(o, r);
      const l = this.labelNodes;
      for (; l.next(); ) {
        const h = l.value, a = h.position;
        h.moveTo(a.x + o, a.y + r);
      }
    }
    get relinkableFrom() {
      return (this.Dt & 1) !== 0;
    }
    set relinkableFrom(t) {
      const i = (this.Dt & 1) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Link, "relinkableFrom"), this.Dt = this.Dt ^ 1, this.i("relinkableFrom", i, t), this.invalidateAdornments());
    }
    get relinkableTo() {
      return (this.Dt & 2) !== 0;
    }
    set relinkableTo(t) {
      const i = (this.Dt & 2) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Link, "relinkableTo"), this.Dt = this.Dt ^ 2, this.i("relinkableTo", i, t), this.invalidateAdornments());
    }
    canRelinkFrom() {
      if (!this.relinkableFrom)
        return false;
      const t = this.layer;
      if (t === null)
        return true;
      if (!t.allowRelink)
        return false;
      const i = t.diagram;
      return !(i !== null && !i.allowRelink);
    }
    canRelinkTo() {
      if (!this.relinkableTo)
        return false;
      const t = this.layer;
      if (t === null)
        return true;
      if (!t.allowRelink)
        return false;
      const i = t.diagram;
      return !(i !== null && !i.allowRelink);
    }
    get resegmentable() {
      return (this.Dt & 4) !== 0;
    }
    set resegmentable(t) {
      const i = (this.Dt & 4) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Link, "resegmentable"), this.Dt = this.Dt ^ 4, this.i("resegmentable", i, t), this.invalidateAdornments());
    }
    get isTreeLink() {
      return (this.Dt & 8) !== 0;
    }
    set isTreeLink(t) {
      const i = (this.Dt & 8) !== 0;
      i !== t && (Debug && Util.t(t, "boolean", _Link, "isTreeLink"), this.Dt = this.Dt ^ 8, this.i("isTreeLink", i, t), this.fromNode !== null && this.fromNode.x0(), this.toNode !== null && this.toNode.x0());
    }
    get path() {
      const t = this.findMainElement();
      return t instanceof Shape2 ? t : null;
    }
    get routeBounds() {
      return this.updateRoute(), this.$I(this.Ac);
    }
    $I(t) {
      let i = 1 / 0, e = 1 / 0;
      const s = this.pointsCount;
      if (s === 0)
        return t.e(NaN, NaN, 0, 0), t;
      if (s === 1) {
        const n = this.getPoint(0);
        i = Math.min(n.x, i), e = Math.min(n.y, e), t.e(n.x, n.y, 0, 0);
      } else if (s === 2) {
        const n = this.getPoint(0), o = this.getPoint(1);
        i = Math.min(n.x, o.x), e = Math.min(n.y, o.y), t.e(n.x, n.y, 0, 0), t.unionPoint(o);
      } else if (this.computeCurve() === 9 && s >= 3 && !this.isOrthogonal) {
        let n = this.getPoint(0);
        if (i = n.x, e = n.y, t.e(i, e, 0, 0), s === 3) {
          const o = this.getPoint(1);
          i = Math.min(o.x, i), e = Math.min(o.y, e);
          const r = this.getPoint(2);
          i = Math.min(r.x, i), e = Math.min(r.y, e), Geo.gu(n.x, n.y, o.x, o.y, o.x, o.y, r.x, r.y, 0.5, t);
        } else
          for (let o = 3; o < s; o += 3) {
            const r = this.getPoint(o - 2);
            o + 3 >= s && (o = s - 1);
            const l = this.getPoint(o - 1), h = this.getPoint(o);
            Geo.gu(n.x, n.y, r.x, r.y, l.x, l.y, h.x, h.y, 0.5, t), i = Math.min(h.x, i), e = Math.min(h.y, e), n = h;
          }
      } else {
        const n = this.getPoint(0), o = this.getPoint(1);
        i = Math.min(n.x, o.x), e = Math.min(n.y, o.y), t.e(n.x, n.y, 0, 0), t.unionPoint(o);
        for (let r = 2; r < s; r++) {
          const l = this.getPoint(r);
          i = Math.min(l.x, i), e = Math.min(l.y, e), t.unionPoint(l);
        }
      }
      return this.bb.e(i - t.x, e - t.y), t;
    }
    get midPoint() {
      return this.updateRoute(), this.computeMidPoint(new Point2());
    }
    wL(t) {
      return this.updateRoute(), this.computeMidPoint(t);
    }
    computeMidPoint(t) {
      const i = this.pointsCount;
      if (i === 0)
        return t.c(Point2.Ek), t;
      if (i === 1)
        return t.c(this.getPoint(0)), t;
      if (i === 2) {
        const a = this.getPoint(0), f = this.getPoint(1);
        return t.e((a.x + f.x) / 2, (a.y + f.y) / 2), t;
      }
      if (this.isOrthogonal && (this.computeCorner() >= 15 || this.computeCurve() === 9)) {
        this.yt.getPointAlongPath(0.5, t), t.add(this.getPoint(0));
        const a = this.yt.figures.first();
        return t.offset(-a.startX, -a.startY), t;
      }
      if (this.computeCurve() === 9) {
        if (i === 3) {
          const c = this.getPoint(0), u = this.getPoint(1), d = this.getPoint(2);
          return Geo.mC(c.x, c.y, u.x, u.y, u.x, u.y, d.x, d.y, t), t;
        }
        const a = (i - 1) / 3 | 0, f = (a / 2 | 0) * 3;
        if (a % 2 === 1) {
          const c = this.getPoint(f), u = this.getPoint(f + 1), d = this.getPoint(f + 2), m = this.getPoint(f + 3);
          return Geo.mC(c.x, c.y, u.x, u.y, d.x, d.y, m.x, m.y, t), t;
        } else
          return t.c(this.getPoint(f)), t;
      }
      const e = this.flattenedLengths, s = this.flattenedTotalLength;
      let n = 0, o = 0, r = 0;
      for (; n < s / 2 && o < i && (r = e[o], !(n + r > s / 2)); )
        n += r, o++;
      const l = this.getPoint(o), h = this.getPoint(o + 1);
      if (Math.abs(l.x - h.x) < 1)
        l.y > h.y ? t.e(l.x, l.y - (s / 2 - n)) : t.e(l.x, l.y + (s / 2 - n));
      else if (Math.abs(l.y - h.y) < 1)
        l.x > h.x ? t.e(l.x - (s / 2 - n), l.y) : t.e(l.x + (s / 2 - n), l.y);
      else {
        const a = (s / 2 - n) / r, f = a * (h.x - l.x), c = a * (h.y - l.y);
        t.e(l.x + f, l.y + c);
      }
      return t;
    }
    get midAngle() {
      return this.updateRoute(), this.computeMidAngle();
    }
    computeMidAngle() {
      const t = this.pointsCount;
      if (t < 2)
        return NaN;
      if (t === 2) {
        const h = this.getPoint(0), a = this.getPoint(1);
        return h.directionPoint(a);
      }
      if (this.isOrthogonal && (this.computeCorner() >= 15 || this.computeCurve() === 9))
        return this.yt.getAngleAlongPath(0.5);
      if (this.computeCurve() === 9 && t >= 4) {
        const h = (t - 1) / 3 | 0;
        let a = (h / 2 | 0) * 3;
        if (h % 2 === 1) {
          a = Math.floor(a);
          const f = this.getPoint(a), c = this.getPoint(a + 1), u = this.getPoint(a + 2), d = this.getPoint(a + 3);
          return Geo.ED(f.x, f.y, c.x, c.y, u.x, u.y, d.x, d.y);
        } else if (a > 0 && a + 1 < t) {
          const f = this.getPoint(a - 1), c = this.getPoint(a + 1);
          return f.directionPoint(c);
        }
      }
      const i = this.flattenedLengths, e = this.flattenedTotalLength;
      let s = 0, n = 0, o = 0;
      for (; s < e / 2 && n < t && (o = i[n], !(s + o > e / 2)); )
        s += o, n++;
      const r = this.getPoint(n), l = this.getPoint(n + 1);
      if (Math.abs(r.x - l.x) < 1 && Math.abs(r.y - l.y) < 1) {
        if (n > 0 && n + 2 < t) {
          const h = this.getPoint(n - 1), a = this.getPoint(n + 2);
          return h.directionPoint(a);
        }
      } else {
        if (Math.abs(r.x - l.x) < 1)
          return r.y > l.y ? 270 : 90;
        if (Math.abs(r.y - l.y) < 1)
          return r.x > l.x ? 180 : 0;
      }
      return r.directionPoint(l);
    }
    QI() {
      if (this.Sy === null) {
        this.Re || this.Sb();
        const t = this.Sy = [];
        this._I(t);
      }
    }
    get flattenedLengths() {
      return this.QI(), this.Sy;
    }
    get flattenedTotalLength() {
      let t = this.kb;
      if (isNaN(t)) {
        const i = this.flattenedLengths, e = i.length;
        t = 0;
        for (let s = 0; s < e; s++)
          t += i[s];
        this.kb = t;
      }
      return t;
    }
    _I(t) {
      const i = this.pointsCount;
      for (let e = 0; e < i - 1; e++) {
        let s = 0;
        const n = this.getPoint(e), o = this.getPoint(e + 1);
        Geo.q(n.x, o.x) ? (s = o.y - n.y, s < 0 && (s = -s), t.push(s)) : Geo.q(n.y, o.y) ? (s = o.x - n.x, s < 0 && (s = -s), t.push(s)) : (s = Math.sqrt(n.distanceSquaredPoint(o)), t.push(s));
      }
    }
    get points() {
      return this.Ci;
    }
    set points(t) {
      const i = this.Ci;
      if (i === t)
        return;
      let e = null;
      if (Array.isArray(t)) {
        const n = t;
        let o = n.length % 2 === 0;
        if (o) {
          for (let r = 0; r < n.length; r++)
            if (typeof n[r] != "number" || isNaN(n[r])) {
              o = false;
              break;
            }
        }
        if (o) {
          e = new List2();
          for (let r = 0; r < n.length / 2; r++) {
            const l = new Point2(n[r * 2], n[r * 2 + 1]).w();
            e.add(l);
          }
        } else {
          let r = true;
          for (let l = 0; l < n.length; l++) {
            const h = n[l];
            if (!Util.Mt(h) || typeof h.x != "number" || isNaN(h.x) || typeof h.y != "number" || isNaN(h.y)) {
              r = false;
              break;
            }
          }
          if (r) {
            e = new List2();
            for (let l = 0; l < n.length; l++) {
              const h = n[l];
              e.add(new Point2(h.x, h.y).w());
            }
          } else
            Debug && Util.n("Link.points array must contain only an even number of numbers or objects with x and y properties, not: " + t);
        }
      } else if (t instanceof List2) {
        e = t.copy();
        const n = e.iterator;
        for (; n.next(); )
          n.value.w();
      } else
        Util.n("Link.points value is not an instance of List or Array: " + t);
      e.w(), this.Ci = e, this.fe(), this.Sb();
      const s = this.diagram;
      s !== null && (!s.Uh && !s.undoManager.isUndoingRedoing && s.Mx.add(this), s.animationManager.Mi && s.animationManager.VM(this, e)), this.i("points", i, e);
    }
    get pointsCount() {
      return this.Ci.count;
    }
    getPoint(t) {
      return this.Ci.h[t];
    }
    setPoint(t, i) {
      Debug && (Util.s(i, Point2, _Link, "setPoint"), i.isReal() || Util.n("Link.setPoint called with a Point that does not have real numbers: " + i.toString())), Debug && this.Ve === null && Util.n("Call Link.startRoute before modifying the points of the route."), this.Ci.setElt(t, i);
    }
    setPointAt(t, i, e) {
      Debug && (Util.r(i, _Link, "setPointAt:x"), Util.r(e, _Link, "setPointAt:y")), Debug && this.Ve === null && Util.n("Call Link.startRoute before modifying the points of the route."), this.Ci.setElt(t, new Point2(i, e));
    }
    insertPoint(t, i) {
      Debug && (Util.s(i, Point2, _Link, "insertPoint"), i.isReal() || Util.n("Link.insertPoint called with a Point that does not have real numbers: " + i.toString())), Debug && this.Ve === null && Util.n("Call Link.startRoute before modifying the points of the route."), this.Ci.insertAt(t, i);
    }
    insertPointAt(t, i, e) {
      Debug && (Util.r(i, _Link, "insertPointAt:x"), Util.r(e, _Link, "insertPointAt:y")), Debug && this.Ve === null && Util.n("Call Link.startRoute before modifying the points of the route."), this.Ci.insertAt(t, new Point2(i, e));
    }
    addPoint(t) {
      Debug && (Util.s(t, Point2, _Link, "addPoint"), t.isReal() || Util.n("Link.addPoint called with a Point that does not have real numbers: " + t.toString())), Debug && this.Ve === null && Util.n("Call Link.startRoute before modifying the points of the route."), this.Ci.add(t);
    }
    addPointAt(t, i) {
      Debug && (Util.r(t, _Link, "insertPointAt:x"), Util.r(i, _Link, "insertPointAt:y")), Debug && this.Ve === null && Util.n("Call Link.startRoute before modifying the points of the route."), this.Ci.add(new Point2(t, i));
    }
    removePoint(t) {
      Debug && this.Ve === null && Util.n("Call Link.startRoute before modifying the points of the route."), this.Ci.removeAt(t);
    }
    clearPoints() {
      Debug && this.Ve === null && Util.n("Call Link.startRoute before modifying the points of the route."), this.Ci.clear();
    }
    Mr(t, i) {
      if (t === 0 && i === 0)
        return;
      if (this.pointsCount === 0) {
        this.defaultFromPoint && this.defaultFromPoint.offset(t, i), this.defaultToPoint && this.defaultToPoint.offset(t, i);
        return;
      }
      const e = this.Re, s = new List2(), n = this.Ci.iterator;
      for (; n.next(); ) {
        const l = n.value;
        s.add(new Point2(l.x + t, l.y + i).w());
      }
      s.w();
      const o = this.Ci;
      this.Ci = s;
      const r = this.diagram;
      isNaN(t) || isNaN(i) || r !== null && r.animationManager.Mi ? this.u() : (this.$s.e(this.$s.x + t, this.$s.y + i), this.lt.e(this.lt.x + t, this.lt.y + i), this.rc()), e ? this.Sb() : (this.defaultFromPoint && (this.defaultFromPoint = this.getPoint(0)), this.defaultToPoint && (this.defaultToPoint = this.getPoint(this.pointsCount - 1))), r !== null && r.animationManager.Mi && r.animationManager.VM(this, s), this.i("points", o, s);
    }
    startRoute() {
      this.Ve === null && (this.Ve = this.Ci, this.Ci = this.Ci.copy());
    }
    commitRoute() {
      if (this.Ve === null)
        return;
      const t = this.Ve, i = this.Ci;
      let e = 1 / 0, s = 1 / 0;
      const n = t.h, o = n.length;
      for (let c = 0; c < o; c++) {
        const u = n[c];
        e = Math.min(u.x, e), s = Math.min(u.y, s);
      }
      let r = 1 / 0, l = 1 / 0;
      const h = i.h, a = h.length;
      for (let c = 0; c < a; c++) {
        const u = h[c];
        r = Math.min(u.x, r), l = Math.min(u.y, l), u.w();
      }
      if (i.w(), a === o)
        for (let c = 0; c < a; c++) {
          const u = n[c], d = h[c];
          if (u.x - e !== d.x - r || u.y - s !== d.y - l) {
            this.fe();
            break;
          }
        }
      else
        this.fe();
      this.Ve = null;
      const f = this.diagram;
      f !== null && f.animationManager.Mi && f.animationManager.VM(this, i), this.Sb(), this.i("points", t, i);
    }
    rollbackRoute() {
      this.Ve !== null && (this.Ci = this.Ve, this.Ve = null);
    }
    xF() {
      this.Dr !== null && (this.points = this.Dr, this.Dr = null);
    }
    Sb() {
      if (this.Ci.count === 0) {
        this.Re = false;
        return;
      }
      this.Re = true, this.Sy = null, this.kb = NaN, this.defaultFromPoint = this.getPoint(0), this.defaultToPoint = this.getPoint(this.pointsCount - 1), this.Mb(false);
    }
    invalidateRoute() {
      if (this.wn)
        return;
      const t = this.path;
      if (t === null)
        return;
      const i = this.diagram;
      if (i) {
        if (i.Mx.contains(this) || i.undoManager.isUndoingRedoing)
          return;
        const e = i.animationManager;
        if (e.isTicking && !e.isAnimating)
          return;
        this.Dr !== null && !e.isTicking && (this.Dr = null);
      }
      this.Re = false, this.u(), t.u();
    }
    get Re() {
      return (this.Dt & 16) !== 0;
    }
    set Re(t) {
      (this.Dt & 16) !== 0 !== t && (this.Dt = this.Dt ^ 16);
    }
    get wn() {
      return (this.Dt & 32) !== 0;
    }
    set wn(t) {
      (this.Dt & 32) !== 0 !== t && (this.Dt = this.Dt ^ 32);
    }
    get Ny() {
      return (this.Dt & 64) !== 0;
    }
    set Ny(t) {
      (this.Dt & 64) !== 0 !== t && (this.Dt = this.Dt ^ 64);
    }
    get cN() {
      return (this.Dt & 512) !== 0;
    }
    set cN(t) {
      (this.Dt & 512) !== 0 !== t && (this.Dt = this.Dt ^ 512);
    }
    get defaultFromPoint() {
      return this.sN;
    }
    set defaultFromPoint(t) {
      this.sN = t.copy();
    }
    get defaultToPoint() {
      return this.nN;
    }
    set defaultToPoint(t) {
      this.nN = t.copy();
    }
    updateRoute() {
      if (this.Re || this.Ny)
        return;
      let t = true;
      try {
        this.Ny = true, this.startRoute(), t = this.computePoints();
      } catch {
        this.Ny = false, this.rollbackRoute();
      } finally {
        this.Ny = false, t ? this.commitRoute() : this.rollbackRoute();
      }
    }
    computePoints() {
      const t = this.diagram;
      if (t === null)
        return false;
      let i = this.fromNode, e = null;
      if (i === null ? (_Link.Ba || (_Link.Ba = new Node2(), _Link.Ba.desiredSize = Size2.lf, _Link.Ba.ensureBounds()), this.defaultFromPoint && (_Link.Ba.location = this.defaultFromPoint, _Link.Ba.ensureBounds(), i = _Link.Ba, e = _Link.Ba)) : e = this.fromPort, e !== null && !i.isVisible()) {
        const m = i.findVisibleNode();
        m !== null && m !== i ? (i = m, e = m.port) : i = m;
      }
      if (this.oN = i, i === null || !i.location.isReal() || (e = i.findVisiblePort(e), e === null))
        return false;
      let s = this.toNode, n = null;
      if (s === null ? (_Link.za || (_Link.za = new Node2(), _Link.za.desiredSize = Size2.lf, _Link.za.ensureBounds()), this.defaultToPoint && (_Link.za.location = this.defaultToPoint, _Link.za.ensureBounds(), s = _Link.za, n = _Link.za)) : n = this.toPort, n !== null && !s.isVisible()) {
        const m = s.findVisibleNode();
        m !== null && m !== s ? (s = m, n = m.port) : s = m;
      }
      if (this.rN = s, s === null || !s.location.isReal() || (n = s.findVisiblePort(n), n === null))
        return false;
      const o = this.pointsCount, r = this.computeSpot(true, e), l = this.computeSpot(false, n), h = this.Gd(r), a = this.Gd(l), f = e === n && e !== null, c = this.isOrthogonal;
      let u = this.curve === 9;
      f && !c ? (u = true, this.sr = true) : this.sr = false;
      const d = this.computeAdjusting() === 0 || f;
      if (!c && !f && h && a) {
        let m = false;
        if (!d && o >= 3) {
          let g = this.getLinkPoint(i, e, r, true, false, s, n), p = this.getLinkPoint(s, n, l, false, false, i, e);
          m = this.adjustPoints(0, g, o - 1, p), m && (g = this.getLinkPoint(i, e, r, true, false, s, n), p = this.getLinkPoint(s, n, l, false, false, i, e), this.adjustPoints(0, g, o - 1, p));
        }
        m || (this.clearPoints(), u ? this.tO(i, e, r, s, n, l) : this.iO(i, e, r, s, n, l));
      } else {
        const m = this.isAvoiding;
        d && (c && m || f) && this.clearPoints();
        const g = f ? this.computeCurviness() : 0, p = this.getLinkPoint(i, e, r, true, c, s, n);
        let y = 0, x = 0, b = 0;
        if (c || !h || f) {
          let N = this.computeEndSegmentLength(i, e, r, true);
          if (b = this.getLinkDirection(i, e, p, r, true, c, s, n), f && (h || r.equals(l) || !c && r.x + l.x === 1 && r.y + l.y === 1) && (b -= c ? 90 : 30, g < 0 && (b -= 180)), b < 0 ? b += 360 : b >= 360 && (b -= 360), f && (N += Math.abs(g) * (c ? 1 : 2)), b === 0 ? y = N : b === 90 ? x = N : b === 180 ? y = -N : b === 270 ? x = -N : (y = N * Math.cos(b * Math.PI / 180), x = N * Math.sin(b * Math.PI / 180)), r.isNoSpot() && f) {
            const T = e.getDocumentPoint(Spot2.Center, Point2.a()), L = Point2.H(T.x + y * 1e3, T.y + x * 1e3);
            this.getLinkPointFromPoint(i, e, T, L, true, p), Point2.o(T), Point2.o(L);
          }
        }
        const k = this.getLinkPoint(s, n, l, false, c, i, e);
        let S = 0, M = 0, A = 0;
        if (c || !a || f) {
          let N = this.computeEndSegmentLength(s, n, l, false);
          if (A = this.getLinkDirection(s, n, k, l, false, c, i, e), f && (a || r.equals(l) || !c && r.x + l.x === 1 && r.y + l.y === 1) && (A += c ? 0 : 30, g < 0 && (A += 180)), A < 0 ? A += 360 : A >= 360 && (A -= 360), f && (N += Math.abs(g) * (c ? 1 : 2)), A === 0 ? S = N : A === 90 ? M = N : A === 180 ? S = -N : A === 270 ? M = -N : (S = N * Math.cos(A * Math.PI / 180), M = N * Math.sin(A * Math.PI / 180)), l.isNoSpot() && f) {
            const T = n.getDocumentPoint(Spot2.Center, Point2.a()), L = Point2.H(T.x + S * 1e3, T.y + M * 1e3);
            this.getLinkPointFromPoint(s, n, T, L, false, k), Point2.o(T), Point2.o(L);
          }
        }
        let C = p;
        (c || !h || f) && (C = new Point2(p.x + y, p.y + x));
        let P = k;
        (c || !a || f) && (P = new Point2(k.x + S, k.y + M)), !d && !c && h && o > 3 && this.adjustPoints(0, p, o - 2, P) ? this.setPoint(o - 1, k) : !d && !c && a && o > 3 && this.adjustPoints(1, C, o - 1, k) ? this.setPoint(0, p) : !d && (c ? o >= 6 : o > 4) && this.adjustPoints(1, C, o - 2, P) ? (this.setPoint(0, p), this.setPoint(o - 1, k)) : (this.clearPoints(), this.addPoint(p), (c || !h || f) && this.addPoint(C), c && this.addOrthoPoints(C, b, P, A, i, s), (c || !a || f) && this.addPoint(P), this.addPoint(k));
      }
      return t.addInvalidRoute(this), true;
    }
    uN(t, i) {
      return Math.abs(i.x - t.x) > Math.abs(i.y - t.y) ? (i.x >= t.x ? i.x = t.x + 9e9 : i.x = t.x - 9e9, i.y = t.y) : (i.y >= t.y ? i.y = t.y + 9e9 : i.y = t.y - 9e9, i.x = t.x), i;
    }
    getLinkPointFromPoint(t, i, e, s, n, o) {
      if (o === void 0 && (o = new Point2()), t === null || i === null)
        return o.c(e), o;
      if (!t.isVisible()) {
        const u = t.findVisibleNode();
        u !== null && u !== t && (t = u, i = t.port);
      }
      let r = 0, l = 0, h = 0, a = 0, f = null, c = i.panel;
      if (c !== null && !c.Mn() && (c = c.panel), c === null)
        r = s.x, l = s.y, h = e.x, a = e.y;
      else {
        f = c.Ms;
        const u = 1 / (f.m11 * f.m22 - f.m12 * f.m21), d = f.m22 * u, m = -f.m12 * u, g = -f.m21 * u, p = f.m11 * u, y = u * (f.m21 * f.dy - f.m22 * f.dx), x = u * (f.m12 * f.dx - f.m11 * f.dy);
        r = s.x * d + s.y * g + y, l = s.x * m + s.y * p + x, h = e.x * d + e.y * g + y, a = e.x * m + e.y * p + x;
      }
      return i.ec(r, l, h, a, o), f !== null && o.D(f), o;
    }
    eO(t, i) {
      const e = t.nd;
      return e !== null ? e.hT(i) : null;
    }
    Pb(t) {
      let i = t.nd;
      return i === null && (i = new Knot(), i.or = t, i.be = t.part, t.nd = i), i.hT(this);
    }
    getLinkPoint(t, i, e, s, n, o, r, l) {
      if (l === void 0 && (l = new Point2()), e.isSpot() && !this.Gd(e))
        return i.getDocumentPoint(e, l), l;
      if (e.isSide()) {
        const f = this.Pb(i);
        if (f !== null) {
          const c = f.Hd;
          if (l.c(c), n && this.routing === 7) {
            const u = this.Pb(r);
            if (u !== null && f.Lc < u.Lc) {
              const d = Point2.a(), m = Point2.a(), g = new Rect2(i.getDocumentPoint(Spot2.TopLeft, d), i.getDocumentPoint(Spot2.BottomRight, m)), p = this.computeSpot(!s, r), y = this.getLinkPoint(o, r, p, !s, n, t, i, m);
              (e.includesSide(Spot2.LeftSide) || e.includesSide(Spot2.RightSide)) && y.y >= g.y && y.y <= g.y + g.height ? l.y = y.y : (e.includesSide(Spot2.TopSide) || e.includesSide(Spot2.BottomSide)) && y.x >= g.x && y.x <= g.x + g.width && (l.x = y.x), Point2.o(d), Point2.o(m);
            }
          }
          return l;
        }
      }
      const h = i.getDocumentPoint(this.Nb(e, s), Point2.a());
      let a = null;
      if (this.pointsCount > (n ? 6 : 2))
        a = s ? this.getPoint(1) : this.getPoint(this.pointsCount - 2), n && (a = this.uN(h, a.copy()));
      else {
        const f = this.computeSpot(!s, r), c = Point2.a();
        a = r.getDocumentPoint(this.Nb(f, !s), c), n && (a = this.uN(h, a)), Point2.o(c);
      }
      return this.getLinkPointFromPoint(t, i, h, a, s, l), Point2.o(h), l;
    }
    getLinkDirection(t, i, e, s, n, o, r, l) {
      let h = this.sO(t, i, e, s, n, o, r, l);
      if (r && s.isNoSpot() && r.isMemberOf(t) && (h += 180, h >= 360 && (h -= 360)), this.Gd(s))
        return h;
      const a = i.getDocumentAngle();
      return a === 0 || (45 <= a && a < 135 ? h += 90 : 135 <= a && a < 225 ? h += 180 : 225 <= a && a < 315 && (h += 270), h >= 360 && (h -= 360)), h;
    }
    sO(t, i, e, s, n, o, r, l) {
      if (s.isSpot())
        return s.x > s.y ? s.x > 1 - s.y ? 0 : s.x < 1 - s.y ? 270 : 315 : s.x < s.y ? s.x > 1 - s.y ? 90 : s.x < 1 - s.y ? 180 : 135 : s.x < 0.5 ? 225 : s.x > 0.5 ? 45 : 0;
      if (s.isSide()) {
        const c = this.Pb(i);
        if (c !== null)
          switch (c.Me) {
            case 1:
              return 270;
            case 2:
              return 180;
            default:
            case 4:
              return 0;
            case 8:
              return 90;
          }
      }
      const h = i.getDocumentPoint(Spot2.Center, Point2.a());
      let a = null;
      if (this.pointsCount > (o ? 6 : 2))
        a = n ? this.getPoint(1) : this.getPoint(this.pointsCount - 2), o ? a = this.uN(h, a.copy()) : a = e;
      else {
        const c = Point2.a();
        a = l.getDocumentPoint(Spot2.Center, c), Point2.o(c);
      }
      let f = 0;
      return Math.abs(a.x - h.x) > Math.abs(a.y - h.y) ? a.x >= h.x ? f = 0 : f = 180 : a.y >= h.y ? f = 90 : f = 270, Point2.o(h), f;
    }
    computeEndSegmentLength(t, i, e, s) {
      if (i !== null && e.isSide()) {
        const o = this.Pb(i);
        if (o !== null)
          return o.Cb;
      }
      let n = NaN;
      return s ? n = this.fromEndSegmentLength : n = this.toEndSegmentLength, i !== null && isNaN(n) && (s ? n = i.fromEndSegmentLength : n = i.toEndSegmentLength), isNaN(n) && (n = 10), n;
    }
    computeSpot(t, i) {
      return i === void 0 && (i = null), t ? this.nO(i || this.fromPort) : this.oO(i || this.toPort);
    }
    nO(t) {
      if (t === null)
        return Spot2.Center;
      let i = this.fromSpot;
      return i.isDefault() && (i = t.fromSpot), i === Spot2.Default ? Spot2.None : i;
    }
    oO(t) {
      if (t === null)
        return Spot2.Center;
      let i = this.toSpot;
      return i.isDefault() && (i = t.toSpot), i === Spot2.Default ? Spot2.None : i;
    }
    Gd(t) {
      return t === Spot2.None || t.x === 0.5 && t.y === 0.5;
    }
    Nb(t, i) {
      return t.x === 0.5 && t.y === 0.5 ? t : Spot2.Center;
    }
    computeOtherPoint(t, i) {
      if (this.computeAdjusting() !== 0 && this.pointsCount > 4)
        return this.computeMidPoint(new Point2());
      {
        const e = this.eO(i, this);
        return e !== null ? e.Hd : i.getDocumentPoint(Spot2.Center);
      }
    }
    computeShortLength(t) {
      if (t) {
        let i = this.fromShortLength;
        if (isNaN(i)) {
          const e = this.fromPort;
          e !== null && (i = e.fromShortLength);
        }
        return isNaN(i) ? 0 : i;
      } else {
        let i = this.toShortLength;
        if (isNaN(i)) {
          const e = this.toPort;
          e !== null && (i = e.toShortLength);
        }
        return isNaN(i) ? 0 : i;
      }
    }
    Um(t, i, e, s, n, o) {
      if (this.pickable === false)
        return false;
      i === void 0 && (i = null), e === void 0 && (e = null);
      let r = o;
      if (o === void 0 && (r = Transform.a(), r.ti()), r.hf(this.D), this.containedInRect(t, r))
        return this.V2(i, e, n), o === void 0 && Transform.o(r), true;
      if (this.intersectsRect(t, r)) {
        let l = false;
        if (!this.dc) {
          const h = this.F.h, a = h.length;
          for (let f = a; f--; ) {
            const c = h[f];
            if (!c.visible && c !== this.locationObject)
              continue;
            const u = c.actualBounds, d = this.naturalBounds;
            if (u.x > d.width || u.y > d.height || u.x + u.width < 0 || u.y + u.height < 0)
              continue;
            const m = c, g = Transform.a();
            if (g.set(r), m instanceof Panel2 ? l = m.Um(t, i, e, s, n, g) : this.path === m ? m instanceof Shape2 && (l = m.AI(t, s, g)) : l = m.eL(t, s, g), l) {
              let p = m;
              i !== null && (p = i(m)), p && (e === null || e(p)) && n.add(p);
            }
            Transform.o(g);
          }
        }
        return o === void 0 && Transform.o(r), l || this.background !== null;
      }
      return o === void 0 && Transform.o(r), false;
    }
    get isOrthogonal() {
      return (this.Va & 2) === 2;
    }
    static aN(t) {
      return (t & 2) === 2;
    }
    get isAvoiding() {
      return (this.Va & 4) === 4;
    }
    computeCurve() {
      if (this.sr === null) {
        const t = this.fromPort, i = t !== null && t === this.toPort, e = this.isOrthogonal;
        this.sr = i && !e;
      }
      return this.sr ? 9 : this.curve;
    }
    computeCorner() {
      if (this.curve === 9)
        return 0;
      let t = this.corner;
      return (isNaN(t) || t < 0) && (t = 10), t;
    }
    findMidLabel() {
      const t = this.path, i = this.F.h, e = i.length;
      for (let n = 0; n < e; n++) {
        const o = i[n];
        if (!(o === t || o.isPanelMain) && (o.segmentIndex === -1 / 0 || isNaN(o.segmentIndex)))
          return o;
      }
      const s = this.labelNodes;
      for (; s.next(); ) {
        const n = s.value;
        if (n.segmentIndex === -1 / 0 || isNaN(n.segmentIndex))
          return n;
      }
      return null;
    }
    computeSpacing() {
      if (!this.isVisible())
        return 0;
      let t = _Link.JI;
      t = Math.max(t, this.computeThickness());
      const i = this.fromPort, e = this.toPort;
      if (i !== null && e !== null) {
        const s = this.findMidLabel();
        if (s !== null) {
          const n = s.naturalBounds, o = s.margin, r = isNaN(n.width) ? 30 : n.width * s.scale + o.left + o.right, l = isNaN(n.height) ? 14 : n.height * s.scale + o.top + o.bottom, h = s.segmentOrientation;
          if (h === 21 || h === 25 || h === 24)
            t = Math.max(t, l);
          else if (h === 23 || h === 27 || h === 22 || h === 26)
            t = Math.max(t, r);
          else {
            const f = i.getDocumentPoint(Spot2.Center).directionPoint(e.getDocumentPoint(Spot2.Center)) / 180 * Math.PI;
            t = Math.max(t, Math.abs(Math.sin(f) * r) + Math.abs(Math.cos(f) * l) + 1);
          }
          this.curve === 9 && (t *= 1.333);
        }
      }
      return t;
    }
    arrangeBundledLinks(t, i) {
      if (i)
        for (let e = 0; e < t.length; e++) {
          const s = t[e];
          s.computeAdjusting() === 0 && s.invalidateRoute();
        }
    }
    computeCurviness() {
      let t = this.curviness;
      if (isNaN(t)) {
        t = _Link.jI;
        const i = this.nr;
        if (i !== null) {
          const e = Util.ct();
          let s = 0;
          const n = i._s;
          for (let r = 0; r < n.length; r++) {
            const h = n[r].computeSpacing();
            e.push(h), s += h;
          }
          let o = -s / 2;
          for (let r = 0; r < n.length; r++) {
            if (n[r] === this) {
              t = o + e[r] / 2;
              break;
            }
            o += e[r];
          }
          i.uy === this.fromNode && (t = -t), Util.ot(e);
        }
      }
      return t;
    }
    computeThickness() {
      if (!this.isVisible())
        return 0;
      const t = this.path;
      return t !== null ? Math.max(t.strokeWidth, 1) : 1;
    }
    hasCurviness() {
      return !isNaN(this.curviness) || this.nr !== null;
    }
    iO(t, i, e, s, n, o) {
      const r = this.getLinkPoint(t, i, e, true, false, s, n), l = this.getLinkPoint(s, n, o, false, false, t, i);
      if (this.hasCurviness()) {
        const h = l.x - r.x, a = l.y - r.y, f = this.computeCurviness(), c = f, u = r.x + h / 2, d = r.y + a / 2;
        let m = u, g = d;
        if (Geo.p(a, 0))
          h > 0 ? g -= c : g += c;
        else {
          const p = -h / a;
          let y = Math.sqrt(c * c / (p * p + 1));
          f < 0 && (y = -y), m = (a < 0 ? -1 : 1) * y + u, g = p * (m - u) + d;
        }
        this.addPoint(r), this.addPointAt(m, g), this.addPoint(l);
      } else {
        this.addPoint(r), this.addPoint(l);
        const h = Rect2.a();
        i.getDocumentBounds(h);
        const a = h.containsPoint(l);
        n.getDocumentBounds(h);
        const f = h.containsPoint(r);
        if (a || f) {
          const c = i.getDocumentPoint(this.Nb(e, true), new Point2());
          this.setPoint(0, this.getLinkPointFromPoint(t, i, c, l, true, c));
          const u = n.getDocumentPoint(this.Nb(o, false), new Point2());
          this.setPoint(1, this.getLinkPointFromPoint(s, n, u, r, false, u));
        }
        Rect2.o(h);
      }
    }
    tO(t, i, e, s, n, o) {
      const r = this.getLinkPoint(t, i, e, true, false, s, n), l = this.getLinkPoint(s, n, o, false, false, t, i), h = l.x - r.x, a = l.y - r.y, f = this.computeCurviness();
      let c = 0, u = 0, d = r.x + h / 3, m = r.y + a / 3, g = d, p = m;
      Geo.p(a, 0) ? h > 0 ? p -= f : p += f : (c = -h / a, u = Math.sqrt(f * f / (c * c + 1)), f < 0 && (u = -u), g = (a < 0 ? -1 : 1) * u + d, p = c * (g - d) + m), d = r.x + 2 * h / 3, m = r.y + 2 * a / 3;
      let y = d, x = m;
      Geo.p(a, 0) ? h > 0 ? x -= f : x += f : (y = (a < 0 ? -1 : 1) * u + d, x = c * (y - d) + m), this.clearPoints(), this.addPoint(r), this.addPointAt(g, p), this.addPointAt(y, x), this.addPoint(l), this.setPoint(0, this.getLinkPoint(t, i, e, true, false, s, n)), this.setPoint(3, this.getLinkPoint(s, n, o, false, false, t, i));
    }
    adjustPoints(t, i, e, s) {
      let n = this.computeAdjusting();
      if (this.isOrthogonal) {
        if (n === 18)
          return false;
        n === 19 && (n = 17);
      }
      switch (n) {
        case 18:
          return this.rO(t, i, e, s);
        case 19:
          return this.lO(t, i, e, s);
        case 17:
          return this.hO(t, i, e, s);
        default:
          return false;
      }
    }
    rO(t, i, e, s) {
      const n = this.getPoint(t), o = this.getPoint(e);
      if (n.equalsApprox(i) && o.equalsApprox(s))
        return true;
      const r = n.x, l = n.y, h = o.x, a = o.y;
      let f = h - r, c = a - l;
      const u = Math.sqrt(f * f + c * c);
      if (Geo.q(u, 0))
        return true;
      let d = 0;
      Geo.q(f, 0) ? c < 0 ? d = -Math.PI / 2 : d = Math.PI / 2 : (d = Math.atan(c / Math.abs(f)), f < 0 && (d = Math.PI - d));
      const m = i.x, g = i.y, p = s.x, y = s.y, x = p - m, b = y - g, k = Math.sqrt(x * x + b * b);
      let S = 0;
      Geo.q(x, 0) ? b < 0 ? S = -Math.PI / 2 : S = Math.PI / 2 : (S = Math.atan(b / Math.abs(x)), x < 0 && (S = Math.PI - S));
      const M = k / u, A = S - d;
      this.setPoint(t, i);
      for (let C = t + 1; C < e; C++) {
        const P = this.getPoint(C);
        f = P.x - r, c = P.y - l;
        const N = Math.sqrt(f * f + c * c);
        if (Geo.q(N, 0))
          continue;
        let T = 0;
        Geo.q(f, 0) ? c < 0 ? T = -Math.PI / 2 : T = Math.PI / 2 : (T = Math.atan(c / Math.abs(f)), f < 0 && (T = Math.PI - T));
        const L = T + A, D = N * M, F = m + D * Math.cos(L), R = g + D * Math.sin(L);
        this.setPointAt(C, F, R);
      }
      return this.setPoint(e, s), true;
    }
    lO(t, i, e, s) {
      const n = this.getPoint(t), o = this.getPoint(e);
      if (n.equalsApprox(i) && o.equalsApprox(s))
        return true;
      const r = n.x, l = n.y, h = o.x, a = o.y, f = (h - r) * (h - r) + (a - l) * (a - l), c = i.x, u = i.y, d = s.x, m = s.y;
      let g = 0, p = 1;
      d - c !== 0 ? (g = (m - u) / (d - c), p = Math.sqrt(1 + 1 / (g * g))) : g = 9e9, this.setPoint(t, i);
      for (let y = t + 1; y < e; y++) {
        const x = this.getPoint(y), b = x.x, k = x.y;
        let S = 0.5;
        f !== 0 && (S = ((r - b) * (r - h) + (l - k) * (l - a)) / f);
        const M = r + S * (h - r), A = l + S * (a - l);
        let C = Math.sqrt((b - M) * (b - M) + (k - A) * (k - A));
        k < g * (b - M) + A && (C = -C), g > 0 && (C = -C);
        const P = c + S * (d - c), N = u + S * (m - u);
        if (g !== 0) {
          const T = P + C / p, L = N - (T - P) / g;
          this.setPointAt(y, T, L);
        } else
          this.setPointAt(y, P, N + C);
      }
      return this.setPoint(e, s), true;
    }
    hO(t, i, e, s) {
      if (this.isOrthogonal) {
        let n = this.getPoint(t), o = this.getPoint(t + 1), r = this.getPoint(t + 2), l = o.x, h = o.y;
        const a = l, f = h;
        Geo.p(n.y, o.y) ? Geo.p(o.x, r.x) ? h = i.y : Geo.p(o.y, r.y) && (l = i.x) : Geo.p(n.x, o.x) && (Geo.p(o.y, r.y) ? l = i.x : Geo.p(o.x, r.x) && (h = i.y)), this.setPointAt(t + 1, l, h), n = this.getPoint(e), o = this.getPoint(e - 1), r = this.getPoint(e - 2);
        let c = o.x, u = o.y;
        const d = c, m = u;
        if (Geo.p(n.y, o.y) ? Geo.p(o.x, r.x) ? u = s.y : Geo.p(o.y, r.y) && (c = s.x) : Geo.p(n.x, o.x) && (Geo.p(o.y, r.y) ? c = s.x : Geo.p(o.x, r.x) && (u = s.y)), this.setPointAt(e - 1, c, u), this.FA())
          return this.setPointAt(t + 1, a, f), this.setPointAt(e - 1, d, m), false;
      }
      return this.setPoint(t, i), this.setPoint(e, s), true;
    }
    addOrthoPoints(t, i, e, s, n, o) {
      i < 0 ? i += 360 : i >= 360 && (i -= 360), s < 0 ? s += 360 : s >= 360 && (s -= 360);
      const f = s;
      i >= 315 || i < 45 ? i = 0 : 45 <= i && i < 135 ? i = 90 : 135 <= i && i < 225 ? i = 180 : i = 270, s >= 315 || s < 45 ? s = 0 : 45 <= s && s < 135 ? s = 90 : 135 <= s && s < 225 ? s = 180 : s = 270;
      const c = t, u = e, d = n.actualBounds.copy(), m = o.actualBounds.copy();
      if (!d.isReal() || !m.isReal())
        return;
      d.inflate(_Link.Xa, _Link.Xa), m.inflate(_Link.Xa, _Link.Xa), d.unionPoint(t), m.unionPoint(e);
      const g = Point2.a(), p = Point2.a();
      i === 0 ? u.x > c.x || s === 270 && u.y < c.y && m.right > c.x || s === 90 && u.y > c.y && m.right > c.x ? (g.e(u.x, c.y), p.e(u.x, (c.y + u.y) / 2), s === 180 ? (g.x = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, false), p.x = g.x, p.y = u.y) : s === 270 && u.y < c.y || s === 90 && u.y > c.y ? (c.x < m.left ? g.x = this.computeMidOrthoPosition(c.x, c.y, m.left, u.y, false) : c.x < m.right && (s === 270 && c.y < m.top || s === 90 && c.y > m.bottom) ? g.x = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, false) : g.x = m.right, p.x = g.x, p.y = u.y) : s === 0 && c.x < m.left && c.y > m.top && c.y < m.bottom && (g.x = c.x, c.y < u.y ? g.y = Math.min(u.y, m.top) : g.y = Math.max(u.y, m.bottom), p.y = g.y)) : (g.e(c.x, u.y), p.e((c.x + u.x) / 2, u.y), (s === 180 || s === 90 && u.y < d.top || s === 270 && u.y > d.bottom) && (s === 180 && (m.containsPoint(c) || d.containsPoint(u)) ? g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, true) : u.y < c.y && (s === 180 || s === 90) ? g.y = this.computeMidOrthoPosition(c.x, d.top, u.x, Math.max(u.y, m.bottom), true) : u.y > c.y && (s === 180 || s === 270) && (g.y = this.computeMidOrthoPosition(c.x, d.bottom, u.x, Math.min(u.y, m.top), true)), p.x = u.x, p.y = g.y), g.y > d.top && g.y < d.bottom && (u.x >= d.left && u.x <= c.x || c.x <= m.right && c.x >= u.x ? (s === 90 || s === 270) && (g.e(Math.max((c.x + u.x) / 2, c.x), c.y), p.e(g.x, u.y)) : (s === 270 || (s === 0 || s === 180) && u.y < c.y ? g.y = Math.min(u.y, s === 0 ? d.top : Math.min(d.top, m.top)) : g.y = Math.max(u.y, s === 0 ? d.bottom : Math.max(d.bottom, m.bottom)), p.x = u.x, p.y = g.y))) : i === 180 ? u.x < c.x || s === 270 && u.y < c.y && m.left < c.x || s === 90 && u.y > c.y && m.left < c.x ? (g.e(u.x, c.y), p.e(u.x, (c.y + u.y) / 2), s === 0 ? (g.x = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, false), p.x = g.x, p.y = u.y) : s === 270 && u.y < c.y || s === 90 && u.y > c.y ? (c.x > m.right ? g.x = this.computeMidOrthoPosition(c.x, c.y, m.right, u.y, false) : c.x > m.left && (s === 270 && c.y < m.top || s === 90 && c.y > m.bottom) ? g.x = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, false) : g.x = m.left, p.x = g.x, p.y = u.y) : s === 180 && c.x > m.right && c.y > m.top && c.y < m.bottom && (g.x = c.x, c.y < u.y ? g.y = Math.min(u.y, m.top) : g.y = Math.max(u.y, m.bottom), p.y = g.y)) : (g.e(c.x, u.y), p.e((c.x + u.x) / 2, u.y), (s === 0 || s === 90 && u.y < d.top || s === 270 && u.y > d.bottom) && (s === 0 && (m.containsPoint(c) || d.containsPoint(u)) ? g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, true) : u.y < c.y && (s === 0 || s === 90) ? g.y = this.computeMidOrthoPosition(c.x, d.top, u.x, Math.max(u.y, m.bottom), true) : u.y > c.y && (s === 0 || s === 270) && (g.y = this.computeMidOrthoPosition(c.x, d.bottom, u.x, Math.min(u.y, m.top), true)), p.x = u.x, p.y = g.y), g.y > d.top && g.y < d.bottom && (u.x <= d.right && u.x >= c.x || c.x >= m.left && c.x <= u.x ? (s === 90 || s === 270) && (g.e(Math.min((c.x + u.x) / 2, c.x), c.y), p.e(g.x, u.y)) : (s === 270 || (s === 0 || s === 180) && u.y < c.y ? g.y = Math.min(u.y, s === 180 ? d.top : Math.min(d.top, m.top)) : g.y = Math.max(u.y, s === 180 ? d.bottom : Math.max(d.bottom, m.bottom)), p.x = u.x, p.y = g.y))) : i === 90 ? u.y > c.y || s === 180 && u.x < c.x && m.bottom > c.y || s === 0 && u.x > c.x && m.bottom > c.y ? (g.e(c.x, u.y), p.e((c.x + u.x) / 2, u.y), s === 270 ? (g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, true), p.x = u.x, p.y = g.y) : s === 180 && u.x < c.x || s === 0 && u.x > c.x ? (c.y < m.top ? g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, m.top, true) : c.y < m.bottom && (s === 180 && c.x < m.left || s === 0 && c.x > m.right) ? g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, true) : g.y = m.bottom, p.x = u.x, p.y = g.y) : s === 90 && c.y < m.top && c.x > m.left && c.x < m.right && (c.x < u.x ? g.x = Math.min(u.x, m.left) : g.x = Math.max(u.x, m.right), g.y = c.y, p.x = g.x)) : (g.e(u.x, c.y), p.e(u.x, (c.y + u.y) / 2), (s === 270 || s === 0 && u.x < d.left || s === 180 && u.x > d.right) && (s === 270 && (m.containsPoint(c) || d.containsPoint(u)) ? g.x = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, false) : u.x < c.x && (s === 270 || s === 0) ? g.x = this.computeMidOrthoPosition(d.left, c.y, Math.max(u.x, m.right), u.y, false) : u.x > c.x && (s === 270 || s === 180) && (g.x = this.computeMidOrthoPosition(d.right, c.y, Math.min(u.x, m.left), u.y, false)), p.x = g.x, p.y = u.y), g.x > d.left && g.x < d.right && (u.y >= d.top && u.y <= c.y || c.y <= m.bottom && c.y >= u.y ? (s === 0 || s === 180) && (g.e(c.x, Math.max((c.y + u.y) / 2, c.y)), p.e(u.x, g.y)) : (s === 180 || (s === 90 || s === 270) && u.x < c.x ? g.x = Math.min(u.x, s === 90 ? d.left : Math.min(d.left, m.left)) : g.x = Math.max(u.x, s === 90 ? d.right : Math.max(d.right, m.right)), p.x = g.x, p.y = u.y))) : u.y < c.y || s === 180 && u.x < c.x && m.top < c.y || s === 0 && u.x > c.x && m.top < c.y ? (g.e(c.x, u.y), p.e((c.x + u.x) / 2, u.y), s === 90 ? (g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, true), p.x = u.x, p.y = g.y) : s === 180 && u.x < c.x || s === 0 && u.x >= c.x ? (c.y > m.bottom ? g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, m.bottom, true) : c.y > m.top && (s === 180 && c.x < m.left || s === 0 && c.x > m.right) ? g.y = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, true) : g.y = m.top, p.x = u.x, p.y = g.y) : s === 270 && c.y > m.bottom && c.x > m.left && c.x < m.right && (c.x < u.x ? g.x = Math.min(u.x, m.left) : g.x = Math.max(u.x, m.right), g.y = c.y, p.x = g.x)) : (g.e(u.x, c.y), p.e(u.x, (c.y + u.y) / 2), (s === 90 || s === 0 && u.x < d.left || s === 180 && u.x > d.right) && (s === 90 && (m.containsPoint(c) || d.containsPoint(u)) ? g.x = this.computeMidOrthoPosition(c.x, c.y, u.x, u.y, false) : u.x < c.x && (s === 90 || s === 0) ? g.x = this.computeMidOrthoPosition(d.left, c.y, Math.max(u.x, m.right), u.y, false) : u.x > c.x && (s === 90 || s === 180) && (g.x = this.computeMidOrthoPosition(d.right, c.y, Math.min(u.x, m.left), u.y, false)), p.x = g.x, p.y = u.y), g.x > d.left && g.x < d.right && (u.y <= d.bottom && u.y >= c.y || c.y >= m.top && c.y <= u.y ? (s === 0 || s === 180) && (g.e(c.x, Math.min((c.y + u.y) / 2, c.y)), p.e(u.x, g.y)) : (s === 180 || (s === 90 || s === 270) && u.x < c.x ? g.x = Math.min(u.x, s === 270 ? d.left : Math.min(d.left, m.left)) : g.x = Math.max(u.x, s === 270 ? d.right : Math.max(d.right, m.right)), p.x = g.x, p.y = u.y))), this.cN = s !== f, this.lN = i, this.hN = s, this.addPoint(g.copy()), this.addPoint(p.copy()), Point2.o(g), Point2.o(p);
    }
    computeMidOrthoPosition(t, i, e, s, n) {
      let o = 0;
      return this.hasCurviness() && !this.computeSpot(true, this.fromPort).isSide() && !this.computeSpot(false, this.toPort).isSide() && (o = this.computeCurviness()), n ? (i + s) / 2 + o : (t + e) / 2 + o;
    }
    FA() {
      if (this.diagram === null || !this.isAvoiding)
        return false;
      const t = this.points.h, i = t.length;
      if (i < 4)
        return false;
      const e = this.diagram.getPositions(true, this.containingGroup, null);
      for (let s = 1; s < i - 2; s++) {
        const n = t[s], o = t[s + 1];
        if (!e.isUnoccupied(Math.min(n.x, o.x), Math.min(n.y, o.y), Math.abs(n.x - o.x), Math.abs(n.y - o.y)))
          return true;
      }
      return false;
    }
    vd(t, i, e, s, n, o) {
      const f = t.cellWidth, c = t.cellHeight;
      let u = t._i(i, e), d = i, m = e, g = d, p = m;
      for (s === 0 ? g += f : s === 90 ? p += c : s === 180 ? g -= f : p -= c, s !== o && u > PositionArray.xo && t._i(g, p) !== u - 1 && (t._i(d - f, m) === u - 1 ? (s = 180, g = d - f, p = m) : t._i(d + f, m) === u - 1 ? (s = 0, g = d + f, p = m) : t._i(d, m - c) === u - 1 ? (s = 270, g = d, p = m - c) : t._i(d, m + c) === u - 1 && (s = 90, g = d, p = m + c)); u > PositionArray.xo && t._i(g, p) === u - 1; )
        d = g, m = p, s === 0 ? g += f : s === 90 ? p += c : s === 180 ? g -= f : p -= c, u -= 1;
      if (n ? u > PositionArray.xo && (s === 180 || s === 0 ? d = Math.floor(d / f) * f + f / 2 : (s === 90 || s === 270) && (m = Math.floor(m / c) * c + c / 2)) : (d = Math.floor(d / f) * f + f / 2, m = Math.floor(m / c) * c + c / 2), u > PositionArray.xo) {
        let y = s, x = d, b = m;
        if (s === 0 ? (y = 90, b += c) : s === 90 ? (y = 180, x -= f) : s === 180 ? (y = 270, b -= c) : s === 270 && (y = 0, x += f), t._i(x, b) === u - 1)
          this.vd(t, x, b, y, false, y);
        else {
          let S = d, M = m;
          s === 0 ? (y = 270, M -= c) : s === 90 ? (y = 0, S += f) : s === 180 ? (y = 90, M += c) : s === 270 && (y = 180, S -= f), t._i(S, M) === u - 1 && this.vd(t, S, M, y, false, y);
        }
      }
      this.addPointAt(d, m);
    }
    findClosestSegment(t) {
      Debug && Util.s(t, Point2, _Link, "findClosestSegment:p");
      const i = t.x, e = t.y;
      let s = this.getPoint(0), n = this.getPoint(1), o = Point2.distanceLineSegmentSquared(i, e, s.x, s.y, n.x, n.y), r = 0;
      for (let l = 1; l < this.pointsCount - 1; l++) {
        s = this.getPoint(l + 1);
        const h = Point2.distanceLineSegmentSquared(i, e, n.x, n.y, s.x, s.y);
        n = s, h < o && (r = l, o = h);
      }
      return r;
    }
    fe() {
      this.Mh = false, this.u();
    }
    get Mh() {
      return (this.Dt & 128) !== 0;
    }
    set Mh(t) {
      (this.Dt & 128) !== 0 !== t && (this.Dt = this.Dt ^ 128);
    }
    get geometry() {
      if (!this.Mh) {
        if (this.updateRoute(), this.pointsCount < 2)
          return this.Mh = true, this.yt;
        this.yt = this.makeGeometry();
      }
      return this.yt;
    }
    pd(t) {
      if (!t) {
        if (this.Re === false)
          return;
        const n = this.findMainElement();
        if (this.Mh && (n === null || n.geometry !== null))
          return;
      }
      this.pointsCount < 2 ? this.Mh = true : this.yt = this.makeGeometry();
      const i = this.path;
      if (i === null)
        return;
      i.yt = this.yt;
      const e = this.F.h, s = e.length;
      for (let n = 0; n < s; n++) {
        const o = e[n];
        o !== i && o.isPanelMain && o instanceof Shape2 && (o.yt = this.yt);
      }
    }
    aO(t) {
      return this.Ya() && t.sh.contains(this) && (this.Ac.width !== 0 || this.Ac.height !== 0) && (t.animationManager.isAnimating || t.currentTool !== t.toolManager);
    }
    makeGeometry() {
      const t = this.yt, i = this.pointsCount;
      let e = false;
      const s = this.diagram;
      s !== null && this.aO(s) && (e = true);
      let n = 0, o = 0, r = this.getPoint(0).copy();
      const l = r.copy(), h = this.Ci.h, a = this.computeCurve();
      if (a === 9 && i >= 3 && !Geo.q(this.smoothness, 0))
        if (i === 3) {
          let f = this.getPoint(1);
          n = Math.min(r.x, f.x), o = Math.min(r.y, f.y), f = this.getPoint(2), n = Math.min(n, f.x), o = Math.min(o, f.y);
        } else if (this.isOrthogonal) {
          for (let f = 0; f < i; f++) {
            const c = h[f];
            l.x = Math.min(c.x, l.x), l.y = Math.min(c.y, l.y);
          }
          n = l.x, o = l.y;
        } else {
          for (let f = 3; f < i; f += 3) {
            f + 3 >= i && (f = i - 1);
            const c = this.getPoint(f);
            l.x = Math.min(c.x, l.x), l.y = Math.min(c.y, l.y);
          }
          n = l.x, o = l.y;
        }
      else {
        for (let f = 0; f < i; f++) {
          const c = h[f];
          l.x = Math.min(c.x, l.x), l.y = Math.min(c.y, l.y);
        }
        n = l.x, o = l.y;
      }
      if (n -= this.bb.x, o -= this.bb.y, r.x -= n, r.y -= o, i === 2 && !this.Ya()) {
        let f = this.getPoint(1).copy();
        return f.x -= n, f.y -= o, this.computeShortLength(true) !== 0 && (r = this.Tc(r, true, l)), this.computeShortLength(false) !== 0 && (f = this.Tc(f, false, l)), t.type = 1, t.startX = r.x, t.startY = r.y, t.endX = f.x, t.endY = f.y, this.Mh = true, t;
      } else {
        t.type = 4;
        const f = GeoStream.xC(t);
        if (this.computeShortLength(true) !== 0 && (r = this.Tc(r, true, l)), f.yu(r.x, r.y, false, false), a === 9 && i >= 3 && !Geo.q(this.smoothness, 0))
          if (i === 3) {
            const c = this.getPoint(1), u = c.x - n, d = c.y - o;
            let m = this.getPoint(2).copy();
            m.x -= n, m.y -= o, this.computeShortLength(false) !== 0 && (m = this.Tc(m, false, l)), f.br(u, d, u, d, m.x, m.y);
          } else if (this.isOrthogonal) {
            const c = Point2.H(n, o), u = Point2.a();
            u.c(this.getPoint(1));
            const d = Point2.H(n, o), m = Point2.H(n, o);
            let g = this.getPoint(0), p = null;
            const y = this.smoothness / 3;
            for (let S = 1; S < this.pointsCount - 1; S++) {
              p = this.getPoint(S);
              const M = g, A = p, C = this.getPoint(this.dN(p, S, false));
              Geo.q(M.x, A.x) && Geo.q(A.x, C.x) || Geo.q(M.y, A.y) && Geo.q(A.y, C.y) || (this.fO(M, A, C, y, d, m), (S === 1 || S === 2 && Geo.q(g.x, this.getPoint(0).x) && Geo.q(g.y, this.getPoint(0).y)) && (u.x = (g.x + p.x) * 0.5, u.y = (g.y + p.y) * 0.5), f.br(u.x - n, u.y - o, d.x - n, d.y - o, p.x - n, p.y - o), c.set(d), u.set(m), g = p);
            }
            let x = g.x, b = g.y, k = this.getPoint(this.pointsCount - 1);
            this.computeShortLength(false) !== 0 && (k = this.Tc(k.copy(), false, Point2.To)), x = 0.5 * (x + k.x), b = 0.5 * (b + k.y), f.br(m.x - n, m.y - o, x - n, b - o, k.x - n, k.y - o), Point2.o(c), Point2.o(u), Point2.o(d), Point2.o(m);
          } else
            for (let c = 3; c < i; c += 3) {
              const u = this.getPoint(c - 2);
              c + 3 >= i && (c = i - 1);
              const d = this.getPoint(c - 1);
              let m = this.getPoint(c);
              c === i - 1 && this.computeShortLength(false) !== 0 && (m = this.Tc(m.copy(), false, Point2.To)), f.br(u.x - n, u.y - o, d.x - n, d.y - o, m.x - n, m.y - o);
            }
        else {
          const c = Point2.a();
          c.c(this.getPoint(0));
          const u = Point2.a();
          u.c(c);
          const d = this.computeCorner();
          let m = 1, g = 0;
          for (; m < i; ) {
            m = this.dN(c, m, m > 1);
            let p = this.getPoint(m);
            if (m >= i - 1) {
              if (!c.equals(p))
                this.computeShortLength(false) !== 0 && (p = this.Tc(p.copy(), false, Point2.To)), this.Rn(f, -n, -o, c, p, e);
              else if (g === 0)
                for (m = 1; m < i; )
                  u.c(c), p = this.getPoint(m++), this.Rn(f, -n, -o, c, p, e), c.c(p);
              break;
            }
            g = this.dN(p, m + 1, m < i - 3);
            const y = this.getPoint(g);
            this.cO(f, -n, -o, c, p, y, c, u, d, e), u.c(p), m = g;
          }
          Point2.o(c);
        }
        return GeoStream.bC(f), this.Mh = true, t;
      }
    }
    Ab(t, i, e, s) {
      let n = e - t;
      if (isNaN(n) || n === 1 / 0 || n === -1 / 0)
        return NaN;
      n < 0 && (n = -n);
      let o = s - i;
      return isNaN(o) || o === 1 / 0 || o === -1 / 0 ? NaN : (o < 0 && (o = -o), Geo.q(n, 0) ? o : Geo.q(o, 0) ? n : Math.sqrt(n * n + o * o));
    }
    fO(t, i, e, s, n, o) {
      isNaN(s) && (s = this.smoothness / 3);
      const r = t.x, l = t.y, h = i.x, a = i.y, f = e.x, c = e.y, u = s * this.Ab(r, l, h, a), d = s * this.Ab(h, a, f, c);
      if (Geo.q(l, a) && Geo.q(h, f) && (h > r ? c > a ? (n.x = h - u, n.y = a - u, o.x = h + d, o.y = a + d) : (n.x = h - u, n.y = a + u, o.x = h + d, o.y = a - d) : c > a ? (n.x = h + u, n.y = a - u, o.x = h - d, o.y = a + d) : (n.x = h + u, n.y = a + u, o.x = h - d, o.y = a - d)), Geo.q(r, h) && Geo.q(a, c) && (a > l ? f > h ? (n.x = h - u, n.y = a - u, o.x = h + d, o.y = a + d) : (n.x = h + u, n.y = a - u, o.x = h - d, o.y = a + d) : f > h ? (n.x = h - u, n.y = a + u, o.x = h + d, o.y = a - d) : (n.x = h + u, n.y = a + u, o.x = h - d, o.y = a - d)), Geo.q(r, h) && Geo.q(h, f) || Geo.q(l, a) && Geo.q(a, c)) {
        const m = 0.5 * (r + f), g = 0.5 * (l + c);
        n.x = m, n.y = g, o.x = m, o.y = g;
      }
    }
    Tc(t, i, e) {
      const s = this.pointsCount;
      if (s < 2)
        return t;
      if (i) {
        const n = this.getPoint(1), o = n.x - e.x, r = n.y - e.y, l = this.Ab(t.x, t.y, o, r);
        if (l === 0)
          return t;
        const h = s === 2 ? l * 0.5 : l;
        let a = this.computeShortLength(true);
        a > h && (a = h);
        const f = a * (o - t.x) / l, c = a * (r - t.y) / l;
        t.x += f, t.y += c;
      } else {
        const n = this.getPoint(s - 2), o = n.x - e.x, r = n.y - e.y, l = this.Ab(t.x, t.y, o, r);
        if (l === 0)
          return t;
        const h = s === 2 ? l * 0.5 : l;
        let a = this.computeShortLength(false);
        a > h && (a = h);
        const f = a * (t.x - o) / l, c = a * (t.y - r) / l;
        t.x -= f, t.y -= c;
      }
      return t;
    }
    dN(t, i, e) {
      const s = this.pointsCount;
      let n = t;
      for (; Geo.q(t.x, n.x) && Geo.q(t.y, n.y); ) {
        if (i >= s)
          return s - 1;
        n = this.getPoint(i++);
      }
      if (!Geo.q(t.x, n.x) && !Geo.q(t.y, n.y))
        return i - 1;
      let o = n;
      for (; Geo.q(t.x, n.x) && Geo.q(n.x, o.x) && (!e || (t.y >= n.y ? n.y >= o.y : n.y <= o.y)) || Geo.q(t.y, n.y) && Geo.q(n.y, o.y) && (!e || (t.x >= n.x ? n.x >= o.x : n.x <= o.x)); ) {
        if (i >= s)
          return s - 1;
        o = this.getPoint(i++);
      }
      return i - 2;
    }
    cO(t, i, e, s, n, o, r, l, h, a) {
      if (Geo.p(s.y, n.y) && Geo.p(n.x, o.x)) {
        let f = Math.min(h, Math.abs(n.x - l.x) / 2);
        const c = Math.min(f, Math.abs(o.y - n.y) / 2);
        if (f = c, Geo.p(f, 0)) {
          this.Rn(t, i, e, s, n, a), r.c(n);
          return;
        }
        let u = n.x;
        const d = n.y, m = u;
        let g = d;
        n.x > s.x ? (u = n.x - f, o.y > n.y ? g = n.y + c : g = n.y - c) : (u = n.x + f, o.y > n.y ? g = n.y + c : g = n.y - c);
        const p = Point2.H(u, d);
        this.Rn(t, i, e, s, p, a), Point2.o(p), t.Dw(n.x + i, n.y + e, m + i, g + e), r.e(m, g);
      } else if (Geo.p(s.x, n.x) && Geo.p(n.y, o.y)) {
        let f = Math.min(h, Math.abs(n.y - l.y) / 2);
        const c = Math.min(f, Math.abs(o.x - n.x) / 2);
        if (f = c, Geo.p(c, 0)) {
          this.Rn(t, i, e, s, n, a), r.c(n);
          return;
        }
        const u = n.x;
        let d = n.y, m = u;
        const g = d;
        n.y > s.y ? (d = n.y - f, o.x > n.x ? m = n.x + c : m = n.x - c) : (d = n.y + f, o.x > n.x ? m = n.x + c : m = n.x - c);
        const p = Point2.H(u, d);
        this.Rn(t, i, e, s, p, a), Point2.o(p), t.Dw(n.x + i, n.y + e, m + i, g + e), r.e(m, g);
      } else
        this.Rn(t, i, e, s, n, a), r.c(n);
    }
    computeJumpLength() {
      return 10;
    }
    Rn(t, i, e, s, n, o) {
      if (o || !this.Ya())
        t.xr(n.x + i, n.y + e);
      else {
        const r = this.computeJumpLength(), l = r / 2, h = [];
        let a = 0;
        this.isVisible() && (a = this.uO(s, n, h));
        let f = s.x, c = s.y;
        if (a > 0) {
          if (Geo.p(s.y, n.y))
            if (s.x < n.x) {
              let u = 0;
              for (; u < a; ) {
                const d = Math.max(s.x, Math.min(h[u++] - l, n.x - r));
                t.xr(d + i, n.y + e), f = d + i, c = n.y + e;
                let m = Math.min(d + r, n.x);
                for (; u < a; ) {
                  const x = h[u];
                  if (x < m + r)
                    u++, m = Math.min(x + l, n.x);
                  else
                    break;
                }
                const g = n.y - r + e, p = m + i, y = n.y + e;
                this.curve === 10 ? t.yu(p, y, false, false) : t.br(f, g, p, g, p, y), f = p, c = y;
              }
            } else {
              let u = a - 1;
              for (; u >= 0; ) {
                const d = Math.min(s.x, Math.max(h[u--] + l, n.x + r));
                t.xr(d + i, n.y + e), f = d + i, c = n.y + e;
                let m = Math.max(d - r, n.x);
                for (; u >= 0; ) {
                  const x = h[u];
                  if (x > m - r)
                    u--, m = Math.max(x - l, n.x);
                  else
                    break;
                }
                const g = n.y - r + e, p = m + i, y = n.y + e;
                this.curve === 10 ? t.yu(p, y, false, false) : t.br(f, g, p, g, p, y), f = p, c = y;
              }
            }
          else if (Geo.p(s.x, n.x))
            if (s.y < n.y) {
              let u = 0;
              for (; u < a; ) {
                const d = Math.max(s.y, Math.min(h[u++] - l, n.y - r));
                t.xr(n.x + i, d + e), f = n.x + i, c = d + e;
                let m = Math.min(d + r, n.y);
                for (; u < a; ) {
                  const x = h[u];
                  if (x < m + r)
                    u++, m = Math.min(x + l, n.y);
                  else
                    break;
                }
                const g = n.x - r + i, p = n.x + i, y = m + e;
                this.curve === 10 ? t.yu(p, y, false, false) : t.br(g, c, g, y, p, y), f = p, c = y;
              }
            } else {
              let u = a - 1;
              for (; u >= 0; ) {
                const d = Math.min(s.y, Math.max(h[u--] + l, n.y + r));
                t.xr(n.x + i, d + e), f = n.x + i, c = d + e;
                let m = Math.max(d - r, n.y);
                for (; u >= 0; ) {
                  const x = h[u];
                  if (x > m - r)
                    u--, m = Math.max(x - l, n.y);
                  else
                    break;
                }
                const g = n.x - r + i, p = n.x + i, y = m + e;
                this.curve === 10 ? t.yu(p, y, false, false) : t.br(g, c, g, y, p, y), f = p, c = y;
              }
            }
        }
        t.xr(n.x + i, n.y + e);
      }
    }
    uO(t, i, e) {
      const s = this.diagram;
      if (s === null || t.equals(i))
        return 0;
      const n = s.layers;
      for (; n.next(); ) {
        const o = n.value;
        if (o !== null && o.visible) {
          const r = o.HM(), l = r.length;
          for (let h = 0; h < l; h++) {
            const a = r[h];
            if (!(a instanceof _Link))
              continue;
            if (a === this)
              return e.length > 0 && e.sort((u, d) => u - d), e.length;
            if (!a.isVisible() || !a.Ya())
              continue;
            const f = a.routeBounds;
            if (!f.isReal() || !this.routeBounds.intersectsRect(f) || this.usesSamePort(a))
              continue;
            const c = a.path;
            c !== null && c.isVisibleObject() && this.dO(t, i, e, a);
          }
        }
      }
      return e.length > 0 && e.sort((o, r) => o - r), e.length;
    }
    dO(t, i, e, s) {
      const n = Geo.p(t.y, i.y), o = s.pointsCount;
      let r = s.getPoint(0);
      const l = Point2.a();
      for (let h = 1; h < o; h++) {
        const a = s.getPoint(h);
        if (h < o - 1) {
          const f = s.getPoint(h + 1);
          if (r.y === a.y && a.y === f.y) {
            if (a.x > r.x && f.x >= a.x || a.x < r.x && f.x <= a.x)
              continue;
          } else if (r.x === a.x && a.x === f.x && (a.y > r.y && f.y >= a.y || a.y < r.y && f.y <= a.y))
            continue;
        }
        this.gO(t, i, r, a, l) && (n ? e.push(l.x) : e.push(l.y)), r = a;
      }
      Point2.o(l);
    }
    gO(t, i, e, s, n) {
      const o = t.x, r = t.y, l = i.x, h = i.y, a = e.x, f = e.y, c = s.x, u = s.y;
      if (Geo.p(o, l)) {
        if (!Geo.p(r, h) && Geo.p(f, u) && Math.min(r, h) < f && Math.max(r, h) > f && Math.min(a, c) < o && Math.max(a, c) > o && !Geo.p(a, c))
          return n.x = o, n.y = f, true;
      } else if (Geo.p(r, h) && Geo.p(a, c) && Math.min(o, l) < a && Math.max(o, l) > a && Math.min(f, u) < r && Math.max(f, u) > r && !Geo.p(f, u))
        return n.x = a, n.y = r, true;
      return n.x = 0, n.y = 0, false;
    }
    get firstPickIndex() {
      return this.pointsCount <= 2 ? 0 : this.isOrthogonal || !this.Gd(this.computeSpot(true)) ? 1 : 0;
    }
    get lastPickIndex() {
      const t = this.pointsCount;
      return t === 0 ? 0 : t <= 2 ? t - 1 : this.isOrthogonal || !this.Gd(this.computeSpot(false)) ? t - 2 : t - 1;
    }
    Ya() {
      const t = this.curve;
      return t === 11 || t === 10;
    }
    Mb(t) {
      if (t || this.Ya()) {
        const i = this.diagram;
        i !== null && !i.animationManager.isTicking && !i.sh.contains(this) && (this.Ac.width !== 0 || this.Ac.height !== 0) && i.sh.add(this, this.Ac.copy());
      }
    }
    invalidateOtherJumpOvers(t) {
      const i = this.layer;
      if (i === null || !i.visible || i.isTemporary)
        return;
      const e = i.diagram;
      if (e === null || e.animationManager.isTicking)
        return;
      let s = false;
      const n = e.layers;
      for (; n.next(); ) {
        const o = n.value;
        if (o.visible) {
          if (o === i) {
            s = true;
            let r = false;
            const l = o.HM(), h = l.length;
            for (let a = 0; a < h; a++) {
              const f = l[a];
              f instanceof _Link && (f === this ? r = true : r && this.aT(f, t));
            }
          } else if (s) {
            const r = o.HM(), l = r.length;
            for (let h = 0; h < l; h++) {
              const a = r[h];
              a instanceof _Link && this.aT(a, t);
            }
          }
        }
      }
    }
    aT(t, i) {
      if (t === null || !t.Mh || !t.Re || !t.Ya())
        return;
      const e = t.routeBounds;
      e.isReal() && (!this.routeBounds.intersectsRect(e) && !i.intersectsRect(e) || this.usesSamePort(t) || t.fe());
    }
    usesSamePort(t) {
      const i = this.pointsCount, e = t.pointsCount;
      if (i > 0 && e > 0) {
        const s = this.getPoint(0), n = t.getPoint(0);
        if (s.equalsApprox(n))
          return true;
        const o = this.getPoint(i - 1), r = t.getPoint(e - 1);
        if (o.equalsApprox(r) || s.equalsApprox(r) || o.equalsApprox(n))
          return true;
      } else if (this.fromNode === t.fromNode || this.toNode === t.toNode || this.fromNode === t.toNode || this.toNode === t.fromNode)
        return true;
      return false;
    }
    isVisible() {
      if (!super.isVisible())
        return false;
      const t = this.containingGroup;
      let i = true;
      const e = this.diagram;
      e !== null && (i = e.isTreePathToChildren);
      const s = this.fromNode;
      if (s !== null) {
        if (this.isTreeLink && i && !s.isTreeExpanded)
          return false;
        if (s === t)
          return true;
        let o = s;
        for (; o !== null; ) {
          if (o.labeledLink === this)
            return true;
          o = o.containingGroup;
        }
        const r = s.findVisibleNode();
        if (r === null || r === t)
          return false;
      }
      const n = this.toNode;
      if (n !== null) {
        if (this.isTreeLink && !i && !n.isTreeExpanded)
          return false;
        if (n === t)
          return true;
        let o = n;
        for (; o !== null; ) {
          if (o.labeledLink === this)
            return true;
          o = o.containingGroup;
        }
        const r = n.findVisibleNode();
        if (r === null || r === t)
          return false;
      }
      return true;
    }
    Ki(t) {
      if (super.Ki(t), t && this.Mb(false), this.nr !== null && this.nr.Vd(), this.Qs !== null) {
        const e = this.Qs.iterator;
        for (; e.next(); )
          e.value.Ki(t);
      }
    }
    get adjusting() {
      return this.Cc;
    }
    set adjusting(t) {
      const i = this.Cc;
      i !== t && (Debug && t !== 0 && t !== 17 && t !== 18 && t !== 19 && Util.n("Link.adjusting can only be set to None, End, Scale, or Stretch, not: " + t), this.Cc = t, this.i("adjusting", i, t));
    }
    computeAdjusting() {
      return this.isAvoiding && this.diagram !== null && this.diagram.animationManager.defaultAnimation.isAnimating ? 17 : this.Cc;
    }
    get corner() {
      return this.Xd;
    }
    set corner(t) {
      const i = this.Xd;
      i !== t && (Debug && Util.t(t, "number", _Link, "corner"), this.Xd = t, this.fe(), this.i("corner", i, t));
    }
    get curve() {
      return this.Yd;
    }
    set curve(t) {
      const i = this.Yd;
      i !== t && (Debug && t !== 0 && t !== 9 && t !== 10 && t !== 11 && Util.n("Link.curve can only be set to None, Bezier, JumpGap, or JumpOver, not: " + t), this.Yd = t, this.invalidateRoute(), this.fe(), this.Mb(i === 10 || i === 11 || t === 10 || t === 11), this.i("curve", i, t));
    }
    get curviness() {
      return this.Kd;
    }
    set curviness(t) {
      const i = this.Kd;
      i !== t && (Debug && Util.t(t, "number", _Link, "curviness"), this.Kd = t, this.invalidateRoute(), this.fe(), this.i("curviness", i, t));
    }
    get routing() {
      return this.Va;
    }
    set routing(t) {
      const i = this.Va;
      i !== t && (Debug && t !== 1 && t !== 2 && t !== 6 && t !== 7 && Util.n("Link.routing can only be set to Normal, Orthogonal, AvoidsNodes, not: " + t), this.Va = t, this.sr = null, this.invalidateRoute(), this.Mb(_Link.aN(i) || _Link.aN(t)), this.i("routing", i, t));
    }
    get smoothness() {
      return this.Ud;
    }
    set smoothness(t) {
      const i = this.Ud;
      i !== t && (Debug && Util.t(t, "number", _Link, "smoothness"), this.Ud = t, this.fe(), this.i("smoothness", i, t));
    }
    Py() {
      const t = this.mo;
      if (t === null)
        return;
      const i = this.yo;
      if (i === null || !isNaN(this.curviness))
        return;
      const e = this.po, s = this.wo;
      let n = null, o = null;
      const r = t.ni.h, l = r.length;
      for (let h = 0; h < l; h++) {
        const a = r[h];
        !(a.mo === t && a.po === e && a.yo === i && a.wo === s) && !(a.mo === i && a.po === s && a.yo === t && a.wo === e) || (o === null ? o = a : (n === null && (n = [], n.push(o)), n.push(a)));
      }
      if (n !== null) {
        let h = t.tT(i, e, s);
        h === null && (h = new LinkBundle(t, e, i, s), t.QL(h), i.QL(h)), h._s = n;
        for (let a = 0; a < n.length; a++) {
          const f = n[a];
          f.nr = h;
        }
        h.Vd();
      }
    }
    My() {
      const t = this.nr;
      if (t !== null) {
        if (!isNaN(this.curviness))
          return;
        this.nr = null;
        const i = t._s.indexOf(this);
        i >= 0 && (Util.rf(t._s, i), t.Vd());
      }
    }
    Il() {
      return true;
    }
    get key() {
      const t = this.diagram;
      if (!(t === null || !t.model.Ea()))
        return t.model.getKeyForLinkData(this.data);
    }
  };
  __publicField(_Link, "Ba", null);
  __publicField(_Link, "za", null);
  __publicField(_Link, "Normal", 1);
  __publicField(_Link, "Orthogonal", 2);
  __publicField(_Link, "AvoidsNodes", 6);
  __publicField(_Link, "AvoidsNodesStraight", 7);
  __publicField(_Link, "None", 0);
  __publicField(_Link, "Bezier", 9);
  __publicField(_Link, "JumpGap", 10);
  __publicField(_Link, "JumpOver", 11);
  __publicField(_Link, "End", 17);
  __publicField(_Link, "Scale", 18);
  __publicField(_Link, "Stretch", 19);
  __publicField(_Link, "OrientAlong", 21);
  __publicField(_Link, "OrientPlus90", 22);
  __publicField(_Link, "OrientMinus90", 23);
  __publicField(_Link, "OrientOpposite", 24);
  __publicField(_Link, "OrientUpright", 25);
  __publicField(_Link, "OrientPlus90Upright", 26);
  __publicField(_Link, "OrientMinus90Upright", 27);
  __publicField(_Link, "OrientUpright45", 28);
  __publicField(_Link, "WI", 8);
  __publicField(_Link, "jI", 16);
  __publicField(_Link, "JI", 14);
  __publicField(_Link, "Xa", 8);
  let Link2 = _Link;
  class LinkBundle {
    constructor(t, i, e, s) {
      __publicField(this, "Go");
      __publicField(this, "Ks");
      __publicField(this, "uy");
      __publicField(this, "iN");
      __publicField(this, "yb");
      __publicField(this, "eN");
      __publicField(this, "_s");
      GSet2.ji(this), this.Go = false, this.Ks = false, this.uy = t, this.iN = i, this.yb = e, this.eN = s, this._s = [];
    }
    Vd() {
      if (!this.Go) {
        const t = this._s;
        if (t.length > 0) {
          const i = t[0].diagram;
          i !== null && (i.uP.add(this), this.Ks = i.undoManager.isUndoingRedoing);
        }
      }
      this.Go = true;
    }
    NP() {
      if (this.Go) {
        this.Go = false;
        const t = this._s;
        if (t.length > 0) {
          const i = t[0], e = i.diagram, s = e === null || e.Uh && !this.Ks;
          this.Ks = false, i.arrangeBundledLinks(t, s), t.length === 1 && (i.nr = null, t.length = 0);
        }
        t.length === 0 && (this.uy._L(this), this.yb._L(this));
      }
    }
  }
  const _PositionArray = class _PositionArray {
    constructor(t) {
      __publicField(this, "de");
      __publicField(this, "ge");
      __publicField(this, "Ka");
      __publicField(this, "Ua");
      __publicField(this, "ki");
      __publicField(this, "Si");
      __publicField(this, "Yt");
      __publicField(this, "Ph");
      __publicField(this, "Nh");
      __publicField(this, "da");
      __publicField(this, "BP");
      __publicField(this, "Go");
      __publicField(this, "Cy");
      __publicField(this, "Jf");
      __publicField(this, "zP");
      __publicField(this, "XP");
      GSet2.ji(this), this.da = null, this.BP = null, this.Go = true, this.Cy = false, this.de = 1, this.ge = 1, this.Ka = -1, this.Ua = -1, this.ki = t.width, this.Si = t.height, this.Yt = null, this.Ph = 0, this.Nh = 0, this.Jf = 11, this.zP = this.Jf * 2, this.XP = this.Jf * 2;
    }
    R1(t) {
      if (t.width <= 0 || t.height <= 0)
        return;
      const i = t.x, e = t.y, s = t.x + t.width, n = t.y + t.height;
      this.de = Math.floor((i - this.ki) / this.ki) * this.ki, this.ge = Math.floor((e - this.Si) / this.Si) * this.Si, this.Ka = Math.ceil((s + 2 * this.ki) / this.ki) * this.ki, this.Ua = Math.ceil((n + 2 * this.Si) / this.Si) * this.Si;
      const o = 1 + (Math.ceil((this.Ka - this.de) / this.ki) | 0), r = 1 + (Math.ceil((this.Ua - this.ge) / this.Si) | 0);
      if (this.Yt === null || this.Ph < o - 1 || this.Nh < r - 1) {
        const l = [];
        for (let h = 0; h <= o; h++)
          l[h] = new Uint32Array(r);
        this.Yt = l, this.Ph = o - 1, this.Nh = r - 1;
      }
      this.mO(_PositionArray.gN);
    }
    get bounds() {
      return new Rect2(this.de, this.ge, this.Ka - this.de, this.Ua - this.ge);
    }
    get cellWidth() {
      return this.ki;
    }
    set cellWidth(t) {
      t > 0 && t !== this.ki && (this.ki = t, this.R1(this.bounds));
    }
    get cellHeight() {
      return this.Si;
    }
    set cellHeight(t) {
      t > 0 && t !== this.Si && (this.Si = t, this.R1(this.bounds));
    }
    Wd(t, i) {
      return this.de <= t && t <= this.Ka && this.ge <= i && i <= this.Ua;
    }
    _i(t, i) {
      if (!this.Wd(t, i))
        return _PositionArray.gN;
      t -= this.de, t /= this.ki, i -= this.ge, i /= this.Si;
      const e = t | 0, s = i | 0;
      return this.Yt[e][s];
    }
    PR(t, i, e, s) {
      if (!this.Wd(t, i))
        return;
      const n = (t - this.de) / this.ki | 0, o = (i - this.ge) / this.Si | 0, r = (t + e - this.de) / this.ki | 0, l = (i + s - this.ge) / this.Si | 0, h = Math.min(r, this.Ph), a = Math.min(l, this.Nh);
      for (let f = n; f <= h; f++) {
        const c = this.Yt[f];
        if (c.fill)
          c.fill(_PositionArray.tn, o, a + 1);
        else
          for (let u = o; u <= a; u++)
            c[u] = _PositionArray.tn;
      }
    }
    mO(t) {
      if (this.Yt !== null)
        for (let i = 0; i <= this.Ph; i++) {
          const e = this.Yt[i];
          if (e.fill)
            e.fill(t);
          else
            for (let s = 0; s <= this.Nh; s++)
              e[s] = t;
        }
    }
    GA() {
      if (this.Yt !== null)
        for (let t = 0; t <= this.Ph; t++) {
          const i = this.Yt[t];
          for (let e = 0; e <= this.Nh; e++)
            i[e] >= _PositionArray.xo && (i[e] = _PositionArray.gN);
        }
    }
    pO(t, i) {
      return this._i(t, i) === _PositionArray.tn;
    }
    isUnoccupied(t, i, e, s) {
      if (t > this.Ka || t + e < this.de || i > this.Ua || i + s < this.ge)
        return true;
      let n = (t - this.de) / this.ki | 0, o = (i - this.ge) / this.Si | 0, r = Math.max(0, e) / this.ki + 1 | 0, l = Math.max(0, s) / this.Si + 1 | 0;
      if (n < 0 && (r += n, n = 0), o < 0 && (l += o, o = 0), r < 0 || l < 0)
        return true;
      const h = Math.min(n + r - 1, this.Ph) | 0, a = Math.min(o + l - 1, this.Nh) | 0;
      for (let f = n; f <= h; f++) {
        const c = this.Yt[f];
        for (let u = o; u <= a; u++)
          if (c[u] === _PositionArray.tn)
            return false;
      }
      return true;
    }
    maxUnoccupiedH(t, i, e, s) {
      if (t > this.Ka || i < this.de || e > this.Ua || e < this.ge)
        return 0;
      const n = (t - this.de) / this.ki | 0, o = (i - this.de) / this.ki | 0, r = (e - this.ge) / this.Si | 0, l = s / this.Si + 1 | 0;
      let h;
      for (h = 0; h < l / 2; h++) {
        let a = false;
        for (let f = n; f <= o; f++)
          if (this.Yt[f][r + h] === _PositionArray.tn || this.Yt[f][r - h] === _PositionArray.tn) {
            a = true;
            break;
          }
        if (a)
          return Math.max(0, (2 * h - 1) * this.Si);
      }
      return s;
    }
    maxUnoccupiedV(t, i, e, s) {
      if (t > this.Ua || i < this.ge || e > this.Ka || e < this.de)
        return 0;
      const n = (t - this.ge) / this.Si | 0, o = (i - this.ge) / this.Si | 0, r = (e - this.de) / this.ki | 0, l = s / this.ki + 1 | 0;
      let h;
      for (h = 0; h < l / 2; h++) {
        let a = false;
        for (let f = n; f <= o; f++)
          if (this.Yt[r + h][f] === _PositionArray.tn || this.Yt[r - h][f] === _PositionArray.tn) {
            a = true;
            break;
          }
        if (a)
          return Math.max(0, (2 * h - 1) * this.ki);
      }
      return s;
    }
    yO(t, i, e, s, n, o, r, l) {
      t = t | 0, i = i | 0;
      let h = this.Yt[t][i];
      if (h >= _PositionArray.xo && h < _PositionArray.qd)
        for (s ? i += e : t += e, h += 1; n <= t && t <= o && r <= i && i <= l; ) {
          const a = this.Yt[t][i];
          if (h >= a)
            break;
          this.Yt[t][i] = h, h += 1, s ? i += e : t += e;
        }
      return s ? i : t;
    }
    bo(t, i, e, s, n, o, r, l) {
      if (t < n || t > o || i < r || i > l)
        return;
      const h = this.yO(t, i, e, s, n, o, r, l);
      if (s)
        if (e > 0)
          for (let a = i + e; a < h; a += e)
            this.bo(t, a, 1, !s, n, o, r, l), this.bo(t, a, -1, !s, n, o, r, l);
        else
          for (let a = i + e; a > h; a += e)
            this.bo(t, a, 1, !s, n, o, r, l), this.bo(t, a, -1, !s, n, o, r, l);
      else if (e > 0)
        for (let a = t + e; a < h; a += e)
          this.bo(a, i, 1, !s, n, o, r, l), this.bo(a, i, -1, !s, n, o, r, l);
      else
        for (let a = t + e; a > h; a += e)
          this.bo(a, i, 1, !s, n, o, r, l), this.bo(a, i, -1, !s, n, o, r, l);
    }
    Lb(t, i, e, s, n, o, r, l, h, a) {
      let f = t | 0, c = i | 0, u = _PositionArray.tn, d = _PositionArray.xo;
      for (this.Yt[f][c] = d; u === _PositionArray.tn && f > r && f < l && c > h && c < a; )
        d += 1, this.Yt[f][c] = d, o ? c += n : f += n, u = this.Yt[f][c];
      return o ? c : f;
    }
    Tb(t, i, e, s, n, o, r, l, h, a) {
      let f = e | 0, c = s | 0, u = _PositionArray.tn;
      const d = _PositionArray.qd;
      for (this.Yt[f][c] = d; u === _PositionArray.tn && f > r && f < l && c > h && c < a; )
        this.Yt[f][c] = d, o ? c += n : f += n, u = this.Yt[f][c];
    }
    fT(t, i, e, s, n, o) {
      if (this.Yt === null)
        return;
      this.Cy = false;
      let r = t.x, l = t.y;
      if (!this.Wd(r, l))
        return;
      r -= this.de, r /= this.ki, l -= this.ge, l /= this.Si;
      let h = e.x, a = e.y;
      if (!this.Wd(h, a))
        return;
      if (h -= this.de, h /= this.ki, a -= this.ge, a /= this.Si, Math.abs(r - h) <= 1 && Math.abs(l - a) <= 1) {
        this.Cy = true;
        return;
      }
      let f = n.x, c = n.y, u = n.x + n.width, d = n.y + n.height;
      f -= this.de, f /= this.ki, c -= this.ge, c /= this.Si, u -= this.de, u /= this.ki, d -= this.ge, d /= this.Si;
      const m = Math.max(0, Math.min(this.Ph, f | 0)), g = Math.min(this.Ph, Math.max(0, u | 0)), p = Math.max(0, Math.min(this.Nh, c | 0)), y = Math.min(this.Nh, Math.max(0, d | 0)), x = 0, b = 90, k = 270, S = this.Yt, M = r | 0, A = l | 0, C = h | 0, P = a | 0, N = i === x || i === b ? 1 : -1, T = i === b || i === k;
      S[M][A] === _PositionArray.tn ? (this.Lb(M, A, C, P, N, T, m, g, p, y), this.Lb(M, A, C, P, 1, !T, m, g, p, y), this.Lb(M, A, C, P, -1, !T, m, g, p, y)) : this.Lb(M, A, C, P, N, T, M, A, M, A), S[C][P] === _PositionArray.tn ? (this.Tb(M, A, C, P, s === x || s === b ? 1 : -1, s === b || s === k, m, g, p, y), this.Tb(M, A, C, P, 1, !(s === b || s === k), m, g, p, y), this.Tb(M, A, C, P, -1, !(s === b || s === k), m, g, p, y)) : this.Tb(M, A, C, P, N, T, C, P, C, P);
      const L = Util.ct();
      if (o && this.cT(C, P, s, M, A, L)) {
        (L[0] !== C || L[1] !== P) && (L.unshift(P), L.unshift(C)), (L[L.length - 2] !== M || L[L.length - 1] !== A) && (L.push(M), L.push(A));
        let D = _PositionArray.xo, F = L[L.length - 2], R = L[L.length - 1];
        S[F][R] = D++;
        for (let I = L.length - 4; I >= 0; I -= 2) {
          F = L[I + 2], R = L[I + 3];
          const O = L[I], B = L[I + 1];
          for (; O > F ? F++ : O < F ? F-- : B > R ? R++ : B < R && R--, S[F][R] = D++, !(F === O && R === B); )
            ;
        }
      } else
        this.bo(M, A, 1, false, m, g, p, y), this.bo(M, A, -1, false, m, g, p, y), this.bo(M, A, 1, true, m, g, p, y), this.bo(M, A, -1, true, m, g, p, y);
      Util.ot(L);
    }
    cT(t, i, e, s, n, o) {
      const f = this.Yt;
      let c = t, u = i;
      for (; ; ) {
        if (c === s && u === n)
          return true;
        let d = c, m = u;
        if (e === 0)
          if (d < s)
            d++;
          else
            break;
        else if (e === 90)
          if (m < n)
            m++;
          else
            break;
        else if (e === 180)
          if (d > s)
            d--;
          else
            break;
        else if (m > n)
          m--;
        else
          break;
        const g = f[d][m];
        if (g === 0 || g === _PositionArray.mN)
          break;
        c = d, u = m;
      }
      for (; ; ) {
        let d = e, m = c, g = u;
        e === 0 ? g < n ? (d = 90, g++) : g > n && (d = 270, g--) : e === 90 ? m < s ? (d = 0, m++) : m > s && (d = 180, m--) : e === 180 ? g < n ? (d = 90, g++) : g > n && (d = 270, g--) : m < s ? (d = 0, m++) : m > s && (d = 180, m--);
        const p = f[m][g];
        if (d !== e && p !== 0 && p !== _PositionArray.mN) {
          if (o.push(c), o.push(u), this.cT(c, u, d, s, n, o))
            return true;
          o.pop(), o.pop();
        }
        if (f[c][u] = _PositionArray.mN, e === 0) {
          if (c === t)
            return false;
          c--;
        } else if (e === 90) {
          if (u === i)
            return false;
          u--;
        } else if (e === 180) {
          if (c === t)
            return false;
          c++;
        } else {
          if (u === i)
            return false;
          u++;
        }
      }
    }
  };
  __publicField(_PositionArray, "tn", 0);
  __publicField(_PositionArray, "xo", 1);
  __publicField(_PositionArray, "qd", 999999);
  __publicField(_PositionArray, "gN", _PositionArray.qd + 1);
  __publicField(_PositionArray, "mN", _PositionArray.qd + 2);
  let PositionArray = _PositionArray;
  class Knot {
    constructor() {
      __publicField(this, "be");
      __publicField(this, "or");
      __publicField(this, "ds");
      __publicField(this, "jd");
      GSet2.ji(this), this.be = null, this.or = null, this.ds = [], this.jd = false;
    }
    toString() {
      const t = this.ds;
      let i = this.be.toString() + " " + t.length.toString() + ":";
      for (let e = 0; e < t.length; e++) {
        const s = t[e];
        s !== null && (i += `
  ` + s.toString());
      }
      return i;
    }
    wO(t, i, e, s) {
      const n = i.offsetY;
      switch (n) {
        case 8:
          return 90;
        case 2:
          return 180;
        case 1:
          return 270;
        case 4:
          return 0;
      }
      let o = e;
      switch (n) {
        case 9:
          return o > 180 ? 270 : 90;
        case 6:
          return o > 90 && o <= 270 ? 180 : 0;
      }
      const r = Math.atan2(t.height, t.width) * 180 / Math.PI;
      switch (n) {
        case 3:
          return o > r && o <= 180 + r ? 180 : 270;
        case 5:
          return o > 180 - r && o <= 360 - r ? 270 : 0;
        case 12:
          return o > r && o <= 180 + r ? 90 : 0;
        case 10:
          return o > 180 - r && o <= 360 - r ? 180 : 90;
        case 7:
          return o > 90 && o <= 180 + r ? 180 : o > 180 + r && o <= 360 - r ? 270 : 0;
        case 13:
          return o > 180 && o <= 360 - r ? 270 : o > r && o <= 180 ? 90 : 0;
        case 14:
          return o > r && o <= 180 - r ? 90 : o > 180 - r && o <= 270 ? 180 : 0;
        case 11:
          return o > 180 - r && o <= 180 + r ? 180 : o > 180 + r ? 270 : 90;
      }
      return s && n !== 15 && (o -= 15, o < 0 && (o += 360)), o > r && o < 180 - r ? 90 : o >= 180 - r && o <= 180 + r ? 180 : o > 180 + r && o < 360 - r ? 270 : 0;
    }
    Vd() {
      this.ds.length = 0;
    }
    hT(t) {
      let i = this.ds;
      i.length === 0 && (this.xO(), i = this.ds);
      for (let e = 0; e < i.length; e++) {
        const s = i[e];
        if (s !== null && s._e === t)
          return s;
      }
      return null;
    }
    xO() {
      if (!this.jd) {
        const t = this.jd;
        this.jd = true;
        let i, e = null;
        const s = this.be, n = s instanceof Group2 ? s : null;
        if (n !== null && !n.isSubGraphExpanded) {
          if (!n.actualBounds.isReal())
            return this.jd = t, this.ds;
          e = n, i = e.findExternalLinksConnected();
        } else
          s.isTreeExpanded ? i = s.findLinksConnected(this.or.portId) : i = s.findExternalTreeLinksConnected();
        this.ds.length = 0;
        let o = 0;
        const r = this.or.getDocumentPoint(Spot2.TopLeft, Point2.a()), l = this.or.getDocumentPoint(Spot2.BottomRight, Point2.a()), h = Rect2.H(r.x, r.y, 0, 0);
        h.unionPoint(l), Point2.o(r), Point2.o(l);
        const a = Point2.H(h.x + h.width / 2, h.y + h.height / 2), f = this.or.getDocumentAngle(), c = i.iterator;
        for (; c.next(); ) {
          const g = c.value;
          if (!g.isVisible() || g.fromPort === g.toPort)
            continue;
          const p = g.fromPort === this.or || g.fromNode !== null && g.fromNode.isMemberOf(e), y = g.computeSpot(p, this.or);
          if (!y.isSide())
            continue;
          let x;
          if (p ? x = g.toPort : x = g.fromPort, x === null)
            continue;
          let b = x.part;
          if (b === null)
            continue;
          const k = b.findVisibleNode();
          k !== null && k !== b && (b = k, x = b.port);
          const S = g.computeOtherPoint(b, x);
          let M = a.directionPoint(S);
          M -= f, M < 0 ? M += 360 : M >= 360 && (M -= 360);
          const A = this.wO(h, y, M, g.isOrthogonal);
          let C = 0;
          A === 0 ? (C = 4, M > 180 && (M -= 360)) : A === 90 ? (C = 8, M > 270 && (M -= 360)) : A === 180 ? C = 2 : (C = 1, M < 90 && (M += 360));
          let P = this.ds[o];
          P === void 0 ? (P = new LinkInfo(g, M, C), this.ds[o] = P) : (P._e = g, P.qt = M, P.Me = C), P.Db.set(S), o++;
        }
        Point2.o(a), this.bO();
        const u = this.ds.length;
        let d = -1, m = 0;
        for (o = 0; o < u; o++) {
          const g = this.ds[o];
          g !== void 0 && (g.Me !== d && (d = g.Me, m = 0), g.Jd = m, m++);
        }
        for (d = -1, m = 0, o = u - 1; o >= 0; o--) {
          const g = this.ds[o];
          g !== void 0 && (g.Me !== d && (d = g.Me, m = g.Jd + 1), g.Lc = m);
        }
        this.kO(this.ds), this.SO(this.ds), this.jd = t, Rect2.o(h);
      }
      return this.ds;
    }
    MO(t, i) {
      return t === i ? 0 : t === null ? -1 : i === null ? 1 : t.Me < i.Me ? -1 : t.Me > i.Me ? 1 : t.qt < i.qt ? -1 : t.qt > i.qt ? 1 : 0;
    }
    bO() {
      this.ds.sort(Knot.prototype.MO);
    }
    kO(t) {
      const i = this.or, e = this.be.portSpreading, s = Point2.a(), n = Point2.a(), o = Point2.a(), r = Point2.a();
      i.getDocumentPoint(Spot2.TopLeft, s), i.getDocumentPoint(Spot2.TopRight, n), i.getDocumentPoint(Spot2.BottomRight, o), i.getDocumentPoint(Spot2.BottomLeft, r);
      let l = 0, h = 0, a = 0, f = 0;
      if (e === 2)
        for (let x = 0; x < t.length; x++) {
          const b = t[x];
          if (b === null)
            continue;
          const k = b._e.computeThickness();
          switch (b.Me) {
            case 8:
              a += k;
              break;
            case 2:
              f += k;
              break;
            case 1:
              l += k;
              break;
            default:
            case 4:
              h += k;
              break;
          }
        }
      let c = 0, u = 0, d = 1, m, g, p = 0, y = 0;
      for (let x = 0; x < t.length; x++) {
        const b = t[x];
        if (b === null)
          continue;
        if (c !== b.Me) {
          switch (c = b.Me, c) {
            case 8:
              m = o, g = r;
              break;
            case 2:
              m = r, g = s;
              break;
            case 1:
              m = s, g = n;
              break;
            default:
            case 4:
              m = n, g = o;
              break;
          }
          switch (p = g.x - m.x, y = g.y - m.y, c) {
            case 8:
              a > Math.abs(p) ? (d = Math.abs(p) / a, a = Math.abs(p)) : d = 1;
              break;
            case 2:
              f > Math.abs(y) ? (d = Math.abs(y) / f, f = Math.abs(y)) : d = 1;
              break;
            case 1:
              l > Math.abs(p) ? (d = Math.abs(p) / l, l = Math.abs(p)) : d = 1;
              break;
            default:
            case 4:
              h > Math.abs(y) ? (d = Math.abs(y) / h, h = Math.abs(y)) : d = 1;
              break;
          }
          u = 0;
        }
        const k = b.Hd;
        if (e === 2) {
          let S = b._e.computeThickness();
          switch (S *= d, k.set(m), c) {
            case 8:
              k.x = m.x + p / 2 + a / 2 - u - S / 2;
              break;
            case 2:
              k.y = m.y + y / 2 + f / 2 - u - S / 2;
              break;
            case 1:
              k.x = m.x + p / 2 - l / 2 + u + S / 2;
              break;
            default:
            case 4:
              k.y = m.y + y / 2 - h / 2 + u + S / 2;
              break;
          }
          u += S;
        } else {
          let S = 0.5;
          e === 1 && (S = (b.Jd + 1) / (b.Lc + 1)), k.x = m.x + p * S, k.y = m.y + y * S;
        }
      }
      Point2.o(s), Point2.o(n), Point2.o(o), Point2.o(r);
    }
    SO(t) {
      for (let i = 0; i < t.length; i++) {
        const e = t[i];
        e !== null && (e.Cb = this.PO(e));
      }
    }
    PO(t) {
      const i = t._e, e = i.fromPort === this.or, s = i.computeEndSegmentLength(this.be, this.or, Spot2.None, e);
      let n = t.Jd;
      if (n < 0)
        return s;
      const o = t.Lc;
      if (o <= 1 || !i.isOrthogonal)
        return s;
      const l = t.Db, h = t.Hd;
      (t.Me === 2 || t.Me === 8) && (n = o - 1 - n);
      const a = Link2.WI, f = t.Me === 2 || t.Me === 4;
      return (f ? l.y < h.y : l.x < h.x) ? s + n * a : (f ? l.y === h.y : l.x === h.x) ? s : s + (o - 1 - n) * a;
    }
  }
  class LinkInfo {
    constructor(t, i, e) {
      __publicField(this, "_e");
      __publicField(this, "qt");
      __publicField(this, "Me");
      __publicField(this, "Db");
      __publicField(this, "Jd");
      __publicField(this, "Lc");
      __publicField(this, "Hd");
      __publicField(this, "Cb");
      this._e = t, this.qt = i, this.Me = e, this.Db = new Point2(), this.Jd = 0, this.Lc = 0, this.Hd = new Point2(), this.Cb = 0;
    }
    toString() {
      return this._e.toString() + " " + this.qt.toString() + " " + this.Me.toString() + ":" + this.Jd.toString() + "/" + this.Lc.toString() + " " + this.Hd.toString() + " " + this.Cb.toString() + " " + this.Db.toString();
    }
  }
  class LinkSettings {
    constructor() {
      __publicField(this, "pa");
      __publicField(this, "ya");
      __publicField(this, "wa");
      __publicField(this, "xa");
      __publicField(this, "ba");
      __publicField(this, "ka");
      __publicField(this, "U0");
      __publicField(this, "Y0");
      __publicField(this, "G0");
      __publicField(this, "K0");
      this.pa = Spot2.Default, this.ya = Spot2.Default, this.wa = NaN, this.xa = NaN, this.ba = NaN, this.ka = NaN, this.U0 = null, this.Y0 = null, this.G0 = 1 / 0, this.K0 = 1 / 0;
    }
    copy() {
      const t = new LinkSettings();
      return t.pa = this.pa.L(), t.ya = this.ya.L(), t.wa = this.wa, t.xa = this.xa, t.ba = this.ba, t.ka = this.ka, t.U0 = this.U0, t.Y0 = this.Y0, t.G0 = this.G0, t.K0 = this.K0, t;
    }
  }
  class LinkElementSettings {
    constructor() {
      __publicField(this, "I0");
      __publicField(this, "O0");
      __publicField(this, "E0");
      __publicField(this, "R0");
      __publicField(this, "Cp");
      __publicField(this, "Ap");
      this.I0 = -1 / 0, this.O0 = 0, this.E0 = Point2.To, this.R0 = 0, this.Cp = "None", this.Ap = "None";
    }
    copy() {
      const t = new LinkElementSettings();
      return t.I0 = this.I0, t.O0 = this.O0, t.E0 = this.E0.L(), t.R0 = this.R0, t.Cp = this.Cp, t.Ap = this.Ap, t;
    }
  }
  class Group2 extends Node2 {
    constructor(t, i) {
      var __super = (...args5) => {
        super(...args5);
        __publicField(this, "Zd");
        __publicField(this, "Et");
        __publicField(this, "ua");
        __publicField(this, "b0");
        __publicField(this, "hi");
        __publicField(this, "le");
        return this;
      };
      t === void 0 || t instanceof PanelLayout2 || typeof t == "number" || typeof t == "string" ? __super(t) : (__super(), t && (i = t)), this.z = this.z | 4608, this.Zd = new GSet2(), this.Et = null, this.le = new Layout2(), this.le.group = this, this.ua = new GSet2(), this.b0 = null, this.hi = null, i && Object.assign(this, i);
    }
    cloneProtected(t) {
      super.cloneProtected(t), this.z = this.z & -32769;
      const i = t.findInVisualTree((e) => e instanceof Placeholder2);
      i instanceof Placeholder2 ? t.Et = i : t.Et = null, this.le !== null ? (t.le = this.le.copy(), t.le.group = t) : (t.le !== null && (t.le.group = null), t.le = null), this.hi !== null && (t.hi = this.hi.copy());
    }
    qo(t) {
      super.qo(t);
      const i = t.findSubGraphParts(), e = t.memberParts;
      for (; e.next(); ) {
        const s = e.value;
        if (s.u(), s.invalidateLayout(8), s.clearAdornments(), s instanceof Node2)
          s.invalidateConnectedLinks(i);
        else if (s instanceof Link2) {
          const n = s.labelNodes;
          for (; n.next(); )
            n.value.invalidateConnectedLinks(i);
        }
      }
    }
    tc(t, i, e, s, n, o, r) {
      if (t === 3 && i === "elements") {
        if (n instanceof Placeholder2)
          this.Et === null ? this.Et = n : this.Et !== n && Util.n("Cannot insert a second Placeholder into the visual tree of a Group.");
        else if (n instanceof Panel2) {
          const l = n.findInVisualTree((h) => h instanceof Placeholder2);
          l instanceof Placeholder2 && (this.Et === null ? this.Et = l : this.Et !== l && Util.n("Cannot insert a second Placeholder into the visual tree of a Group."));
        }
      } else
        t === 4 && i === "elements" && this.Et !== null && (s === this.Et ? this.Et = null : s instanceof Panel2 && this.Et.isContainedBy(s) && (this.Et = null));
      super.tc(t, i, e, s, n, o, r);
    }
    ad(t, i) {
      if (super.ad(t, i), this.isClipping && this.type !== Panel2.Spot && this.isSubGraphExpanded) {
        let e = this.resizeObject;
        e instanceof Panel2 && (e = e.findMainElement()), this.hi === null && (this.hi = new Rect2()), e.getDocumentBounds(this.hi), e instanceof Shape2 && this.hi.inflate(-e.strokeWidth, -e.strokeWidth);
      }
    }
    gh(t, i, e, s) {
      this.hasPlaceholder() && (this.er = this.placeholder), super.gh(t, i, e, s);
    }
    ensureBounds() {
      const t = this;
      t.isSubGraphExpanded && this.memberParts.each((i) => {
        !t.computesBoundsIncludingLinks && i instanceof Link2 || i.ensureBounds();
      }), super.ensureBounds();
    }
    tl() {
      if (!super.tl())
        return false;
      const t = this.memberParts;
      for (; t.next(); ) {
        const i = t.value;
        if (i instanceof Node2) {
          if (!i.isVisible())
            continue;
          if (i.hs())
            return false;
        } else if (i instanceof Link2) {
          if (!i.isVisible())
            continue;
          if (i.hs() && i.fromNode !== this && i.toNode !== this)
            return false;
        }
      }
      return true;
    }
    hasPlaceholder() {
      return this.Et !== null && this.Et.isVisibleObject() && this.isSubGraphExpanded;
    }
    get placeholder() {
      return this.Et;
    }
    get computesBoundsAfterDrag() {
      return (this.z & 2048) !== 0;
    }
    set computesBoundsAfterDrag(t) {
      const i = (this.z & 2048) !== 0;
      i !== t && (Util.t(t, "boolean", Group2, "computesBoundsAfterDrag"), this.z = this.z ^ 2048, this.i("computesBoundsAfterDrag", i, t));
    }
    get computesBoundsIncludingLinks() {
      return (this.z & 4096) !== 0;
    }
    set computesBoundsIncludingLinks(t) {
      Util.t(t, "boolean", Group2, "computesBoundsIncludingLinks");
      const i = (this.z & 4096) !== 0;
      i !== t && (this.z = this.z ^ 4096, this.i("computesBoundsIncludingLinks", i, t));
    }
    get computesBoundsIncludingLocation() {
      return (this.z & 8192) !== 0;
    }
    set computesBoundsIncludingLocation(t) {
      Util.t(t, "boolean", Group2, "computesBoundsIncludingLocation");
      const i = (this.z & 8192) !== 0;
      i !== t && (this.z = this.z ^ 8192, this.i("computesBoundsIncludingLocation", i, t));
    }
    get handlesDragDropForMembers() {
      return (this.z & 16384) !== 0;
    }
    set handlesDragDropForMembers(t) {
      Util.t(t, "boolean", Group2, "handlesDragDropForMembers");
      const i = (this.z & 16384) !== 0;
      i !== t && (this.z = this.z ^ 16384, this.i("handlesDragDropForMembers", i, t));
    }
    get avoidableMembers() {
      return (this.z & 131072) !== 0;
    }
    set avoidableMembers(t) {
      Util.t(t, "boolean", Group2, "avoidableMembers");
      const i = (this.z & 131072) !== 0;
      i !== t && (this.z = this.z ^ 131072, this.i("avoidableMembers", i, t));
    }
    get memberParts() {
      return this.Zd.iterator;
    }
    $2(t) {
      if (this.Zd.add(t)) {
        t instanceof Group2 && this.ua.add(t);
        const e = this.memberAdded;
        if (e !== null) {
          let s = true;
          const n = this.diagram;
          n !== null && (s = n.W, n.W = true), e(this, t), n !== null && (n.W = s);
        }
        (!this.isVisible() || !this.isSubGraphExpanded) && t.Ki(false);
      }
      if (t instanceof Link2 && !this.computesBoundsIncludingLinks)
        return;
      let i = this.Et;
      i === null && (i = this), i.u();
    }
    Z2(t) {
      if (this.Zd.remove(t)) {
        t instanceof Group2 && this.ua.remove(t);
        const e = this.memberRemoved;
        if (e !== null) {
          let s = true;
          const n = this.diagram;
          n !== null && (s = n.W, n.W = true), e(this, t), n !== null && (n.W = s);
        }
        (!this.isVisible() || !this.isSubGraphExpanded) && t.Ki(true);
      }
      if (t instanceof Link2 && !this.computesBoundsIncludingLinks)
        return;
      let i = this.Et;
      i === null && (i = this), i.u();
    }
    Wf() {
      if (this.Zd.count > 0) {
        const t = this.diagram;
        if (t !== null) {
          const e = this.Zd.copy().iterator;
          for (; e.next(); ) {
            const s = e.value;
            t.remove(s);
          }
        }
      }
      super.Wf();
    }
    get layout() {
      return this.le;
    }
    set layout(t) {
      const i = this.le;
      if (i !== t) {
        t !== null && (Util.s(t, Layout2, Group2, "layout"), t.diagram !== null && t.diagram.layout === t && Util.n("A layout cannot be both the Diagram.layout and a Group.layout: " + t)), i !== null && (i.diagram = null, i.group = null), this.le = t;
        const e = this.diagram;
        t !== null && (t.diagram = e, t.group = this), e !== null && (e.Jr = true), this.i("layout", i, t), e !== null && e.requestUpdate();
      }
    }
    get memberAdded() {
      return this.bt !== null ? this.bt.xy : null;
    }
    set memberAdded(t) {
      const i = this.memberAdded;
      i !== t && (t !== null && Util.t(t, "function", Group2, "memberAdded"), this.wl(), this.bt.xy = t, this.i("memberAdded", i, t));
    }
    get memberRemoved() {
      return this.bt !== null ? this.bt.by : null;
    }
    set memberRemoved(t) {
      const i = this.memberRemoved;
      i !== t && (t !== null && Util.t(t, "function", Group2, "memberRemoved"), this.wl(), this.bt.by = t, this.i("memberRemoved", i, t));
    }
    get memberValidation() {
      return this.bt !== null ? this.bt.hh : null;
    }
    set memberValidation(t) {
      const i = this.memberValidation;
      i !== t && (t !== null && Util.t(t, "function", Group2, "memberValidation"), this.wl(), this.bt.hh = t, this.i("memberValidation", i, t));
    }
    canAddMembers(t) {
      const i = this.diagram;
      if (i === null)
        return false;
      const e = i.commandHandler, n = e.h2(t).iterator;
      for (; n.next(); ) {
        const o = n.value;
        if (!e.isValidMember(this, o))
          return false;
      }
      return true;
    }
    addMembers(t, i) {
      const e = this.diagram;
      if (e === null)
        return false;
      const s = e.commandHandler, n = s.h2(t);
      let o = true;
      const r = n.iterator;
      for (; r.next(); ) {
        const l = r.value;
        !i || s.isValidMember(this, l) ? l.containingGroup = this : o = false;
      }
      return o;
    }
    get ungroupable() {
      return (this.z & 256) !== 0;
    }
    set ungroupable(t) {
      const i = (this.z & 256) !== 0;
      i !== t && (Util.t(t, "boolean", Group2, "ungroupable"), this.z = this.z ^ 256, this.i("ungroupable", i, t));
    }
    canUngroup() {
      if (!this.ungroupable)
        return false;
      const t = this.layer;
      if (t === null || !t.allowUngroup)
        return false;
      const i = t.diagram;
      return !(i !== null && !i.allowUngroup);
    }
    invalidateConnectedLinks(t) {
      const i = this.NO();
      if (super.invalidateConnectedLinks(t), i)
        return;
      this.PA(true);
      const e = this.findExternalLinksConnected();
      for (; e.next(); ) {
        const s = e.value;
        if (t !== void 0 && t.contains(s))
          continue;
        const n = s.fromNode;
        if (n !== null && n !== this && n.isMemberOf(this) && !n.isVisible())
          n.Se(s.fromPort), n.Se(s.toPort), s.invalidateRoute();
        else {
          const o = s.toNode;
          o !== null && o !== this && o.isMemberOf(this) && !o.isVisible() && (o.Se(s.fromPort), o.Se(s.toPort), s.invalidateRoute());
        }
      }
    }
    findExternalLinksConnected() {
      const t = this.diagram !== null && this.diagram.wP;
      if (t && this.b0 !== null)
        return this.b0.iterator;
      const i = this.findSubGraphParts();
      i.add(this);
      const e = new GSet2(), s = i.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (!(n instanceof Node2))
          continue;
        const o = n.linksConnected;
        for (; o.next(); ) {
          const r = o.value;
          i.contains(r) || e.add(r);
        }
      }
      return t && (this.b0 = e), e.iterator;
    }
    findExternalNodesConnected() {
      const t = this.findSubGraphParts();
      t.add(this);
      const i = new GSet2(), e = t.iterator;
      for (; e.next(); ) {
        const s = e.value;
        if (!(s instanceof Node2))
          continue;
        const n = s.linksConnected;
        for (; n.next(); ) {
          const o = n.value, r = o.fromNode;
          r !== null && (!t.contains(r) || r === this) && i.add(r);
          const l = o.toNode;
          l !== null && (!t.contains(l) || l === this) && i.add(l);
        }
      }
      return i.iterator;
    }
    mE() {
      function t(e, s) {
        e !== null && (s.add(e), t(e.containingGroup, s));
      }
      const i = new GSet2();
      return t(this, i), i;
    }
    findSubGraphParts() {
      const t = new GSet2();
      return Part2.ah(t, this, true, 0, true), t.remove(this), t;
    }
    Ki(t) {
      super.Ki(t);
      const i = this.memberParts;
      for (; i.next(); )
        i.value.Ki(t);
    }
    collapseSubGraph() {
      const t = this.diagram;
      if (t === null || t.isCollapsingExpanding)
        return;
      t.isCollapsingExpanding = true;
      const i = this.findSubGraphParts();
      this.uT(i, t, this), t.isCollapsingExpanding = false;
    }
    uT(t, i, e) {
      const s = this.memberParts;
      for (; s.next(); ) {
        const n = s.value;
        if (n.Ki(false), n instanceof Group2 && n.isSubGraphExpanded && (n.wasSubGraphExpanded = n.isSubGraphExpanded, n.uT(t, i, e)), n instanceof Node2)
          n.invalidateConnectedLinks(t), i.Rf(n, e);
        else if (n instanceof Link2) {
          const o = n.labelNodes;
          for (; o.next(); )
            o.value.invalidateConnectedLinks(t);
        }
      }
      this.isSubGraphExpanded = false;
    }
    expandSubGraph() {
      const t = this.diagram;
      if (t === null || t.isCollapsingExpanding)
        return;
      t.isCollapsingExpanding = true;
      const i = this.findSubGraphParts();
      this.dT(i, t, this), t.isCollapsingExpanding = false;
    }
    dT(t, i, e) {
      const s = this.memberParts;
      for (; s.next(); ) {
        const n = s.value;
        if (n.Ki(true), n instanceof Group2 && n.wasSubGraphExpanded && (n.wasSubGraphExpanded = false, n.dT(t, i, e)), n instanceof Node2)
          n.invalidateConnectedLinks(t);
        else if (n instanceof Link2) {
          const o = n.labelNodes;
          for (; o.next(); )
            o.value.invalidateConnectedLinks(t);
        }
      }
      this.isSubGraphExpanded = true;
    }
    get isSubGraphExpanded() {
      return (this.z & 512) !== 0;
    }
    set isSubGraphExpanded(t) {
      const i = (this.z & 512) !== 0;
      if (i !== t) {
        Util.t(t, "boolean", Group2, "isSubGraphExpanded"), this.z = this.z ^ 512;
        const e = this.diagram;
        this.i("isSubGraphExpanded", i, t);
        const s = this.subGraphExpandedChanged;
        if (s !== null) {
          let n = true;
          e !== null && (n = e.W, e.W = true), s(this), e !== null && (e.W = n);
        }
        if (e !== null && e.undoManager.isUndoingRedoing) {
          this.Et !== null && this.Et.u(), this.memberParts.each((n) => n.updateAdornments());
          return;
        }
        t ? this.expandSubGraph() : this.collapseSubGraph();
      }
    }
    get wasSubGraphExpanded() {
      return (this.z & 1024) !== 0;
    }
    set wasSubGraphExpanded(t) {
      const i = (this.z & 1024) !== 0;
      i !== t && (Util.t(t, "boolean", Group2, "wasSubGraphExpanded"), this.z = this.z ^ 1024, this.i("wasSubGraphExpanded", i, t));
    }
    get subGraphExpandedChanged() {
      return this.bt !== null ? this.bt.ky : null;
    }
    set subGraphExpandedChanged(t) {
      const i = this.subGraphExpandedChanged;
      i !== t && (t !== null && Util.t(t, "function", Group2, "subGraphExpandedChanged"), this.wl(), this.bt.ky = t, this.i("subGraphExpandedChanged", i, t));
    }
    move(t, i) {
      i === void 0 && (i = false);
      const e = i ? this.location : this.position, s = e.x, n = e.y, o = t.x, r = t.y;
      if ((s === o || isNaN(s) && isNaN(o)) && (n === r || isNaN(n) && isNaN(r)))
        return;
      const l = o - (isNaN(s) ? 0 : s), h = r - (isNaN(n) ? 0 : n), a = Point2.a();
      super.move(t, i);
      const f = new GSet2(), u = this.findSubGraphParts().iterator;
      for (; u.next(); ) {
        const d = u.value;
        d instanceof Link2 && (d.wn && f.add(d), !(!d.Re && (d.fromNode === this || d.toNode === this)) && (d.wn = true));
      }
      for (u.reset(); u.next(); ) {
        const d = u.value;
        if (d.Il() || d instanceof Node2 && d.isLinkLabel)
          continue;
        const m = d.position, g = d.location;
        m.isReal() ? (a.x = m.x + l, a.y = m.y + h, d.position = a) : g.isReal() && (a.x = g.x + l, a.y = g.y + h, d.location = a);
      }
      for (u.reset(); u.next(); ) {
        const d = u.value;
        if (!(d instanceof Link2) || (d.wn = f.contains(d), !d.Re && (d.fromNode === this || d.toNode === this)))
          continue;
        const m = d.position;
        a.x = m.x + l, a.y = m.y + h, a.isReal() ? d.move(a) : d.invalidateRoute();
      }
      Point2.o(a);
    }
    NO() {
      return (this.z & 65536) !== 0;
    }
    PA(t) {
      (this.z & 65536) !== 0 !== t && (this.z = this.z ^ 65536);
    }
    get sl() {
      return (this.z & 32768) !== 0;
    }
    set sl(t) {
      (this.z & 32768) !== 0 !== t && (this.z = this.z ^ 32768);
    }
  }
  class Placeholder2 extends GraphObject2 {
    constructor(t) {
      super();
      __publicField(this, "ei");
      __publicField(this, "$d");
      this.ei = Margin2.qg, this.$d = new Rect2(NaN, NaN, NaN, NaN), t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.ei = this.ei.L(), t.$d = this.$d.copy();
    }
    dh(t) {
      if (this.background === null)
        return false;
      const i = this.naturalBounds;
      return Rect2.contains(0, 0, i.width, i.height, t.x, t.y);
    }
    ld(t, i, e, s) {
      const n = this.part;
      if ((n === null || !(n instanceof Group2) && !(n instanceof Adornment2)) && Util.n("Placeholder is not inside a Group or Adornment."), n instanceof Group2) {
        const o = this.computeBorder(this.$d), r = this.minSize, l = isFinite(r.width) ? Math.max(r.width, o.width) : o.width, h = isFinite(r.height) ? Math.max(r.height, o.height) : o.height, a = this.Hi;
        a.Do(l || 0, h || 0), this.oo(0, 0, a.width, a.height);
        const f = n.memberParts;
        let c = false;
        for (; f.next(); )
          if (f.value.isVisible()) {
            c = true;
            break;
          }
        const u = n.diagram;
        if (c && u !== null && !u.animationManager.OM(n) && !isNaN(o.x) && !isNaN(o.y)) {
          const d = Point2.a();
          d.setRectSpot(o, n.locationSpot), n.location = d, Point2.o(d);
        }
      } else {
        const o = n, r = this.Hi, l = this.ei, h = l.left + l.right, a = l.top + l.bottom, f = o.adornedObject, c = f.getDocumentAngle();
        o.angle = c;
        let u = 0;
        f instanceof Shape2 && (u = f.strokeWidth);
        const d = f.getDocumentScale(), m = f.naturalBounds, g = (m.width + u) * d, p = (m.height + u) * d;
        if (o.type !== Panel2.Link) {
          const y = o.category === "Selection" ? Spot2.TopLeft : o.locationSpot, x = f.getDocumentPoint(y, Point2.a());
          o.location = x, Point2.o(x);
        }
        if (!isNaN(g) && !isNaN(p))
          r.Do(g + h || 0, p + a || 0), this.oo(-l.left, -l.top, r.width, r.height);
        else {
          const y = f.getDocumentPoint(Spot2.TopLeft, Point2.a()), x = Rect2.H(y.x, y.y, 0, 0);
          x.unionPoint(f.getDocumentPoint(Spot2.BottomRight, y)), x.unionPoint(f.getDocumentPoint(Spot2.TopRight, y)), x.unionPoint(f.getDocumentPoint(Spot2.BottomLeft, y)), r.Do(x.width + h || 0, x.height + a || 0), this.oo(-l.left, -l.top, r.width, r.height), Point2.o(y), Rect2.o(x);
        }
      }
    }
    gh(t, i, e, s) {
      this.actualBounds.e(t, i, e, s);
    }
    computeBorder(t) {
      const i = this.part, e = i.diagram, s = e === null || !e.animationManager.isAnimating;
      if (e !== null && i instanceof Group2 && !i.layer.isTemporary && i.computesBoundsAfterDrag && this.$d.isReal()) {
        const l = e.toolManager.findTool("Dragging");
        if (l === e.currentTool) {
          const h = l.computeBorder(i, this.$d, t);
          if (h !== null)
            return h;
        }
      }
      const n = Rect2.a(), o = this.computeMemberBounds(n), r = this.ei;
      return i instanceof Group2 && !i.isSubGraphExpanded ? t.e(o.x - r.left, o.y - r.top, 0, 0) : t.e(o.x - r.left, o.y - r.top, Math.max(o.width + r.left + r.right, 0), Math.max(o.height + r.top + r.bottom, 0)), Rect2.o(n), s && i instanceof Group2 && i.computesBoundsIncludingLocation && i.location.isReal() && t.unionPoint(i.location), t;
    }
    computeMemberBounds(t) {
      if (!(this.part instanceof Group2))
        return t.e(0, 0, 0, 0), t;
      const i = this.part;
      let e = 1 / 0, s = 1 / 0, n = -1 / 0, o = -1 / 0;
      const r = i.memberParts;
      for (; r.next(); ) {
        const l = r.value;
        if (!l.isVisible() || l instanceof Link2 && (!i.computesBoundsIncludingLinks || l.Ko() || l.fromNode === i || l.toNode === i))
          continue;
        const h = l.actualBounds;
        h.left < e && (e = h.left), h.top < s && (s = h.top), h.right > n && (n = h.right), h.bottom > o && (o = h.bottom);
      }
      if (!isFinite(e) || !isFinite(s)) {
        const l = i.location;
        t.e(l.x, l.y, 0, 0);
      } else
        t.e(e, s, n - e, o - s);
      return t;
    }
    get padding() {
      return this.ei;
    }
    set padding(t) {
      typeof t == "number" ? t = new Margin2(t) : Util.s(t, Margin2, Placeholder2, "padding");
      const i = this.ei;
      i.equals(t) || (t = t.L(), this.ei = t, this.i("padding", i, t), this.u());
    }
  }
  class Layout2 {
    constructor(t) {
      __publicField(this, "b");
      __publicField(this, "da");
      __publicField(this, "Qd");
      __publicField(this, "Lr");
      __publicField(this, "_d");
      __publicField(this, "tg");
      __publicField(this, "zo");
      __publicField(this, "xl");
      __publicField(this, "ig");
      __publicField(this, "eg");
      __publicField(this, "ko");
      GSet2.ji(this), this.b = null, this.da = null, this.Qd = true, this.Lr = true, this._d = false, this.tg = new Point2(0, 0).w(), this.zo = true, this.xl = null, this.ig = null, this.eg = false, this.ko = null, t && Object.assign(this, t);
    }
    cloneProtected(t) {
      t.Qd = this.Qd, t.Lr = this.Lr, t._d = this._d, t.tg.c(this.tg), t.zo = this.zo, t.xl = this.xl, t.ig = this.ig, t.eg = true;
    }
    copy() {
      const t = new this.constructor();
      return this.cloneProtected(t), t;
    }
    ci(t) {
      Util.gr(this, t);
    }
    toString() {
      let t = Util.an(this.constructor);
      return t += "(", this.group !== null && (t += " in " + this.group), this.diagram !== null && (t += " for " + this.diagram), t += ")", t;
    }
    get diagram() {
      return this.b;
    }
    set diagram(t) {
      t !== null && Util.s(t, Diagram2, Layout2, "diagram"), this.b = t;
    }
    get group() {
      return this.da;
    }
    set group(t) {
      this.da !== t && (t !== null && Util.s(t, Group2, Layout2, "group"), this.da = t, t !== null && (this.b = t.diagram));
    }
    get isOngoing() {
      return this.Qd;
    }
    set isOngoing(t) {
      this.Qd !== t && (Util.t(t, "boolean", Layout2, "isOngoing"), this.Qd = t);
    }
    get isInitial() {
      return this.Lr;
    }
    set isInitial(t) {
      Util.t(t, "boolean", Layout2, "isInitial"), this.Lr = t, t || (this.eg = true);
    }
    get isViewportSized() {
      return this._d;
    }
    set isViewportSized(t) {
      this._d !== t && (Util.t(t, "boolean", Layout2, "isViewportSized"), this._d = t, t && this.invalidateLayout());
    }
    get isRouting() {
      return this.zo;
    }
    set isRouting(t) {
      this.zo !== t && (Util.t(t, "boolean", Layout2, "isRouting"), this.zo = t);
    }
    get isRealtime() {
      return this.xl;
    }
    set isRealtime(t) {
      this.xl !== t && (t !== null && Util.t(t, "boolean", Layout2, "isRealtime"), this.xl = t);
    }
    get isValidLayout() {
      return this.eg;
    }
    set isValidLayout(t) {
      if (this.eg !== t && (Util.t(t, "boolean", Layout2, "isValidLayout"), this.eg = t, !t)) {
        const i = this.diagram;
        i !== null && (i.Jr = true);
      }
    }
    invalidateLayout() {
      if (this.isValidLayout) {
        const t = this.diagram;
        if (t === null || t.undoManager.isUndoingRedoing)
          return;
        const i = t.animationManager;
        if (i.isTicking)
          return;
        i.defaultAnimation.isAnimating && i.stopAnimation(), (this.isOngoing && t.Uh || this.isInitial && !t.Uh) && (this.isValidLayout = false, t.requestUpdate());
      }
    }
    get network() {
      return this.ko;
    }
    set network(t) {
      this.ko !== t && (t !== null && Util.s(t, LayoutNetwork2, Layout2, "network"), this.ko = t, t !== null && (t.layout = this));
    }
    createNetwork() {
      return new LayoutNetwork2(this);
    }
    makeNetwork(t) {
      const i = this.createNetwork();
      return t instanceof Diagram2 ? (i.addParts(t.nodes, true), i.addParts(t.links, true)) : t instanceof Group2 ? i.addParts(t.memberParts) : i.addParts(t.iterator), i;
    }
    updateParts() {
      this.isValidLayout = true;
      let t = this.diagram;
      if (t === null && this.network !== null) {
        const i = this.network.vertexes.iterator;
        for (; i.next(); ) {
          const s = i.value.node;
          if (s !== null && (t = s.diagram, t !== null))
            break;
        }
      }
      try {
        t !== null && t.startTransaction("Layout"), this.commitLayout();
      } finally {
        t !== null && t.commitTransaction("Layout");
      }
    }
    commitLayout() {
      if (this.network === null)
        return;
      const t = this.network.vertexes.iterator;
      for (; t.next(); )
        t.value.commit();
      if (this.isRouting) {
        const i = this.network.edges.iterator;
        for (; i.next(); )
          i.value.commit();
      }
    }
    doLayout(t) {
      Debug && t === null && Util.n("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts");
      const i = new GSet2();
      if (t instanceof Diagram2 ? (this.Ch(i, t.nodes, true, this.sl, true, false, true), this.Ch(i, t.parts, true, this.sl, true, false, true)) : t instanceof Group2 ? this.Ch(i, t.memberParts, false, this.sl, true, false, true) : i.addAll(t.iterator), i.count > 0) {
        const s = this.diagram;
        s !== null && s.startTransaction("Layout"), this.doMinimalNoNetworkLayout(i), s !== null && s.commitTransaction("Layout");
      }
      this.isValidLayout = true;
    }
    doMinimalNoNetworkLayout(t) {
      const i = t.count, e = Math.ceil(Math.sqrt(i));
      this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
      const s = this.arrangementOrigin.x, n = this.arrangementOrigin.y;
      let o = s, r = n, l = 0, h = 0;
      const a = t.iterator;
      for (; a.next(); ) {
        const f = a.value;
        f.ensureBounds();
        const c = f.measuredBounds, u = c.width, d = c.height;
        f.moveTo(o, r), f instanceof Group2 && (f.sl = false), o += Math.max(u, 50) + 20, h = Math.max(h, Math.max(d, 50)), l >= e - 1 ? (l = 0, o = s, r += h + 20, h = 0) : l++;
      }
    }
    doMinimalNetworkLayout() {
      const t = this.network.vertexes.count, i = Math.ceil(Math.sqrt(t));
      this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
      const e = this.arrangementOrigin.x, s = this.arrangementOrigin.y;
      let n = e, o = s, r = 0, l = 0;
      const h = this.network.vertexes.iterator;
      for (; h.next(); ) {
        const a = h.value.node;
        if (a === null || a instanceof Link2 || (a.ensureBounds(), !this.sl(a)))
          continue;
        const f = a.measuredBounds, c = f.width, u = f.height;
        a.moveTo(n, o), a instanceof Group2 && (a.sl = false), n += Math.max(c, 50) + 20, l = Math.max(l, Math.max(u, 50)), r >= i - 1 ? (r = 0, n = e, o += l + 20, l = 0) : r++;
      }
    }
    sl(t) {
      return !!(!t.location.isReal() && !t.position.isReal() || t instanceof Group2 && t.sl);
    }
    Ch(t, i, e, s, n, o, r) {
      const l = i.iterator;
      for (; l.next(); ) {
        const h = l.value;
        if (!(e && !h.isTopLevel) && !(s !== null && !s(h)) && h.canLayout())
          if (n && h instanceof Node2) {
            if (h.isLinkLabel)
              continue;
            h instanceof Group2 && h.layout === null ? this.Ch(t, h.memberParts, false, s, n, o, r) : (h.ensureBounds(), t.add(h));
          } else
            o && h instanceof Link2 ? t.add(h) : r && h.De() && !(h instanceof Node2) && (h.ensureBounds(), t.add(h));
      }
    }
    getLayoutBounds(t, i) {
      const e = this.boundsComputation;
      return e !== null ? (i || (i = new Rect2()), e(t, this, i)) : !i && t.margin.equalTo(0, 0, 0, 0) ? t.actualBounds : (i || (i = new Rect2()), i.set(t.actualBounds), i.addMargin(t.margin), i);
    }
    get boundsComputation() {
      return this.ig;
    }
    set boundsComputation(t) {
      this.ig !== t && (t !== null && Util.t(t, "function", Layout2, "boundsComputation"), this.ig = t, this.invalidateLayout());
    }
    collectParts(t) {
      const i = new GSet2();
      return t instanceof Diagram2 ? (this.Ch(i, t.nodes, true, null, true, true, true), this.Ch(i, t.links, true, null, true, true, true), this.Ch(i, t.parts, true, null, true, true, true)) : t instanceof Group2 ? this.Ch(i, t.memberParts, false, null, true, true, true) : this.Ch(i, t.iterator, false, null, true, true, true), i;
    }
    get arrangementOrigin() {
      return this.tg;
    }
    set arrangementOrigin(t) {
      Util.s(t, Point2, Layout2, "arrangementOrigin"), this.tg.equals(t) || (this.tg.c(t), this.invalidateLayout());
    }
    initialOrigin(t) {
      const i = this.group;
      if (i !== null)
        if (i.hasPlaceholder()) {
          const e = i.placeholder, s = e.getDocumentPoint(Spot2.TopLeft);
          (isNaN(s.x) || isNaN(s.y)) && s.set(t);
          const n = e.padding;
          return s.x += n.left, s.y += n.top, s;
        } else {
          const e = i.position.copy();
          return (isNaN(e.x) || isNaN(e.y)) && e.set(t), e;
        }
      return t;
    }
  }
  class LayoutNetwork2 {
    constructor(t) {
      __publicField(this, "le");
      __publicField(this, "So");
      __publicField(this, "In");
      __publicField(this, "Ay");
      __publicField(this, "Ly");
      GSet2.ji(this), Debug && !t && Util.n("LayoutNetwork constructor requires non-null Layout argument"), this.le = t, this.So = new GSet2(), this.In = new GSet2(), this.Ay = new GMap2(), this.Ly = new GMap2();
    }
    clear() {
      if (this.So) {
        const t = this.So.iterator;
        for (; t.next(); )
          t.value.clear();
      }
      if (this.In) {
        const t = this.In.iterator;
        for (; t.next(); )
          t.value.clear();
      }
      this.So = new GSet2(), this.In = new GSet2(), this.Ay = new GMap2(), this.Ly = new GMap2();
    }
    toString(t) {
      t === void 0 && (t = 0);
      let i = "LayoutNetwork" + (this.layout !== null ? "(" + this.layout.toString() + ")" : "");
      if (t <= 0)
        return i;
      if (i += " vertexes: " + this.So.count + " edges: " + this.In.count, t > 1) {
        const e = this.So.iterator;
        for (; e.next(); ) {
          const n = e.value;
          i += `
    ` + n.toString(t - 1);
        }
        const s = this.In.iterator;
        for (; s.next(); ) {
          const n = s.value;
          i += `
    ` + n.toString(t - 1);
        }
      }
      return i;
    }
    get layout() {
      return this.le;
    }
    set layout(t) {
      t !== null && (this.le = t);
    }
    get vertexes() {
      return this.So;
    }
    get edges() {
      return this.In;
    }
    createVertex() {
      return new LayoutVertex2(this);
    }
    createEdge() {
      return new LayoutEdge2(this);
    }
    addParts(t, i, e) {
      if (t === null)
        return;
      i === void 0 && (i = false), Util.t(i, "boolean", LayoutNetwork2, "addParts:toplevelonly"), e === void 0 && (e = null), e === null && (e = (n) => {
        if (n instanceof Node2)
          return !n.isLinkLabel;
        if (n instanceof Link2) {
          const o = n.fromNode;
          if (o === null || o.isLinkLabel)
            return false;
          const r = n.toNode;
          return !(r === null || r.isLinkLabel);
        }
        return false;
      });
      const s = t.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n instanceof Node2 && !(i && !n.isTopLevel) && n.canLayout() && e(n))
          if (n instanceof Group2 && n.layout === null)
            this.addParts(n.memberParts, false);
          else {
            if (this.findVertex(n) !== null)
              continue;
            const o = this.createVertex();
            o.node = n, this.addVertex(o);
          }
      }
      for (s.reset(); s.next(); ) {
        const n = s.value;
        if (!(n instanceof Link2) || i && !n.isTopLevel || !n.canLayout() || !e(n) || this.findEdge(n) !== null)
          continue;
        const o = n.fromNode, r = n.toNode;
        if (o === null || r === null || o === r)
          continue;
        const l = this.findGroupVertex(o), h = this.findGroupVertex(r);
        this.linkVertexes(l, h, n);
      }
    }
    findGroupVertex(t) {
      if (t === null)
        return null;
      const i = t.findVisibleNode();
      if (i === null)
        return null;
      let e = this.findVertex(i);
      if (e !== null)
        return e;
      let s = i.containingGroup;
      for (; s !== null; ) {
        if (e = this.findVertex(s), e !== null)
          return e;
        s = s.containingGroup;
      }
      return null;
    }
    addVertex(t) {
      if (t === null)
        return;
      Debug && Util.s(t, LayoutVertex2, LayoutNetwork2, "addVertex:vertex"), this.So.add(t);
      const i = t.node;
      i !== null && this.Ay.add(i, t), t.network = this;
    }
    addNode(t) {
      if (t === null)
        return null;
      Debug && Util.s(t, Node2, LayoutNetwork2, "addNode:node");
      let i = this.findVertex(t);
      return i === null && (i = this.createVertex(), i.node = t, this.addVertex(i)), i;
    }
    deleteVertex(t) {
      if (t !== null && (Debug && Util.s(t, LayoutVertex2, LayoutNetwork2, "deleteVertex:vertex"), this.gT(t))) {
        let i = t.rr;
        for (let e = i.count - 1; e >= 0; e--) {
          const s = i.elt(e);
          this.deleteEdge(s);
        }
        i = t.lr;
        for (let e = i.count - 1; e >= 0; e--) {
          const s = i.elt(e);
          this.deleteEdge(s);
        }
      }
    }
    gT(t) {
      if (t === null)
        return false;
      const i = this.So.remove(t);
      if (i) {
        const e = t.node;
        e !== null && this.Ay.remove(e);
      }
      return i;
    }
    deleteNode(t) {
      if (t === null)
        return;
      Debug && Util.s(t, Node2, LayoutNetwork2, "deleteNode:node");
      const i = this.findVertex(t);
      i !== null && this.deleteVertex(i);
    }
    findVertex(t) {
      return t === null ? null : (Debug && Util.s(t, Node2, LayoutNetwork2, "findVertex:node"), this.Ay.getValue(t));
    }
    addEdge(t) {
      if (t === null)
        return;
      Debug && Util.s(t, LayoutEdge2, LayoutNetwork2, "addEdge:edge"), this.pN(t);
      const i = t.toVertex;
      i !== null && i.addSourceEdge(t);
      const e = t.fromVertex;
      e !== null && e.addDestinationEdge(t);
    }
    pN(t) {
      if (t === null)
        return;
      this.In.add(t);
      const i = t.link;
      i !== null && this.findEdge(i) === null && this.Ly.add(i, t), t.network = this;
    }
    addLink(t) {
      if (t === null)
        return null;
      Debug && Util.s(t, Link2, LayoutNetwork2, "addLink:link");
      const i = t.fromNode, e = t.toNode;
      let s = this.findEdge(t);
      return s === null ? (s = this.createEdge(), s.link = t, i !== null && (s.fromVertex = this.addNode(i)), e !== null && (s.toVertex = this.addNode(e)), this.addEdge(s)) : (i !== null ? s.fromVertex = this.addNode(i) : s.fromVertex = null, e !== null ? s.toVertex = this.addNode(e) : s.toVertex = null), s;
    }
    deleteEdge(t) {
      if (t === null)
        return;
      Debug && Util.s(t, LayoutEdge2, LayoutNetwork2, "deleteEdge:edge");
      const i = t.toVertex;
      i !== null && i.deleteSourceEdge(t);
      const e = t.fromVertex;
      e !== null && e.deleteDestinationEdge(t), this.yN(t);
    }
    yN(t) {
      if (t === null)
        return false;
      const i = this.In.remove(t);
      if (i) {
        const e = t.link;
        e !== null && this.Ly.remove(e);
      }
      return i;
    }
    deleteLink(t) {
      if (t === null)
        return;
      Debug && Util.s(t, Link2, LayoutNetwork2, "deleteLink:link");
      const i = this.findEdge(t);
      i !== null && this.deleteEdge(i);
    }
    findEdge(t) {
      return t === null ? null : (Debug && Util.s(t, Link2, LayoutNetwork2, "findEdge:link"), this.Ly.getValue(t));
    }
    linkVertexes(t, i, e) {
      if (t === null || i === null)
        return null;
      if (Debug && (Util.s(t, LayoutVertex2, LayoutNetwork2, "linkVertexes:fromVertex"), Util.s(i, LayoutVertex2, LayoutNetwork2, "linkVertexes:toVertex"), e !== null && Util.s(e, Link2, LayoutNetwork2, "linkVertexes:link")), t.network === this && i.network === this) {
        const s = this.createEdge();
        return s.link = e, s.fromVertex = t, s.toVertex = i, this.addEdge(s), s;
      }
      return null;
    }
    reverseEdge(t) {
      if (t === null)
        return;
      Debug && Util.s(t, LayoutEdge2, LayoutNetwork2, "reverseEdge:edge");
      const i = t.fromVertex, e = t.toVertex;
      i === null || e === null || (i.deleteDestinationEdge(t), e.deleteSourceEdge(t), t.reverseEdge(), i.addSourceEdge(t), e.addDestinationEdge(t));
    }
    deleteSelfEdges() {
      const t = Util.ct(), i = this.In.iterator;
      for (; i.next(); ) {
        const s = i.value;
        s.fromVertex === s.toVertex && t.push(s);
      }
      const e = t.length;
      for (let s = 0; s < e; s++)
        this.deleteEdge(t[s]);
      Util.ot(t);
    }
    deleteArtificialVertexes() {
      const t = Util.ct(), i = this.So.iterator;
      for (; i.next(); ) {
        const o = i.value;
        o.node === null && o.data === null && t.push(o);
      }
      let e = t.length;
      for (let o = 0; o < e; o++)
        this.deleteVertex(t[o]);
      const s = Util.ct(), n = this.In.iterator;
      for (; n.next(); ) {
        const o = n.value;
        o.link === null && o.data === null && s.push(o);
      }
      e = s.length;
      for (let o = 0; o < e; o++)
        this.deleteEdge(s[o]);
      Util.ot(t), Util.ot(s);
    }
    deleteUselessEdges() {
      const t = Util.ct(), i = this.In.iterator;
      for (; i.next(); ) {
        const s = i.value;
        (s.fromVertex === null || s.toVertex === null) && t.push(s);
      }
      const e = t.length;
      for (let s = 0; s < e; s++)
        this.deleteEdge(t[s]);
      Util.ot(t);
    }
    isSingleton(t) {
      return !(t.rr.count > 0 || t.lr.count > 0);
    }
    splitIntoSubNetworks(t) {
      t === void 0 && (t = true), t && (this.deleteArtificialVertexes(), this.deleteUselessEdges(), this.deleteSelfEdges());
      const i = new List2();
      let e = true;
      for (; e; ) {
        e = false;
        const s = this.So.iterator;
        for (; s.next(); ) {
          const n = s.value;
          if (this.isSingleton(n))
            continue;
          const o = this.layout.createNetwork();
          i.add(o), this.CO(o, n), e = true;
          break;
        }
      }
      return i.sort((s, n) => s === null || n === null || s === n ? 0 : n.vertexes.count - s.vertexes.count), i;
    }
    CO(t, i) {
      if (i === null)
        return;
      const e = new List2();
      for (e.add(i); e.count > 0; ) {
        const s = e.first();
        if (e.removeAt(0), s.network === t)
          continue;
        this.gT(s), t.addVertex(s);
        let n = s.sourceEdges;
        for (; n.next(); ) {
          const o = n.value;
          o.network !== t && (this.yN(o), t.pN(o), e.add(o.fromVertex));
        }
        for (n = s.destinationEdges; n.next(); ) {
          const o = n.value;
          o.network !== t && (this.yN(o), t.pN(o), e.add(o.toVertex));
        }
      }
    }
    findAllParts() {
      const t = new GSet2(), i = this.So.iterator;
      for (; i.next(); ) {
        const s = i.value;
        t.add(s.node);
      }
      const e = this.In.iterator;
      for (; e.next(); ) {
        const s = e.value;
        t.add(s.link);
      }
      return t;
    }
  }
  class LayoutVertex2 {
    constructor(t) {
      __publicField(this, "ko");
      __publicField(this, "si");
      __publicField(this, "be");
      __publicField(this, "Be");
      __publicField(this, "ts");
      __publicField(this, "rr");
      __publicField(this, "lr");
      GSet2.ji(this), Debug && !t && Util.n("LayoutVertex constructor requires non-null LayoutNetwork argument"), this.ko = t, this.Be = new Rect2(0, 0, 10, 10).w(), this.ts = new Point2(5, 5).w(), this.si = null, this.be = null, this.rr = new List2(), this.lr = new List2();
    }
    clear() {
      this.si = null, this.be = null, this.rr = new List2(), this.lr = new List2();
    }
    toString(t) {
      t === void 0 && (t = 0);
      let i = "LayoutVertex#" + GSet2.ps(this);
      if (t > 0 && (i += this.node !== null ? "(" + this.node.toString() + ")" : "", t > 1)) {
        let e = "", s = true, n = this.rr.iterator;
        for (; n.next(); ) {
          const r = n.value;
          s ? s = false : e += ",", e += r.toString(0);
        }
        let o = "";
        for (s = true, n = this.lr.iterator; n.next(); ) {
          const r = n.value;
          s ? s = false : o += ",", o += r.toString(0);
        }
        i += " sources: " + e + " destinations: " + o;
      }
      return i;
    }
    get Mo() {
      return this.rr._N;
    }
    get hr() {
      return this.lr._N;
    }
    get data() {
      return this.si;
    }
    set data(t) {
      if (this.si = t, t !== null && t.bounds) {
        const i = t.bounds, e = i.x, s = i.y, n = i.width, o = i.height;
        this.ts.e(n / 2, o / 2), this.Be.e(e, s, n, o);
      }
    }
    get node() {
      return this.be;
    }
    set node(t) {
      if (this.be !== t) {
        Debug && t !== null && Util.s(t, Node2, LayoutVertex2, "node"), this.be = t, t.ensureBounds();
        const i = this.network.layout, e = Rect2.a(), s = i.getLayoutBounds(t, e);
        let n = s.x, o = s.y;
        const r = s.width, l = s.height;
        if (isNaN(n) && (n = 0), isNaN(o) && (o = 0), this.Be.e(n, o, r, l), Rect2.o(e), !(t instanceof Group2)) {
          const h = t.locationObject.getDocumentPoint(Spot2.Center);
          if (h.isReal()) {
            this.ts.e(h.x - n, h.y - o);
            return;
          }
        }
        this.ts.e(r / 2, l / 2);
      }
    }
    get bounds() {
      return this.Be;
    }
    set bounds(t) {
      this.Be.equals(t) || (Debug && Util.s(t, Rect2, LayoutVertex2, "bounds"), this.Be.c(t));
    }
    get focus() {
      return this.ts;
    }
    set focus(t) {
      this.ts.equals(t) || (Debug && Util.s(t, Point2, LayoutVertex2, "focus"), this.ts.c(t));
    }
    get centerX() {
      return this.Be.x + this.ts.x;
    }
    set centerX(t) {
      const i = this.Be;
      i.x + this.ts.x !== t && (Debug && Util.r(t, LayoutVertex2, "centerX"), i.ut(), i.x = t - this.ts.x, i.w());
    }
    get centerY() {
      return this.Be.y + this.ts.y;
    }
    set centerY(t) {
      const i = this.Be;
      i.y + this.ts.y !== t && (Debug && Util.r(t, LayoutVertex2, "centerY"), i.ut(), i.y = t - this.ts.y, i.w());
    }
    get focusX() {
      return this.ts.x;
    }
    set focusX(t) {
      const i = this.ts;
      i.x !== t && (i.ut(), i.x = t, i.w());
    }
    get focusY() {
      return this.ts.y;
    }
    set focusY(t) {
      const i = this.ts;
      i.y !== t && (i.ut(), i.y = t, i.w());
    }
    get x() {
      return this.Be.x;
    }
    set x(t) {
      const i = this.Be;
      i.x !== t && (i.ut(), i.x = t, i.w());
    }
    get y() {
      return this.Be.y;
    }
    set y(t) {
      const i = this.Be;
      i.y !== t && (i.ut(), i.y = t, i.w());
    }
    get width() {
      return this.Be.width;
    }
    set width(t) {
      const i = this.Be;
      i.width !== t && (i.ut(), i.width = t, i.w());
    }
    get height() {
      return this.Be.height;
    }
    set height(t) {
      const i = this.Be;
      i.height !== t && (i.ut(), i.height = t, i.w());
    }
    commit() {
      const t = this.si;
      if (t !== null) {
        const e = this.bounds, s = t.bounds;
        Util.Mt(s) ? (s.x = e.x, s.y = e.y, s.width = e.width, s.height = e.height) : t.bounds = e.copy();
        return;
      }
      const i = this.node;
      if (i !== null) {
        const e = this.bounds;
        if (!(i instanceof Group2)) {
          const s = Rect2.a();
          i.ensureBounds();
          const n = this.network.layout.getLayoutBounds(i, s), o = i.locationObject.getDocumentPoint(Spot2.Center);
          if (n.isReal() && o.isReal()) {
            i.moveTo(e.x + this.focusX - (o.x - n.x), e.y + this.focusY - (o.y - n.y)), Rect2.o(s);
            return;
          }
          Rect2.o(s);
        }
        i.moveTo(e.x, e.y);
      }
    }
    addSourceEdge(t) {
      t !== null && (Debug && Util.s(t, LayoutEdge2, LayoutVertex2, "addSourceEdge:edge"), this.rr.contains(t) || this.rr.add(t));
    }
    deleteSourceEdge(t) {
      t !== null && (Debug && Util.s(t, LayoutEdge2, LayoutVertex2, "deleteSourceEdge:edge"), this.rr.remove(t));
    }
    addDestinationEdge(t) {
      t !== null && (Debug && Util.s(t, LayoutEdge2, LayoutVertex2, "addDestinationEdge:edge"), this.lr.contains(t) || this.lr.add(t));
    }
    deleteDestinationEdge(t) {
      t !== null && (Debug && Util.s(t, LayoutEdge2, LayoutVertex2, "deleteDestinationEdge:edge"), this.lr.remove(t));
    }
    get network() {
      return this.ko;
    }
    set network(t) {
      Debug && Util.s(t, LayoutNetwork2, LayoutVertex2, "network"), this.ko = t;
    }
    get sourceVertexes() {
      const t = new GSet2(), i = this.sourceEdges;
      for (; i.next(); ) {
        const e = i.value;
        t.add(e.fromVertex);
      }
      return t.iterator;
    }
    get destinationVertexes() {
      const t = new GSet2(), i = this.destinationEdges;
      for (; i.next(); ) {
        const e = i.value;
        t.add(e.toVertex);
      }
      return t.iterator;
    }
    get vertexes() {
      const t = new GSet2();
      let i = this.sourceEdges;
      for (; i.next(); ) {
        const e = i.value;
        t.add(e.fromVertex);
      }
      for (i = this.destinationEdges; i.next(); ) {
        const e = i.value;
        t.add(e.toVertex);
      }
      return t.iterator;
    }
    get sourceEdges() {
      return this.rr.iterator;
    }
    get destinationEdges() {
      return this.lr.iterator;
    }
    get edges() {
      const t = new List2();
      let i = this.sourceEdges;
      for (; i.next(); ) {
        const e = i.value;
        t.add(e);
      }
      for (i = this.destinationEdges; i.next(); ) {
        const e = i.value;
        t.add(e);
      }
      return t.iterator;
    }
    get edgesCount() {
      return this.rr.count + this.lr.count;
    }
    static standardComparer(t, i) {
      Debug && Util.s(t, LayoutVertex2, LayoutVertex2, "standardComparer:m"), Debug && Util.s(i, LayoutVertex2, LayoutVertex2, "standardComparer:n");
      const e = t.be, s = i.be;
      if (e)
        if (s) {
          const n = e.text, o = s.text;
          return n < o ? -1 : n > o ? 1 : 0;
        } else
          return 1;
      else
        return s !== null ? -1 : 0;
    }
    static smartComparer(t, i) {
      if (Debug && Util.s(t, LayoutVertex2, LayoutVertex2, "smartComparer:m"), Debug && Util.s(i, LayoutVertex2, LayoutVertex2, "smartComparer:n"), t !== null)
        if (i !== null) {
          const e = t.be, s = i.be;
          if (e !== null)
            if (s !== null) {
              const n = e.text.toLocaleLowerCase(), o = s.text.toLocaleLowerCase(), r = n.split(/([+-]?[.]?\d+(?:\.\d*)?(?:e[+-]?\d+)?)/), l = o.split(/([+-]?[.]?\d+(?:\.\d*)?(?:e[+-]?\d+)?)/);
              let h = 0;
              for (; h < r.length; h++)
                if (l[h] !== "" && l[h] !== void 0) {
                  const a = parseFloat(r[h]), f = parseFloat(l[h]);
                  if (isNaN(a))
                    if (isNaN(f)) {
                      if (r[h].localeCompare(l[h]) !== 0)
                        return r[h].localeCompare(l[h]);
                      continue;
                    } else
                      return 1;
                  else {
                    if (isNaN(f))
                      return -1;
                    if (a - f !== 0)
                      return a - f;
                    continue;
                  }
                } else {
                  if (r[h] === "")
                    continue;
                  return 1;
                }
              return l[h] !== "" && l[h] !== void 0 ? -1 : 0;
            } else
              return 1;
          else
            return s !== null ? -1 : 0;
        } else
          return 1;
      else
        return i !== null ? -1 : 0;
    }
  }
  class LayoutEdge2 {
    constructor(t) {
      __publicField(this, "ko");
      __publicField(this, "si");
      __publicField(this, "_e");
      __publicField(this, "is");
      __publicField(this, "es");
      GSet2.ji(this), Debug && !t && Util.n("LayoutEdge constructor requires non-null LayoutNetwork argument"), this.ko = t, this.si = null, this._e = null, this.is = null, this.es = null;
    }
    clear() {
      this.si = null, this._e = null, this.is = null, this.es = null;
    }
    toString(t) {
      t === void 0 && (t = 0);
      let i = "LayoutEdge#" + GSet2.ps(this);
      return t > 0 && (i += this._e !== null ? "(" + this._e.toString() + ")" : "", t > 1 && (i += " " + (this.is ? this.is.toString() : "null") + " --> " + (this.es ? this.es.toString() : "null"))), i;
    }
    reverseEdge() {
      const t = this.is;
      this.is = this.es, this.es = t;
    }
    commit() {
    }
    getOtherVertex(t) {
      return Debug && Util.s(t, LayoutVertex2, LayoutEdge2, "getOtherVertex:v"), this.es === t ? this.is : this.is === t ? this.es : null;
    }
    get network() {
      return this.ko;
    }
    set network(t) {
      Debug && Util.s(t, LayoutNetwork2, LayoutEdge2, "network"), this.ko = t;
    }
    get data() {
      return this.si;
    }
    set data(t) {
      this.si !== t && (Debug && t !== null && Util.t(t, "object", LayoutEdge2, "data"), this.si = t);
    }
    get link() {
      return this._e;
    }
    set link(t) {
      this._e !== t && (Debug && t !== null && Util.s(t, Link2, LayoutEdge2, "link"), this._e = t);
    }
    get fromVertex() {
      return this.is;
    }
    set fromVertex(t) {
      this.is !== t && (Debug && t !== null && Util.s(t, LayoutVertex2, LayoutEdge2, "fromVertex"), this.is = t);
    }
    get toVertex() {
      return this.es;
    }
    set toVertex(t) {
      this.es !== t && (Debug && t !== null && Util.s(t, LayoutVertex2, LayoutEdge2, "toVertex"), this.es = t);
    }
  }
  var GridAlignment2 = ((w) => (w[w.Position = 0] = "Position", w[w.Location = 1] = "Location", w))(GridAlignment2 || {}), GridArrangement2 = ((w) => (w[w.LeftToRight = 10] = "LeftToRight", w[w.RightToLeft = 11] = "RightToLeft", w))(GridArrangement2 || {}), GridSorting2 = ((w) => (w[w.Forwards = 20] = "Forwards", w[w.Reverse = 21] = "Reverse", w[w.Ascending = 22] = "Ascending", w[w.Descending = 23] = "Descending", w))(GridSorting2 || {});
  const _GridLayout = class _GridLayout extends Layout2 {
    constructor(t) {
      super();
      __publicField(this, "sg");
      __publicField(this, "ng");
      __publicField(this, "Oo");
      __publicField(this, "On");
      __publicField(this, "fi");
      __publicField(this, "vi");
      __publicField(this, "Pe");
      __publicField(this, "Ne");
      this.isViewportSized = true, this.sg = NaN, this.ng = NaN, this.Oo = new Size2(NaN, NaN).w(), this.On = new Size2(10, 10).w(), this.fi = 1, this.vi = 10, this.Pe = 22, this.Ne = _GridLayout.standardComparer, t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.sg = this.sg, t.ng = this.ng, t.Oo.c(this.Oo), t.On.c(this.On), t.fi = this.fi, t.vi = this.vi, t.Pe = this.Pe, t.Ne = this.Ne;
    }
    ci(t) {
      t in GridSorting2 ? this.sorting = t : t in GridArrangement2 ? this.arrangement = t : t in GridAlignment2 ? this.alignment = t : super.ci(t);
    }
    doLayout(t) {
      Debug && t === null && Util.n("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"), this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
      const i = this.collectParts(t), e = this.diagram, n = i.copy().iterator;
      for (; n.next(); ) {
        const m = n.value;
        if (m.Il() && (m.fromNode !== null || m.toNode !== null)) {
          i.remove(m);
          continue;
        }
        if (m.ensureBounds(), m instanceof Group2) {
          const g = m.memberParts;
          for (; g.next(); ) {
            const p = g.value;
            i.remove(p);
          }
        }
      }
      const o = i.toArray();
      if (o.length === 0)
        return;
      switch (this.sorting) {
        case 20:
          break;
        case 21:
          o.reverse();
          break;
        case 22:
          o.sort(this.comparer);
          break;
        case 23:
          o.sort(this.comparer), o.reverse();
          break;
      }
      let r = this.wrappingColumn;
      isNaN(r) && (r = 0);
      let l = this.wrappingWidth;
      if (isNaN(l) && e !== null) {
        const m = e.viewportBounds, g = e.padding;
        l = Math.max(m.width - g.left - g.right, 0);
      } else
        l = Math.max(this.wrappingWidth, 0);
      r <= 0 && l <= 0 && (r = 1);
      let h = this.spacing.width;
      isFinite(h) || (h = 0);
      let a = this.spacing.height;
      isFinite(a) || (a = 0), e !== null && e.startTransaction("Layout");
      const f = [];
      switch (this.alignment) {
        case 0:
          this.AO(o, l, r, h, a, f);
          break;
        case 1:
          this.LO(o, l, r, h, a, f);
          break;
      }
      let c = 0, u = 0, d = 0;
      for (let m = 0; m < f.length; m++) {
        const g = f[m];
        c = Math.min(c, g.x), u = Math.min(u, g.y), d = Math.max(d, g.x + g.width);
      }
      this.arrangement === 11 ? this.commitLayers(f, new Point2(c + h / 2 - (d + c), u - a / 2)) : this.commitLayers(f, new Point2(c - h / 2, u - a / 2)), e !== null && e.commitTransaction("Layout"), this.isValidLayout = true;
    }
    AO(t, i, e, s, n, o) {
      const r = Rect2.a();
      let l = Math.max(this.cellSize.width, 1);
      if (!isFinite(l)) {
        l = 0;
        for (let p = 0; p < t.length; p++) {
          const y = t[p], x = this.getLayoutBounds(y, r);
          l = Math.max(l, x.width);
        }
      }
      l += s, l = Math.max(l, 1);
      let h = Math.max(this.cellSize.height, 1);
      if (!isFinite(h)) {
        h = 0;
        for (let p = 0; p < t.length; p++) {
          const y = t[p], x = this.getLayoutBounds(y, r);
          h = Math.max(h, x.height);
        }
      }
      h += n, h = Math.max(h, 1);
      const a = this.arrangement, f = this.arrangementOrigin.x, c = this.arrangementOrigin.y;
      let u = f, d = c, m = 0, g = 0;
      for (let p = 0; p < t.length; p++) {
        const y = t[p], x = this.getLayoutBounds(y, r), b = Math.ceil((x.width + s) / l), k = Math.ceil((x.height + n) / h), S = b * l, M = k * h;
        let A = 0;
        switch (a) {
          case 11:
            A = Math.abs(u - x.width);
            break;
          default:
            A = u + x.width;
            break;
        }
        (e > 0 && m > e - 1 || i > 0 && m > 0 && A - f > i) && (o.push(new Rect2(0, d, i + s, g)), m = 0, u = f, d += g, g = 0), g = Math.max(g, M);
        let C = 0;
        switch (a) {
          case 11:
            C = -x.width;
            break;
          default:
            C = 0;
            break;
        }
        switch (y.moveTo(u + C, d), a) {
          case 11:
            u -= S;
            break;
          default:
            u += S;
            break;
        }
        m++;
      }
      o.push(new Rect2(0, d, i + s, g)), Rect2.o(r);
    }
    LO(t, i, e, s, n, o) {
      const r = Rect2.a();
      let l = Math.max(this.cellSize.width, 1), h = 0, a = 0, f = 0;
      const c = Point2.a();
      for (let C = 0; C < t.length; C++) {
        const P = t[C], N = this.getLayoutBounds(P, r), T = P.getRelativePoint(P.locationObject, P.locationSpot, c);
        h = Math.max(h, T.x), a = Math.max(a, N.width - T.x), f = Math.max(f, T.y);
      }
      const u = this.arrangement;
      switch (u) {
        case 11:
          h += s;
          break;
        default:
          a += s;
          break;
      }
      isFinite(l) ? l = Math.max(l + s, 1) : l = Math.max(h + a, 1);
      const d = this.arrangementOrigin.x, m = this.arrangementOrigin.y;
      let g = d, p = m, y = 0;
      i >= h && (i -= h);
      let x = 0, b = 0;
      const k = Math.max(this.cellSize.height, 1);
      f = 0;
      let S = 0, M = true;
      const A = Point2.a();
      for (let C = 0; C < t.length; C++) {
        const P = t[C], N = this.getLayoutBounds(P, r), T = P.getRelativePoint(P.locationObject, P.locationSpot, c);
        if (y > 0)
          switch (u) {
            case 11: {
              let D = (g - d - (N.width - T.x)) / l;
              Geo.q(Math.round(D), D) ? D = Math.round(D) : D = Math.floor(D), g = D * l + d;
              break;
            }
            default: {
              let D = (g - d + T.x) / l;
              Geo.q(Math.round(D), D) ? D = Math.round(D) : D = Math.ceil(D), g = D * l + d;
              break;
            }
          }
        else
          switch (u) {
            case 11:
              x = g + T.x + N.width;
              break;
            default:
              x = g - T.x;
              break;
          }
        let L = 0;
        switch (u) {
          case 11:
            L = -(g + T.x) + x;
            break;
          default:
            L = g + N.width - T.x - x;
            break;
        }
        if (e > 0 && y > e - 1 || i > 0 && y > 0 && L > i) {
          o.push(new Rect2(0, M ? p - f : p, i + s, S + f + n));
          for (let D = 0; D < y && C !== y; D++) {
            const F = t[C - y + D], R = F.getRelativePoint(F.locationObject, F.locationSpot, A);
            F.moveTo(F.position.x, F.position.y + f - R.y);
          }
          S += n, M ? p += S : p += S + f, f = 0, S = 0, y = 0, g = d, M = false;
        }
        switch (g === d && (u === 11 ? b = Math.max(b, N.width - T.x) : b = Math.min(b, -T.x)), f = Math.max(f, T.y), S = Math.max(S, N.height - T.y), isFinite(k) && (S = Math.max(S, Math.max(N.height, k) - T.y)), M ? P.moveTo(g - T.x, p - T.y) : P.moveTo(g - T.x, p), u) {
          case 11:
            g -= T.x + s;
            break;
          default:
            g += N.width - T.x + s;
            break;
        }
        y++;
      }
      if (o.push(new Rect2(0, p, i + s, (M ? S : S + f) + n)), t.length !== y)
        for (let C = 0; C < y; C++) {
          const P = t[t.length - y + C], N = P.getRelativePoint(P.locationObject, P.locationSpot, c);
          P.moveTo(P.position.x, P.position.y + f - N.y);
        }
      if (Point2.o(c), Point2.o(A), u === 11)
        for (let C = 0; C < o.length; C++) {
          const P = o[C];
          P.width += b, P.x -= b;
        }
      else
        for (let C = 0; C < o.length; C++) {
          const P = o[C];
          P.x > b && (P.width += P.x - b, P.x = b);
        }
      Rect2.o(r);
    }
    commitLayers(t, i) {
    }
    get wrappingWidth() {
      return this.sg;
    }
    set wrappingWidth(t) {
      this.sg !== t && (Util.t(t, "number", _GridLayout, "wrappingWidth"), (t > 0 || isNaN(t)) && (this.sg = t, this.isViewportSized = isNaN(t), this.invalidateLayout()));
    }
    get wrappingColumn() {
      return this.ng;
    }
    set wrappingColumn(t) {
      this.ng !== t && (Util.t(t, "number", _GridLayout, "wrappingColumn"), (t > 0 || isNaN(t)) && (this.ng = t, this.invalidateLayout()));
    }
    get cellSize() {
      return this.Oo;
    }
    set cellSize(t) {
      Util.s(t, Size2, _GridLayout, "cellSize"), this.Oo.equals(t) || (this.Oo.c(t), this.invalidateLayout());
    }
    get spacing() {
      return this.On;
    }
    set spacing(t) {
      Util.s(t, Size2, _GridLayout, "spacing"), this.On.equals(t) || (this.On.c(t), this.invalidateLayout());
    }
    get alignment() {
      return this.fi;
    }
    set alignment(t) {
      this.fi !== t && (Util.it(t, GridAlignment2, "GridAlignment"), (t === 1 || t === 0) && (this.fi = t, this.invalidateLayout()));
    }
    get arrangement() {
      return this.vi;
    }
    set arrangement(t) {
      this.vi !== t && (Util.it(t, GridArrangement2, "GridArrangement"), (t === 10 || t === 11) && (this.vi = t, this.invalidateLayout()));
    }
    get sorting() {
      return this.Pe;
    }
    set sorting(t) {
      this.Pe !== t && (Util.it(t, GridSorting2, "GridSorting"), (t === 20 || t === 21 || t === 22 || t === 23) && (this.Pe = t, this.invalidateLayout()));
    }
    get comparer() {
      return this.Ne;
    }
    set comparer(t) {
      this.Ne !== t && (Util.t(t, "function", _GridLayout, "comparer"), this.Ne = t, this.invalidateLayout());
    }
    static standardComparer(t, i) {
      Debug && Util.s(t, Part2, _GridLayout, "standardComparer:a"), Debug && Util.s(i, Part2, _GridLayout, "standardComparer:b");
      const e = t.text, s = i.text;
      return e < s ? -1 : e > s ? 1 : 0;
    }
    static smartComparer(t, i) {
      if (Debug && Util.s(t, Part2, _GridLayout, "standardComparer:a"), Debug && Util.s(i, Part2, _GridLayout, "standardComparer:b"), t !== null)
        if (i !== null) {
          const e = t.text.toLocaleLowerCase(), s = i.text.toLocaleLowerCase(), n = e.split(/([+-]?[.]?\d+(?:\.\d*)?(?:e[+-]?\d+)?)/), o = s.split(/([+-]?[.]?\d+(?:\.\d*)?(?:e[+-]?\d+)?)/);
          let r = 0;
          for (; r < n.length; r++)
            if (o[r] !== "" && o[r] !== void 0) {
              const l = parseFloat(n[r]), h = parseFloat(o[r]);
              if (isNaN(l))
                if (isNaN(h)) {
                  if (n[r].localeCompare(o[r]) !== 0)
                    return n[r].localeCompare(o[r]);
                  continue;
                } else
                  return 1;
              else {
                if (isNaN(h))
                  return -1;
                if (l - h !== 0)
                  return l - h;
                continue;
              }
            } else {
              if (n[r] === "")
                continue;
              return 1;
            }
          return o[r] !== "" && o[r] !== void 0 ? -1 : 0;
        } else
          return 1;
      else
        return i !== null ? -1 : 0;
    }
  };
  __publicField(_GridLayout, "Position", 0);
  __publicField(_GridLayout, "Location", 1);
  __publicField(_GridLayout, "LeftToRight", 10);
  __publicField(_GridLayout, "RightToLeft", 11);
  __publicField(_GridLayout, "Forward", 20);
  __publicField(_GridLayout, "Reverse", 21);
  __publicField(_GridLayout, "Ascending", 22);
  __publicField(_GridLayout, "Descending", 23);
  let GridLayout2 = _GridLayout;
  const _PartManager = class _PartManager {
    constructor() {
      __publicField(this, "og");
      __publicField(this, "_s");
      __publicField(this, "It");
      __publicField(this, "Ga");
      __publicField(this, "b");
      __publicField(this, "Ty");
      __publicField(this, "Po");
      __publicField(this, "bl");
      __publicField(this, "wN");
      this.og = new GSet2(), this._s = new GSet2(), this.It = new GSet2(), this.Po = new GMap2(), this.bl = new GMap2(), this.Ga = new GMap2(), this.b = null, this.Ty = false, this.wN = true;
    }
    clear() {
      this.og.clear(), this._s.clear(), this.It.clear(), this.Po.clear(), this.bl.clear(), this.Ga.clear();
    }
    Vo(t) {
      Debug && t !== null && Util.s(t, Diagram2, _PartManager, "setDiagram"), this.b = t;
    }
    Qh(t) {
      if (t instanceof Node2) {
        if (this.og.add(t), t instanceof Group2) {
          const e = t.containingGroup;
          e === null ? this.b.Zr.add(t) : e.ua.add(t);
          const s = t.layout;
          s !== null && (s.diagram = this.b);
        }
      } else
        t instanceof Link2 ? this._s.add(t) : t instanceof Adornment2 || this.It.add(t);
      const i = t.data;
      i !== null && (t instanceof Adornment2 || (t instanceof Link2 ? this.mT(i, t) : this.Po.add(i, t)));
    }
    re(t) {
      if (t.clearAdornments(), t instanceof Node2) {
        if (this.og.remove(t), t instanceof Group2) {
          const e = t.containingGroup;
          e === null ? this.b.Zr.remove(t) : e.ua.remove(t);
          const s = t.layout;
          s !== null && (s.diagram = null);
        }
      } else
        t instanceof Link2 ? this._s.remove(t) : t instanceof Adornment2 || this.It.remove(t);
      const i = t.data;
      i !== null && (t instanceof Adornment2 || (t instanceof Link2 ? this.pT(i, t) : this.Po.remove(i)));
    }
    mT(t, i) {
      this.bl.add(t, i);
    }
    pT(t, i) {
      this.bl.remove(t);
    }
    rebuildParts() {
      const t = this.b;
      if (t === null)
        return;
      const i = t.nodeTemplateMap.iterator;
      for (; i.next(); ) {
        const a = i.value, f = i.key;
        (!a.De() || a instanceof Group2) && Util.n(`Invalid node template in Diagram.nodeTemplateMap: template for "${f}" must be a Node or a simple Part, not a Group or Link: ${a}`);
      }
      const e = t.groupTemplateMap.iterator;
      for (; e.next(); ) {
        const a = e.value, f = e.key;
        a instanceof Group2 || Util.n(`Invalid group template in Diagram.groupTemplateMap: template for "${f}" must be a Group, not a normal Node or Link: ${a}`);
      }
      const s = t.linkTemplateMap.iterator;
      for (; s.next(); ) {
        const a = s.value, f = s.key;
        a instanceof Link2 || Util.n(`Invalid link template in Diagram.linkTemplateMap: template for "${f}" must be a Link, not a normal Node or simple Part: ${a}`);
      }
      const n = Util.ct(), o = t.selection.iterator;
      for (; o.next(); ) {
        const f = o.value.data;
        f && n.push(f);
      }
      const r = Util.ct(), l = t.highlighteds.iterator;
      for (; l.next(); ) {
        const f = l.value.data;
        f && r.push(f);
      }
      const h = Util.ct();
      if (this.preservesRebuildLocations) {
        const a = this.nodes.iterator;
        for (; a.next(); ) {
          const u = a.value;
          u.data !== null && (h.push(u.data), h.push(u.location));
        }
        const f = this.links.iterator;
        for (; f.next(); ) {
          const u = f.value;
          u.data !== null && (h.push(u.data), h.push(u.location));
        }
        const c = this.parts.iterator;
        for (; c.next(); ) {
          const u = c.value;
          u.data !== null && (h.push(u.data), h.push(u.location));
        }
      }
      this.yT(), this.RP();
      for (let a = 0; a < n.length; a++) {
        const f = this.findPartForData(n[a]);
        f !== null && (f.isSelected = true);
      }
      for (let a = 0; a < r.length; a++) {
        const f = this.findPartForData(r[a]);
        f !== null && (f.isHighlighted = true);
      }
      if (this.preservesRebuildLocations)
        for (let a = 0; a < h.length; a += 2) {
          const f = this.findPartForData(h[a]);
          f !== null && (f.location = h[a + 1]);
        }
      Util.ot(n), Util.ot(r), Util.ot(h);
    }
    RP() {
      const t = this.diagram.model;
      this.Dy(t.nodeDataArray);
    }
    Dy(t, i) {
      const e = this.diagram.model;
      t.forEach((s) => {
        e.containsNodeData(s) && this.wT(s, false);
      }), t.forEach((s) => {
        e.containsNodeData(s) && this.Fb(s);
      }), i !== false && this.diagram.F1(false);
    }
    wT(t, i) {
      if (t == null || this.diagram.undoManager.isUndoingRedoing || this.Po.contains(t))
        return null;
      i === void 0 && (i = true);
      const e = this.TO(t);
      return e !== null && i && this.Fb(t), e;
    }
    TO(t) {
      if (t == null || this.b.undoManager.isUndoingRedoing || this.Po.contains(t))
        return null;
      const i = this.DO(t), e = this.findTemplateForNodeData(t, i);
      if (e !== null) {
        e.ui();
        const s = e.copy();
        if (s !== null) {
          const n = this.diagram.xe;
          return this.diagram.xe = true, s._o = i, s.si = t, this.Ty && (s.ml = "Tool"), this.diagram.add(s), s.si = null, s.data = t, this.diagram.xe = n, s;
        }
      }
      return null;
    }
    insertLink(t, i, e, s) {
      return null;
    }
    Fb(t) {
    }
    DO(t) {
      return this.b.model.getCategoryForNodeData(t);
    }
    findTemplateForNodeData(t, i) {
      const e = this.b, s = e.model, n = s.ma() && s.isGroupForData(t);
      let o = null;
      return n ? (o = e.groupTemplateMap.getValue(i), o === null && (o = e.groupTemplateMap.getValue(""), o === null && (_PartManager.bT || (_PartManager.bT = true, Util.ft('No Group template found for category "' + i + '"'), Util.ft("  Using default group template")), o = e.OF))) : (o = e.nodeTemplateMap.getValue(i), o === null && (o = e.nodeTemplateMap.getValue(""), o === null && (_PartManager.xT || (_PartManager.xT = true, Util.ft('No Node template found for category "' + i + '"'), Util.ft("  Using default node template")), o = e.RF))), o;
    }
    getLinkCategoryForData(t) {
      return "";
    }
    setLinkCategoryForData(t, i) {
    }
    setFromNodeForLink(t, i, e) {
    }
    setToNodeForLink(t, i, e) {
    }
    findLinkTemplateForCategory(t) {
      const i = this.b;
      let e = i.linkTemplateMap.getValue(t);
      return e === null && (e = i.linkTemplateMap.getValue(""), e === null && (_PartManager.kT || (_PartManager.kT = true, Util.ft('No Link template found for category "' + t + '"'), Util.ft("  Using default link template")), e = i.IF)), e;
    }
    yI(t, i, e) {
      t instanceof Link2 ? (i !== null && this.pT(i, t), e !== null && this.mT(e, t)) : t instanceof Part2 && (i !== null && this.Po.remove(i), e !== null && this.Po.add(e, t));
    }
    yT() {
      const t = this.diagram.model;
      this.xN(t.nodeDataArray);
    }
    xN(t) {
      t.forEach((i) => {
        this.Rb(i);
      });
    }
    Rb(t) {
      const i = this.findPartForData(t);
      i !== null && (this.diagram.DP(i, false), this.bN(i));
    }
    bN(t) {
    }
    fN(t) {
    }
    findPartForKey(t) {
      if (t == null)
        return null;
      const i = this.b.model.findNodeDataForKey(t);
      return i !== null ? this.Po.getValue(i) : null;
    }
    findNodeForKey(t) {
      if (t == null)
        return null;
      const i = this.b.model.findNodeDataForKey(t);
      if (i === null)
        return null;
      const e = this.Po.getValue(i);
      return e instanceof Node2 ? e : null;
    }
    findLinkForKey(t) {
      return null;
    }
    findPartForData(t) {
      if (t === null)
        return null;
      let i = this.Po.getValue(t);
      return i !== null || (i = this.bl.getValue(t)), i;
    }
    findNodeForData(t) {
      if (t === null)
        return null;
      const i = this.Po.getValue(t);
      return i instanceof Node2 ? i : null;
    }
    findLinkForData(t, i) {
      return t === null ? null : this.bl.getValue(t);
    }
    findNodesByExample(...t) {
      const i = new GSet2(), e = this.og.iterator;
      for (; e.next(); ) {
        const s = e.value, n = s.data;
        if (n !== null)
          for (let o = 0; o < arguments.length; o++) {
            const r = arguments[o];
            if (Util.Mt(r) && this.kN(n, r)) {
              i.add(s);
              break;
            }
          }
      }
      return i.iterator;
    }
    findLinksByExample(...t) {
      const i = new GSet2(), e = this._s.iterator;
      for (; e.next(); ) {
        const s = e.value, n = s.data;
        if (n !== null)
          for (let o = 0; o < arguments.length; o++) {
            const r = arguments[o];
            if (Util.Mt(r) && this.kN(n, r)) {
              i.add(s);
              break;
            }
          }
      }
      return i.iterator;
    }
    kN(t, i) {
      for (const e in i) {
        const s = t[e], n = i[e];
        if (Array.isArray(n)) {
          if (!Array.isArray(s))
            return false;
          const o = s, r = n;
          if (o.length < r.length)
            return false;
          for (let l = 0; l < o.length; l++) {
            const h = o[l], a = r[l];
            if (a !== void 0 && !this.ST(h, a))
              return false;
          }
        } else if (!this.ST(s, n))
          return false;
      }
      return true;
    }
    ST(t, i) {
      if (typeof i == "function") {
        if (!i(t))
          return false;
      } else if (i instanceof RegExp) {
        if (!t || !i.test(t.toString()))
          return false;
      } else if (Util.Mt(t) && Util.Mt(i)) {
        if (!this.kN(t, i))
          return false;
      } else if (t !== i)
        return false;
      return true;
    }
    doModelDataChanged(t) {
      if (t.model === this.diagram.model && this.diagram.W) {
        this.diagram.W = false;
        try {
          const i = t.change;
          t.modelChange === "" && i === 2 && this.Fy(t.object, t.propertyName);
        } finally {
          this.diagram.W = true;
        }
      }
    }
    doModelChanged(t) {
      if (!this.b)
        return;
      const i = this.b;
      if (t.model !== i.model)
        return;
      const e = t.change;
      if (i.bR(t), !!i.W) {
        i.W = false;
        try {
          const s = t.modelChange;
          if (s !== "")
            if (e === 2) {
              if (s === "nodeCategory") {
                const n = t.object, o = this.findPartForData(n), r = t.newValue;
                o !== null && typeof r == "string" && (o.category = r);
              } else if (s === "nodeDataArray") {
                const n = t.oldValue;
                this.xN(n);
                const o = t.newValue;
                this.Dy(o);
              }
              i.isModified = true;
            } else if (e === 3) {
              const n = t.newValue;
              s === "nodeDataArray" && Util.Mt(n) && this.wT(n), i.isModified = true;
            } else if (e === 4) {
              const n = t.oldValue;
              s === "nodeDataArray" && Util.Mt(n) && this.Rb(n), i.isModified = true;
            } else
              e === 1 && (s === "SourceChanged" ? t.object !== null ? this.Fy(t.object, t.propertyName) : (this.updateAllRelationshipsFromData(), this.updateAllTargetBindings()) : s === "ModelDisplaced" && this.rebuildParts());
          else if (e === 2) {
            const n = t.propertyName, o = t.object, r = i.model;
            o === r ? (n === "nodeKeyProperty" || n === "nodeCategoryProperty") && (i.undoManager.isUndoingRedoing || this.rebuildParts()) : this.Fy(o, n), i.isModified = true;
          } else
            (e === 3 || e === 4) && (this.FO(t), i.isModified = true);
        } finally {
          i.W = true;
        }
      }
    }
    updateAllTargetBindings(t) {
      t === void 0 && (t = "");
      let i = this.parts.iterator;
      for (; i.next(); )
        i.value.updateTargetBindings(t);
      for (i = this.nodes.iterator; i.next(); )
        i.value.updateTargetBindings(t);
      for (i = this.links.iterator; i.next(); )
        i.value.updateTargetBindings(t);
    }
    updateAllThemeBindings() {
      let t = this.parts.iterator;
      for (; t.next(); )
        t.value.Uo();
      for (t = this.nodes.iterator; t.next(); )
        t.value.Uo();
      for (t = this.links.iterator; t.next(); )
        t.value.Uo();
    }
    updateAllRelationshipsFromData() {
      const t = this.b.model, i = new GSet2(), e = t.nodeDataArray;
      for (let o = 0; o < e.length; o++) {
        const r = e[o];
        i.add(r);
      }
      const s = [];
      this.nodes.each((o) => {
        o.data !== null && !i.contains(o.data) && s.push(o.data);
      }), this.parts.each((o) => {
        o.data !== null && !i.contains(o.data) && s.push(o.data);
      }), s.forEach((o) => t.MT(o, false));
      for (let o = 0; o < e.length; o++) {
        const r = e[o];
        this.findPartForData(r) === null && t.PT(r, false);
      }
      this.NT();
      let n = this.parts.iterator;
      for (; n.next(); )
        n.value.updateRelationshipsFromData();
      for (n = this.nodes.iterator; n.next(); )
        n.value.updateRelationshipsFromData();
      for (n = this.links.iterator; n.next(); )
        n.value.updateRelationshipsFromData();
    }
    NT() {
    }
    updateRelationshipsFromData(t) {
    }
    Fy(t, i) {
      if (typeof i == "string") {
        const e = this.findPartForData(t);
        if (e !== null)
          e.updateTargetBindings(i);
        else {
          const s = this.RO(t);
          if (s !== null) {
            for (let n = 0; n < s.length; n++)
              s[n].updateTargetBindings(i);
            Util.ot(s);
          }
        }
        t === this.diagram.model.modelData && this.updateAllTargetBindings(i);
      }
    }
    RO(t) {
      let i = null;
      const e = this.Ga.iterator;
      for (; e.next(); ) {
        const s = e.value;
        for (let n = 0; n < s.length; n++) {
          const r = s[n].findItemPanelForData(t);
          r !== null && (i === null && (i = Util.ct()), i.push(r));
        }
        if (i !== null)
          break;
      }
      return i;
    }
    FO(t) {
      const i = t.object, e = t.change === 3, s = e ? t.newParam : t.oldParam, n = e ? t.newValue : t.oldValue, o = this.Ga.getValue(i);
      if (Array.isArray(o))
        for (let r = 0; r < o.length; r++) {
          const l = o[r];
          e ? l.ob(n, s, true) : l.xI(s);
        }
    }
    LP(t, i) {
      i !== null && t.il((s) => i.CA(s));
      const e = t.bh;
      if (Array.isArray(e)) {
        const s = this.Ga.getValue(e);
        if (s === null) {
          const n = [];
          n.push(t), this.Ga.add(e, n);
        } else {
          for (let n = 0; n < s.length; n++)
            if (s[n] === t)
              return;
          s.push(t);
        }
      }
    }
    TP(t, i) {
      t.il((s) => i.SR(s));
      const e = t.bh;
      if (Array.isArray(e)) {
        const s = this.Ga.getValue(e);
        if (s !== null) {
          for (let n = 0; n < s.length; n++)
            if (s[n] === t) {
              s.splice(n, 1), s.length === 0 && this.Ga.remove(e);
              return;
            }
        }
      }
    }
    copyParts(t, i, e) {
      e === void 0 && (e = false);
      const s = new GMap2();
      if (Array.isArray(t))
        for (let o = 0; o < t.length; o++)
          this.Ib(t[o], i, s, e);
      else {
        const o = t.iterator;
        for (; o.next(); )
          this.Ib(o.value, i, s, e);
      }
      if (i !== null) {
        const o = i.model, r = i.y0().dragsLink, l = new GSet2(), h = new GMap2(), a = s.iterator;
        for (; a.next(); ) {
          const f = a.value;
          if (f instanceof Link2)
            !r && (f.fromNode === null || f.toNode === null) && l.add(f);
          else if (f instanceof Node2 && f.data !== null) {
            if (o.Qu()) {
              const c = f, u = a.key, d = u.findTreeParentNode();
              if (d !== null) {
                const m = s.getValue(d);
                if (m !== null) {
                  o.setParentKeyForNodeData(c.data, o.getKeyForNodeData(m.data));
                  const g = i.findLinkForData(c.data), p = u.findTreeParentLink();
                  p !== null && g !== null && h.add(p, g);
                } else
                  o.setParentKeyForNodeData(c.data, void 0);
              }
            } else if (o._u()) {
              const c = f, u = a.key, d = o.isRelatedKeysPathTo ? u.findNodesOutOf() : u.findNodesInto();
              for (; d.next(); ) {
                const m = d.value, g = s.getValue(m);
                if (g !== null) {
                  o.addRelatedKeyForNodeData(c.data, g.key);
                  const p = i.partManager.findLinkForData(c.data, g.key), y = this.findLinkForData(u.data, m.key);
                  y !== null && p !== null && h.add(y, p);
                } else
                  o.removeRelatedKeyForNodeData(c.data, m.key);
              }
            }
          }
        }
        if (l.count > 0 && i.removeParts(l, false), h.count > 0) {
          const f = h.iterator;
          for (; f.next(); ) {
            const c = f.key, u = f.value;
            s.add(c, u);
          }
        }
      }
      if (i !== null && this.b !== null) {
        const o = i.model, r = o.afterCopyFunction;
        if (r !== null) {
          const l = new GMap2();
          s.each((a) => {
            a.key.data !== null && l.add(a.key.data, a.value.data);
          });
          const h = this.b.model;
          r(l, o, h);
        }
      }
      const n = s.iterator;
      for (; n.next(); )
        n.value.updateTargetBindings();
      return s;
    }
    Ib(t, i, e, s) {
      if (t === null || s && !t.canCopy())
        return null;
      if (e.contains(t))
        return e.getValue(t);
      const n = this.SN(t, i);
      if (!(n instanceof Part2))
        return null;
      if (n.isSelected = false, n.isHighlighted = false, e.add(t, n), t instanceof Node2) {
        const o = t.linksConnected;
        for (; o.next(); ) {
          const r = o.value;
          if (r.fromNode === t) {
            const l = e.getValue(r);
            l !== null && (l.fromNode = n);
          }
          if (r.toNode === t) {
            const l = e.getValue(r);
            l !== null && (l.toNode = n);
          }
        }
        if (t instanceof Group2 && n instanceof Group2) {
          const r = t.memberParts;
          for (; r.next(); ) {
            const l = r.value, h = this.Ib(l, i, e, s);
            h instanceof Link2 || h !== null && (h.containingGroup = n);
          }
        }
      } else if (t instanceof Link2 && n instanceof Link2) {
        const o = t.fromNode;
        if (o !== null) {
          const h = e.getValue(o);
          h !== null && (n.fromNode = h);
        }
        const r = t.toNode;
        if (r !== null) {
          const h = e.getValue(r);
          h !== null && (n.toNode = h);
        }
        const l = t.labelNodes;
        for (; l.next(); ) {
          const h = l.value, a = this.Ib(h, i, e, s);
          a !== null && a instanceof Node2 && (a.labeledLink = n);
        }
      }
      return n;
    }
    SN(t, i) {
      let e = null;
      const s = t.data;
      if (s !== null && i !== null) {
        const n = i.model;
        if (!(t instanceof Link2)) {
          const o = n.copyNodeData(s);
          Util.Mt(o) && (n.addNodeData(o), e = i.findPartForData(o));
        }
      } else if (t.ui(), e = t.copy(), e !== null) {
        const n = this.b;
        if (i !== null)
          i.add(e);
        else if (s !== null && n !== null && n.commandHandler !== null && n.commandHandler.copiesClipboardData) {
          const o = n.model;
          let r = null;
          e instanceof Link2 || (r = o.copyNodeData(s)), Util.Mt(r) && (e.data = r);
        }
      }
      return e;
    }
    get nodes() {
      return this.og;
    }
    get links() {
      return this._s;
    }
    get parts() {
      return this.It;
    }
    get diagram() {
      return this.b;
    }
    get addsToTemporaryLayer() {
      return this.Ty;
    }
    set addsToTemporaryLayer(t) {
      this.Ty = t;
    }
    get preservesRebuildLocations() {
      return this.wN;
    }
    set preservesRebuildLocations(t) {
      this.wN = t;
    }
  };
  __publicField(_PartManager, "xT", false);
  __publicField(_PartManager, "bT", false);
  __publicField(_PartManager, "kT", false);
  let PartManager = _PartManager;
  class GraphLinksPartManager extends PartManager {
    RP() {
      const t = this.diagram.model;
      this.Dy(t.nodeDataArray), this.CT(t.linkDataArray);
    }
    Dy(t) {
      super.Dy(t, false);
      const i = this.links.iterator;
      for (; i.next(); )
        i.value.Ed();
      this.diagram.F1(false);
    }
    CT(t) {
      t.forEach((i) => {
        this.AT(i);
      }), this.diagram.F1(false);
    }
    AT(t) {
      if (t == null || this.diagram.undoManager.isUndoingRedoing || this.bl.contains(t))
        return null;
      const i = this.getLinkCategoryForData(t), e = this.findLinkTemplateForCategory(i);
      if (e !== null) {
        e.ui();
        const s = e.copy();
        if (s !== null) {
          const n = this.diagram.xe;
          this.diagram.xe = true, s._o = i, s.si = t;
          const o = this.diagram.model, r = o.Ob(t, true);
          r !== "" && (s.fromPortId = r);
          const l = o.ze(t, true);
          if (l !== void 0) {
            const c = this.findNodeForKey(l);
            c instanceof Node2 && (s.fromNode = c);
          }
          const h = o.Ob(t, false);
          h !== "" && (s.toPortId = h);
          const a = o.ze(t, false);
          if (a !== void 0) {
            const c = this.findNodeForKey(a);
            c instanceof Node2 && (s.toNode = c);
          }
          const f = o.getLabelKeysForLinkData(t);
          return Array.isArray(f) && f.forEach((c) => {
            const u = this.findNodeForKey(c);
            u !== null && (u.labeledLink = s);
          }), this.Ty && (s.ml = "Tool"), this.diagram.add(s), s.si = null, s.data = t, this.diagram.xe = n, s;
        }
      }
      return null;
    }
    yT() {
      const t = this.diagram.model;
      this.LT(t.linkDataArray), this.xN(t.nodeDataArray);
    }
    LT(t) {
      t.forEach((i) => {
        this.Rb(i);
      });
    }
    getLinkCategoryForData(t) {
      return this.diagram.model.getCategoryForLinkData(t);
    }
    setLinkCategoryForData(t, i) {
      return this.diagram.model.setCategoryForLinkData(t, i);
    }
    setFromNodeForLink(t, i) {
      const e = this.diagram.model, s = i !== null ? i.data : null;
      e.setFromKeyForLinkData(t.data, e.getKeyForNodeData(s));
    }
    setToNodeForLink(t, i) {
      const e = this.diagram.model, s = i !== null ? i.data : null;
      e.setToKeyForLinkData(t.data, e.getKeyForNodeData(s));
    }
    fN(t) {
      this.diagram.model.removeLinkData(t.data);
    }
    findPartForKey(t) {
      const i = super.findPartForKey(t);
      if (i === null) {
        const s = this.diagram.model.findLinkDataForKey(t);
        if (s !== null)
          return this.bl.getValue(s);
      }
      return i;
    }
    findLinkForKey(t) {
      if (t == null)
        return null;
      const e = this.diagram.model.findLinkDataForKey(t);
      return e !== null ? this.bl.getValue(e) : null;
    }
    doModelChanged(t) {
      if (super.doModelChanged(t), !this.diagram)
        return;
      const i = this.diagram;
      if (t.model !== i.model)
        return;
      const e = t.change;
      if (i.W) {
        i.W = false;
        try {
          const s = t.modelChange;
          if (s !== "") {
            if (e === 2) {
              if (s === "linkFromKey") {
                const n = t.object, o = this.findLinkForData(n);
                if (o !== null) {
                  const r = t.newValue, l = this.findNodeForKey(r);
                  o.fromNode = l;
                }
              } else if (s === "linkToKey") {
                const n = t.object, o = this.findLinkForData(n);
                if (o !== null) {
                  const r = t.newValue, l = this.findNodeForKey(r);
                  o.toNode = l;
                }
              } else if (s === "linkFromPortId") {
                const n = t.object, o = this.findLinkForData(n);
                if (o !== null) {
                  const r = t.newValue;
                  typeof r == "string" && (o.fromPortId = r);
                }
              } else if (s === "linkToPortId") {
                const n = t.object, o = this.findLinkForData(n);
                if (o !== null) {
                  const r = t.newValue;
                  typeof r == "string" && (o.toPortId = r);
                }
              } else if (s === "nodeGroupKey") {
                const n = t.object, o = this.findPartForData(n);
                if (o !== null) {
                  const r = t.newValue;
                  if (r !== void 0) {
                    const l = this.findNodeForKey(r);
                    l instanceof Group2 ? o.containingGroup = l : o.containingGroup = null;
                  } else
                    o.containingGroup = null;
                }
              } else if (s === "linkLabelKeys") {
                const n = t.object, o = this.findLinkForData(n);
                if (o !== null) {
                  const r = t.oldValue, l = t.newValue;
                  Array.isArray(r) && r.forEach((h) => {
                    if (l.indexOf(h) >= 0)
                      return;
                    const a = this.findNodeForKey(h);
                    a !== null && (a.labeledLink = null);
                  }), Array.isArray(l) && l.forEach((h) => {
                    const a = this.findNodeForKey(h);
                    a !== null && (a.labeledLink = o);
                  });
                }
              } else if (s === "linkCategory") {
                const n = t.object, o = this.findLinkForData(n), r = t.newValue;
                o !== null && typeof r == "string" && (o.category = r);
              } else if (s === "linkDataArray") {
                const n = t.oldValue;
                this.LT(n);
                const o = t.newValue;
                this.CT(o);
              }
              i.isModified = true;
            } else if (e === 3) {
              const n = t.newValue;
              if (s === "linkDataArray" && typeof n == "object" && n !== null)
                this.AT(n);
              else if (s === "linkLabelKeys" && t.model.isKeyType(n)) {
                const o = t.object, r = this.findLinkForData(o), l = this.findNodeForKey(n);
                r !== null && l !== null && (l.labeledLink = r);
              }
              i.isModified = true;
            } else if (e === 4) {
              const n = t.oldValue;
              if (s === "linkDataArray" && typeof n == "object" && n !== null)
                this.Rb(n);
              else if (s === "linkLabelKeys" && t.model.isKeyType(n)) {
                const o = this.findNodeForKey(n);
                o !== null && (o.labeledLink = null);
              }
              i.isModified = true;
            }
          } else if (e === 2) {
            const n = t.propertyName, o = t.object, r = i.model;
            o === r && (n === "linkFromKeyProperty" || n === "linkToKeyProperty" || n === "linkFromPortIdProperty" || n === "linkToPortIdProperty" || n === "linkLabelKeysProperty" || n === "nodeIsGroupProperty" || n === "nodeGroupKeyProperty" || n === "linkCategoryProperty") && (i.undoManager.isUndoingRedoing || this.rebuildParts()), i.isModified = true;
          }
        } finally {
          i.W = true;
        }
      }
    }
    NT() {
      const t = this.diagram.model, i = new GSet2(), e = t.linkDataArray;
      e.forEach((n) => {
        i.add(n);
      });
      const s = [];
      this.links.each((n) => {
        n.data !== null && !i.contains(n.data) && s.push(n.data);
      }), s.forEach((n) => {
        t.TT(n, false);
      }), e.forEach((n) => {
        this.findLinkForData(n) === null && t.DT(n, false);
      });
    }
    updateRelationshipsFromData(t) {
      const i = t.data;
      if (i === null)
        return;
      const e = t.diagram;
      if (e === null)
        return;
      const s = e.model;
      if (t instanceof Link2) {
        let n = s.ze(i, true), o = e.findNodeForKey(n);
        t.fromNode = o, n = s.ze(i, false), o = e.findNodeForKey(n), t.toNode = o;
        const r = s.getLabelKeysForLinkData(i);
        if (r.length > 0 || t.labelNodes.count > 0) {
          if (r.length === 1 && t.labelNodes.count === 1) {
            const c = r[0], u = t.labelNodes.first();
            if (s.getKeyForNodeData(u.data) === c)
              return;
          }
          const l = new GSet2().addAll(r), h = new GSet2();
          t.labelNodes.each((c) => {
            if (c.data !== null) {
              const u = s.getKeyForNodeData(c.data);
              u !== void 0 && h.add(u);
            }
          });
          const a = h.copy();
          a.removeAll(l);
          const f = l.copy();
          if (f.removeAll(h), a.count > 0 || f.count > 0) {
            const c = t;
            a.each((u) => {
              const d = e.findNodeForKey(u);
              d !== null && d.labeledLink === c && (d.labeledLink = null);
            }), f.each((u) => {
              const d = e.findNodeForKey(u);
              d !== null && d.labeledLink !== c && (d.labeledLink = c);
            });
          }
        }
      } else if (!(t instanceof Adornment2)) {
        const n = s.getGroupKeyForNodeData(i), o = e.findPartForKey(n);
        (o === null || o instanceof Group2) && (t.containingGroup = o);
      }
    }
    Fb(t) {
      const i = this.diagram.model, e = i.getKeyForNodeData(t);
      if (e !== void 0) {
        const s = i.Ry(e), n = this.findPartForData(t);
        if (s !== null && n !== null) {
          const r = s.iterator;
          for (; r.next(); ) {
            const l = r.value;
            if (i.containsNodeData(l)) {
              if (n instanceof Group2 && i.getGroupKeyForNodeData(l) === e) {
                const h = this.findPartForData(l);
                h !== null && (h.containingGroup = n);
              }
            } else {
              const h = this.findLinkForData(l);
              if (h !== null && n instanceof Node2) {
                i.ze(l, true) === e && (h.fromNode = n), i.ze(l, false) === e && (h.toNode = n);
                const a = i.getLabelKeysForLinkData(l);
                Array.isArray(a) && a.some((f) => f === e ? (n.labeledLink = h, true) : false);
              }
            }
          }
          i.en(e);
        }
        const o = i.getGroupKeyForNodeData(t);
        if (o !== void 0) {
          const r = this.findNodeForKey(o);
          r instanceof Group2 && (n.containingGroup = r);
        }
      }
    }
    bN(t) {
      const i = this.diagram.model;
      if (t instanceof Node2) {
        const e = i.getKeyForNodeData(t.data);
        if (e !== void 0) {
          const s = t.linksConnected;
          for (; s.next(); ) {
            const n = s.value;
            i.sn(e, n.data);
          }
          if (t.isLinkLabel) {
            const n = t.labeledLink;
            n !== null && i.sn(e, n.data);
          }
          if (t instanceof Group2) {
            const n = t.memberParts;
            for (; n.next(); ) {
              const r = n.value.data;
              i.containsNodeData(r) && i.sn(e, r);
            }
          }
        }
      }
    }
    SN(t, i) {
      let e = super.SN(t, i);
      if (t instanceof Link2) {
        const s = t.data;
        if (s !== null && i !== null) {
          const n = i.model, o = n.copyLinkData(s);
          typeof o == "object" && o !== null && (n.addLinkData(o), e = i.findLinkForData(o));
        } else if (e !== null) {
          const n = this.diagram;
          if (s !== null && n !== null && n.commandHandler !== null && n.commandHandler.copiesClipboardData) {
            const r = n.model.copyLinkData(s);
            typeof r == "object" && r !== null && (e.data = r);
          }
        }
      }
      return e;
    }
    insertLink(t, i, e, s) {
      const n = this.diagram, o = n.model, r = n.toolManager.findTool("Linking");
      let l = "";
      t !== null && (i === null && (i = t), l = i.portId, l === null && (l = ""));
      let h = "";
      e !== null && (s === null && (s = e), h = s.portId, h === null && (h = ""));
      const a = r.archetypeLinkData;
      if (a instanceof Link2) {
        a.ui();
        const f = a.copy();
        if (f !== null) {
          f.fromNode = t, f.fromPortId = l, f.toNode = e, f.toPortId = h, n.add(f);
          const c = r.archetypeLabelNodeData;
          if (c instanceof Node2) {
            c.ui();
            const u = c.copy();
            u !== null && (u.labeledLink = f, n.add(u));
          }
          return f;
        }
      } else if (a !== null) {
        const f = o.copyLinkData(a);
        if (typeof f == "object" && f !== null) {
          t !== null && o.rg(f, o.getKeyForNodeData(t.data), true), o.lg(f, l, true), e !== null && o.rg(f, o.getKeyForNodeData(e.data), false), o.lg(f, h, false), o.addLinkData(f);
          const c = r.archetypeLabelNodeData;
          if (c !== null && !(c instanceof Node2)) {
            const d = o.copyNodeData(c);
            if (typeof d == "object" && d !== null) {
              o.addNodeData(d);
              const m = o.getKeyForNodeData(d);
              m !== void 0 && o.addLabelKeyForLinkData(f, m);
            }
          }
          return n.findLinkForData(f);
        }
      }
      return null;
    }
  }
  class TreePartManager extends PartManager {
    constructor() {
      super(...arguments);
      __publicField(this, "Ah", null);
    }
    Eb(t, i) {
      if (t === null || i === null || i.findTreeParentLink() !== null)
        return null;
      const e = this.diagram.toolManager.findTool("Linking");
      let s = t, n = i;
      if (this.diagram.isTreePathToChildren) {
        if (e !== null && e.Cu(s, n, null, true))
          return null;
      } else if (s = i, n = t, e !== null && e.Cu(s, n, null, true))
        return null;
      const o = this.getLinkCategoryForData(i.data), r = this.findLinkTemplateForCategory(o);
      if (r !== null) {
        r.ui();
        const l = r.copy();
        if (l !== null) {
          const h = this.diagram.xe;
          return this.diagram.xe = true, l._o = o, l.si = i.data, l.fromNode = s, l.toNode = n, this.diagram.add(l), l.si = null, l.data = i.data, this.diagram.xe = h, l;
        }
      }
      return null;
    }
    getLinkCategoryForData(t) {
      return this.diagram.model.getParentLinkCategoryForNodeData(t);
    }
    setLinkCategoryForData(t, i) {
      this.diagram.model.setParentLinkCategoryForNodeData(t, i);
    }
    setFromNodeForLink(t, i, e) {
      const s = this.diagram.model;
      e === void 0 && (e = null);
      const n = i !== null ? i.data : null;
      if (this.diagram.isTreePathToChildren)
        s.setParentKeyForNodeData(t.data, s.getKeyForNodeData(n));
      else {
        const o = this.Ah;
        this.Ah = t, e !== null && s.setParentKeyForNodeData(e.data, void 0);
        const r = t.toNode !== null ? t.toNode.data : null;
        s.setParentKeyForNodeData(n, s.getKeyForNodeData(r)), this.Ah = o;
      }
    }
    setToNodeForLink(t, i, e) {
      const s = this.diagram.model;
      e === void 0 && (e = null);
      const n = i !== null ? i.data : null;
      if (this.diagram.isTreePathToChildren) {
        const o = this.Ah;
        this.Ah = t, e !== null && s.setParentKeyForNodeData(e.data, void 0);
        const r = t.fromNode !== null ? t.fromNode.data : null;
        s.setParentKeyForNodeData(n, s.getKeyForNodeData(r)), this.Ah = o;
      } else
        s.setParentKeyForNodeData(t.data, s.getKeyForNodeData(n));
    }
    fN(t) {
      this.diagram.model.setParentKeyForNodeData(t.data, void 0);
    }
    findLinkForKey(t) {
      if (t == null)
        return null;
      const e = this.diagram.model.findNodeDataForKey(t);
      return e !== null ? this.bl.getValue(e) : null;
    }
    doModelChanged(t) {
      if (super.doModelChanged(t), !this.diagram)
        return;
      const i = this.diagram;
      if (t.model !== i.model)
        return;
      const e = t.change;
      if (i.W) {
        i.W = false;
        try {
          const s = t.modelChange;
          if (s !== "") {
            if (e === 2) {
              if (s === "nodeParentKey") {
                const n = t.object, o = t.newValue, r = this.findNodeForKey(o), l = this.findNodeForData(n);
                if (this.Ah !== null)
                  r !== null && (this.Ah.data = n, this.Ah.category = this.getLinkCategoryForData(n));
                else if (l !== null) {
                  const h = l.findTreeParentLink();
                  h !== null ? r === null ? i.remove(h) : i.isTreePathToChildren ? h.fromNode = r : h.toNode = r : this.Eb(r, l);
                }
              } else if (s === "parentLinkCategory") {
                const n = t.object, o = this.findNodeForData(n), r = t.newValue;
                if (o !== null && typeof r == "string") {
                  const l = o.findTreeParentLink();
                  l !== null && (l.category = r);
                }
              }
              i.isModified = true;
            }
          } else if (e === 2) {
            const n = t.propertyName, o = t.object, r = i.model;
            o === r && n === "nodeParentKeyProperty" && (i.undoManager.isUndoingRedoing || this.rebuildParts()), i.isModified = true;
          }
        } finally {
          i.W = true;
        }
      }
    }
    updateRelationshipsFromData(t) {
      const i = t.data;
      if (i === null)
        return;
      const e = t.diagram;
      if (e === null)
        return;
      const s = e.model;
      if (t instanceof Node2) {
        const n = s.getParentKeyForNodeData(i), o = e.findNodeForKey(n), r = t.findTreeParentNode();
        if (o !== r) {
          const l = t.findTreeParentLink();
          o !== null ? l !== null ? e.isTreePathToChildren ? l.fromNode = o : l.toNode = o : this.Eb(o, t) : l !== null && e.DP(l, false);
        }
      }
    }
    Fy(t, i) {
      if (super.Fy(t, i), typeof i == "string" && this.findPartForData(t) !== null) {
        const s = this.findLinkForData(t);
        s !== null && s.updateTargetBindings(i);
      }
    }
    Fb(t) {
      const i = this.diagram.model, e = i.getKeyForNodeData(t);
      if (e !== void 0) {
        const s = i.Ry(e), n = this.findPartForData(t);
        if (s !== null && n !== null) {
          const r = s.iterator;
          for (; r.next(); ) {
            const l = r.value;
            if (i.containsNodeData(l) && n instanceof Node2 && i.getParentKeyForNodeData(l) === e) {
              const h = this.findNodeForData(l);
              this.Eb(n, h);
            }
          }
          i.en(e);
        }
        const o = i.getParentKeyForNodeData(t);
        if (o !== void 0 && n instanceof Node2) {
          const r = this.findNodeForKey(o);
          this.Eb(r, n);
        }
      }
    }
    bN(t) {
      const i = this.diagram.model;
      if (t instanceof Node2) {
        const e = i.getKeyForNodeData(t.data), s = this.findLinkForData(t.data);
        if (s !== null) {
          s.isSelected = false, s.isHighlighted = false;
          const r = s.layer;
          if (r !== null) {
            const l = r.re(-1, s, false);
            l >= 0 && this.diagram.raiseChangedEvent(4, "parts", r, s, null, l, null);
            const h = s.layerChanged;
            h !== null && h(s, r, null);
          }
        }
        const n = this.diagram.isTreePathToChildren, o = t.linksConnected;
        for (; o.next(); ) {
          const r = o.value, h = (n ? r.toNode : r.fromNode).data;
          i.containsNodeData(h) && i.sn(e, h);
        }
      }
    }
    insertLink(t, i, e, s) {
      const n = this.diagram.model;
      let o = t, r = e;
      if (this.diagram.isTreePathToChildren || (o = e, r = t), o !== null && r !== null) {
        const l = o.data, h = r.data;
        return n.setParentKeyForNodeData(h, n.getKeyForNodeData(l)), r.findTreeParentLink();
      }
      return null;
    }
  }
  var BindingMode2 = ((w) => (w[w.OneWay = 1] = "OneWay", w[w.TwoWay = 2] = "TwoWay", w))(BindingMode2 || {});
  const _Binding = class _Binding {
    constructor(t, i, e, s) {
      __publicField(this, "l");
      __publicField(this, "MN");
      __publicField(this, "Ha");
      __publicField(this, "Dc");
      __publicField(this, "Lh");
      __publicField(this, "Fc");
      __publicField(this, "Rc");
      __publicField(this, "Ic");
      __publicField(this, "Vb");
      __publicField(this, "Te");
      __publicField(this, "Sd");
      __publicField(this, "mc");
      GSet2.ji(this), t === void 0 ? t = "" : Util.t(t, "string", _Binding, "constructor:targetprop"), i === void 0 ? i = t : Util.t(i, "string", _Binding, "constructor:sourceprop"), e === void 0 ? e = null : e !== null && Util.t(e, "function", _Binding, "constructor:conv"), this.MN = -1, this.Te = null, this.Ha = t, this.Sd = 0, this.mc = 0, this.Dc = null, this.Lh = i, this.Fc = e, s === void 0 ? (this.Rc = 1, this.Ic = null) : (this.Rc = 2, this.Ic = s), this.Vb = new GSet2(), this.l = 2;
    }
    copy() {
      const t = new this.constructor();
      return this.cloneProtected(t), t;
    }
    cloneProtected(t) {
      t.Ha = this.Ha, t.Sd = this.Sd, t.mc = this.mc, t.Dc = this.Dc, t.Lh = this.Lh, t.Fc = this.Fc, t.Rc = this.Rc, t.Ic = this.Ic, t.l = this.l & -2;
    }
    static parseEnum(t, i) {
      return Util.t(t, "function", _Binding, "parseEnum:ctor"), (e) => {
        let s = parseInt(e);
        return isNaN(s) && (s = Util.Yh(t, e), s === null) ? i : s;
      };
    }
    ci(t) {
      t in BindingMode2 ? this.mode = t : Util.gr(this, t);
    }
    static toString(t) {
      return Util.toString(t);
    }
    toString() {
      return "Binding(" + this.targetProperty + ":" + this.sourceProperty + (this.targetId !== -1 ? " " + this.targetId : "") + " " + BindingMode2[this.mode] + ")";
    }
    w() {
      return this.l = this.l | 1, this;
    }
    ut() {
      return this.l = this.l & -2, this;
    }
    get targetId() {
      return this.MN;
    }
    set targetId(t) {
      this.f && Util.O(this), Util.t(t, "number", _Binding, "targetId"), this.MN = t;
    }
    get targetProperty() {
      return this.Ha;
    }
    set targetProperty(t) {
      this.f && Util.O(this), Util.t(t, "string", _Binding, "targetProperty"), this.Ha = t;
    }
    get sourceProperty() {
      return this.Lh;
    }
    set sourceProperty(t) {
      this.f && Util.O(this), Util.t(t, "string", _Binding, "sourceProperty"), this.Lh = t;
    }
    get f() {
      return (this.l & 1) !== 0;
    }
    get isToData() {
      return (this.l & 2) !== 0;
    }
    get isToObject() {
      return (this.l & 4) !== 0;
    }
    get isToModel() {
      return (this.l & 8) !== 0;
    }
    get isToTheme() {
      return (this.l & 16) !== 0;
    }
    get PN() {
      return this.isToTheme && !(this.isToData || this.isToObject || this.isToModel);
    }
    rd() {
      return false;
    }
    get sourceName() {
      return this.Dc;
    }
    set sourceName(t) {
      this.f && Util.O(this), t !== null && Util.t(t, "string", _Binding, "sourceName"), this.Dc = t, t !== null ? this.l = this.l & -3 | 4 : this.l = this.l | 2;
    }
    get converter() {
      return this.Fc;
    }
    set converter(t) {
      this.f && Util.O(this), t !== null && Util.t(t, "function", _Binding, "converter"), this.Fc = t;
    }
    get backConverter() {
      return this.Ic;
    }
    set backConverter(t) {
      this.f && Util.O(this), t !== null && Util.t(t, "function", _Binding, "backConverter"), this.Ic = t;
    }
    get mode() {
      return this.Rc;
    }
    set mode(t) {
      this.f && Util.O(this), this.isToTheme && t === 2 && Util.n("Theme Bindings cannot be TwoWay."), Util.it(t, BindingMode2, "BindingMode"), this.Rc = t;
    }
    makeTwoWay(t) {
      return this.isToTheme && Util.n("Theme Bindings cannot be TwoWay."), this.mode = 2, t && (Util.t(t, "function", _Binding, "makeTwoWay"), this.backConverter = t), this;
    }
    ofObject(t) {
      return this.f && Util.O(this), t === void 0 && (t = ""), Debug && Util.t(t, "string", _Binding, "ofObject:srcname"), this.sourceName = t, this;
    }
    ofModel() {
      return this.f && Util.O(this), this.l = this.l & -3 & -5 | 8, this.Dc = null, this;
    }
    iL(t, i) {
      const e = this.sourceName;
      let s = null;
      return e === null || e === "" ? s = t : e === "/" ? s = i.part : e === "." ? s = i : e === ".." ? s = i.panel : s = t.findObject(e), s;
    }
    check(t) {
      const i = this.Ha, e = this.Lh, s = this.Fc;
      (this.rd() && s === null && this.Th === null && i === "" || s === null && i === "") && Util.ft("Binding error: target property is the empty string: " + this.toString()), this.rd() && this.PN && e === "" && s === null && this.Th === null && Util.ft("Binding error: theme bindings require a source property when not using a converter: " + this.toString()), t && typeof i == "string" && (typeof t.setAttribute != "function" && i.length > 0 && i[0] !== "_" && !Util.yw(t, i) ? Util.ft("Binding error: undefined target property: " + i + " on " + t.toString()) : i === "name" && t instanceof GraphObject2 && Util.ft("Binding error: cannot modify GraphObject.name on " + t.toString()));
    }
    updateTarget(t, i, e) {
      var _a, _b, _c;
      const s = this.Lh;
      if (e !== void 0 && s !== "" && s !== e)
        return;
      const n = this.Ha, o = this.Fc;
      let r = i;
      if (s !== "" && !this.PN && (r = Model2.Xt(i, s)), r === void 0)
        return;
      const l = ((_a = t.diagram) == null ? void 0 : _a.themeManager) ?? ((_c = (_b = t.panel) == null ? void 0 : _b.diagram) == null ? void 0 : _c.themeManager);
      if (o === null) {
        if (n !== "") {
          if (this.rd() && (r = this.FT(l, r, t, n), r === void 0))
            return;
          Model2.dt(t, n, r);
        }
      } else
        try {
          if (n !== "") {
            let h = o(r, t);
            if (Debug && h === void 0 && Util.ft('Binding warning: conversion function returned undefined when setting target property "' + n + '" on ' + t.toString() + ", function is: " + o), this.rd() && (h = this.FT(l, h, t, n), h === void 0))
              return;
            Model2.dt(t, n, h);
          } else
            o(r, t);
        } catch (h) {
          Debug && Util.ft("Binding error: " + h.toString() + ' setting target property "' + n + '" on ' + t.toString() + " with conversion function: " + o);
        }
    }
    updateSource(t, i, e, s) {
      if (this.Rc !== 2)
        return;
      const n = this.Ha;
      if (e !== void 0 && n !== e)
        return;
      const o = this.Lh, r = this.Ic;
      let l = t;
      if (n !== "" && (l = Model2.Xt(t, n)), l !== void 0 && !this.Vb.contains(t))
        try {
          this.Vb.add(t);
          const h = s !== null ? s.diagram : null, a = h !== null ? h.model : null;
          if (r === null) {
            if (o !== "")
              a !== null ? (Debug && a.nodeKeyProperty === o && a.containsNodeData(i) && Util.ft("Binding error: cannot have TwoWay Binding on node data key property: " + this.toString()), a.setDataProperty(i, o, l)) : Model2.dt(i, o, l);
            else if (a !== null && s !== null && s.itemIndex >= 0 && s.panel !== null && Array.isArray(s.panel.itemArray)) {
              const f = s.itemIndex, c = s.panel.itemArray;
              a.removeArrayItem(c, f), a.insertArrayItem(c, f, l);
            }
          } else
            try {
              if (o !== "") {
                const f = r(l, i, a);
                a !== null ? (Debug && (a.nodeKeyProperty === o && a.containsNodeData(i) && Util.ft("Binding error: cannot have TwoWay Binding on node data key property: " + this.toString()), f === void 0 && Util.ft(`Binding warning: conversion function returned undefined when setting source property "${o}" on ${i.toString()}, function is: ${r}`)), a.setDataProperty(i, o, f)) : Model2.dt(i, o, f);
              } else {
                const f = r(l, i, a);
                if (f !== void 0 && a !== null && s !== null && s.itemIndex >= 0 && s.panel !== null && Array.isArray(s.panel.itemArray)) {
                  const c = s.itemIndex, u = s.panel.itemArray;
                  a.removeArrayItem(u, c), a.insertArrayItem(u, c, f);
                }
              }
            } catch (f) {
              Debug && Util.ft("Binding error: " + f.toString() + ' setting source property "' + o + '" on ' + i.toString() + " with conversion function: " + r);
            }
        } finally {
          this.Vb.remove(t);
        }
    }
  };
  __publicField(_Binding, "OneWay", 1);
  __publicField(_Binding, "TwoWay", 2);
  let Binding2 = _Binding;
  class ThemeBinding2 extends Binding2 {
    constructor(t, i, e, s, n) {
      super(t, i, s);
      __publicField(this, "Iy");
      __publicField(this, "Th");
      __publicField(this, "va");
      e == null && (e = ""), n === void 0 && (n = null), this.Iy = e, this.Th = n, this.va = null, this.l = 16;
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Iy = this.Iy, t.Th = this.Th, t.va = this.va;
    }
    rd() {
      return true;
    }
    get themeSource() {
      return this.Iy;
    }
    set themeSource(t) {
      this.f && Util.O(this), t !== null && Util.t(t, "string", ThemeBinding2, "themeSource"), this.Iy = t, this.va = null, t !== null ? this.l = this.l | 16 : this.l = this.l & -17;
    }
    get themeConverter() {
      return this.Th;
    }
    set themeConverter(t) {
      this.f && Util.O(this), t !== null && Util.t(t, "function", ThemeBinding2, "themeConverter"), this.Th = t;
    }
    ofData() {
      return this.f && Util.O(this), this.l = this.l | 2, this.Dc = null, this;
    }
    FT(t, i, e, s) {
      if (!t || (this.PN && (i = this.Lh), !i && i !== 0))
        return;
      let n = this.themeSource;
      this.va !== null ? n = this.va : typeof n == "string" && n.includes(".") && (this.va = n.split("."), n = this.va);
      let o = t.findValue(i, n, s);
      return o === void 0 && Util.ft(`Theme warning: ${i} could not be found when setting target property ${s}.`), typeof this.Th == "function" && (o = this.Th(o, e)), o;
    }
  }
  const _Model = class _Model {
    constructor(t, i) {
      __publicField(this, "Tt");
      __publicField(this, "hg");
      __publicField(this, "Yo");
      __publicField(this, "Bb");
      __publicField(this, "Ce");
      __publicField(this, "Oc");
      __publicField(this, "Ec");
      __publicField(this, "ag");
      __publicField(this, "fg");
      __publicField(this, "cg");
      __publicField(this, "ug");
      __publicField(this, "qa");
      __publicField(this, "ar");
      __publicField(this, "zb");
      __publicField(this, "Xo");
      __publicField(this, "Xb");
      __publicField(this, "oi");
      __publicField(this, "Dh");
      __publicField(this, "dg", new GSet2());
      __publicField(this, "gg", new GSet2());
      __publicField(this, "Oy");
      __publicField(this, "BT", `,
  "insertedNodeKeys": `);
      __publicField(this, "IO", `,
  "modifiedNodeData": `);
      __publicField(this, "zT", `,
  "removedNodeKeys": `);
      __publicField(this, "Wa", null);
      if (GSet2.ji(this), this.Tt = "", this.hg = "", this.Yo = false, this.Bb = {}, this.Ce = [], this.oi = new GMap2(), this.Dh = "key", this.Oc = null, this.Ec = null, this.ag = false, this.fg = false, this.cg = false, this.ug = null, this.qa = "category", this.ar = new GMap2(), this.Oy = 100, this.zb = new List2(), this.Xo = false, this.Xb = null, this.undoManager = new UndoManager2(), t !== void 0 && (Array.isArray(t) ? this.nodeDataArray = t : i = t), i) {
        Object.assign(this, i);
        const e = i.Changed;
        e && (delete this.Changed, this.addChangedListener(e));
      }
    }
    cloneProtected(t) {
      t.Tt = this.Tt, t.hg = this.hg, t.Yo = this.Yo, t.Dh = this.Dh, t.Oc = this.Oc, t.Ec = this.Ec, t.ag = this.ag, t.fg = this.fg, t.cg = this.cg, t.Oy = this.Oy, t.ug = this.ug, t.qa = this.qa;
    }
    copy() {
      const t = new this.constructor();
      return this.cloneProtected(t), t;
    }
    clear() {
      this.Ce = [], this.oi.clear(), this.ar.clear(), this.undoManager.clear();
    }
    toString(t) {
      if (t === void 0 && (t = 0), t > 1)
        return this.toJson();
      {
        let i = (this.name !== "" ? this.name : "") + " Model";
        if (t > 0) {
          i += `
 node data:`;
          const e = this.nodeDataArray, s = e.length;
          for (let n = 0; n < s; n++) {
            const o = e[n];
            i += " " + this.getKeyForNodeData(o) + ":" + Util.toString(o);
          }
        }
        return i;
      }
    }
    toIncrementalData(t) {
      Util.s(t, ChangedEvent2, _Model, "toIncrementalData:e"), t.change !== 1 && Util.n("Model.toIncrementalData argument is not a Transaction ChangedEvent:" + t.toString());
      const i = t.object;
      if (!t.isTransactionFinished || !(i instanceof Transaction2))
        return null;
      this.RT(i);
      const e = this.NN(i, t.propertyName === "FinishedUndo");
      return this.Wa = null, e;
    }
    NN(t, i) {
      const e = this;
      let s = false;
      const n = new GSet2(), o = new GSet2(), r = new GSet2(), l = this.Wa;
      t.changes.each((u) => {
        if (u.model === e) {
          if (u.modelChange === "nodeDataArray")
            u.change === 3 ? n.add(u.newValue) : u.change === 4 && r.add(u.oldValue);
          else if (e.containsNodeData(u.object))
            o.add(u.object);
          else if (u.change === 2 && (e.modelData === u.object || u.propertyName === "modelData"))
            s = true;
          else if (u.object !== null)
            if (l && l.contains(u.object))
              l.get(u.object).each((m) => {
                e.containsNodeData(m) && o.add(m);
              });
            else {
              if (u.object instanceof _Model || e.Ea() && e.containsLinkData(u.object))
                return;
              e.IT(u.object).each((m) => {
                o.add(m);
              });
            }
        }
      });
      const h = this.gg;
      h.clear(), n.each((u) => {
        h.add(e.getKeyForNodeData(u)), i || o.add(u);
      });
      const a = this.dg;
      a.clear(), r.each((u) => {
        a.add(e.getKeyForNodeData(u)), i && o.add(u);
      });
      const f = e.cloneDeep(o.toArray());
      let c = null;
      return s && (c === null && (c = {}), c.modelData = this.cloneDeep(this.modelData)), h.count > 0 && (c === null && (c = {}), i ? c.removedNodeKeys = h.toArray() : c.insertedNodeKeys = h.toArray()), f.length > 0 && (c === null && (c = {}), c.modifiedNodeData = f), a.count > 0 && (c === null && (c = {}), i ? c.insertedNodeKeys = a.toArray() : c.removedNodeKeys = a.toArray()), a.clear(), h.clear(), c;
    }
    cloneDeep(t) {
      return this.mg(t, true);
    }
    mg(t, i, e, s, n) {
      if (!Util.Mt(t))
        return t;
      n || (n = []);
      const o = Object.isExtensible(t);
      if (e || (e = new GMap2()), o) {
        const h = e.get(t);
        if (h)
          return h;
      } else {
        s || (s = new GMap2());
        const h = s.iterator;
        for (; h.next(); ) {
          const a = h.key;
          if (h.value === t) {
            const c = e.get(a);
            if (c)
              return c;
          }
        }
      }
      function r(h, a) {
        if (o)
          h.__gohashid === void 0 && n.push(h), e.set(h, a);
        else {
          const f = GSet2.fu++;
          e.set(f, a), s.set(f, t);
        }
      }
      let l;
      if (Array.isArray(t)) {
        l = [], r(t, l);
        for (let h = 0; h < t.length; h++) {
          const a = t[h];
          l.push(this.mg(a, false, e, s, n));
        }
      } else if (t instanceof Point2 || t instanceof Size2 || t instanceof Rect2 || t instanceof Margin2 || t instanceof Spot2)
        l = t.copy(), r(t, l);
      else {
        if (t instanceof Brush2 || t instanceof Geometry2)
          return t;
        if (t instanceof List2)
          l = new List2().addAll(this.mg(t.toArray(), false, e, s, n)), r(t, l);
        else if (t instanceof GSet2)
          l = new GSet2().addAll(this.mg(t.toArray(), false, e, s, n)), r(t, l);
        else if (t instanceof GMap2)
          l = new GMap2().addAll(this.mg(t.toArray(), false, e, s, n)), r(t, l);
        else if (t instanceof Date)
          l = new Date(t.getTime()), r(t, l);
        else if (t instanceof RegExp)
          l = new RegExp(t), r(t, l), l.lastIndex = t.lastIndex;
        else if (typeof t.copy == "function")
          l = t.copy(), r(t, l);
        else {
          l = {}, r(t, l);
          for (const h in t) {
            if (h === "__gohashid")
              continue;
            const a = t[h];
            l[h] = this.mg(a, false, e, s, n);
          }
        }
      }
      return i && n.forEach((h) => {
        delete h.__gohashid;
      }), l;
    }
    Xe(t) {
      return JSON.stringify(t).replace(/[\u007F-\uFFFF]/g, (e) => {
        const s = "0000" + e.charCodeAt(0).toString(16);
        return "\\u" + s.substring(s.length - 4);
      });
    }
    pg() {
      let t = "";
      return this.name !== "" && (t += `,
  "name": ` + this.Xe(this.name)), this.dataFormat !== "" && (t += `,
  "dataFormat": ` + this.Xe(this.dataFormat)), this.isReadOnly && (t += `,
  "isReadOnly": ` + this.isReadOnly), this.nodeKeyProperty !== "key" && typeof this.nodeKeyProperty == "string" && (t += `,
  "nodeKeyProperty": ` + this.Xe(this.nodeKeyProperty)), this.copiesArrays && (t += `,
  "copiesArrays": true`), this.copiesArrayObjects && (t += `,
  "copiesArrayObjects": true`), this.copiesKey && (t += `,
  "copiesKey": true`), this.pointsDigits !== 100 && (t += `,
  "pointsDigits": ` + this.pointsDigits.toString()), this.nodeCategoryProperty !== "category" && typeof this.nodeCategoryProperty == "string" && (t += `,
  "nodeCategoryProperty": ` + this.Xe(this.nodeCategoryProperty)), t;
    }
    Ey(t) {
      t.name && (this.name = t.name), t.dataFormat && (this.dataFormat = t.dataFormat), t.isReadOnly && (this.isReadOnly = true), t.nodeKeyProperty && (this.nodeKeyProperty = t.nodeKeyProperty), t.copiesArrays && (this.copiesArrays = true), t.copiesArrayObjects && (this.copiesArrayObjects = true), t.copiesKey !== void 0 && (this.copiesKey = t.copiesKey), t.pointsDigits !== void 0 && (this.pointsDigits = parseInt(t.pointsDigits)), t.nodeCategoryProperty && (this.nodeCategoryProperty = t.nodeCategoryProperty);
    }
    OT() {
      const t = this.modelData;
      return `,
  "modelData": ` + this.ET(t);
    }
    VT(t) {
      const i = t.modelData;
      Util.Mt(i) && (this.replaceJsonObjects(i), this.modelData = i);
    }
    CN() {
      const t = this.modelData;
      let i = false;
      for (const s in t)
        if (!this.Yb(t, s, t[s])) {
          i = true;
          break;
        }
      let e = "";
      return i && (e = this.OT()), e + `,
  "nodeDataArray": ` + this.Fh(this.nodeDataArray, true);
    }
    AN(t) {
      this.VT(t);
      const i = t.nodeDataArray;
      Array.isArray(i) && (this.replaceJsonObjects(i), this.nodeDataArray = i);
    }
    LN(t, i, e) {
      if (t === i)
        return true;
      if (typeof t != typeof i || typeof t == "function" || typeof i == "function")
        return false;
      if (Array.isArray(t) && Array.isArray(i)) {
        if (e.getValue(t) === i)
          return true;
        if (e.add(t, i), t.length !== i.length)
          return false;
        for (let s = 0; s < t.length; s++)
          if (!this.LN(t[s], i[s], e))
            return false;
        return true;
      } else if (Util.Mt(t) && Util.Mt(i)) {
        if (e.getValue(t) === i)
          return true;
        e.add(t, i);
        for (const s in t) {
          const n = t[s];
          if (this.Yb(t, s, n))
            continue;
          const o = i[s];
          if (o === void 0 || !this.LN(n, o, e))
            return false;
        }
        for (const s in i) {
          const n = i[s];
          if (this.Yb(i, s, n))
            continue;
          const o = t[s];
          if (o === void 0 || !this.LN(o, n, e))
            return false;
        }
        return true;
      }
      return false;
    }
    RT(t) {
      let i = this.Wa;
      const e = (s, n) => {
        const o = n.part;
        if (!o)
          return;
        const r = o.data;
        if (s === r)
          return;
        let l = i.get(s);
        l === null ? (l = new GSet2(), l.add(r), i.add(s, l)) : l.add(r);
      };
      i === null && (i = new GMap2(), t.changes.each((s) => {
        if (s.diagram !== null) {
          const n = s.change;
          if (n === 2) {
            const o = s.object.panel;
            if (o) {
              const r = o.data;
              r && e(r, o);
            }
          } else if (n === 3 || n === 4) {
            const o = s.object, r = o.itemArray;
            r && e(r, o);
          }
        }
      }), this.Wa = i);
    }
    IT(t) {
      const i = new GSet2();
      for (let e = 0; e < this.nodeDataArray.length; e++) {
        const s = this.nodeDataArray[e];
        this.Kb(t, s, s, i);
      }
      return i;
    }
    Kb(t, i, e, s) {
      if (Array.isArray(i))
        for (let n = 0; n < i.length; n++) {
          const o = i[n];
          if (o === t)
            return s.add(e), true;
          if (this.Kb(t, o, e, s))
            return true;
        }
      else if (Util.Mt(i) && Object.getPrototypeOf(i) === Object.prototype)
        for (const n in i) {
          const o = i[n];
          if (o === t)
            return s.add(e), true;
          if (this.Kb(t, o, e, s))
            return true;
        }
      return false;
    }
    TN(t, i) {
      const e = this;
      let s = false;
      const n = new GSet2(), o = new GSet2(), r = new GSet2(), l = this.Wa;
      t.changes.each((c) => {
        if (c.model === e) {
          if (c.modelChange === "nodeDataArray")
            c.change === 3 ? n.add(c.newValue) : c.change === 4 && r.add(c.oldValue);
          else if (e.containsNodeData(c.object))
            o.add(c.object);
          else if (c.change === 2 && (e.modelData === c.object || c.propertyName === "modelData"))
            s = true;
          else if (c.object !== null)
            if (l && l.contains(c.object))
              l.get(c.object).each((d) => {
                e.containsNodeData(d) && o.add(d);
              });
            else {
              if (c.object instanceof _Model || e.Ea() && e.containsLinkData(c.object))
                return;
              e.IT(c.object).each((d) => {
                o.add(d);
              });
            }
        }
      });
      const h = this.gg;
      h.clear(), n.each((c) => {
        h.add(e.getKeyForNodeData(c)), i || o.add(c);
      });
      const a = this.dg;
      a.clear(), r.each((c) => {
        a.add(e.getKeyForNodeData(c)), i && o.add(c);
      });
      let f = "";
      return s && (f += this.OT()), h.count > 0 && (f += (i ? this.zT : this.BT) + this.Fh(h.toArray(), true)), o.count > 0 && (f += this.IO + this.Fh(o.toArray(), true)), a.count > 0 && (f += (i ? this.BT : this.zT) + this.Fh(a.toArray(), true)), a.clear(), h.clear(), f;
    }
    Vy(t) {
      (t.name !== void 0 && t.name !== this.name || t.dataFormat !== void 0 && t.dataFormat !== this.dataFormat || t.isReadOnly !== void 0 && t.isReadOnly !== this.isReadOnly || t.nodeKeyProperty !== void 0 && t.nodeKeyProperty !== this.nodeKeyProperty || t.copiesArrays !== void 0 && t.copiesArrays !== this.copiesArrays || t.copiesArrayObjects !== void 0 && t.copiesArrayObjects !== this.copiesArrayObjects || t.copiesKey !== void 0 && t.copiesKey !== this.copiesKey || t.nodeCategoryProperty !== void 0 && t.nodeCategoryProperty !== this.nodeCategoryProperty) && Util.n("applyIncrementalJson cannot change Model properties"), this.VT(t);
      const i = t.insertedNodeKeys, e = t.modifiedNodeData, s = new GMap2();
      if (Array.isArray(e))
        for (let o = 0; o < e.length; o++) {
          const r = e[o], l = this.getKeyForNodeData(r);
          l != null && s.set(l, r);
        }
      if (Array.isArray(i)) {
        const o = i.length;
        for (let r = 0; r < o; r++) {
          const l = i[r];
          let h = this.findNodeDataForKey(l);
          if (h === null) {
            const a = s.get(l);
            h = a || this.copyNodeData({}), this.setKeyForNodeData(h, l), this.addNodeData(h);
          }
        }
      }
      if (Array.isArray(e)) {
        const o = e.length;
        for (let r = 0; r < o; r++) {
          const l = e[r], h = this.getKeyForNodeData(l), a = this.findNodeDataForKey(h);
          if (a !== null) {
            for (const f in l)
              f === "__gohashid" || f === this.nodeKeyProperty || (this.bf() || this._u()) && f === this.nodeIsGroupProperty || this.setDataProperty(a, f, l[f]);
            this.yg(l, a);
          }
        }
      }
      const n = t.removedNodeKeys;
      if (Array.isArray(n)) {
        const o = n.length;
        for (let r = 0; r < o; r++) {
          const l = n[r], h = this.findNodeDataForKey(l);
          h !== null && this.removeNodeData(h);
        }
      }
    }
    toIncrementalJson(t, i) {
      Util.s(t, ChangedEvent2, _Model, "toIncrementalJson:e"), t.change !== 1 && Util.n("Model.toIncrementalJson argument is not a Transaction ChangedEvent:" + t.toString());
      const e = t.object;
      if (!t.isTransactionFinished || !(e instanceof Transaction2))
        return '{ "incremental": 0 }';
      i === void 0 && (i = Util.an(this)), this.RT(e);
      const s = this.TN(e, t.propertyName === "FinishedUndo");
      return this.Wa = null, i === "2" ? '{ "incremental": 2' + s + "}" : '{ "class": ' + this.Xe(i) + ', "incremental": 1' + this.pg() + s + "}";
    }
    toIncrementalJSON(t, i) {
      return this.toIncrementalJson(t, i);
    }
    toJson(t) {
      return t === void 0 && (t = Util.an(this)), '{ "class": ' + this.Xe(t) + this.pg() + this.CN() + "}";
    }
    toJSON(t) {
      return this.toJson(t);
    }
    applyIncrementalJson(t) {
      let i = null;
      if (typeof t == "string")
        try {
          i = root.JSON.parse(t);
        } catch (s) {
          Debug && Util.ft("JSON.parse error: " + s.toString());
        }
      else
        typeof t == "object" ? i = t : Util.n("Unable to modify a Model from: " + t);
      const e = i.incremental;
      typeof e != "number" && Util.n("Unable to apply non-incremental changes to Model: " + t), e !== 0 && (this.startTransaction("applyIncrementalJson"), this.Vy(i), this.commitTransaction("applyIncrementalJson"));
    }
    applyIncrementalJSON(t) {
      return this.applyIncrementalJson(t);
    }
    static fromJson(t, i) {
      i === void 0 && (i = null), i !== null && Util.s(i, _Model, _Model, "fromJson:model");
      let e = null;
      if (typeof t == "string")
        try {
          e = root.JSON.parse(t);
        } catch (s) {
          Debug && Util.ft("JSON.parse error: " + s.toString());
        }
      else
        typeof t == "object" ? e = t : Util.n("Unable to construct a Model from: " + t);
      if (i === null) {
        const s = _Model.OO(e);
        s === null || s instanceof _Model ? i = s : Util.n("Unable to construct a Model of declared class: " + e.class);
      }
      return i === null && (i = _Model.constructGraphLinksModel()), i.Ey(e), i.AN(e), i;
    }
    static fromJSON(t, i) {
      return this.fromJson(t, i);
    }
    static constructGraphLinksModel() {
      return Debug && Util.n("Unable to construct a Model. Provided JSON requires GraphLinksModel, which is not loaded."), new _Model();
    }
    static OO(t) {
      let i = null, e = t.class;
      if (typeof e == "string")
        try {
          let s = null;
          e.indexOf("go.") === 0 ? (e = e.substring(3), s = _Model.Ub(e)) : (s = _Model.Ub(e), s === null && (s = root[e])), typeof s == "function" && (i = new s());
        } catch {
        }
      return i;
    }
    replaceJsonObjects(t) {
      if (Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++) {
          const s = t[e];
          Util.Mt(s) && (t[e] = this.replaceJsonObjects(s));
        }
      } else if (Util.Mt(t)) {
        for (const i in t) {
          const e = t[i];
          if (Util.Mt(e)) {
            const s = this.replaceJsonObjects(e);
            if (t[i] = s, i === "points" && Array.isArray(s)) {
              let n = s.length % 2 === 0;
              for (let o = 0; o < s.length; o++)
                if (typeof s[o] != "number") {
                  n = false;
                  break;
                }
              if (n) {
                const o = new List2();
                for (let r = 0; r < s.length / 2; r++)
                  o.add(new Point2(s[r * 2], s[r * 2 + 1]));
                o.w(), t[i] = o;
              }
            }
          }
        }
        return this.EO(t);
      }
      return t;
    }
    writeJsonValue(t) {
      return t === void 0 ? "undefined" : t === null ? "null" : t === true ? "true" : t === false ? "false" : typeof t == "string" ? this.Xe(t) : typeof t == "number" ? t === 1 / 0 ? "9e9999" : t === -1 / 0 ? "-9e9999" : isNaN(t) ? '{"class":"NaN"}' : t.toString() : t instanceof Date ? '{"class":"Date", "value":"' + t.toJSON() + '"}' : t instanceof Number ? this.writeJsonValue(t.valueOf()) : Array.isArray(t) ? this.Fh(t) : Util.Mt(t) ? this.ET(t) : typeof t == "function" ? "null" : t.toString();
    }
    Fh(t, i) {
      i === void 0 && (i = false);
      const e = t.length;
      if (e <= 0)
        return "[]";
      const s = new StringBuilder();
      s.add("["), i && e > 1 && s.add(`
`);
      for (let n = 0; n < e; n++) {
        const o = t[n];
        o !== void 0 && (n > 0 && (s.add(","), i && s.add(`
`)), s.add(this.writeJsonValue(o)));
      }
      return i && e > 1 && s.add(`
`), s.add("]"), s.toString();
    }
    Yb(t, i, e) {
      return e === void 0 || i === "__gohashid" || i[0] === "_" || typeof e == "function";
    }
    qi(t) {
      return isNaN(t) ? "NaN" : t === 1 / 0 ? "9e9999" : t === -1 / 0 ? "-9e9999" : t;
    }
    ET(t) {
      const i = t;
      if (i instanceof Point2)
        t = { class: "go.Point", x: this.qi(i.x), y: this.qi(i.y) };
      else if (i instanceof Size2)
        t = { class: "go.Size", width: this.qi(i.width), height: this.qi(i.height) };
      else if (i instanceof Rect2)
        t = { class: "go.Rect", x: this.qi(i.x), y: this.qi(i.y), width: this.qi(i.width), height: this.qi(i.height) };
      else if (i instanceof Margin2)
        t = { class: "go.Margin", top: this.qi(i.top), right: this.qi(i.right), bottom: this.qi(i.bottom), left: this.qi(i.left) };
      else if (i instanceof Spot2)
        i.isSpot() ? t = { class: "go.Spot", x: this.qi(i.x), y: this.qi(i.y), offsetX: this.qi(i.offsetX), offsetY: this.qi(i.offsetY) } : t = { class: "go.Spot", enum: i.toString() };
      else if (i instanceof Brush2) {
        if (t = { class: "go.Brush", type: BrushType2[i.type] }, i.type === 1 ? t.color = i.color : (i.type === 2 || i.type === 3) && (t.start = i.start, t.end = i.end, i.type === 3 && (i.startRadius !== 0 && (t.startRadius = this.qi(i.startRadius)), isNaN(i.endRadius) || (t.endRadius = this.qi(i.endRadius)))), i.colorStops !== null) {
          const n = {}, o = i.colorStops.iterator;
          for (; o.next(); ) {
            const r = o.key, l = o.value;
            n[r] = l;
          }
          t.colorStops = n;
        }
      } else if (i instanceof Geometry2)
        t = { class: "go.Geometry", type: GeometryType2[i.type] }, i.startX !== 0 && (t.startX = this.qi(i.startX)), i.startY !== 0 && (t.startY = this.qi(i.startY)), i.endX !== 0 && (t.endX = this.qi(i.endX)), i.endY !== 0 && (t.endY = this.qi(i.endY)), i.spot1.equals(Spot2.TopLeft) || (t.spot1 = i.spot1), i.spot2.equals(Spot2.BottomRight) || (t.spot2 = i.spot2), i.type === 4 && (t.path = Geometry2.stringify(i));
      else if (_Model.Ub(Util.an(i)) !== null)
        return Util.ft("ERROR: trying to convert a GraphObject or Diagram or Model or Tool or Layout or UndoManager or other unknown data type into JSON text: " + i.toString()), "{}";
      let e = "{", s = true;
      for (const n in t) {
        const o = _Model.Xt(t, n);
        if (!this.Yb(t, n, o))
          if (s ? s = false : e += ",", e += this.Xe(n) + ":", n === "points" && o instanceof List2) {
            const r = o;
            let l = "[";
            const h = r.iterator;
            for (; h.next(); ) {
              const a = h.value;
              l.length > 1 && (l += ","), l += this.XT(a.x), l += ",", l += this.XT(a.y);
            }
            l += "]", e += l;
          } else
            e += this.writeJsonValue(o);
      }
      return e += "}", e;
    }
    XT(t) {
      if (t === 1 / 0)
        return "9e9999";
      if (t === -1 / 0)
        return "-9e9999";
      if (isNaN(t))
        return "0";
      const i = this.pointsDigits;
      return i > 16 ? t.toString() : t.toFixed(i);
    }
    get pointsDigits() {
      return this.Oy;
    }
    set pointsDigits(t) {
      t < 0 ? t = 0 : t > 100 && (t = 100), this.Oy = t;
    }
    Wi(t) {
      return typeof t == "number" ? t : t === "NaN" ? NaN : t === "9e9999" ? 1 / 0 : t === "-9e9999" ? -1 / 0 : parseFloat(t);
    }
    EO(t) {
      if (typeof t != "object")
        return t;
      let i = t.class || "";
      if (typeof i != "string" || i === "")
        return t;
      if (i === "NaN")
        return NaN;
      if (i === "Date")
        return new Date(t.value);
      if (i.indexOf("go.") !== 0)
        return t;
      i = i.substring(3);
      let e = t;
      if (i === "Point")
        e = new Point2(this.Wi(t.x), this.Wi(t.y));
      else if (i === "Size")
        e = new Size2(this.Wi(t.width), this.Wi(t.height));
      else if (i === "Rect")
        e = new Rect2(this.Wi(t.x), this.Wi(t.y), this.Wi(t.width), this.Wi(t.height));
      else if (i === "Margin")
        e = new Margin2(this.Wi(t.top), this.Wi(t.right), this.Wi(t.bottom), this.Wi(t.left));
      else if (i === "Spot")
        typeof t.enum == "string" ? e = Spot2.parse(t.enum) : e = new Spot2(this.Wi(t.x), this.Wi(t.y), this.Wi(t.offsetX), this.Wi(t.offsetY));
      else if (i === "Brush") {
        const s = new Brush2();
        s.type = Util.Yh(BrushType2, t.type) ?? 1, typeof t.color == "string" && (s.color = t.color), t.start instanceof Spot2 && (s.start = t.start), t.end instanceof Spot2 && (s.end = t.end), typeof t.startRadius == "number" && (s.startRadius = this.Wi(t.startRadius)), typeof t.endRadius == "number" && (s.endRadius = this.Wi(t.endRadius));
        const n = t.colorStops;
        if (Util.Mt(n))
          for (const o in n) {
            const r = parseFloat(o);
            s.addColorStop(r, n[o]);
          }
        e = s;
      } else if (i === "Geometry") {
        let s = null;
        typeof t.path == "string" ? s = Geometry2.parse(t.path) : s = new Geometry2(), s.type = Util.Yh(GeometryType2, t.type) ?? 1, typeof t.startX == "number" && (s.startX = this.Wi(t.startX)), typeof t.startY == "number" && (s.startY = this.Wi(t.startY)), typeof t.endX == "number" && (s.endX = this.Wi(t.endX)), typeof t.endY == "number" && (s.endY = this.Wi(t.endY)), t.spot1 instanceof Spot2 && (s.spot1 = t.spot1), t.spot2 instanceof Spot2 && (s.spot2 = t.spot2), e = s;
      } else if (i === "EnumValue") {
        let s = t.classType;
        s.indexOf("go.") === 0 && (s = s.substring(3));
        const n = _Model.Ub(s);
        typeof n == "function" && (e = Util.Yh(n, t.name));
      }
      return e;
    }
    get name() {
      return this.Tt;
    }
    set name(t) {
      const i = this.Tt;
      i !== t && (Util.t(t, "string", _Model, "name"), this.Tt = t, this.i("name", i, t));
    }
    get dataFormat() {
      return this.hg;
    }
    set dataFormat(t) {
      const i = this.hg;
      i !== t && (Util.t(t, "string", _Model, "dataFormat"), this.hg = t, this.i("dataFormat", i, t));
    }
    get isReadOnly() {
      return this.Yo;
    }
    set isReadOnly(t) {
      const i = this.Yo;
      i !== t && (Util.t(t, "boolean", _Model, "isReadOnly"), this.Yo = t, this.i("isReadOnly", i, t));
    }
    get modelData() {
      return this.Bb;
    }
    set modelData(t) {
      const i = this.Bb;
      i !== t && (Util.t(t, "object", _Model, "modelData"), this.Bb = t, this.i("modelData", i, t), this.updateTargetBindings(t));
    }
    addChangedListener(t) {
      return Util.t(t, "function", _Model, "addChangedListener:listener"), this.zb.add(t), this;
    }
    removeChangedListener(t) {
      Util.t(t, "function", _Model, "removeChangedListener:listener"), this.zb.remove(t);
    }
    Gw(t) {
      this.skipsUndoManager || this.undoManager.handleChanged(t);
      const i = this.zb, e = i.length;
      for (let s = 0; s < e; s++)
        i.elt(s)(t);
    }
    raiseChangedEvent(t, i, e, s, n, o, r) {
      this.Kt("", t, i, e, s, n, o, r);
    }
    raiseChanged(t, i, e, s, n) {
      this.Kt("", 2, t, this, i, e, s, n);
    }
    i(t, i, e, s, n) {
      this.Kt("", 2, t, this, i, e, s, n);
    }
    raiseDataChanged(t, i, e, s, n, o) {
      this.Kt("", 2, i, t, e, s, n, o);
    }
    Kt(t, i, e, s, n, o, r, l) {
      r === void 0 && (r = null), l === void 0 && (l = null);
      const h = new ChangedEvent2();
      h.model = this, h.change = i, h.modelChange = t, h.propertyName = e, h.object = s, h.oldValue = n, h.oldParam = r, h.newValue = o, h.newParam = l, this.Gw(h);
    }
    get undoManager() {
      return this.Xb;
    }
    set undoManager(t) {
      const i = this.Xb;
      i !== t && (Util.s(t, UndoManager2, _Model, "undoManager"), i !== null && i.removeModel(this), this.Xb = t, t !== null && t.addModel(this));
    }
    get skipsUndoManager() {
      return this.Xo;
    }
    set skipsUndoManager(t) {
      Util.t(t, "boolean", _Model, "skipsUndoManager"), this.Xo = t;
    }
    changeState(t, i) {
      if (t !== null && t.model === this)
        if (t.change === 2) {
          const e = t.object, s = t.propertyName, n = t.getValue(i);
          if (s === this.nodeKeyProperty && this.containsNodeData(e)) {
            const o = t.getValue(!i);
            o !== void 0 && this.oi.remove(o), n !== void 0 && this.oi.add(n, e);
          }
          _Model.dt(e, s, n);
        } else if (t.change === 3) {
          const e = t.newParam;
          if (t.modelChange === "nodeDataArray") {
            const s = t.newValue;
            if (Util.Mt(s) && typeof e == "number") {
              const n = this.getKeyForNodeData(s);
              i ? (this.Ce[e] === s && Util.rf(this.Ce, e), n !== void 0 && this.oi.remove(n)) : (this.Ce[e] !== s && Util.au(this.Ce, e, s), n !== void 0 && this.oi.add(n, s));
            }
          } else if (t.modelChange === "") {
            let s = t.object;
            if (s && !Array.isArray(s) && t.propertyName && (s = _Model.Xt(t.object, t.propertyName)), Array.isArray(s) && typeof e == "number") {
              const n = t.newValue;
              i ? Util.rf(s, e) : Util.au(s, e, n);
            }
          } else
            Util.n("unknown ChangeType.Insert modelChange: " + t.toString());
        } else if (t.change === 4) {
          const e = t.oldParam;
          if (t.modelChange === "nodeDataArray") {
            const s = t.oldValue;
            if (Util.Mt(s) && typeof e == "number") {
              const n = this.getKeyForNodeData(s);
              i ? (this.Ce[e] !== s && Util.au(this.Ce, e, s), n !== void 0 && this.oi.add(n, s)) : (this.Ce[e] === s && Util.rf(this.Ce, e), n !== void 0 && this.oi.remove(n));
            }
          } else if (t.modelChange === "") {
            let s = t.object;
            if (s && !Array.isArray(s) && t.propertyName && (s = _Model.Xt(t.object, t.propertyName)), Array.isArray(s) && typeof e == "number") {
              const n = t.oldValue;
              i ? Util.au(s, e, n) : Util.rf(s, e);
            }
          } else
            Util.n("unknown ChangeType.Remove modelChange: " + t.toString());
        } else
          t.change === 1 || Util.n("unknown ChangedEvent: " + t.toString());
    }
    startTransaction(t) {
      return this.undoManager.startTransaction(t);
    }
    commitTransaction(t) {
      return this.undoManager.commitTransaction(t);
    }
    rollbackTransaction() {
      return this.undoManager.rollbackTransaction();
    }
    commit(t, i) {
      let e = i;
      e === void 0 && (e = "");
      const s = this.skipsUndoManager;
      e === null && (this.skipsUndoManager = true, e = ""), this.undoManager.startTransaction(e);
      let n = false;
      try {
        t(this), n = true;
      } finally {
        n ? this.undoManager.commitTransaction(e) : this.undoManager.rollbackTransaction(), this.skipsUndoManager = s;
      }
    }
    updateTargetBindings(t, i) {
      i === void 0 && (i = ""), this.Kt("SourceChanged", 1, i, t, null, null);
    }
    get nodeKeyProperty() {
      return this.Dh;
    }
    set nodeKeyProperty(t) {
      const i = this.Dh;
      i !== t && (this.En(t, _Model, "nodeKeyProperty"), t === "" && Util.n("Model.nodeKeyProperty may not be the empty string"), this.oi.count > 0 && Util.n("Cannot set Model.nodeKeyProperty when there is existing node data"), this.Dh = t, this.i("nodeKeyProperty", i, t));
    }
    En(t, i, e) {
      typeof t != "string" && typeof t != "function" && Util.Bi(t, "string or function", i, e);
    }
    getKeyForNodeData(t) {
      if (t === null)
        return;
      const i = this.Dh;
      if (i === "")
        return;
      const e = _Model.Xt(t, i);
      if (e !== void 0) {
        if (this.isKeyType(e))
          return e;
        Util.n("Key value for node data " + t + " is not a number or a string: " + e);
      }
    }
    setKeyForNodeData(t, i) {
      if ((i == null || !this.isKeyType(i)) && Util.Bi(i, "number or string", _Model, "setKeyForNodeData:key"), t === null)
        return;
      const e = this.Dh;
      if (e === "")
        return;
      if (!this.containsNodeData(t)) {
        _Model.dt(t, e, i);
        return;
      }
      const s = _Model.Xt(t, e);
      if (s !== i) {
        if (this.findNodeDataForKey(i) !== null)
          return;
        _Model.dt(t, e, i), s !== void 0 && this.oi.remove(s), this.oi.add(i, t), this.Kt("nodeKey", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e), this.By(s, i);
      }
    }
    get makeUniqueKeyFunction() {
      return this.Oc;
    }
    set makeUniqueKeyFunction(t) {
      const i = this.Oc;
      i !== t && (t !== null && Util.t(t, "function", _Model, "makeUniqueKeyFunction"), this.Oc = t, this.i("makeUniqueKeyFunction", i, t));
    }
    isKeyType(t) {
      return typeof t == "number" || typeof t == "string";
    }
    containsNodeData(t) {
      const i = this.getKeyForNodeData(t);
      return i === void 0 ? false : this.oi.getValue(i) === t;
    }
    findNodeDataForKey(t) {
      return t === null && Util.n("Model.findNodeDataForKey:key must not be null"), t === void 0 || !this.isKeyType(t) ? null : this.oi.getValue(t);
    }
    get nodeDataArray() {
      return this.Ce;
    }
    set nodeDataArray(t) {
      const i = this.Ce;
      if (i !== t) {
        Util.Hg(t, _Model, "nodeDataArray"), this.oi.clear(), this.DN();
        const e = t.length;
        for (let o = 0; o < e; o++) {
          const r = t[o];
          Util.Mt(r) || Util.n("Model.nodeDataArray must only contain Objects, not: " + r);
        }
        this.Ce = t;
        const s = new List2();
        for (let o = 0; o < e; o++) {
          const r = t[o], l = this.getKeyForNodeData(r);
          l === void 0 || this.oi.getValue(l) !== null ? s.add(r) : this.oi.add(l, r);
        }
        const n = s.iterator;
        for (; n.next(); ) {
          const o = n.value;
          this.makeNodeDataKeyUnique(o);
          const r = this.getKeyForNodeData(o);
          r !== void 0 && this.oi.add(r, o);
        }
        this.Kt("nodeDataArray", 2, "nodeDataArray", this, i, t);
        for (let o = 0; o < e; o++) {
          const r = t[o];
          this.wg(r), this.xg(r);
        }
      }
    }
    makeNodeDataKeyUnique(t) {
      if (t === null)
        return;
      const i = this.Dh;
      if (i === "")
        return;
      let e = this.getKeyForNodeData(t);
      if (e !== void 0 && !this.oi.contains(e))
        return;
      const s = this.Oc;
      if (s !== null && (e = s(this, t), e != null && !this.oi.contains(e))) {
        _Model.dt(t, i, e);
        return;
      }
      if (typeof e == "string") {
        let n = 2;
        for (; this.oi.contains(e + n); )
          n++;
        _Model.dt(t, i, e + n);
      } else if (e === void 0 || typeof e == "number") {
        let n = -this.oi.count - 1;
        for (; this.oi.contains(n); )
          n--;
        _Model.dt(t, i, n);
      } else
        Debug && Util.n("Model.getKeyForNodeData returned something other than a string or a number: " + e);
    }
    addNodeData(t) {
      t !== null && (this.containsNodeData(t) || this.PT(t, true));
    }
    PT(t, i) {
      let e = this.getKeyForNodeData(t);
      if (e === void 0)
        this.makeNodeDataKeyUnique(t), e = this.getKeyForNodeData(t);
      else {
        if (this.oi.getValue(e) === t)
          return;
        this.makeNodeDataKeyUnique(t), e = this.getKeyForNodeData(t);
      }
      e === void 0 && Util.n("Model.makeNodeDataKeyUnique failed on " + t + ".  Data not added to Model."), this.oi.add(e, t);
      let s = null;
      i && (s = this.Ce.length, Util.au(this.Ce, s, t)), this.Kt("nodeDataArray", 3, "nodeDataArray", this, null, t, null, s), this.wg(t), this.xg(t);
    }
    addNodeDataCollection(t) {
      if (Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++)
          this.addNodeData(t[e]);
      } else {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          this.addNodeData(e);
        }
      }
    }
    removeNodeData(t) {
      t !== null && this.MT(t, true);
    }
    MT(t, i) {
      const e = this.getKeyForNodeData(t);
      e !== void 0 && this.oi.remove(e);
      let s = null;
      if (i) {
        if (s = this.Ce.indexOf(t), s < 0)
          return;
        Util.rf(this.Ce, s);
      }
      this.Kt("nodeDataArray", 4, "nodeDataArray", this, t, null, s, null), this.zy(t);
    }
    removeNodeDataCollection(t) {
      if (Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++)
          this.removeNodeData(t[e]);
      } else {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          this.removeNodeData(e);
        }
      }
    }
    mergeNodeDataArray(t) {
      if (t !== this.nodeDataArray && Array.isArray(t)) {
        const i = this.dg;
        i.clear(), i.addAll(this.oi.iteratorKeys);
        const e = this.gg;
        e.clear();
        const s = t.length;
        for (let o = 0; o < s; o++) {
          const r = t[o], l = this.getKeyForNodeData(r);
          if (l !== void 0) {
            e.add(l);
            const h = this.findNodeDataForKey(l);
            if (h === r)
              continue;
            if (h !== null)
              this.assignAllDataProperties(h, r), this.yg(r, h);
            else {
              const a = this.cloneDeep(r);
              this.setKeyForNodeData(a, l), this.addNodeData(a);
            }
          } else {
            const h = this.cloneDeep(r);
            this.addNodeData(h), e.add(this.getKeyForNodeData(h));
          }
        }
        const n = i.iterator;
        for (; n.next(); ) {
          const o = n.value;
          if (!e.contains(o)) {
            const r = this.findNodeDataForKey(o);
            r && this.removeNodeData(r);
          }
        }
        i.clear(), e.clear();
      }
    }
    By(t, i) {
      if (i === void 0)
        return;
      const e = this.Ry(t);
      e instanceof GSet2 && this.ar.add(i, e);
    }
    DN() {
    }
    wg(t) {
    }
    xg(t) {
    }
    zy(t) {
    }
    sn(t, i) {
      if (t === void 0)
        return;
      let e = this.ar.getValue(t);
      e === null && (e = new GSet2(), this.ar.add(t, e)), e.add(i);
    }
    en(t, i) {
      if (t === void 0)
        return;
      const e = this.ar.getValue(t);
      e instanceof GSet2 && (i == null ? this.ar.remove(t) : (e.remove(i), e.count === 0 && this.ar.remove(t)));
    }
    Ry(t) {
      if (t === void 0)
        return null;
      const i = this.ar.getValue(t);
      return i instanceof GSet2 ? i : null;
    }
    pE(t) {
      t === void 0 ? this.ar.clear() : this.ar.remove(t);
    }
    get copyNodeDataFunction() {
      return this.Ec;
    }
    set copyNodeDataFunction(t) {
      const i = this.Ec;
      i !== t && (t !== null && Util.t(t, "function", _Model, "copyNodeDataFunction"), this.Ec = t, this.i("copyNodeDataFunction", i, t));
    }
    get copiesArrays() {
      return this.ag;
    }
    set copiesArrays(t) {
      const i = this.ag;
      i !== t && (t !== null && Util.t(t, "boolean", _Model, "copiesArrays"), this.ag = t, this.i("copiesArrays", i, t));
    }
    get copiesArrayObjects() {
      return this.fg;
    }
    set copiesArrayObjects(t) {
      const i = this.fg;
      i !== t && (t !== null && Util.t(t, "boolean", _Model, "copiesArrayObjects"), this.fg = t, this.i("copiesArrayObjects", i, t));
    }
    get copiesKey() {
      return this.cg;
    }
    set copiesKey(t) {
      const i = this.cg;
      i !== t && (t !== null && Util.t(t, "boolean", _Model, "copiesKey"), this.cg = t, this.i("copiesKey", i, t));
    }
    copyNodeData(t) {
      if (t === null)
        return null;
      let i = null;
      const e = this.Ec;
      return e !== null ? i = e(t, this) : i = this.Gb(t, true), Util.Mt(i), i;
    }
    Gb(t, i) {
      if (this.copiesArrays && Array.isArray(t)) {
        const e = t, s = [];
        for (let n = 0; n < e.length; n++) {
          const o = e[n], r = this.Gb(o, this.copiesArrayObjects);
          s.push(r);
        }
        return s;
      } else if (i && Util.Mt(t)) {
        const e = t, s = e.constructor, n = s ? new s() : {}, o = !this.copiesKey && typeof this.nodeKeyProperty == "string" ? this.nodeKeyProperty : null;
        for (const r in e) {
          if (r === "__gohashid") {
            n.__gohashid = void 0;
            continue;
          }
          if (r === o) {
            n[o] = void 0;
            continue;
          }
          const l = _Model.Xt(e, r);
          if (this.VO(e, r, l))
            _Model.dt(n, r, l);
          else {
            const h = this.Gb(l, false);
            _Model.dt(n, r, h);
          }
        }
        return n;
      } else
        return t instanceof Point2 || t instanceof Size2 || t instanceof Rect2 || t instanceof Spot2 || t instanceof Margin2 ? t.copy() : t;
    }
    get afterCopyFunction() {
      return this.ug;
    }
    set afterCopyFunction(t) {
      const i = this.ug;
      i !== t && (t !== null && Util.t(t, "function", _Model, "afterCopyFunction"), this.ug = t, this.i("afterCopyFunction", i, t));
    }
    VO(t, i, e) {
      const s = Util.an(e);
      return s === "GraphObject" || s === "Diagram" || s === "Layer" || s === "RowColumnDefinition" || s === "AnimationManager" || s === "Tool" || s === "CommandHandler" || s === "Layout" || s === "InputEvent" || s === "DiagramEvent" ? (Debug && i[0] !== "_" && Util.ft('Warning: found GraphObject or Diagram reference when copying model data on property "' + i + '" of data object: ' + t.toString() + `  
Model data should not have any references to a Diagram or any part of a diagram, such as: ` + e.toString()), true) : e instanceof _Model || e instanceof UndoManager2 || e instanceof Transaction2 || e instanceof ChangedEvent2;
    }
    setDataProperty(t, i, e) {
      if (Debug && (Util.t(t, "object", _Model, "setDataProperty:data"), Util.t(i, "string", _Model, "setDataProperty:propname"), i === "" && Util.n("Model.setDataProperty: property name must not be an empty string when setting " + t + " to " + e)), this.containsNodeData(t)) {
        if (i === this.nodeKeyProperty) {
          this.setKeyForNodeData(t, e);
          return;
        } else if (i === this.nodeCategoryProperty) {
          this.setCategoryForNodeData(t, e);
          return;
        }
      } else
        !_Model.YT && t instanceof GraphObject2 && (_Model.YT = true, Util.ft('Model.setDataProperty is modifying a GraphObject, "' + t.toString() + '"'), Util.ft("  Is that really your intent?"));
      const s = _Model.Xt(t, i);
      s !== e && (_Model.dt(t, i, e), this.raiseDataChanged(t, i, s, e));
    }
    set(t, i, e) {
      this.setDataProperty(t, i, e);
    }
    assignAllDataProperties(t, i) {
      if (!i)
        return;
      const e = this.containsNodeData(t);
      for (const s in i)
        s !== "__gohashid" && (e && s === this.nodeKeyProperty || this.setDataProperty(t, s, i[s]));
    }
    addArrayItem(t, i) {
      this.insertArrayItem(t, -1, i);
    }
    insertArrayItem(t, i, e) {
      Debug && (Util.Hg(t, _Model, "insertArrayItem:arr"), Util.r(i, _Model, "insertArrayItem:idx"), t === this.Ce && Util.n("Model.insertArrayItem or Model.addArrayItem should not be called on the Model.nodeDataArray")), i < 0 && (i = t.length), Util.au(t, i, e), this.Kt("", 3, "", t, null, e, null, i);
    }
    removeArrayItem(t, i) {
      i === void 0 && (i = -1), Debug && (Util.Hg(t, _Model, "removeArrayItem:arr"), Util.r(i, _Model, "removeArrayItem:idx")), t === this.Ce && Util.n("Model.removeArrayItem should not be called on the Model.nodeDataArray"), i === -1 && (i = t.length - 1);
      const e = t[i];
      Util.rf(t, i), this.Kt("", 4, "", t, e, null, i, null);
    }
    get nodeCategoryProperty() {
      return this.qa;
    }
    set nodeCategoryProperty(t) {
      const i = this.qa;
      i !== t && (this.En(t, _Model, "nodeCategoryProperty"), this.qa = t, this.i("nodeCategoryProperty", i, t));
    }
    getCategoryForNodeData(t) {
      if (t === null)
        return "";
      const i = this.qa;
      if (i === "")
        return "";
      const e = _Model.Xt(t, i);
      if (e === void 0)
        return "";
      if (typeof e == "string")
        return e;
      Util.n("getCategoryForNodeData found a non-string category for " + t + ": " + e);
    }
    setCategoryForNodeData(t, i) {
      if (Util.t(i, "string", _Model, "setCategoryForNodeData:cat"), t === null)
        return;
      const e = this.qa;
      if (e === "")
        return;
      if (!this.containsNodeData(t)) {
        _Model.dt(t, e, i);
        return;
      }
      let s = _Model.Xt(t, e);
      s === void 0 && (s = ""), s !== i && (_Model.dt(t, e, i), this.Kt("nodeCategory", 2, e, t, s, i));
    }
    yg(t, i) {
      this.setCategoryForNodeData(i, this.getCategoryForNodeData(t));
    }
    get type() {
      return "Model";
    }
    Qu() {
      return false;
    }
    bf() {
      return false;
    }
    _u() {
      return false;
    }
    Ea() {
      return false;
    }
    jw() {
      return false;
    }
    ma() {
      return false;
    }
    static initDiagramModel() {
      return new _Model();
    }
    static Ub(t) {
      return _Model.classMap[t] ? _Model.classMap[t] : root.go !== void 0 && root.go[t] ? root.go[t] : null;
    }
    static registerClass(t, i) {
      _Model.classMap[i] = t;
    }
    static Xt(t, i) {
      if (!t || !i)
        return null;
      let e;
      try {
        typeof i == "function" ? e = i(t) : typeof t.getAttribute == "function" ? (e = t.getAttribute(i), e === null && (e = void 0)) : e = t[i];
      } catch (s) {
        Debug && Util.ft("property get error: " + s.toString());
      }
      return e;
    }
    static dt(t, i, e) {
      if (!(!t || !i))
        try {
          typeof i == "function" ? i(t, e) : typeof t.setAttribute == "function" ? t.setAttribute(i, e) : t[i] = e;
        } catch (s) {
          Debug && Util.ft("property set error: " + s.toString());
        }
    }
  };
  __publicField(_Model, "YT", false);
  __publicField(_Model, "classMap", {});
  _Model.registerClass(Brush2, "Brush"), _Model.registerClass(ChangedEvent2, "ChangedEvent"), _Model.registerClass(Geometry2, "Geometry"), _Model.registerClass(Margin2, "Margin"), _Model.registerClass(Panel2, "Panel"), _Model.registerClass(Point2, "Point"), _Model.registerClass(Rect2, "Rect"), _Model.registerClass(Size2, "Size"), _Model.registerClass(Spot2, "Spot"), _Model.registerClass(Transaction2, "Transaction"), _Model.registerClass(UndoManager2, "UndoManager");
  let Model2 = _Model;
  Model2.fromJSON = Model2.fromJson = Model2.fromJson;
  const _GraphLinksModel = class _GraphLinksModel extends Model2 {
    constructor(t, i, e) {
      super();
      __publicField(this, "ss");
      __publicField(this, "fr");
      __publicField(this, "pi");
      __publicField(this, "Rh");
      __publicField(this, "Vc");
      __publicField(this, "Bc");
      __publicField(this, "Ol");
      __publicField(this, "No");
      __publicField(this, "Co");
      __publicField(this, "ja");
      __publicField(this, "Ja");
      __publicField(this, "Za");
      __publicField(this, "nn");
      __publicField(this, "zc");
      __publicField(this, "Vn");
      __publicField(this, "bg");
      __publicField(this, "UT", `,
  "insertedLinkKeys": `);
      __publicField(this, "BO", `,
  "modifiedLinkData": `);
      __publicField(this, "GT", `,
  "removedLinkKeys": `);
      if (this.ss = [], this.fr = new GSet2(), this.pi = new GMap2(), this.Rh = "", this.Vc = null, this.Bc = null, this.Ol = null, this.No = "from", this.Co = "to", this.ja = "", this.Ja = "", this.Za = "category", this.nn = "", this.zc = "isGroup", this.Vn = "group", this.bg = false, i !== void 0 && (this.linkDataArray = i), t !== void 0 && (Array.isArray(t) ? this.nodeDataArray = t : e = t), e) {
        Object.assign(this, e);
        const s = e.Changed;
        s && (delete this.Changed, this.addChangedListener(s));
      }
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Rh = this.Rh, t.Vc = this.Vc, t.Bc = this.Bc, t.No = this.No, t.Co = this.Co, t.ja = this.ja, t.Ja = this.Ja, t.Za = this.Za, t.nn = this.nn, t.zc = this.zc, t.Vn = this.Vn, t.bg = this.bg;
    }
    clear() {
      super.clear(), this.ss = [], this.pi.clear(), this.fr.clear();
    }
    toString(t) {
      if (t === void 0 && (t = 0), t >= 2)
        return this.toJson();
      {
        let i = (this.name !== "" ? this.name : "") + " GraphLinksModel";
        if (t > 0) {
          i += `
 node data:`;
          let e = this.nodeDataArray, s = e.length, n = 0;
          for (n = 0; n < s; n++) {
            const o = e[n];
            i += " " + this.getKeyForNodeData(o) + ":" + Binding2.toString(o);
          }
          for (i += `
 link data:`, e = this.linkDataArray, s = e.length, n = 0; n < s; n++) {
            const o = e[n];
            i += " " + this.ze(o, true) + "-->" + this.ze(o, false);
          }
        }
        return i;
      }
    }
    NN(t, i) {
      if (this.linkKeyProperty === "") {
        const c = this.skipsUndoManager;
        this.skipsUndoManager = true, this.linkKeyProperty = "key", this.skipsUndoManager = c;
      }
      let e = super.NN(t, i);
      const s = this, n = new GSet2(), o = new GSet2(), r = new GSet2(), l = this.Wa;
      t.changes.each((c) => {
        if (c.model === s) {
          if (c.modelChange === "linkDataArray")
            c.change === 3 ? n.add(c.newValue) : c.change === 4 && r.add(c.oldValue);
          else if (s.containsLinkData(c.object))
            o.add(c.object);
          else if (c.object !== null)
            if (c.object !== null && l && l.contains(c.object))
              l.get(c.object).each((d) => {
                s.containsLinkData(d) && o.add(d);
              });
            else {
              if (c.object instanceof Model2 || s.containsNodeData(c.object))
                return;
              s.KT(c.object).each((d) => o.add(d));
            }
        }
      });
      const h = this.gg;
      h.clear(), n.each((c) => {
        h.add(s.getKeyForLinkData(c)), i || o.add(c);
      });
      const a = this.dg;
      a.clear(), r.each((c) => {
        a.add(s.getKeyForLinkData(c)), i && o.add(c);
      });
      const f = s.cloneDeep(o.toArray());
      return h.count > 0 && (e === null && (e = {}), i ? e.removedLinkKeys = h.toArray() : e.insertedLinkKeys = h.toArray()), f.length > 0 && (e === null && (e = {}), e.modifiedLinkData = f), a.count > 0 && (e === null && (e = {}), i ? e.insertedLinkKeys = a.toArray() : e.removedLinkKeys = a.toArray()), a.clear(), h.clear(), e;
    }
    pg() {
      const t = super.pg();
      let i = "";
      return this.linkCategoryProperty !== "category" && typeof this.linkCategoryProperty == "string" && (i += `,
  "linkCategoryProperty": ` + this.Xe(this.linkCategoryProperty)), this.linkKeyProperty !== "" && typeof this.linkKeyProperty == "string" && (i += `,
  "linkKeyProperty": ` + this.Xe(this.linkKeyProperty)), this.linkFromKeyProperty !== "from" && typeof this.linkFromKeyProperty == "string" && (i += `,
  "linkFromKeyProperty": ` + this.Xe(this.linkFromKeyProperty)), this.linkToKeyProperty !== "to" && typeof this.linkToKeyProperty == "string" && (i += `,
  "linkToKeyProperty": ` + this.Xe(this.linkToKeyProperty)), this.linkFromPortIdProperty !== "" && typeof this.linkFromPortIdProperty == "string" && (i += `,
  "linkFromPortIdProperty": ` + this.Xe(this.linkFromPortIdProperty)), this.linkToPortIdProperty !== "" && typeof this.linkToPortIdProperty == "string" && (i += `,
  "linkToPortIdProperty": ` + this.Xe(this.linkToPortIdProperty)), this.linkLabelKeysProperty !== "" && typeof this.linkLabelKeysProperty == "string" && (i += `,
  "linkLabelKeysProperty": ` + this.Xe(this.linkLabelKeysProperty)), this.nodeIsGroupProperty !== "isGroup" && typeof this.nodeIsGroupProperty == "string" && (i += `,
  "nodeIsGroupProperty": ` + this.Xe(this.nodeIsGroupProperty)), this.nodeGroupKeyProperty !== "group" && typeof this.nodeGroupKeyProperty == "string" && (i += `,
  "nodeGroupKeyProperty": ` + this.Xe(this.nodeGroupKeyProperty)), t + i;
    }
    Ey(t) {
      super.Ey(t), t.linkKeyProperty && (this.linkKeyProperty = t.linkKeyProperty), t.linkFromKeyProperty && (this.linkFromKeyProperty = t.linkFromKeyProperty), t.linkToKeyProperty && (this.linkToKeyProperty = t.linkToKeyProperty), t.linkFromPortIdProperty && (this.linkFromPortIdProperty = t.linkFromPortIdProperty), t.linkToPortIdProperty && (this.linkToPortIdProperty = t.linkToPortIdProperty), t.linkCategoryProperty && (this.linkCategoryProperty = t.linkCategoryProperty), t.linkLabelKeysProperty && (this.linkLabelKeysProperty = t.linkLabelKeysProperty), t.nodeIsGroupProperty && (this.nodeIsGroupProperty = t.nodeIsGroupProperty), t.nodeGroupKeyProperty && (this.nodeGroupKeyProperty = t.nodeGroupKeyProperty);
    }
    CN() {
      const t = super.CN(), i = `,
  "linkDataArray": ` + this.Fh(this.linkDataArray, true);
      return t + i;
    }
    AN(t) {
      super.AN(t);
      const i = t.linkDataArray;
      Array.isArray(i) && (this.replaceJsonObjects(i), this.linkDataArray = i);
    }
    KT(t) {
      const i = new GSet2();
      for (let e = 0; e < this.linkDataArray.length; e++) {
        const s = this.linkDataArray[e];
        this.Kb(t, s, s, i);
      }
      return i;
    }
    TN(t, i) {
      if (this.linkKeyProperty === "") {
        const c = this.skipsUndoManager;
        this.skipsUndoManager = true, this.linkKeyProperty = "key", this.skipsUndoManager = c;
      }
      const e = super.TN(t, i), s = this, n = new GSet2(), o = new GSet2(), r = new GSet2(), l = this.Wa;
      t.changes.each((c) => {
        if (c.model === s) {
          if (c.modelChange === "linkDataArray")
            c.change === 3 ? n.add(c.newValue) : c.change === 4 && r.add(c.oldValue);
          else if (s.containsLinkData(c.object))
            o.add(c.object);
          else if (c.object !== null)
            if (c.object !== null && l && l.contains(c.object))
              l.get(c.object).each((d) => {
                s.containsLinkData(d) && o.add(d);
              });
            else {
              if (c.object instanceof Model2 || s.containsNodeData(c.object))
                return;
              s.KT(c.object).each((d) => o.add(d));
            }
        }
      });
      const h = this.gg;
      h.clear(), n.each((c) => {
        h.add(s.getKeyForLinkData(c)), i || o.add(c);
      });
      const a = this.dg;
      a.clear(), r.each((c) => {
        a.add(s.getKeyForLinkData(c)), i && o.add(c);
      });
      let f = e;
      return h.count > 0 && (f += (i ? this.GT : this.UT) + this.Fh(h.toArray(), true)), o.count > 0 && (f += this.BO + this.Fh(o.toArray(), true)), a.count > 0 && (f += (i ? this.UT : this.GT) + this.Fh(a.toArray(), true)), a.clear(), h.clear(), f;
    }
    Vy(t) {
      (t.linkCategoryProperty !== void 0 && t.linkCategoryProperty !== this.linkCategoryProperty || t.linkKeyProperty !== void 0 && t.linkKeyProperty !== this.linkKeyProperty || t.linkFromKeyProperty !== void 0 && t.linkFromKeyProperty !== this.linkFromKeyProperty || t.linkToKeyProperty !== void 0 && t.linkToKeyProperty !== this.linkToKeyProperty || t.linkFromPortIdProperty !== void 0 && t.linkFromPortIdProperty !== this.linkFromPortIdProperty || t.linkToPortIdProperty !== void 0 && t.linkToPortIdProperty !== this.linkToPortIdProperty || t.linkLabelKeysProperty !== void 0 && t.linkLabelKeysProperty !== this.linkLabelKeysProperty || t.nodeIsGroupProperty !== void 0 && t.nodeIsGroupProperty !== this.nodeIsGroupProperty || t.nodeGroupKeyProperty !== void 0 && t.nodeGroupKeyProperty !== this.nodeGroupKeyProperty) && Util.n("applyIncrementalJson cannot change Model properties"), super.Vy(t);
      const i = t.insertedLinkKeys;
      if (Array.isArray(i)) {
        const n = i.length;
        for (let o = 0; o < n; o++) {
          const r = i[o];
          let l = this.findLinkDataForKey(r);
          l === null && (l = this.copyLinkData({}), this.setKeyForLinkData(l, r), this.addLinkData(l));
        }
      }
      const e = t.modifiedLinkData;
      if (Array.isArray(e)) {
        const n = e.length;
        for (let o = 0; o < n; o++) {
          const r = e[o], l = this.getKeyForLinkData(r), h = this.findLinkDataForKey(l);
          if (h !== null) {
            for (const a in r)
              a === "__gohashid" || a === this.linkKeyProperty || this.setDataProperty(h, a, r[a]);
            this.HT(r, h);
          }
        }
      }
      const s = t.removedLinkKeys;
      if (Array.isArray(s)) {
        const n = s.length;
        for (let o = 0; o < n; o++) {
          const r = s[o], l = this.findLinkDataForKey(r);
          l !== null && this.removeLinkData(l);
        }
      }
    }
    changeState(t, i) {
      if (!(t === null || t.model !== this)) {
        if (t.change === 2) {
          const e = t.object, s = t.propertyName;
          if (s === this.linkKeyProperty && this.containsLinkData(e)) {
            const n = t.getValue(i), o = t.getValue(!i);
            o !== void 0 && this.pi.remove(o), n !== void 0 && this.pi.add(n, e), Model2.dt(e, s, n);
            return;
          }
        } else if (t.change === 3) {
          let e = t.newParam;
          if (t.modelChange === "linkDataArray") {
            const s = t.newValue;
            if (Util.Mt(s) && typeof e == "number") {
              const n = this.getKeyForLinkData(s);
              i ? (this.fr.remove(s), this.ss[e] === s && this.ss.splice(e, 1), n !== void 0 && this.pi.remove(n)) : (this.fr.add(s), this.ss[e] !== s && this.ss.splice(e, 0, s), n !== void 0 && this.pi.add(n, s));
            }
            return;
          } else if (t.modelChange === "linkLabelKeys") {
            const s = this.getLabelKeysForLinkData(t.object);
            Array.isArray(s) && typeof e == "number" && (i ? (e = s.indexOf(t.newValue), e >= 0 && s.splice(e, 1)) : s.indexOf(t.newValue) < 0 && s.splice(e, 0, t.newValue));
            return;
          }
        } else if (t.change === 4) {
          let e = t.oldParam;
          if (t.modelChange === "linkDataArray") {
            const s = t.oldValue;
            if (Util.Mt(s) && typeof e == "number") {
              const n = this.getKeyForLinkData(s);
              i ? (this.fr.add(s), this.ss[e] !== s && this.ss.splice(e, 0, s), n !== void 0 && this.pi.add(n, s)) : (this.fr.remove(s), this.ss[e] === s && this.ss.splice(e, 1), n !== void 0 && this.pi.remove(n));
            }
            return;
          } else if (t.modelChange === "linkLabelKeys") {
            const s = this.getLabelKeysForLinkData(t.object);
            Array.isArray(s) && typeof e == "number" && (i ? s.indexOf(t.newValue) < 0 && s.splice(e, 0, t.newValue) : (e = s.indexOf(t.newValue), e >= 0 && s.splice(e, 1)));
            return;
          }
        }
        super.changeState(t, i);
      }
    }
    get archetypeNodeData() {
      return this.Ol;
    }
    set archetypeNodeData(t) {
      const i = this.Ol;
      i !== t && (t !== null && Util.t(t, "object", _GraphLinksModel, "archetypeNodeData"), this.Ol = t, this.i("archetypeNodeData", i, t));
    }
    FN(t) {
      if (t === void 0)
        return;
      const i = this.Ol;
      if (i !== null) {
        let e = this.findNodeDataForKey(t);
        e === null && (e = this.copyNodeData(i), Model2.dt(e, this.nodeKeyProperty, t), this.addNodeData(e));
      }
      return t;
    }
    get linkFromKeyProperty() {
      return this.No;
    }
    set linkFromKeyProperty(t) {
      const i = this.No;
      i !== t && (this.En(t, _GraphLinksModel, "linkFromKeyProperty"), this.No = t, this.i("linkFromKeyProperty", i, t));
    }
    getFromKeyForLinkData(t) {
      return this.ze(t, true);
    }
    setFromKeyForLinkData(t, i) {
      this.rg(t, i, true);
    }
    get linkToKeyProperty() {
      return this.Co;
    }
    set linkToKeyProperty(t) {
      const i = this.Co;
      i !== t && (this.En(t, _GraphLinksModel, "linkToKeyProperty"), this.Co = t, this.i("linkToKeyProperty", i, t));
    }
    getToKeyForLinkData(t) {
      return this.ze(t, false);
    }
    setToKeyForLinkData(t, i) {
      this.rg(t, i, false);
    }
    ze(t, i) {
      if (t === null)
        return;
      const e = i ? this.No : this.Co;
      if (e === "")
        return;
      const s = Model2.Xt(t, e);
      if (s !== void 0) {
        if (this.isKeyType(s))
          return s;
        Util.n((i ? "FromKey" : "ToKey") + " value for link data " + t + " is not a number or a string: " + s);
      }
    }
    rg(t, i, e) {
      if (i === null && (i = void 0), i !== void 0 && !this.isKeyType(i) && Util.Bi(i, "number or string", _GraphLinksModel, e ? "setFromKeyForLinkData:key" : "setToKeyForLinkData:key"), t === null)
        return;
      const s = e ? this.No : this.Co;
      if (s === "")
        return;
      if (i = this.FN(i), !this.containsLinkData(t)) {
        Model2.dt(t, s, i);
        return;
      }
      const n = Model2.Xt(t, s);
      n !== i && (this.en(n, t), Model2.dt(t, s, i), this.findNodeDataForKey(i) === null && this.sn(i, t), this.Kt(e ? "linkFromKey" : "linkToKey", 2, s, t, n, i), typeof s == "string" && this.updateTargetBindings(t, s));
    }
    get linkFromPortIdProperty() {
      return this.ja;
    }
    set linkFromPortIdProperty(t) {
      const i = this.ja;
      i !== t && (this.En(t, _GraphLinksModel, "linkFromPortIdProperty"), Debug && (t === this.linkFromKeyProperty || t === this.linkToKeyProperty) && Util.n("linkFromPortIdProperty name must not be the same as the GraphLinksModel.linkFromKeyProperty or linkToKeyProperty: " + t), this.ja = t, this.i("linkFromPortIdProperty", i, t));
    }
    getFromPortIdForLinkData(t) {
      return this.Ob(t, true);
    }
    setFromPortIdForLinkData(t, i) {
      this.lg(t, i, true);
    }
    get linkToPortIdProperty() {
      return this.Ja;
    }
    set linkToPortIdProperty(t) {
      const i = this.Ja;
      i !== t && (this.En(t, _GraphLinksModel, "linkToPortIdProperty"), Debug && (t === this.linkFromKeyProperty || t === this.linkToKeyProperty) && Util.n("linkFromPortIdProperty name must not be the same as the GraphLinksModel.linkFromKeyProperty or linkToKeyProperty: " + t), this.Ja = t, this.i("linkToPortIdProperty", i, t));
    }
    getToPortIdForLinkData(t) {
      return this.Ob(t, false);
    }
    setToPortIdForLinkData(t, i) {
      this.lg(t, i, false);
    }
    Ob(t, i) {
      if (t === null)
        return "";
      const e = i ? this.ja : this.Ja;
      if (e === "")
        return "";
      const s = Model2.Xt(t, e);
      return s === void 0 ? "" : s;
    }
    lg(t, i, e) {
      if (Util.t(i, "string", _GraphLinksModel, e ? "setFromPortIdForLinkData:portname" : "setToPortIdForLinkData:portname"), t === null)
        return;
      const s = e ? this.ja : this.Ja;
      if (s === "")
        return;
      if (!this.containsLinkData(t)) {
        Model2.dt(t, s, i);
        return;
      }
      let n = Model2.Xt(t, s);
      n === void 0 && (n = ""), n !== i && (Model2.dt(t, s, i), this.Kt(e ? "linkFromPortId" : "linkToPortId", 2, s, t, n, i), typeof s == "string" && this.updateTargetBindings(t, s));
    }
    get linkLabelKeysProperty() {
      return this.nn;
    }
    set linkLabelKeysProperty(t) {
      const i = this.nn;
      i !== t && (this.En(t, _GraphLinksModel, "linkLabelKeysProperty"), this.nn = t, this.i("linkLabelKeysProperty", i, t));
    }
    getLabelKeysForLinkData(t) {
      if (t === null)
        return _GraphLinksModel.EmptyArray;
      const i = this.nn;
      if (i === "")
        return _GraphLinksModel.EmptyArray;
      const e = Model2.Xt(t, i);
      return e === void 0 ? _GraphLinksModel.EmptyArray : e;
    }
    setLabelKeysForLinkData(t, i) {
      if (Util.Hg(i, _GraphLinksModel, "setLabelKeysForLinkData:arr"), t === null)
        return;
      const e = this.nn;
      if (e === "")
        return;
      if (!this.containsLinkData(t)) {
        Model2.dt(t, e, i);
        return;
      }
      let s = Model2.Xt(t, e);
      if (s === void 0 && (s = _GraphLinksModel.EmptyArray), s !== i) {
        if (Array.isArray(s)) {
          const o = s.length;
          for (let r = 0; r < o; r++) {
            const l = s[r];
            this.en(l, t);
          }
        }
        Model2.dt(t, e, i);
        const n = i.length;
        for (let o = 0; o < n; o++) {
          const r = i[o];
          this.findNodeDataForKey(r) === null && this.sn(r, t);
        }
        this.Kt("linkLabelKeys", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e);
      }
    }
    addLabelKeyForLinkData(t, i) {
      if (i == null || (this.isKeyType(i) || Util.Bi(i, "number or string", _GraphLinksModel, "addLabelKeyForLinkData:key"), t === null))
        return;
      const e = this.nn;
      if (e === "")
        return;
      const s = Model2.Xt(t, e);
      if (s === void 0) {
        const n = [];
        n.push(i), this.setLabelKeysForLinkData(t, n);
      } else if (Array.isArray(s)) {
        let n = s.indexOf(i);
        if (n >= 0)
          return;
        n = s.length, s.push(i), this.containsLinkData(t) && (this.findNodeDataForKey(i) === null && this.sn(i, t), this.Kt("linkLabelKeys", 3, e, t, null, i, null, n));
      } else
        Util.n(e + " property is not an Array; cannot addLabelKeyForLinkData: " + t);
    }
    removeLabelKeyForLinkData(t, i) {
      if (i == null || (this.isKeyType(i) || Util.Bi(i, "number or string", _GraphLinksModel, "removeLabelKeyForLinkData:key"), t === null))
        return;
      const e = this.nn;
      if (e === "")
        return;
      const s = Model2.Xt(t, e);
      if (Array.isArray(s)) {
        const n = s.indexOf(i);
        if (n < 0)
          return;
        s.splice(n, 1), this.containsLinkData(t) && (this.en(i, t), this.Kt("linkLabelKeys", 4, e, t, i, null, n, null));
      } else
        s !== void 0 && Util.n(e + " property is not an Array; cannot removeLabelKeyforLinkData: " + t);
    }
    get linkDataArray() {
      return this.ss;
    }
    set linkDataArray(t) {
      const i = this.ss;
      if (i !== t) {
        Util.Hg(t, _GraphLinksModel, "linkDataArray"), this.pi.clear();
        const e = t.length;
        for (let n = 0; n < e; n++) {
          const o = t[n];
          Util.Mt(o) || Util.n("GraphLinksModel.linkDataArray must only contain Objects, not: " + o);
        }
        if (this.ss = t, this.linkKeyProperty !== "") {
          const n = new List2();
          for (let r = 0; r < e; r++) {
            const l = t[r], h = this.getKeyForLinkData(l);
            h === void 0 || this.pi.getValue(h) !== null ? n.add(l) : this.pi.add(h, l);
          }
          const o = n.iterator;
          for (; o.next(); ) {
            const r = o.value;
            this.makeLinkDataKeyUnique(r);
            const l = this.getKeyForLinkData(r);
            l !== void 0 && this.pi.add(l, r);
          }
        }
        const s = new GSet2();
        for (let n = 0; n < e; n++) {
          const o = t[n];
          s.add(o);
        }
        this.fr = s, this.Kt("linkDataArray", 2, "linkDataArray", this, i, t);
        for (let n = 0; n < e; n++) {
          const o = t[n];
          this.RN(o);
        }
      }
    }
    get linkKeyProperty() {
      return this.Rh;
    }
    set linkKeyProperty(t) {
      const i = this.Rh;
      if (i !== t) {
        this.En(t, _GraphLinksModel, "linkKeyProperty"), this.Rh = t, this.pi.clear();
        const e = this.linkDataArray.length;
        for (let s = 0; s < e; s++) {
          const n = this.linkDataArray[s];
          let o = this.getKeyForLinkData(n);
          o === void 0 && (this.makeLinkDataKeyUnique(n), o = this.getKeyForLinkData(n)), o !== void 0 && this.pi.add(o, n);
        }
        this.i("linkKeyProperty", i, t);
      }
    }
    getKeyForLinkData(t) {
      if (t === null)
        return;
      const i = this.Rh;
      if (i === "")
        return;
      const e = Model2.Xt(t, i);
      if (e !== void 0) {
        if (this.isKeyType(e))
          return e;
        Util.n("Key value for link data " + t + " is not a number or a string: " + e);
      }
    }
    setKeyForLinkData(t, i) {
      if ((i == null || !this.isKeyType(i)) && Util.Bi(i, "number or string", _GraphLinksModel, "setKeyForLinkData:key"), t === null)
        return;
      const e = this.Rh;
      if (e === "")
        return;
      if (!this.containsLinkData(t)) {
        Model2.dt(t, e, i);
        return;
      }
      const s = Model2.Xt(t, e);
      if (s !== i) {
        if (this.findLinkDataForKey(i) !== null)
          return;
        Model2.dt(t, e, i), s !== void 0 && this.pi.remove(s), this.pi.add(i, t), this.Kt("linkKey", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e);
      }
    }
    get makeUniqueLinkKeyFunction() {
      return this.Vc;
    }
    set makeUniqueLinkKeyFunction(t) {
      const i = this.Vc;
      i !== t && (t !== null && Util.t(t, "function", _GraphLinksModel, "makeUniqueLinkKeyFunction"), this.Vc = t, this.i("makeUniqueLinkKeyFunction", i, t));
    }
    findLinkDataForKey(t) {
      return t === null && Util.n("GraphLinksModel.findLinkDataForKey:key must not be null"), t === void 0 || !this.isKeyType(t) ? null : this.pi.getValue(t);
    }
    makeLinkDataKeyUnique(t) {
      if (t === null)
        return;
      const i = this.Rh;
      if (i === "")
        return;
      let e = this.getKeyForLinkData(t);
      if (e !== void 0 && !this.pi.contains(e))
        return;
      const s = this.Vc;
      if (s !== null && (e = s(this, t), e != null && !this.pi.contains(e))) {
        Model2.dt(t, i, e);
        return;
      }
      if (typeof e == "string") {
        let n = 2;
        for (; this.pi.contains(e + n); )
          n++;
        Model2.dt(t, i, e + n);
      } else if (e === void 0 || typeof e == "number") {
        let n = -this.pi.count - 1;
        for (; this.pi.contains(n); )
          n--;
        Model2.dt(t, i, n);
      } else
        Debug && Util.n("GraphLinksModel.getKeyForLinkData returned something other than a string or a number: " + e);
    }
    containsLinkData(t) {
      return t === null ? false : this.fr.contains(t);
    }
    addLinkData(t) {
      t !== null && (this.containsLinkData(t) || this.DT(t, true));
    }
    DT(t, i) {
      if (this.linkKeyProperty !== "") {
        let s = this.getKeyForLinkData(t);
        if (s === void 0)
          this.makeLinkDataKeyUnique(t), s = this.getKeyForLinkData(t);
        else {
          if (this.pi.getValue(s) === t)
            return;
          this.makeLinkDataKeyUnique(t), s = this.getKeyForLinkData(t);
        }
        s === void 0 && Util.n("GraphLinksModel.makeLinkDataKeyUnique failed on " + t + ". Data not added to model."), this.pi.add(s, t);
      }
      this.fr.add(t);
      let e = null;
      i && (e = this.ss.length, this.ss.splice(e, 0, t)), this.Kt("linkDataArray", 3, "linkDataArray", this, null, t, null, e), this.RN(t);
    }
    addLinkDataCollection(t) {
      if (Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++)
          this.addLinkData(t[e]);
      } else {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          this.addLinkData(e);
        }
      }
    }
    removeLinkData(t) {
      t !== null && this.TT(t, true);
    }
    TT(t, i) {
      this.fr.remove(t);
      const e = this.getKeyForLinkData(t);
      e !== void 0 && this.pi.remove(e);
      let s = null;
      if (i) {
        if (s = this.ss.indexOf(t), s < 0)
          return;
        this.ss.splice(s, 1);
      }
      this.Kt("linkDataArray", 4, "linkDataArray", this, t, null, s, null), this.zO(t);
    }
    removeLinkDataCollection(t) {
      if (Array.isArray(t)) {
        const i = t.length;
        for (let e = 0; e < i; e++)
          this.removeLinkData(t[e]);
      } else {
        const i = t.iterator;
        for (; i.next(); ) {
          const e = i.value;
          this.removeLinkData(e);
        }
      }
    }
    mergeLinkDataArray(t) {
      if (this.linkKeyProperty === "" && Util.n("GraphLinksModel.linkKeyProperty must not be an empty string for .mergeLinkDataArray() to succeed."), t !== this.linkDataArray && Array.isArray(t)) {
        const i = this.dg;
        i.clear(), i.addAll(this.pi.iteratorKeys);
        const e = this.gg;
        e.clear();
        const s = t.length;
        for (let o = 0; o < s; o++) {
          const r = t[o], l = this.getKeyForLinkData(r);
          if (l !== void 0) {
            e.add(l);
            const h = this.findLinkDataForKey(l);
            if (h === r)
              continue;
            if (h !== null)
              this.assignAllDataProperties(h, r), this.HT(r, h);
            else {
              const a = this.cloneDeep(r);
              this.setKeyForLinkData(a, l), this.addLinkData(a);
            }
          } else {
            const h = this.cloneDeep(r);
            this.addLinkData(h), e.add(this.getKeyForLinkData(h));
          }
        }
        const n = i.iterator;
        for (; n.next(); ) {
          const o = n.value;
          if (!e.contains(o)) {
            const r = this.findLinkDataForKey(o);
            r && this.removeLinkData(r);
          }
        }
        i.clear(), e.clear();
      }
    }
    RN(t) {
      let i = this.ze(t, true);
      i = this.FN(i), this.findNodeDataForKey(i) === null && this.sn(i, t), i = this.ze(t, false), i = this.FN(i), this.findNodeDataForKey(i) === null && this.sn(i, t);
      const e = this.getLabelKeysForLinkData(t);
      if (Array.isArray(e)) {
        const s = e.length;
        for (let n = 0; n < s; n++)
          i = e[n], this.findNodeDataForKey(i) === null && this.sn(i, t);
      }
    }
    zO(t) {
      let i = this.ze(t, true);
      this.en(i, t), i = this.ze(t, false), this.en(i, t);
      const e = this.getLabelKeysForLinkData(t);
      if (Array.isArray(e)) {
        const s = e.length;
        for (let n = 0; n < s; n++)
          i = e[n], this.en(i, t);
      }
    }
    get copyLinkDataFunction() {
      return this.Bc;
    }
    set copyLinkDataFunction(t) {
      const i = this.Bc;
      i !== t && (t !== null && Util.t(t, "function", _GraphLinksModel, "copyLinkDataFunction"), this.Bc = t, this.i("copyLinkDataFunction", i, t));
    }
    copyLinkData(t) {
      if (t === null)
        return null;
      let i = null;
      const e = this.Bc;
      return e !== null ? i = e(t, this) : i = this.Gb(t, true), Util.Mt(i) && (this.No !== "" && Model2.dt(i, this.No, void 0), this.Co !== "" && Model2.dt(i, this.Co, void 0), this.nn !== "" && Model2.dt(i, this.nn, [])), i;
    }
    get nodeIsGroupProperty() {
      return this.zc;
    }
    set nodeIsGroupProperty(t) {
      const i = this.zc;
      i !== t && (this.En(t, _GraphLinksModel, "nodeIsGroupProperty"), this.zc = t, this.i("nodeIsGroupProperty", i, t));
    }
    isGroupForNodeData(t) {
      if (t === null)
        return false;
      const i = this.zc;
      return i === "" ? false : !!Model2.Xt(t, i);
    }
    isGroupForData(t) {
      return this.isGroupForNodeData(t);
    }
    get nodeGroupKeyProperty() {
      return this.Vn;
    }
    set nodeGroupKeyProperty(t) {
      const i = this.Vn;
      i !== t && (this.En(t, _GraphLinksModel, "nodeGroupKeyProperty"), this.Vn = t, this.i("nodeGroupKeyProperty", i, t));
    }
    get copiesGroupKeyOfNodeData() {
      return this.bg;
    }
    set copiesGroupKeyOfNodeData(t) {
      this.bg !== t && (Util.t(t, "boolean", _GraphLinksModel, "copiesGroupKeyOfNodeData"), this.bg = t);
    }
    getGroupKeyForNodeData(t) {
      if (t === null)
        return;
      const i = this.Vn;
      if (i === "")
        return;
      const e = Model2.Xt(t, i);
      if (e !== void 0) {
        if (this.isKeyType(e))
          return e;
        Util.n("GroupKey value for node data " + t + " is not a number or a string: " + e);
      }
    }
    getGroupForData(t) {
      return this.getGroupKeyForNodeData(t);
    }
    setGroupKeyForNodeData(t, i) {
      if (i === null && (i = void 0), i !== void 0 && !this.isKeyType(i) && Util.Bi(i, "number or string", _GraphLinksModel, "setGroupKeyForNodeData:key"), t === null)
        return;
      const e = this.Vn;
      if (e === "")
        return;
      if (!this.containsNodeData(t)) {
        Model2.dt(t, e, i);
        return;
      }
      const s = Model2.Xt(t, e);
      s !== i && (this.en(s, t), Model2.dt(t, e, i), this.findNodeDataForKey(i) === null && this.sn(i, t), this.Kt("nodeGroupKey", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e));
    }
    setGroupForData(t, i) {
      this.setGroupKeyForNodeData(t, i);
    }
    copyNodeData(t) {
      if (t === null)
        return null;
      const i = super.copyNodeData(t);
      return !this.copiesGroupKeyOfNodeData && this.Vn !== "" && Model2.Xt(i, this.Vn) !== void 0 && Model2.dt(i, this.Vn, void 0), i;
    }
    setDataProperty(t, i, e) {
      if (Debug && (Util.t(t, "object", _GraphLinksModel, "setDataProperty:data"), Util.t(i, "string", _GraphLinksModel, "setDataProperty:propname"), i === "" && Util.n("GraphLinksModel.setDataProperty: property name must not be an empty string when setting " + t + " to " + e)), this.containsNodeData(t))
        if (i === this.nodeKeyProperty) {
          this.setKeyForNodeData(t, e);
          return;
        } else if (i === this.nodeCategoryProperty) {
          this.setCategoryForNodeData(t, e);
          return;
        } else if (i === this.nodeGroupKeyProperty) {
          this.setGroupKeyForNodeData(t, e);
          return;
        } else
          Debug && i === this.nodeIsGroupProperty && Util.n("GraphLinksModel.setDataProperty: property name must not be the nodeIsGroupProperty: " + i);
      else if (this.containsLinkData(t)) {
        if (i === this.linkFromKeyProperty) {
          this.rg(t, e, true);
          return;
        } else if (i === this.linkToKeyProperty) {
          this.rg(t, e, false);
          return;
        } else if (i === this.linkFromPortIdProperty) {
          this.lg(t, e, true);
          return;
        } else if (i === this.linkToPortIdProperty) {
          this.lg(t, e, false);
          return;
        } else if (i === this.linkKeyProperty) {
          this.setKeyForLinkData(t, e);
          return;
        } else if (i === this.linkCategoryProperty) {
          this.setCategoryForLinkData(t, e);
          return;
        } else if (i === this.linkLabelKeysProperty) {
          this.setLabelKeysForLinkData(t, e);
          return;
        }
      }
      const s = Model2.Xt(t, i);
      s !== e && (Model2.dt(t, i, e), this.raiseDataChanged(t, i, s, e));
    }
    assignAllDataProperties(t, i) {
      if (!i)
        return;
      const e = this.containsNodeData(t), s = this.containsLinkData(t);
      for (const n in i)
        if (n !== "__gohashid" && !(e && n === this.nodeKeyProperty)) {
          {
            if (e && n === this.nodeIsGroupProperty && Model2.Xt(t, n) === i[n])
              continue;
            if (s && n === this.linkKeyProperty)
              continue;
          }
          this.setDataProperty(t, n, i[n]);
        }
    }
    By(t, i) {
      super.By(t, i);
      const e = this.oi.iterator;
      for (; e.next(); ) {
        const n = e.value;
        this.IN(n, t, i);
      }
      const s = this.fr.iterator;
      for (; s.next(); ) {
        const n = s.value;
        this.XO(n, t, i);
      }
    }
    IN(t, i, e) {
      if (this.getGroupKeyForNodeData(t) === i) {
        const n = this.Vn;
        Model2.dt(t, n, e), this.Kt("nodeGroupKey", 2, n, t, i, e), typeof n == "string" && this.updateTargetBindings(t, n);
      }
    }
    XO(t, i, e) {
      if (this.ze(t, true) === i) {
        const r = this.No;
        Model2.dt(t, r, e), this.Kt("linkFromKey", 2, r, t, i, e), typeof r == "string" && this.updateTargetBindings(t, r);
      }
      if (this.ze(t, false) === i) {
        const r = this.Co;
        Model2.dt(t, r, e), this.Kt("linkToKey", 2, r, t, i, e), typeof r == "string" && this.updateTargetBindings(t, r);
      }
      const o = this.getLabelKeysForLinkData(t);
      if (Array.isArray(o)) {
        const r = o.length, l = this.nn;
        for (let h = 0; h < r; h++)
          o[h] === i && (o[h] = e, this.Kt("linkLabelKeys", 3, l, t, i, e, h, h));
      }
    }
    DN() {
      super.DN();
      const t = this.linkDataArray, i = t.length;
      for (let e = 0; e < i; e++) {
        const s = t[e];
        this.RN(s);
      }
    }
    wg(t) {
      super.wg(t);
      const i = this.getKeyForNodeData(t), e = this.Ry(i);
      if (e !== null) {
        const s = Util.ct(), n = e.iterator;
        for (; n.next(); ) {
          const o = n.value;
          if (this.containsNodeData(o)) {
            if (this.getGroupKeyForNodeData(o) === i) {
              const l = this.Vn;
              this.Kt("nodeGroupKey", 2, l, o, i, i), typeof l == "string" && this.updateTargetBindings(o, l), s.push(o);
            }
          } else {
            if (this.ze(o, true) === i) {
              const a = this.No;
              this.Kt("linkFromKey", 2, a, o, i, i), typeof a == "string" && this.updateTargetBindings(o, a), s.push(o);
            }
            if (this.ze(o, false) === i) {
              const a = this.Co;
              this.Kt("linkToKey", 2, a, o, i, i), typeof a == "string" && this.updateTargetBindings(o, a), s.push(o);
            }
            const h = this.getLabelKeysForLinkData(o);
            if (Array.isArray(h)) {
              const a = h.length, f = this.nn;
              for (let c = 0; c < a; c++)
                h[c] === i && (this.Kt("linkLabelKeys", 3, f, o, i, i, c, c), s.push(o));
            }
          }
        }
        for (let o = 0; o < s.length; o++)
          this.en(i, s[o]);
        Util.ot(s);
      }
    }
    xg(t) {
      super.xg(t);
      const i = this.getGroupKeyForNodeData(t);
      this.findNodeDataForKey(i) === null && this.sn(i, t);
    }
    zy(t) {
      super.zy(t);
      const i = this.getGroupKeyForNodeData(t);
      this.en(i, t);
    }
    get linkCategoryProperty() {
      return this.Za;
    }
    set linkCategoryProperty(t) {
      const i = this.Za;
      i !== t && (this.En(t, _GraphLinksModel, "linkCategoryProperty"), this.Za = t, this.i("linkCategoryProperty", i, t));
    }
    getCategoryForLinkData(t) {
      if (t === null)
        return "";
      const i = this.Za;
      if (i === "")
        return "";
      const e = Model2.Xt(t, i);
      if (e === void 0)
        return "";
      if (typeof e == "string")
        return e;
      Util.n("getCategoryForLinkData found a non-string category for " + t + ": " + e);
    }
    getLinkCategoryForData(t) {
      return this.getCategoryForLinkData(t);
    }
    setCategoryForLinkData(t, i) {
      if (Util.t(i, "string", _GraphLinksModel, "setCategoryForLinkData:cat"), t === null)
        return;
      const e = this.Za;
      if (e === "")
        return;
      if (!this.containsLinkData(t)) {
        Model2.dt(t, e, i);
        return;
      }
      let s = Model2.Xt(t, e);
      s === void 0 && (s = ""), s !== i && (Model2.dt(t, e, i), this.Kt("linkCategory", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e));
    }
    setLinkCategoryForData(t, i) {
      this.setCategoryForLinkData(t, i);
    }
    yg(t, i) {
      super.yg(t, i), this.setGroupKeyForNodeData(i, this.getGroupKeyForNodeData(t));
    }
    HT(t, i) {
      this.setCategoryForLinkData(i, this.getCategoryForLinkData(t)), this.setFromKeyForLinkData(i, this.getFromKeyForLinkData(t)), this.setToKeyForLinkData(i, this.getToKeyForLinkData(t)), this.setLabelKeysForLinkData(i, this.getLabelKeysForLinkData(t)), this.setFromPortIdForLinkData(i, this.getFromPortIdForLinkData(t)), this.setToPortIdForLinkData(i, this.getToPortIdForLinkData(t));
    }
    get type() {
      return "GraphLinksModel";
    }
    bf() {
      return true;
    }
    Ea() {
      return true;
    }
    jw() {
      return true;
    }
    ma() {
      return true;
    }
  };
  __publicField(_GraphLinksModel, "EmptyArray", Object.freeze([]));
  let GraphLinksModel2 = _GraphLinksModel;
  Model2.registerClass(GraphLinksModel2, "GraphLinksModel"), Model2.constructGraphLinksModel = Model2.constructGraphLinksModel = () => new GraphLinksModel2(), Model2.initDiagramModel = Model2.initDiagramModel = () => new GraphLinksModel2();
  class TreeModel2 extends Model2 {
    constructor(t, i) {
      super();
      __publicField(this, "Bn");
      __publicField(this, "kg");
      __publicField(this, "$a");
      if (this.Bn = "parent", this.kg = false, this.$a = "parentLinkCategory", t !== void 0 && (Array.isArray(t) ? this.nodeDataArray = t : i = t), i) {
        Object.assign(this, i);
        const e = i.Changed;
        e && (delete this.Changed, this.addChangedListener(e));
      }
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Bn = this.Bn, t.kg = this.kg, t.$a = this.$a;
    }
    toString(t) {
      if (t === void 0 && (t = 0), t >= 2)
        return this.toJson();
      {
        let i = (this.name !== "" ? this.name : "") + " TreeModel";
        if (t > 0) {
          i += `
 node data:`;
          const e = this.nodeDataArray, s = e.length;
          for (let n = 0; n < s; n++) {
            const o = e[n];
            i += " " + this.getKeyForNodeData(o) + ":" + Binding2.toString(o);
          }
        }
        return i;
      }
    }
    pg() {
      const t = super.pg();
      let i = "";
      return this.nodeParentKeyProperty !== "parent" && typeof this.nodeParentKeyProperty == "string" && (i += `,
  "nodeParentKeyProperty": ` + this.Xe(this.nodeParentKeyProperty)), t + i;
    }
    Ey(t) {
      super.Ey(t), t.nodeParentKeyProperty && (this.nodeParentKeyProperty = t.nodeParentKeyProperty);
    }
    Vy(t) {
      t.nodeParentKeyProperty !== void 0 && t.nodeParentKeyProperty !== this.nodeParentKeyProperty && Util.n("applyIncrementalJson cannot change Model properties"), super.Vy(t);
    }
    maybeEnsureLinkReference(t) {
      return t;
    }
    get nodeParentKeyProperty() {
      return this.Bn;
    }
    set nodeParentKeyProperty(t) {
      const i = this.Bn;
      i !== t && (this.En(t, TreeModel2, "nodeParentKeyProperty"), this.Bn = t, this.i("nodeParentKeyProperty", i, t));
    }
    get copiesParentKeyOfNodeData() {
      return this.kg;
    }
    set copiesParentKeyOfNodeData(t) {
      this.kg !== t && (Util.t(t, "boolean", TreeModel2, "copiesParentKeyOfNodeData"), this.kg = t);
    }
    getParentKeyForNodeData(t) {
      if (t === null)
        return;
      const i = this.Bn;
      if (i === "")
        return;
      const e = Model2.Xt(t, i);
      if (e !== void 0) {
        if (this.isKeyType(e))
          return e;
        Util.n("ParentKey value for node data " + t + " is not a number or a string: " + e);
      }
    }
    setParentKeyForNodeData(t, i) {
      if (i === null && (i = void 0), i !== void 0 && !this.isKeyType(i) && Util.Bi(i, "number or string", TreeModel2, "setParentKeyForNodeData:key"), t === null)
        return;
      const e = this.Bn;
      if (e === "")
        return;
      if (i = this.maybeEnsureLinkReference(i), !this.containsNodeData(t)) {
        Model2.dt(t, e, i);
        return;
      }
      const s = Model2.Xt(t, e);
      s !== i && (this.en(s, t), Model2.dt(t, e, i), this.findNodeDataForKey(i) === null && this.sn(i, t), this.Kt("nodeParentKey", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e));
    }
    get parentLinkCategoryProperty() {
      return this.$a;
    }
    set parentLinkCategoryProperty(t) {
      const i = this.$a;
      i !== t && (this.En(t, TreeModel2, "parentLinkCategoryProperty"), this.$a = t, this.i("parentLinkCategoryProperty", i, t));
    }
    get linkCategoryProperty() {
      return this.parentLinkCategoryProperty;
    }
    set linkCategoryProperty(t) {
      this.parentLinkCategoryProperty = t;
    }
    getParentLinkCategoryForNodeData(t) {
      if (t === null)
        return "";
      const i = this.$a;
      if (i === "")
        return "";
      const e = Model2.Xt(t, i);
      if (e === void 0)
        return "";
      if (typeof e == "string")
        return e;
      Util.n("getParentLinkCategoryForNodeData found a non-string category for " + t + ": " + e);
    }
    getLinkCategoryForData(t) {
      return this.getParentLinkCategoryForNodeData(t);
    }
    setParentLinkCategoryForNodeData(t, i) {
      if (Util.t(i, "string", TreeModel2, "setParentLinkCategoryForNodeData:cat"), t === null)
        return;
      const e = this.$a;
      if (e === "")
        return;
      if (!this.containsNodeData(t)) {
        Model2.dt(t, e, i);
        return;
      }
      let s = Model2.Xt(t, e);
      s === void 0 && (s = ""), s !== i && (Model2.dt(t, e, i), this.Kt("parentLinkCategory", 2, e, t, s, i), typeof e == "string" && this.updateTargetBindings(t, e));
    }
    setLinkCategoryForData(t, i) {
      this.setParentLinkCategoryForNodeData(t, i);
    }
    copyNodeData(t) {
      if (t === null)
        return null;
      const i = super.copyNodeData(t);
      return !this.copiesParentKeyOfNodeData && this.Bn !== "" && Model2.Xt(i, this.Bn) !== void 0 && Model2.dt(i, this.Bn, void 0), i;
    }
    setDataProperty(t, i, e) {
      if (Debug && (Util.t(t, "object", TreeModel2, "setDataProperty:data"), Util.t(i, "string", TreeModel2, "setDataProperty:propname"), i === "" && Util.n("TreeModel.setDataProperty: property name must not be an empty string when setting " + t + " to " + e)), this.containsNodeData(t)) {
        if (i === this.nodeKeyProperty) {
          this.setKeyForNodeData(t, e);
          return;
        } else if (i === this.nodeCategoryProperty) {
          this.setCategoryForNodeData(t, e);
          return;
        } else if (i === this.nodeParentKeyProperty) {
          this.setParentKeyForNodeData(t, e);
          return;
        }
      }
      const s = Model2.Xt(t, i);
      s !== e && (Model2.dt(t, i, e), this.raiseDataChanged(t, i, s, e));
    }
    By(t, i) {
      super.By(t, i);
      const e = this.oi.iterator;
      for (; e.next(); ) {
        const s = e.value;
        this.IN(s, t, i);
      }
    }
    IN(t, i, e) {
      if (this.getParentKeyForNodeData(t) === i) {
        const n = this.Bn;
        Model2.dt(t, n, e), this.Kt("nodeParentKey", 2, n, t, i, e), typeof n == "string" && this.updateTargetBindings(t, n);
      }
    }
    wg(t) {
      super.wg(t);
      const i = this.getKeyForNodeData(t), e = this.Ry(i);
      if (e !== null) {
        const s = Util.ct(), n = e.iterator;
        for (; n.next(); ) {
          const o = n.value;
          if (this.containsNodeData(o) && this.getParentKeyForNodeData(o) === i) {
            const l = this.Bn;
            this.Kt("nodeParentKey", 2, l, o, i, i), typeof l == "string" && this.updateTargetBindings(o, l), s.push(o);
          }
        }
        for (let o = 0; o < s.length; o++)
          this.en(i, s[o]);
        Util.ot(s);
      }
    }
    xg(t) {
      super.xg(t);
      let i = this.getParentKeyForNodeData(t);
      i = this.maybeEnsureLinkReference(i), this.findNodeDataForKey(i) === null && this.sn(i, t);
    }
    zy(t) {
      super.zy(t);
      const i = this.getParentKeyForNodeData(t);
      this.en(i, t);
    }
    yg(t, i) {
      super.yg(t, i), this.setParentLinkCategoryForNodeData(i, this.getParentLinkCategoryForNodeData(t)), this.setParentKeyForNodeData(i, this.getParentKeyForNodeData(t));
    }
    get type() {
      return "TreeModel";
    }
    Qu() {
      return true;
    }
    jw() {
      return true;
    }
  }
  Model2.registerClass(TreeModel2, "TreeModel");
  var CircularArrangement2 = ((w) => (w[w.ConstantSpacing = 0] = "ConstantSpacing", w[w.ConstantDistance = 1] = "ConstantDistance", w[w.ConstantAngle = 2] = "ConstantAngle", w[w.Packed = 3] = "Packed", w))(CircularArrangement2 || {}), CircularDirection2 = ((w) => (w[w.Clockwise = 10] = "Clockwise", w[w.Counterclockwise = 11] = "Counterclockwise", w[w.BidirectionalLeft = 12] = "BidirectionalLeft", w[w.BidirectionalRight = 13] = "BidirectionalRight", w))(CircularDirection2 || {}), CircularSorting2 = ((w) => (w[w.Forwards = 20] = "Forwards", w[w.Reverse = 21] = "Reverse", w[w.Ascending = 22] = "Ascending", w[w.Descending = 23] = "Descending", w[w.Optimized = 24] = "Optimized", w))(CircularSorting2 || {}), CircularNodeDiameterFormula2 = ((w) => (w[w.Pythagorean = 30] = "Pythagorean", w[w.Circular = 31] = "Circular", w))(CircularNodeDiameterFormula2 || {});
  const _CircularLayout = class _CircularLayout extends Layout2 {
    constructor(t) {
      super();
      __publicField(this, "me");
      __publicField(this, "Xc");
      __publicField(this, "Hb");
      __publicField(this, "Sg");
      __publicField(this, "vb");
      __publicField(this, "Ih");
      __publicField(this, "ON");
      __publicField(this, "EN");
      __publicField(this, "VN");
      __publicField(this, "Ls");
      __publicField(this, "Xy");
      __publicField(this, "Yy");
      __publicField(this, "Qa");
      __publicField(this, "Ky");
      __publicField(this, "vT");
      __publicField(this, "Mg");
      __publicField(this, "Pg");
      __publicField(this, "Ng");
      __publicField(this, "Yc");
      __publicField(this, "vi");
      __publicField(this, "C");
      __publicField(this, "Pe");
      __publicField(this, "Ne");
      __publicField(this, "On");
      __publicField(this, "Cg");
      this.me = 0, this.Xc = 0, this.Hb = 0, this.Sg = 360, this.vb = 0, this.Ih = 0, this.ON = new Point2(), this.EN = 30, this.VN = 0, this.Ls = 0, this.Xy = 0, this.Yy = new VertexArrangement(), this.Qa = 0, this.Ky = 0, this.vT = 600, this.Mg = NaN, this.Pg = 1, this.Ng = 0, this.Yc = 360, this.vi = 0, this.C = 10, this.Pe = 24, this.Ne = LayoutVertex2.standardComparer, this.On = 6, this.Cg = 30, t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Mg = this.Mg, t.Pg = this.Pg, t.Ng = this.Ng, t.Yc = this.Yc, t.vi = this.vi, t.C = this.C, t.Pe = this.Pe, t.Ne = this.Ne, t.On = this.On, t.Cg = this.Cg;
    }
    ci(t) {
      t in CircularSorting2 ? this.sorting = t : t in CircularDirection2 ? this.direction = t : t in CircularArrangement2 ? this.arrangement = t : t in CircularNodeDiameterFormula2 ? this.nodeDiameterFormula = t : super.ci(t);
    }
    createNetwork() {
      return new CircularNetwork2(this);
    }
    YO(t, i, e) {
      t = this.KO(t);
      let s = this.vb, n = this.EN, o = this.me, r = this.Xc, l = this.Hb, h = this.Sg, a = this.Ih, f = this.VN, c = this.Ls, u = this.Xy;
      if (s = this.arrangement, n = this.nodeDiameterFormula, o = this.radius, (!isFinite(o) || o <= 0) && (o = NaN), r = this.aspectRatio, (!isFinite(r) || r <= 0) && (r = 1), l = this.startAngle, isFinite(l) || (l = 0), h = this.sweepAngle, (!isFinite(h) || h > 360 || h < 1) && (h = 360), a = this.spacing, isFinite(a) || (a = NaN), s === 3 && n === 31 ? s = 0 : s === 3 && n !== 31 && (n = 31, s = this.arrangement), (this.direction === 12 || this.direction === 13) && this.sorting !== 24) {
        for (let g = 0; !(g >= t.length || (i.add(t.elt(g)), g + 1 >= t.length)); g += 2)
          e.add(t.elt(g + 1));
        this.direction === 12 ? (this.arrangement === 3 && i.reverse(), t = new List2(), t.addAll(i), t.addAll(e)) : (this.arrangement === 3 && e.reverse(), t = new List2(), t.addAll(e), t.addAll(i));
      }
      const d = t.length;
      f = 0;
      let m = 0;
      for (let g = 0; g < t.length; g++) {
        const p = l + h * m * (this.direction === 10 ? 1 : -1) / d;
        let y = t.elt(g).diameter;
        isNaN(y) && (y = t.elt(g).Oh(p)), h < 360 && (g === 0 || g === t.length - 1) && (y /= 2), f += y, m++;
      }
      if (isNaN(o) || s === 3) {
        if (isNaN(a) && (a = 6), s !== 0 && s !== 3) {
          let g = -1 / 0;
          for (let p = 0; p < d; p++) {
            const y = t.elt(p), x = t.elt(p === d - 1 ? 0 : p + 1);
            isNaN(y.diameter) && y.Oh(0), isNaN(x.diameter) && x.Oh(0), g = Math.max(g, (y.diameter + x.diameter) / 2);
          }
          if (u = g + a, s === 2) {
            const p = 2 * Math.PI / d, y = (g + a) / p;
            r > 1 ? (o = y, c = o * r) : (c = y, o = c);
          } else
            o = this.qb(u * (h >= 360 ? d : d - 1), r, l * Math.PI / 180, h * Math.PI / 180);
        } else
          o = this.qb(f + (h >= 360 ? d : d - 1) * (s !== 3 ? a : a * 1.6), r, l * Math.PI / 180, h * Math.PI / 180);
        c = o * r;
      } else {
        c = o * r;
        const g = this.BN(o, c, l * Math.PI / 180, h * Math.PI / 180);
        if (isNaN(a))
          s === 0 && (a = (g - f) / (h >= 360 ? d : d - 1));
        else if (s === 0) {
          const p = (g - f) / (h >= 360 ? d : d - 1);
          p < a ? (o = this.qb(f + a * (h >= 360 ? d : d - 1), r, l * Math.PI / 180, h * Math.PI / 180), c = o * r) : a = p;
        } else {
          let p = -1 / 0;
          for (let b = 0; b < d; b++) {
            const k = t.elt(b), S = t.elt(b === d - 1 ? 0 : b + 1);
            isNaN(k.diameter) && k.Oh(0), isNaN(S.diameter) && S.Oh(0), p = Math.max(p, (k.diameter + S.diameter) / 2);
          }
          const y = p + a, x = this.qb(y * (h >= 360 ? d : d - 1), r, l * Math.PI / 180, h * Math.PI / 180);
          x > o ? (o = x, c = o * r, u = y) : u = g / (h >= 360 ? d : d - 1);
        }
      }
      return this.vb = s, this.EN = n, this.me = o, this.Xc = r, this.Hb = l, this.Sg = h, this.Ih = a, this.VN = f, this.Ls = c, this.Xy = u, t;
    }
    doLayout(t) {
      Debug && t === null && Util.n("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"), this.network === null && (this.network = this.makeNetwork(t)), this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin);
      const i = this.network.vertexes;
      if (i.count <= 1) {
        if (i.count === 1) {
          const u = i.first();
          u.centerX = 0, u.centerY = 0;
        }
        this.updateParts(), this.network = null, this.isValidLayout = true;
        return;
      }
      let e = new List2();
      e.addAll(i.iterator);
      const s = new List2(), n = new List2();
      e = this.YO(e, s, n);
      const o = this.vb, r = this.me, l = this.Hb, h = this.Sg, a = this.Ih, f = this.Ls, c = this.Xy;
      if ((this.direction === 12 || this.direction === 13) && o === 3)
        this.qT(e, h, l - h / 2, 10);
      else if (this.direction === 12 || this.direction === 13) {
        let u = 0;
        switch (o) {
          case 1:
            u = this.Wb(r, f, l, c) * 180 / Math.PI;
            break;
          case 0: {
            let d = 0, m = 0;
            const g = s.first();
            g !== null && (d = g.Oh(Math.PI / 2));
            const p = n.first();
            p !== null && (m = p.Oh(Math.PI / 2)), u = this.Wb(r, f, l, a + (d + m) / 2) * 180 / Math.PI;
            break;
          }
          case 2:
            u = h / e.length;
            break;
        }
        if (this.direction === 12) {
          switch (o) {
            case 1:
              this.Uy(s, h / 2, l, 11);
              break;
            case 0:
              this.Gy(s, h / 2, l, 11);
              break;
            case 2:
              this.Hy(s, h / 2, l, 11);
              break;
          }
          switch (o) {
            case 1:
              this.Uy(n, h / 2, l + u, 10);
              break;
            case 0:
              this.Gy(n, h / 2, l + u, 10);
              break;
            case 2:
              this.Hy(n, h / 2, l + u, 10);
              break;
          }
        } else {
          switch (o) {
            case 1:
              this.Uy(n, h / 2, l, 11);
              break;
            case 0:
              this.Gy(n, h / 2, l, 11);
              break;
            case 2:
              this.Hy(n, h / 2, l, 11);
              break;
          }
          switch (o) {
            case 1:
              this.Uy(s, h / 2, l + u, 10);
              break;
            case 0:
              this.Gy(s, h / 2, l + u, 10);
              break;
            case 2:
              this.Hy(s, h / 2, l + u, 10);
              break;
          }
        }
      } else
        switch (o) {
          case 1:
            this.Uy(e, h, l, this.direction);
            break;
          case 0:
            this.Gy(e, h, l, this.direction);
            break;
          case 2:
            this.Hy(e, h, l, this.direction);
            break;
          case 3:
            this.qT(e, h, l, this.direction);
            break;
        }
      this.updateParts(), this.network = null, this.isValidLayout = true;
    }
    Hy(t, i, e, s) {
      const n = this.Sg, o = this.me, r = this.Ls, l = e * Math.PI / 180, h = i * Math.PI / 180, a = t.length;
      for (let f = 0; f < a; f++) {
        const c = l + (s === 10 ? f * h / (n >= 360 ? a : a - 1) : -(f * h) / a), u = t.elt(f), d = o * Math.tan(c) / r, m = Math.sqrt((o * o + r * r * d * d) / (1 + d * d));
        u.centerX = m * Math.cos(c), u.centerY = m * Math.sin(c), u.actualAngle = c * 180 / Math.PI;
      }
    }
    Gy(t, i, e, s) {
      const n = this.me, o = this.Ls, r = this.Ih;
      let l = e * Math.PI / 180;
      const h = t.length;
      for (let a = 0; a < h; a++) {
        const f = t.elt(a), c = t.elt(a === h - 1 ? 0 : a + 1), u = n * Math.cos(l), d = o * Math.sin(l);
        f.centerX = u, f.centerY = d, f.actualAngle = l * 180 / Math.PI, isNaN(f.diameter) && f.Oh(0), isNaN(c.diameter) && c.Oh(0);
        const m = (f.diameter + c.diameter) / 2, g = this.Wb(n, o, s === 10 ? l : -l, m + r);
        l += s === 10 ? g : -g;
      }
    }
    Uy(t, i, e, s) {
      const n = this.me, o = this.Ls, r = this.Xy;
      let l = e * Math.PI / 180;
      const h = t.length;
      for (let a = 0; a < h; a++) {
        const f = t.elt(a);
        f.centerX = n * Math.cos(l), f.centerY = o * Math.sin(l), f.actualAngle = l * 180 / Math.PI;
        const c = this.Wb(n, o, s === 10 ? l : -l, r);
        l += s === 10 ? c : -c;
      }
    }
    qT(t, i, e, s) {
      let n = this.Ky;
      const o = this.Sg;
      if (this.Qa = 0, this.Yy = new VertexArrangement(), i < 360) {
        for (n = e + (s === 10 ? o : -o); n < 0; )
          n += 360;
        n %= 360, n > 180 && (n -= 360), n *= Math.PI / 180, this.Ky = n, this.WT(t, i, e, s);
      } else
        this.jT(t, i, e, s);
      this.Yy.commit(t);
    }
    jT(t, i, e, s) {
      const n = this.me, o = this.Ls, r = this.Ih, l = this.Xc;
      let h = n * Math.cos(e * Math.PI / 180), a = o * Math.sin(e * Math.PI / 180);
      const f = t.toArray();
      if (f.length === 3) {
        f[0].centerX = n, f[0].centerY = 0, f[1].centerX = f[0].centerX - f[0].width / 2 - f[1].width / 2 - r, f[1].y = f[0].y, f[2].centerX = (f[0].centerX + f[1].centerX) / 2, f[2].y = f[0].y - f[2].height - r;
        return;
      } else if (f.length === 4) {
        f[0].centerX = n, f[0].centerY = 0, f[2].centerX = -f[0].centerX, f[2].centerY = f[0].centerY, f[1].centerX = 0, f[1].y = Math.min(f[0].y, f[2].y) - f[1].height - r, f[3].centerX = 0, f[3].y = Math.max(f[0].y + f[0].height + r, f[2].y + f[2].height + r);
        return;
      }
      const c = Point2.a();
      for (let k = 0; k < f.length && (f[k].centerX = h, f[k].centerY = a, !(k >= f.length - 1)); k++)
        this.JT(h, a, f, k, s, c) || this.ZT(h, a, f, k, s, c), h = c.x, a = c.y;
      if (Point2.o(c), this.Qa++, this.Qa > 23)
        return;
      const u = f[0].centerX, d = f[0].centerY, m = f[f.length - 1].centerX, g = f[f.length - 1].centerY;
      let p = Math.abs(u - m) - ((f[0].width + f[f.length - 1].width) / 2 + r);
      const y = Math.abs(d - g) - ((f[0].height + f[f.length - 1].height) / 2 + r);
      let x = 0;
      if (Math.abs(y) < 1) {
        const k = Math.abs(u - m), S = (f[0].width + f[f.length - 1].width) / 2;
        k < S && (x = 0), p = k - S;
      } else
        y > 0 ? x = y : Math.abs(p) < 1 ? x = 0 : x = p;
      let b = false;
      Math.abs(m) > Math.abs(g) ? b = m > 0 != d > g : b = g > 0 != u < m, b = s === 10 ? b : !b, b && (x = -Math.abs(x), x = Math.min(x, -f[f.length - 1].width), x = Math.min(x, -f[f.length - 1].height)), this.Yy.UO(x, f), Math.abs(x) > 1 && (this.Qa < 8 ? this.me -= x / (2 * Math.PI) : f.length < 5 && x > 10 ? this.me /= 2 : this.me -= x > 0 ? 1.7 : -2.3, this.Ls = this.me * l, this.jT(t, i, e, s));
    }
    WT(t, i, e, s) {
      const n = this.me, o = this.Ls, r = this.Xc;
      let l = n * Math.cos(e * Math.PI / 180), h = o * Math.sin(e * Math.PI / 180);
      const a = Point2.a(), f = t.toArray();
      for (let m = 0; m < f.length && (f[m].centerX = l, f[m].centerY = h, !(m >= f.length - 1)); m++)
        this.JT(l, h, f, m, s, a) || this.ZT(l, h, f, m, s, a), l = a.x, h = a.y;
      if (Point2.o(a), this.Qa++, this.Qa > 23)
        return;
      const c = Math.atan2(h, l);
      let u = s === 10 ? this.Ky - c : c - this.Ky;
      u = Math.abs(u) < Math.abs(u - 2 * Math.PI) ? u : u - 2 * Math.PI;
      const d = u * (n + o) / 2;
      this.Yy.GO(d, f), Math.abs(d) > 1 && (this.Qa < 8 ? this.me -= d / (2 * Math.PI) : this.me -= d > 0 ? 1.7 : -2.3, this.Ls = this.me * r, this.WT(t, i, e, s));
    }
    JT(t, i, e, s, n, o) {
      const r = this.Ih, l = this.me, h = this.Ls;
      let a = 0, f = 0;
      const c = (e[s].width + e[s + 1].width) / 2 + r;
      let u = false;
      if (i >= 0 != (n === 10)) {
        if (a = t + c, a > l) {
          if (a = t - c, a < -l)
            return o.x = a, o.y = f, false;
          u = true;
        }
      } else if (a = t - c, a < -l) {
        if (a = t + c, a > l)
          return o.x = a, o.y = f, false;
        u = true;
      }
      return f = Math.sqrt(1 - Math.min(1, a * a / (l * l))) * h, i < 0 !== u && (f = -f), Math.abs(i - f) > (e[s].height + e[s + 1].height) / 2 ? (o.x = a, o.y = f, false) : (o.x = a, o.y = f, true);
    }
    ZT(t, i, e, s, n, o) {
      const r = this.Ih, l = this.me, h = this.Ls;
      let a = 0, f = 0;
      const c = (e[s].height + e[s + 1].height) / 2 + r;
      let u = false;
      if (t >= 0 != (n === 10)) {
        if (f = i - c, f < -h) {
          if (f = i + c, f > h)
            return o.x = a, o.y = f, false;
          u = true;
        }
      } else if (f = i + c, f > h) {
        if (f = i - c, f < -h)
          return o.x = a, o.y = f, false;
        u = true;
      }
      return a = Math.sqrt(1 - Math.min(1, f * f / (h * h))) * l, t < 0 !== u && (a = -a), Math.abs(t - a) > (e[s].width + e[s + 1].width) / 2 ? (o.x = a, o.y = f, false) : (o.x = a, o.y = f, true);
    }
    commitLayout() {
      this.commitNodes(), this.isRouting && this.commitLinks();
    }
    commitNodes() {
      const t = this.group !== null && this.group.hasPlaceholder(), i = t ? this.group.location.copy() : null;
      let e = this.actualCenter;
      t ? e = new Point2(0, 0) : (e.x = this.arrangementOrigin.x + this.me, e.y = this.arrangementOrigin.y + this.Ls);
      const s = this.network.vertexes.iterator;
      for (; s.next(); ) {
        const n = s.value;
        n.x += e.x, n.y += e.y, n.commit();
      }
      if (t) {
        this.group.ensureBounds();
        const n = this.group.position.copy(), o = this.group.location.copy(), r = i.subtract(o.subtract(n));
        this.group.move(r), this.ON = r.subtract(n);
      }
    }
    commitLinks() {
      const t = this.network.edges.iterator;
      for (; t.next(); )
        t.value.commit();
    }
    BN(t, i, e, s) {
      const n = this.vT;
      if (Math.abs(this.Xc - 1) < 1e-3)
        return e !== void 0 && s !== void 0 ? s * t : 2 * Math.PI * t;
      const o = t > i ? Math.sqrt(t * t - i * i) / t : Math.sqrt(i * i - t * t) / i;
      let r = 0, l = 0;
      e !== void 0 && s !== void 0 ? l = s / (n + 1) : l = Math.PI / (2 * (n + 1));
      let h = 0;
      for (let a = 0; a <= n; a++) {
        e !== void 0 && s !== void 0 ? h = e + a * s / n : h = a * Math.PI / (2 * n);
        const f = Math.sin(h);
        r += Math.sqrt(1 - o * o * f * f) * l;
      }
      return e !== void 0 && s !== void 0 ? (t > i ? t : i) * r : 4 * (t > i ? t : i) * r;
    }
    qb(t, i, e, s) {
      let n = 0;
      return e !== void 0 && s !== void 0 ? n = this.BN(1, i, e, s) : n = this.BN(1, i), t / n;
    }
    Wb(t, i, e, s) {
      if (Math.abs(this.Xc - 1) < 1e-3)
        return s / t;
      const n = t > i ? Math.sqrt(t * t - i * i) / t : Math.sqrt(i * i - t * t) / i;
      let o = 0;
      const r = 2 * Math.PI / (this.network.vertexes.count * 700);
      t > i && (e += Math.PI / 2);
      for (let l = 0; ; l++) {
        const h = e + l * r, a = Math.sin(h);
        if (o += (t > i ? t : i) * Math.sqrt(1 - n * n * a * a) * r, o >= s)
          return l * r;
      }
    }
    KO(t) {
      switch (this.sorting) {
        case 20:
          break;
        case 21:
          t.reverse();
          break;
        case 22:
          t.sort(this.comparer);
          break;
        case 23:
          t.sort(this.comparer), t.reverse();
          break;
        case 24:
          return this.HO(this.vO(t));
        default:
          Util.n("Invalid sorting type.");
      }
      return t;
    }
    vO(t) {
      const i = [];
      for (let s = 0; s < t.length; s++)
        i.push(0);
      const e = new List2();
      for (let s = 0; s < t.length; s++) {
        let n = -1, o = -1;
        if (s === 0)
          for (let f = 0; f < t.length; f++) {
            const u = t.elt(f).edgesCount;
            u > n && (n = u, o = f);
          }
        else
          for (let f = 0; f < t.length; f++) {
            const c = i[f];
            c > n && (n = c, o = f);
          }
        e.add(t.elt(o)), i[o] = -1;
        const r = t.elt(o);
        let l = 0;
        const h = r.sourceEdges;
        for (; h.next(); ) {
          const c = h.value.fromVertex;
          l = t.indexOf(c), !(l < 0) && i[l] >= 0 && i[l]++;
        }
        const a = r.destinationEdges;
        for (; a.next(); ) {
          const c = a.value.toVertex;
          l = t.indexOf(c), !(l < 0) && i[l] >= 0 && i[l]++;
        }
      }
      return e;
    }
    HO(t) {
      const i = [];
      for (let c = 0; c < t.length; c++) {
        const u = t.elt(c);
        i[c] = [];
        let d = 0;
        const m = u.destinationEdges;
        for (; m.next(); ) {
          const p = m.value.toVertex;
          d = t.indexOf(p), d !== c && i[c].indexOf(d) < 0 && i[c].push(d);
        }
        const g = u.sourceEdges;
        for (; g.next(); ) {
          const p = g.value.fromVertex;
          d = t.indexOf(p), d !== c && i[c].indexOf(d) < 0 && i[c].push(d);
        }
      }
      const e = [];
      for (let c = 0; c < i.length; c++)
        e[c] = 0;
      const s = [], n = [], o = [], r = [], l = new List2();
      let h = 0;
      for (let c = 0; c < i.length; c++) {
        const u = i[c].length;
        if (u === 1) {
          r.push(c);
          continue;
        }
        if (u === 0) {
          l.add(t.elt(c));
          continue;
        }
        if (h === 0) {
          s.push(c), h++;
          continue;
        }
        let d = 1 / 0, m = 1 / 0, g = -1;
        const p = [];
        for (let y = 0; y < s.length; y++)
          i[s[y]].indexOf(s[y === s.length - 1 ? 0 : y + 1]) < 0 && p.push(y === s.length - 1 ? 0 : y + 1);
        if (p.length === 0)
          for (let y = 0; y < s.length; y++)
            p.push(y);
        for (let y = 0; y < p.length; y++) {
          const x = p[y], b = this.qO(i[c], n, o, e, x, s);
          let k = 0;
          for (let S = 0; S < i[c].length; S++) {
            const M = i[c][S], A = s.indexOf(M);
            if (A >= 0) {
              const C = Math.abs(x - (A >= x ? A + 1 : A));
              k += C < s.length + 1 - C ? C : s.length + 1 - C;
            }
          }
          for (let S = 0; S < n.length; S++) {
            let M = e[n[S]], A = e[o[S]];
            if (M >= x && M++, A >= x && A++, M > A) {
              const C = A;
              A = M, M = C;
            }
            A - M < (s.length + 2) / 2 == (M < x && x <= A) && k++;
          }
          (b < d || b === d && k < m) && (d = b, m = k, g = x);
        }
        s.splice(g, 0, c);
        for (let y = 0; y < s.length; y++)
          e[s[y]] = y;
        for (let y = 0; y < i[c].length; y++) {
          const x = i[c][y];
          s.indexOf(x) >= 0 && (n.push(c), o.push(x));
        }
        h++;
      }
      let a = false;
      const f = s.length;
      for (; ; ) {
        a = true;
        for (let c = 0; c < r.length; c++) {
          const u = r[c], d = i[u][0], m = s.indexOf(d);
          if (m >= 0) {
            let g = 0;
            for (let p = 0; p < i[d].length; p++) {
              const y = i[d][p], x = s.indexOf(y);
              if (x < 0 || x === m)
                continue;
              const b = x > m ? x - m : m - x, k = f - b;
              g += x < m != b > k ? 1 : -1;
            }
            s.splice(g < 0 ? m : m + 1, 0, u), r.splice(c, 1), c--;
          } else
            a = false;
        }
        if (a)
          break;
        s.push(r[0]), r.splice(0, 1);
      }
      for (let c = 0; c < s.length; c++) {
        const u = s[c];
        l.add(t.elt(u));
      }
      return l;
    }
    qO(t, i, e, s, n, o) {
      let r = 0;
      for (let l = 0; l < i.length; l++) {
        const h = i[l], a = e[l], f = s[h], c = s[a];
        let u = 0, d = 0;
        if (f < c ? (u = f, d = c) : (u = c, d = f), u < n && n <= d)
          for (let m = 0; m < t.length; m++) {
            const g = t[m];
            o.indexOf(g) < 0 || u < s[g] && s[g] < d || u === s[g] || d === s[g] || r++;
          }
        else
          for (let m = 0; m < t.length; m++) {
            const g = t[m];
            o.indexOf(g) < 0 || !(u < s[g] && s[g] < d) || u === s[g] || d === s[g] || r++;
          }
      }
      return r;
    }
    get radius() {
      return this.Mg;
    }
    set radius(t) {
      this.Mg !== t && (Util.t(t, "number", _CircularLayout, "radius"), (t > 0 || isNaN(t)) && (this.Mg = t, this.invalidateLayout()));
    }
    get aspectRatio() {
      return this.Pg;
    }
    set aspectRatio(t) {
      this.Pg !== t && (Util.t(t, "number", _CircularLayout, "aspectRatio"), t > 0 && (this.Pg = t, this.invalidateLayout()));
    }
    get startAngle() {
      return this.Ng;
    }
    set startAngle(t) {
      this.Ng !== t && (Util.t(t, "number", _CircularLayout, "startAngle"), this.Ng = t, this.invalidateLayout());
    }
    get sweepAngle() {
      return this.Yc;
    }
    set sweepAngle(t) {
      this.Yc !== t && (Util.t(t, "number", _CircularLayout, "sweepAngle"), t > 0 && t <= 360 ? this.Yc = t : this.Yc = 360, this.invalidateLayout());
    }
    get arrangement() {
      return this.vi;
    }
    set arrangement(t) {
      this.vi !== t && (Util.it(t, CircularArrangement2, "CircularArrangement"), (t === 3 || t === 0 || t === 1 || t === 2) && (this.vi = t, this.invalidateLayout()));
    }
    get direction() {
      return this.C;
    }
    set direction(t) {
      this.C !== t && (Util.it(t, CircularDirection2, "CircularDirection"), (t === 10 || t === 11 || t === 12 || t === 13) && (this.C = t, this.invalidateLayout()));
    }
    get sorting() {
      return this.Pe;
    }
    set sorting(t) {
      this.Pe !== t && (Util.it(t, CircularSorting2, "CircularSorting"), this.Pe = t, this.invalidateLayout());
    }
    get comparer() {
      return this.Ne;
    }
    set comparer(t) {
      this.Ne !== t && (Util.t(t, "function", _CircularLayout, "comparer"), this.Ne = t, this.invalidateLayout());
    }
    get spacing() {
      return this.On;
    }
    set spacing(t) {
      this.On !== t && (Util.t(t, "number", _CircularLayout, "spacing"), this.On = t, this.invalidateLayout());
    }
    get nodeDiameterFormula() {
      return this.Cg;
    }
    set nodeDiameterFormula(t) {
      this.Cg !== t && (Util.it(t, CircularNodeDiameterFormula2, "CircularNodeDiameterFormula"), (t === 30 || t === 31) && (this.Cg = t, this.invalidateLayout()));
    }
    get actualXRadius() {
      return this.me;
    }
    get actualYRadius() {
      return this.Ls;
    }
    get actualSpacing() {
      return this.Ih;
    }
    get actualCenter() {
      return this.ON;
    }
  };
  __publicField(_CircularLayout, "ConstantSpacing", 0);
  __publicField(_CircularLayout, "ConstantDistance", 1);
  __publicField(_CircularLayout, "ConstantAngle", 2);
  __publicField(_CircularLayout, "Packed", 3);
  __publicField(_CircularLayout, "Clockwise", 10);
  __publicField(_CircularLayout, "Counterclockwise", 11);
  __publicField(_CircularLayout, "BidirectionalLeft", 12);
  __publicField(_CircularLayout, "BidirectionalRight", 13);
  __publicField(_CircularLayout, "Forwards", 20);
  __publicField(_CircularLayout, "Reverse", 21);
  __publicField(_CircularLayout, "Ascending", 22);
  __publicField(_CircularLayout, "Descending", 23);
  __publicField(_CircularLayout, "Optimized", 24);
  __publicField(_CircularLayout, "Pythagorean", 30);
  __publicField(_CircularLayout, "Circular", 31);
  let CircularLayout2 = _CircularLayout;
  class VertexArrangement {
    constructor() {
      __publicField(this, "Kc");
      __publicField(this, "_a");
      __publicField(this, "Uc");
      this.Kc = -1 / 0, this._a = null, this.Uc = null;
    }
    UO(t, i) {
      if (t > 0 && this.Kc < 0 || Math.abs(t) < Math.abs(this.Kc) && !(t < 0 && this.Kc > 0)) {
        this.Kc = t, this._a = [], this.Uc = [];
        for (let e = 0; e < i.length; e++)
          this._a[e] = i[e].bounds.x, this.Uc[e] = i[e].bounds.y;
      }
    }
    GO(t, i) {
      if (Math.abs(t) < Math.abs(this.Kc)) {
        this.Kc = t, this._a = [], this.Uc = [];
        for (let e = 0; e < i.length; e++)
          this._a[e] = i[e].bounds.x, this.Uc[e] = i[e].bounds.y;
      }
    }
    commit(t) {
      if (!(this._a === null || this.Uc === null))
        for (let i = 0; i < this._a.length; i++) {
          const e = t.elt(i);
          e.x = this._a[i], e.y = this.Uc[i];
        }
    }
  }
  class CircularNetwork2 extends LayoutNetwork2 {
    constructor(t) {
      super(t);
    }
    createVertex() {
      return new CircularVertex2(this);
    }
    createEdge() {
      return new CircularEdge2(this);
    }
  }
  class CircularVertex2 extends LayoutVertex2 {
    constructor(t) {
      super(t);
      __publicField(this, "Ao");
      __publicField(this, "jb");
      this.Ao = NaN, this.jb = NaN;
    }
    Oh(t) {
      const i = this.network;
      if (i === null)
        return NaN;
      const e = i.layout;
      if (e === null)
        return NaN;
      if (e.arrangement === 3) {
        if (e.nodeDiameterFormula === 31)
          return this.Ao = Math.max(this.width, this.height), this.Ao;
        {
          const s = Math.abs(Math.sin(t)), n = Math.abs(Math.cos(t));
          return s === 0 ? this.width : n === 0 ? this.height : (this.Ao = Math.min(this.height / s, this.width / n), this.Ao);
        }
      } else
        return e.nodeDiameterFormula === 31 ? (this.Ao = Math.max(this.width, this.height), this.Ao) : (this.Ao = Math.sqrt(this.width * this.width + this.height * this.height), this.Ao);
    }
    get diameter() {
      return this.Ao;
    }
    set diameter(t) {
      this.Ao !== t && (Util.t(t, "number", CircularVertex2, "diameter"), this.Ao = t);
    }
    get actualAngle() {
      return this.jb;
    }
    set actualAngle(t) {
      this.jb !== t && (Util.t(t, "number", CircularVertex2, "actualAngle"), this.jb = t);
    }
  }
  class CircularEdge2 extends LayoutEdge2 {
    constructor(t) {
      super(t);
    }
  }
  class ForceDirectedLayout2 extends Layout2 {
    constructor(t) {
      super();
      __publicField(this, "vy");
      __publicField(this, "Eh");
      __publicField(this, "Ts");
      __publicField(this, "Ag");
      __publicField(this, "zn");
      __publicField(this, "Ye");
      __publicField(this, "Lg");
      __publicField(this, "Tg");
      __publicField(this, "Dg");
      __publicField(this, "Gc");
      __publicField(this, "Fg");
      __publicField(this, "Rg");
      __publicField(this, "Hc");
      __publicField(this, "vc");
      __publicField(this, "qc");
      __publicField(this, "Wc");
      __publicField(this, "Ig");
      __publicField(this, "Og");
      __publicField(this, "jc");
      __publicField(this, "tf");
      this.vy = 0, this.Eh = 0, this.Ts = new Size2(100, 100).w(), this.Ag = false, this.zn = true, this.Ye = false, this.Lg = 100, this.Tg = 300, this.Dg = 1, this.Gc = 1e3, this.Fg = 10, this.Rg = Math, this.Hc = 0.05, this.vc = 50, this.qc = 150, this.Wc = 0, this.Ig = 10, this.Og = 5, this.jc = NaN, this.tf = 10, t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Ts.c(this.Ts), t.Ag = this.Ag, t.zn = this.zn, t.Ye = this.Ye, t.Lg = this.Lg, t.Tg = this.Tg, t.Dg = this.Dg, t.Gc = this.Gc, t.Fg = this.Fg, t.Rg = this.Rg, t.Hc = this.Hc, t.vc = this.vc, t.qc = this.qc, t.Wc = this.Wc, t.Ig = this.Ig, t.Og = this.Og, t.jc = this.jc, t.tf = this.tf;
    }
    createNetwork() {
      return new ForceDirectedNetwork2(this);
    }
    doLayout(t) {
      Debug && t === null && Util.n("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"), this.network = this.makeNetwork(t);
      let i = this.network.vertexes.iterator;
      const e = this.maxIterations;
      if (this.network.vertexes.count > 0) {
        for (this.network.deleteSelfEdges(), i = this.network.vertexes.iterator; i.next(); ) {
          const o = i.value;
          o.charge = this.electricalCharge(o), o.mass = this.gravitationalMass(o);
        }
        const s = this.network.edges.iterator;
        for (; s.next(); ) {
          const o = s.value;
          o.stiffness = this.springStiffness(o), o.length = this.springLength(o);
        }
        if (this.zN(), this.Eh = 0, this.needsPrelayout()) {
          const o = this.network, r = o.splitIntoSubNetworks(false);
          let l = r.iterator;
          for (; l.next(); ) {
            const h = l.value;
            this.doConnectedSubnetLayout(h);
          }
          for (l = r.iterator, this.WO(l, o), l = r.iterator; l.next(); ) {
            const h = l.value, a = h.vertexes.iterator;
            for (; a.next(); ) {
              const c = a.value;
              o.addVertex(c);
            }
            const f = h.edges.iterator;
            for (; f.next(); ) {
              const c = f.value;
              o.addEdge(c);
            }
          }
        } else
          this.$T(this.network, this.maxIterations);
        this.updateParts();
      }
      this.maxIterations = e, this.isValidLayout = true;
    }
    needsPrelayout() {
      if (this.network.vertexes.count < 3)
        return false;
      let t = 0, i = 0;
      const e = this.network.vertexes.first().bounds, s = this.network.vertexes.iterator;
      for (; s.next(); ) {
        const n = s.value, o = n.bounds;
        if (isNaN(n.x) || isNaN(n.y) || o.intersectsRect(e) && (t++, t > 2))
          return true;
        if (i > 10)
          return false;
        i++;
      }
      return false;
    }
    doConnectedSubnetLayout(t) {
      let i = t.vertexes.iterator;
      for (; i.next(); ) {
        const l = i.value;
        l.hierarchicalVertexes.add(l);
      }
      let e = t, s = this.jc;
      if (isNaN(s) && (s = t.edges.count / t.vertexes.count), s < t.vertexes.count)
        for (; e.vertexes.count > Math.max(100, Math.sqrt(s * t.vertexes.count)); )
          e = this.coarsenNetwork(e);
      let n = 0;
      i = e.vertexes.iterator;
      let o = this.randomNumberGenerator;
      for (o === null && (this.randomNumberGenerator = o = new RandomNumberGenerator(0)); i.next(); ) {
        i.value.idInCluster = n++;
        const l = 10 * (o.random() - 0.5), h = 10 * (o.random() - 0.5);
        i.value.x = l, i.value.y = h;
        const a = i.value.hierarchicalVertexes.iterator;
        for (; a.next(); )
          a.value.x = l, a.value.y = h;
      }
      const r = this.computePairwiseDistances(e);
      this.jO(e, r, this.maxPrelayoutIterations, t.vertexes.count), this.$T(t, this.maxIterations);
    }
    computePairwiseDistances(t) {
      const i = t.vertexes.count, e = new Array(i);
      for (let r = 0; r < i; r++)
        e[r] = new Array(i).fill(-1), e[r][r] = 0;
      const s = t.vertexes.iterator;
      let n = /* @__PURE__ */ new Map(), o = [];
      for (; s.next(); ) {
        const r = s.value;
        for (o = [r], n = /* @__PURE__ */ new Map(), n.set(r.idInCluster, 0); o.length > 0; ) {
          const l = o.shift(), h = l.vertexes.iterator;
          for (; h.next(); ) {
            const a = h.value;
            n.has(a.idInCluster) || (n.set(a.idInCluster, n.get(l.idInCluster) + 1), o.push(a));
          }
        }
        for (let l = 0; l < i; l++) {
          const h = Math.min(e[r.idInCluster][l], e[l][r.idInCluster]), a = n.get(l);
          (h < 0 || a < h) && (e[r.idInCluster][l] = a, e[l][r.idInCluster] = a);
        }
      }
      return e;
    }
    coarsenNetwork(t) {
      const i = this.createNetwork(), e = /* @__PURE__ */ new Map();
      let s = 0, n = t.vertexes.iterator;
      for (; n.next(); )
        n.value.idInCluster = s++;
      for (n = t.vertexes.iterator; n.next(); ) {
        const r = n.value;
        if (e.has(r.idInCluster))
          continue;
        let l = Number.MAX_SAFE_INTEGER, h = null;
        const a = r.vertexes.iterator;
        for (; a.next(); ) {
          const c = a.value;
          e.has(c.idInCluster) || c.hierarchicalVertexes.length < l && (l = c.hierarchicalVertexes.length, h = c);
        }
        const f = i.createVertex();
        f.hierarchicalVertexes.addAll(r.hierarchicalVertexes), h != null && f.hierarchicalVertexes.addAll(h.hierarchicalVertexes), e.set(r.idInCluster, f), h != null && e.set(h.idInCluster, f), i.addVertex(f);
      }
      const o = t.edges.iterator;
      for (; o.next(); ) {
        const r = o.value, l = e.get(r.fromVertex.idInCluster), h = e.get(r.toVertex.idInCluster);
        if (l === h)
          continue;
        const a = i.createEdge();
        a.fromVertex = l, a.toVertex = h, i.addEdge(a);
      }
      return i;
    }
    Fw(t, i) {
      let e = true;
      const s = t.vertexes.iterator;
      for (; s.next(); ) {
        const n = s.value;
        e ? (e = false, i.set(n.bounds)) : i.unionRect(n.bounds);
      }
      return i;
    }
    WO(t, i) {
      Debug && Util.s(i, ForceDirectedNetwork2, ForceDirectedLayout2, "arrangeConnectedGraphs:singletons");
      const e = this.arrangementSpacing, s = t.count;
      let n = true, o = 0, r = 0;
      const l = Util.ct();
      for (let c = 0; c < s + i.vertexes.count + 2; c++)
        l[c] = null;
      let h = 0;
      t.reset();
      const a = Rect2.a();
      let f;
      for (; t.next(); ) {
        const c = t.value;
        if (this.Fw(c, a), n)
          n = false, o = a.x + a.width / 2, r = a.y + a.height / 2, l[0] = new Point2(a.x + a.width + e.width, a.y), l[1] = new Point2(a.x, a.y + a.height + e.height), h = 2;
        else {
          const u = this.QT(l, h, o, r, a.width, a.height, e), d = l[u], m = new Point2(d.x + a.width + e.width, d.y), g = new Point2(d.x, d.y + a.height + e.height);
          u + 1 < h && l.splice(u + 1, 0, null), l[u] = m, l[u + 1] = g, h++;
          const p = d.x - a.x, y = d.y - a.y;
          for (f = c.vertexes.iterator; f.next(); ) {
            const x = f.value;
            x.centerX += p, x.centerY += y;
          }
        }
      }
      for (Rect2.o(a), f = i.vertexes.iterator; f.next(); ) {
        const c = f.value, u = c.bounds;
        if (h < 2) {
          o = u.x + u.width / 2, r = u.y + u.height / 2, l[0] = new Point2(u.x + u.width + e.width, u.y), l[1] = new Point2(u.x, u.y + u.height + e.height), h = 2;
          continue;
        }
        const d = this.QT(l, h, o, r, u.width, u.height, e), m = l[d], g = new Point2(m.x + u.width + e.width, m.y), p = new Point2(m.x, m.y + u.height + e.height);
        d + 1 < h && l.splice(d + 1, 0, null), l[d] = g, l[d + 1] = p, h++, c.centerX = m.x + c.width / 2, c.centerY = m.y + c.height / 2;
      }
      Util.ot(l);
    }
    QT(t, i, e, s, n, o, r) {
      let l = 9e19, h = -1;
      t:
        for (let a = 0; a < i; a++) {
          const f = t[a], c = f.x - e, u = f.y - s, d = c * c + u * u;
          if (d < l) {
            for (let m = a - 1; m >= 0; m--)
              if (t[m].y > f.y && t[m].x - f.x < n + r.width)
                continue t;
            for (let m = a + 1; m < i; m++)
              if (t[m].x > f.x && t[m].y - f.y < o + r.height)
                continue t;
            h = a, l = d;
          }
        }
      return h;
    }
    zN() {
      if (!this.comments)
        return;
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const i = t.value;
        this.addComments(i);
      }
    }
    addComments(t) {
      const i = t.node;
      if (i !== null) {
        const e = i.findNodesConnected();
        for (; e.next(); ) {
          const s = e.value;
          if (s.category !== "Comment" || !s.isVisible())
            continue;
          let n = this.network.findVertex(s);
          n === null && (n = this.network.addNode(s)), n.charge = this.defaultCommentElectricalCharge;
          let o = null;
          const r = n.destinationEdges;
          for (; r.next(); ) {
            const l = r.value;
            if (l.toVertex === t) {
              o = l;
              break;
            }
          }
          if (o === null) {
            const l = n.sourceEdges;
            for (; l.next(); ) {
              const h = l.value;
              if (h.fromVertex === t) {
                o = h;
                break;
              }
            }
          }
          o === null && (o = this.network.linkVertexes(t, n, null)), o.length = this.defaultCommentSpringLength;
        }
      }
    }
    XN(t, i) {
      Debug && (Util.s(t, ForceDirectedVertex2, ForceDirectedLayout2, "getNodeDistance:vertexA"), Util.s(i, ForceDirectedVertex2, ForceDirectedLayout2, "getNodeDistance:vertexB"));
      const e = t.bounds, s = e.x, n = e.y, o = e.width, r = e.height, l = i.bounds, h = l.x, a = l.y, f = l.width, c = l.height;
      if (s + o < h)
        if (n > a + c) {
          const u = s + o - h, d = n - a - c;
          return Geo.Cw(u * u + d * d);
        } else if (n + r < a) {
          const u = s + o - h, d = n + r - a;
          return Geo.Cw(u * u + d * d);
        } else
          return h - (s + o);
      else if (s > h + f)
        if (n > a + c) {
          const u = s - h - f, d = n - a - c;
          return Geo.Cw(u * u + d * d);
        } else if (n + r < a) {
          const u = s - h - f, d = n + r - a;
          return Geo.Cw(u * u + d * d);
        } else
          return s - (h + f);
      else
        return n > a + c ? n - (a + c) : n + r < a ? a - (n + r) : 0.1;
    }
    $T(t, i) {
      Debug && Util.r(i, ForceDirectedLayout2, "performIterations:num");
      const e = this.Eh + i;
      for (; this.Eh < e && (this.Eh++, !!this.JO(t)); )
        ;
    }
    JO(t) {
      const i = t.vertexes.toArray();
      if (i.length <= 0)
        return false;
      const e = i[0];
      e.forceX = 0, e.forceY = 0;
      let s = e.centerX, n = s, o = e.centerY, r = o;
      for (let m = 1; m < i.length; m++) {
        const g = i[m];
        g.forceX = 0, g.forceY = 0;
        const p = g.centerX, y = g.centerY;
        s = Math.min(s, p), n = Math.max(n, p), o = Math.min(o, y), r = Math.max(r, y);
      }
      const l = n - s > r - o;
      l ? i.sort((m, g) => m === null || g === null || m === g ? 0 : m.centerX - g.centerX) : i.sort((m, g) => m === null || g === null || m === g ? 0 : m.centerY - g.centerY);
      const h = this.Gc;
      let a = 0, f = 0, c = 0;
      for (let m = 0; m < i.length; m++) {
        const g = i[m], p = g.bounds, y = g.focus, x = p.x + y.x, b = p.y + y.y;
        f = g.charge * this.electricalFieldX(x, b), c = g.charge * this.electricalFieldY(x, b), f += g.mass * this.gravitationalFieldX(x, b), c += g.mass * this.gravitationalFieldY(x, b), g.forceX += f, g.forceY += c;
        for (let k = m + 1; k < i.length; k++) {
          const S = i[k];
          if (!this.shouldInteract(g, S) || k === m)
            continue;
          const M = S.bounds, A = S.focus, C = M.x + A.x, P = M.y + A.y;
          if (x - C > h || C - x > h) {
            if (l)
              break;
            continue;
          }
          if (b - P > h || P - b > h) {
            if (!l)
              break;
            continue;
          }
          const N = this.XN(g, S), T = 2 * g.charge, L = 2 * S.charge;
          if (N > 1)
            a = T * L / (N * N), f = a * (x - C) / N, c = a * (b - P) / N;
          else {
            let D = this.randomNumberGenerator;
            D === null && (this.randomNumberGenerator = D = new RandomNumberGenerator(0));
            const F = D.random(), R = D.random();
            if (x > C)
              f = Math.abs(S.bounds.right - g.bounds.x), f = T * L * (1 + f) * F;
            else if (x < C)
              f = Math.abs(S.bounds.x - g.bounds.right), f = -(T * L) * (1 + f) * F;
            else {
              const I = Math.max(S.width, g.width);
              f = T * L * ((1 + I) * F - I / 2);
            }
            if (b > P)
              c = Math.abs(S.bounds.bottom - g.bounds.y), c = T * L * (1 + c) * R;
            else if (x < C)
              c = Math.abs(S.bounds.y - g.bounds.bottom), c = -(T * L) * (1 + c) * R;
            else {
              const I = Math.max(S.height, g.height);
              c = T * L * ((1 + I) * R - I / 2);
            }
          }
          g.forceX += f, g.forceY += c, S.forceX -= f, S.forceY -= c;
        }
      }
      const u = t.edges.iterator;
      for (; u.next(); ) {
        const m = u.value, g = m.fromVertex, p = m.toVertex, y = g.bounds, x = g.focus, b = y.x + x.x, k = y.y + x.y, S = p.bounds, M = p.focus, A = S.x + M.x, C = S.y + M.y, P = this.XN(g, p);
        P > 1 && (a = 0.1 * m.stiffness * (P - m.length), f = a * 0.5 * (g.width + p.height) * (b - A) / P, c = a * 0.5 * (g.width + p.height) * (k - C) / P), g.forceX -= f, g.forceY -= c, p.forceX += f, p.forceY += c;
      }
      let d = 0;
      for (let m = 0; m < i.length; m++) {
        const g = i[m];
        this.isFixed(g) ? this.moveFixedVertex(g) : d = Math.max(d, this.moveVertex(g) || 0);
      }
      return d > this.epsilonDistance * this.epsilonDistance;
    }
    jO(t, i, e, s) {
      Debug && Util.r(e, ForceDirectedLayout2, "performIterations:num");
      const n = this.Eh + e, o = Math.sqrt(s);
      this.vy = this.tf * t.vertexes.count;
      const r = t.vertexes.toArray();
      let l = 0, h = 0, a = 0;
      for (; this.Eh < n; ) {
        this.Eh++, h = l, l = 0;
        for (let f = 0; f < r.length; f++) {
          r[f].forceX = 0, r[f].forceY = 0;
          for (let u = 0; u < r.length; u++) {
            if (f === u)
              continue;
            const d = this.XN(r[f], r[u]), m = i[r[f].idInCluster][r[u].idInCluster], g = (d - this.tf * o * m) / d;
            r[f].forceX += g * (r[u].x - r[f].x), r[f].forceY += g * (r[u].y - r[f].y);
          }
          const c = Math.sqrt(r[f].forceX * r[f].forceX + r[f].forceY * r[f].forceY);
          if (c > 0) {
            r[f].forceX = this.vy * r[f].forceX / c, r[f].forceY = this.vy * r[f].forceY / c, r[f].x += r[f].forceX, r[f].y += r[f].forceY;
            const u = r[f].hierarchicalVertexes.iterator;
            for (; u.next(); ) {
              const d = u.value;
              d.centerX += r[f].forceX, d.centerY += r[f].forceY;
            }
          }
          l += c * c;
        }
        if (l >= h) {
          if (a++, a >= 5)
            break;
        } else
          a = 0;
        this.vy *= 0.95;
      }
    }
    moveVertex(t) {
      let i = t.forceX, e = t.forceY;
      const s = this.moveLimit;
      return i < -s ? i = -s : i > s && (i = s), e < -s ? e = -s : e > s && (e = s), t.centerX += i, t.centerY += e, i * i + e * e;
    }
    shouldInteract(t, i) {
      return true;
    }
    moveFixedVertex(t) {
    }
    commitLayout() {
      this.qy(), this.commitNodes(), this.isRouting && this.commitLinks();
    }
    qy() {
      if (!this.setsPortSpots)
        return;
      const t = this.network.edges.iterator;
      for (; t.next(); ) {
        const e = t.value.link;
        e !== null && (e.fromSpot = Spot2.Default, e.toSpot = Spot2.Default);
      }
    }
    commitNodes() {
      let t = 0, i = 0;
      if (this.arrangesToOrigin) {
        const n = Rect2.a();
        this.Fw(this.network, n);
        const o = this.arrangementOrigin;
        t = o.x - n.x, i = o.y - n.y, Rect2.o(n);
      }
      const e = Rect2.a(), s = this.network.vertexes.iterator;
      for (; s.next(); ) {
        const n = s.value;
        (t !== 0 || i !== 0) && (e.c(n.bounds), e.x += t, e.y += i, n.bounds = e), n.commit();
      }
      Rect2.o(e);
    }
    commitLinks() {
      const t = this.network.edges.iterator;
      for (; t.next(); )
        t.value.commit();
    }
    springStiffness(t) {
      const i = t.stiffness;
      return isNaN(i) ? this.Hc : i;
    }
    springLength(t) {
      const i = t.length;
      return isNaN(i) ? this.vc : i;
    }
    electricalCharge(t) {
      const i = t.charge;
      return isNaN(i) ? this.qc : i;
    }
    electricalFieldX(t, i) {
      return 0;
    }
    electricalFieldY(t, i) {
      return 0;
    }
    gravitationalMass(t) {
      const i = t.mass;
      return isNaN(i) ? this.Wc : i;
    }
    gravitationalFieldX(t, i) {
      return 0;
    }
    gravitationalFieldY(t, i) {
      return 0;
    }
    isFixed(t) {
      return t.isFixed;
    }
    get currentIteration() {
      return this.Eh;
    }
    get arrangementSpacing() {
      return this.Ts;
    }
    set arrangementSpacing(t) {
      Util.s(t, Size2, ForceDirectedLayout2, "arrangementSpacing"), this.Ts.equals(t) || (this.Ts.c(t), this.invalidateLayout());
    }
    get arrangesToOrigin() {
      return this.Ag;
    }
    set arrangesToOrigin(t) {
      this.Ag !== t && (Util.t(t, "boolean", ForceDirectedLayout2, "arrangesToOrigin"), this.Ag = t, this.invalidateLayout());
    }
    get setsPortSpots() {
      return this.zn;
    }
    set setsPortSpots(t) {
      this.zn !== t && (Util.t(t, "boolean", ForceDirectedLayout2, "setsPortSpots"), this.zn = t, this.invalidateLayout());
    }
    get comments() {
      return this.Ye;
    }
    set comments(t) {
      this.Ye !== t && (Util.t(t, "boolean", ForceDirectedLayout2, "comments"), this.Ye = t, this.invalidateLayout());
    }
    get maxPrelayoutIterations() {
      return this.Lg;
    }
    set maxPrelayoutIterations(t) {
      this.Lg !== t && (Util.t(t, "number", ForceDirectedLayout2, "maxPrelayoutIterations"), t >= 0 && (this.Lg = t, this.invalidateLayout()));
    }
    get maxIterations() {
      return this.Tg;
    }
    set maxIterations(t) {
      this.Tg !== t && (Util.t(t, "number", ForceDirectedLayout2, "maxIterations"), t >= 0 && (this.Tg = t, this.invalidateLayout()));
    }
    get epsilonDistance() {
      return this.Dg;
    }
    set epsilonDistance(t) {
      this.Dg !== t && (Util.t(t, "number", ForceDirectedLayout2, "epsilonDistance"), t > 0 && (this.Dg = t, this.invalidateLayout()));
    }
    get infinityDistance() {
      return this.Gc;
    }
    set infinityDistance(t) {
      this.Gc !== t && (Util.t(t, "number", ForceDirectedLayout2, "infinityDistance"), t > 1 && (this.Gc = t, this.invalidateLayout()));
    }
    get moveLimit() {
      return this.Fg;
    }
    set moveLimit(t) {
      this.Fg !== t && (Util.t(t, "number", ForceDirectedLayout2, "moveLimit"), this.Fg = t, this.invalidateLayout());
    }
    get randomNumberGenerator() {
      return this.Rg;
    }
    set randomNumberGenerator(t) {
      this.Rg !== t && (t !== null && typeof t.random != "function" && Util.n('ForceDirectedLayout.randomNumberGenerator must have a "random()" function on it: ' + t), this.Rg = t);
    }
    get defaultSpringStiffness() {
      return this.Hc;
    }
    set defaultSpringStiffness(t) {
      this.Hc !== t && (Util.t(t, "number", ForceDirectedLayout2, "defaultSpringStiffness"), this.Hc = t, this.invalidateLayout());
    }
    get defaultSpringLength() {
      return this.vc;
    }
    set defaultSpringLength(t) {
      this.vc !== t && (Util.t(t, "number", ForceDirectedLayout2, "defaultSpringLength"), this.vc = t, this.invalidateLayout());
    }
    get defaultElectricalCharge() {
      return this.qc;
    }
    set defaultElectricalCharge(t) {
      this.qc !== t && (Util.t(t, "number", ForceDirectedLayout2, "defaultElectricalCharge"), this.qc = t, this.invalidateLayout());
    }
    get defaultGravitationalMass() {
      return this.Wc;
    }
    set defaultGravitationalMass(t) {
      this.Wc !== t && (Util.t(t, "number", ForceDirectedLayout2, "defaultGravitationalMass"), this.Wc = t, this.invalidateLayout());
    }
    get defaultCommentSpringLength() {
      return this.Ig;
    }
    set defaultCommentSpringLength(t) {
      this.Ig !== t && (Util.t(t, "number", ForceDirectedLayout2, "defaultCommentSpringLength"), this.Ig = t, this.invalidateLayout());
    }
    get defaultCommentElectricalCharge() {
      return this.Og;
    }
    set defaultCommentElectricalCharge(t) {
      this.Og !== t && (Util.t(t, "number", ForceDirectedLayout2, "defaultCommentElectricalCharge"), this.Og = t, this.invalidateLayout());
    }
    get prelayoutQuality() {
      return this.jc;
    }
    set prelayoutQuality(t) {
      this.jc !== t && (Util.t(t, "number", ForceDirectedLayout2, "prelayoutQuality"), this.jc = t, this.invalidateLayout());
    }
    get prelayoutSpread() {
      return this.tf;
    }
    set prelayoutSpread(t) {
      this.tf !== t && (Util.t(t, "number", ForceDirectedLayout2, "prelayoutSpread"), this.tf = t, this.invalidateLayout());
    }
  }
  class ForceDirectedNetwork2 extends LayoutNetwork2 {
    constructor(t) {
      super(t);
    }
    createVertex() {
      return new ForceDirectedVertex2(this);
    }
    createEdge() {
      return new ForceDirectedEdge2(this);
    }
  }
  class ForceDirectedVertex2 extends LayoutVertex2 {
    constructor(t) {
      super(t);
      __publicField(this, "Jb");
      __publicField(this, "Zb");
      __publicField(this, "$b");
      __publicField(this, "Qb");
      __publicField(this, "_b");
      __publicField(this, "hierarchicalVertexes");
      __publicField(this, "idInCluster");
      this.Jb = false, this.Zb = NaN, this.$b = NaN, this.Qb = 0, this._b = 0, this.hierarchicalVertexes = new List2(), this.idInCluster = -1;
    }
    get isFixed() {
      return this.Jb;
    }
    set isFixed(t) {
      this.Jb !== t && (Util.t(t, "boolean", ForceDirectedVertex2, "isFixed"), this.Jb = t);
    }
    get charge() {
      return this.Zb;
    }
    set charge(t) {
      this.Zb !== t && (Util.t(t, "number", ForceDirectedVertex2, "charge"), this.Zb = t);
    }
    get mass() {
      return this.$b;
    }
    set mass(t) {
      this.$b !== t && (Util.t(t, "number", ForceDirectedVertex2, "mass"), this.$b = t);
    }
    get forceX() {
      return this.Qb;
    }
    set forceX(t) {
      this.Qb !== t && (Util.t(t, "number", ForceDirectedVertex2, "forceX"), this.Qb = t);
    }
    get forceY() {
      return this._b;
    }
    set forceY(t) {
      this._b !== t && (Util.t(t, "number", ForceDirectedVertex2, "forceY"), this._b = t);
    }
  }
  class ForceDirectedEdge2 extends LayoutEdge2 {
    constructor(t) {
      super(t);
      __publicField(this, "tk");
      __publicField(this, "ik");
      this.tk = NaN, this.ik = NaN;
    }
    get stiffness() {
      return this.tk;
    }
    set stiffness(t) {
      this.tk !== t && (Util.t(t, "number", ForceDirectedEdge2, "stiffness"), this.tk = t);
    }
    get length() {
      return this.ik;
    }
    set length(t) {
      this.ik !== t && (Util.t(t, "number", ForceDirectedEdge2, "length"), this.ik = t);
    }
  }
  class RandomNumberGenerator {
    constructor(t) {
      __publicField(this, "I");
      __publicField(this, "R");
      __publicField(this, "Q");
      __publicField(this, "M");
      __publicField(this, "A");
      __publicField(this, "seed");
      t === void 0 && (t = 42), this.seed = t, this.A = 48271, this.M = 2147483647, this.Q = this.M / this.A, this.R = this.M % this.A, this.I = 1 / this.M, this.random();
    }
    random() {
      const t = this.seed / this.Q, i = this.seed % this.Q, e = this.A * i - this.R * t;
      return e > 0 ? this.seed = e : this.seed = e + this.M, this.seed * this.I;
    }
  }
  var LayeredDigraphCycleRemove2 = ((w) => (w[w.DepthFirst = 0] = "DepthFirst", w[w.Greedy = 1] = "Greedy", w[w.FromLayers = 2] = "FromLayers", w))(LayeredDigraphCycleRemove2 || {}), LayeredDigraphLayering2 = ((w) => (w[w.OptimalLinkLength = 10] = "OptimalLinkLength", w[w.LongestPathSink = 11] = "LongestPathSink", w[w.LongestPathSource = 12] = "LongestPathSource", w))(LayeredDigraphLayering2 || {}), LayeredDigraphInit2 = ((w) => (w[w.DepthFirstOut = 20] = "DepthFirstOut", w[w.DepthFirstIn = 21] = "DepthFirstIn", w[w.Naive = 22] = "Naive", w))(LayeredDigraphInit2 || {}), LayeredDigraphAggressive2 = ((w) => (w[w.None = 30] = "None", w[w.Less = 31] = "Less", w[w.More = 32] = "More", w))(LayeredDigraphAggressive2 || {}), LayeredDigraphPack2 = ((w) => (w[w.None = 0] = "None", w[w.Expand = 1] = "Expand", w[w.Straighten = 2] = "Straighten", w[w.Median = 4] = "Median", w[w.MaybeExpand = 8] = "MaybeExpand", w[w.All = 15] = "All", w))(LayeredDigraphPack2 || {}), LayeredDigraphAlign2 = ((w) => (w[w.None = 0] = "None", w[w.UpperLeft = 1] = "UpperLeft", w[w.UpperRight = 2] = "UpperRight", w[w.LowerLeft = 4] = "LowerLeft", w[w.LowerRight = 8] = "LowerRight", w[w.All = 15] = "All", w))(LayeredDigraphAlign2 || {});
  const _LayeredDigraphLayout = class _LayeredDigraphLayout extends Layout2 {
    constructor(t) {
      super();
      __publicField(this, "Ds");
      __publicField(this, "te");
      __publicField(this, "C");
      __publicField(this, "Jc");
      __publicField(this, "Zc");
      __publicField(this, "$c");
      __publicField(this, "ef");
      __publicField(this, "Qc");
      __publicField(this, "cr");
      __publicField(this, "_c");
      __publicField(this, "zn");
      __publicField(this, "Lt");
      __publicField(this, "Wy");
      __publicField(this, "Wt");
      __publicField(this, "Eg");
      __publicField(this, "Fs");
      __publicField(this, "yi");
      __publicField(this, "on");
      __publicField(this, "Rs");
      __publicField(this, "Is");
      __publicField(this, "Gt");
      __publicField(this, "Vg");
      __publicField(this, "sf");
      __publicField(this, "Bg");
      __publicField(this, "rn");
      __publicField(this, "tu");
      __publicField(this, "ur");
      __publicField(this, "Xn");
      __publicField(this, "Yn");
      __publicField(this, "YN");
      this.Ds = 25, this.te = 25, this.C = 0, this.Jc = 0, this.Zc = 10, this.$c = 20, this.ef = 4, this.Qc = 31, this.cr = 15, this._c = 10, this.zn = true, this.Lt = -1, this.Wy = -1, this.Wt = -1, this.Eg = 0, this.Fs = 0, this.yi = null, this.on = null, this.Rs = null, this.Is = null, this.Gt = null, this.Vg = 0, this.sf = null, this.Bg = null, this.rn = 0, this.tu = null, this.ur = new Point2(), this.Xn = [], this.Xn.length = 100, this.Yn = 15, this.YN = 0, t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Ds = this.Ds, t.te = this.te, t.C = this.C, t.Jc = this.Jc, t.Zc = this.Zc, t.$c = this.$c, t.ef = this.ef, t.Qc = this.Qc, t.cr = this.cr, t._c = this._c, t.zn = this.zn, t.Yn = this.Yn;
    }
    ci(t) {
      t in LayeredDigraphAggressive2 ? this.aggressiveOption = t : t in LayeredDigraphCycleRemove2 ? this.cycleRemoveOption = t : t in LayeredDigraphInit2 ? this.initializeOption = t : t in LayeredDigraphLayering2 ? this.layeringOption = t : super.ci(t);
    }
    createNetwork() {
      return new LayeredDigraphNetwork2(this);
    }
    doLayout(t) {
      Debug && t === null && Util.n("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"), this.network === null && (this.network = this.makeNetwork(t)), this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin), this.ZO(), this.network.vertexes.count > 0 && (this.network.deleteSelfEdges(), this.cycleRemoveOption !== 2 && this.removeCycles(), this.$O(), this.cycleRemoveOption === 2 && this.removeCycles(), this.QO(), this._O(), this.t3(), this.reduceCrossings(), this.straightenAndPack(), this.updateParts()), this.network = null, this.isValidLayout = true;
    }
    linkMinLength(t) {
      return 1;
    }
    linkLengthWeight(t) {
      return 1;
    }
    linkStraightenWeight(t) {
      const i = t.fromVertex.node || t.fromVertex.data, e = t.toVertex.node || t.toVertex.data;
      return i === null && e === null ? 8 : i === null || e === null ? 4 : 1;
    }
    nodeMinLayerSpace(t, i) {
      return t.node === null && t.data === null ? 0 : this.C === 90 || this.C === 270 ? i ? t.focus.y + 10 : t.bounds.height - t.focus.y + 10 : i ? t.focus.x + 10 : t.bounds.width - t.focus.x + 10;
    }
    nodeMinColumnSpace(t, i) {
      if (t.node === null && t.data === null)
        return 0;
      const e = i ? t.ek : t.sk;
      if (e !== null)
        return e;
      const s = this.C;
      return s === 90 || s === 270 ? i ? t.ek = t.focus.x / this.te + 1 | 0 : t.sk = (t.bounds.width - t.focus.x) / this.te + 1 | 0 : i ? t.ek = t.focus.y / this.te + 1 | 0 : t.sk = (t.bounds.height - t.focus.y) / this.te + 1 | 0;
    }
    ie() {
      this.sf === null && (this.sf = []);
      let t = 0;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        this.sf[t] = e.layer, t++, this.sf[t] = e.column, t++, this.sf[t] = e.index, t++;
      }
      return this.sf;
    }
    ns(t) {
      let i = 0;
      const e = this.network.vertexes.iterator;
      for (; e.next(); ) {
        const s = e.value;
        s.layer = t[i], i++, s.column = t[i], i++, s.index = t[i], i++;
      }
    }
    _T(t, i) {
      Debug && (Util.r(t, _LayeredDigraphLayout, "crossingMatrix:unfixedLayer"), Util.r(i, _LayeredDigraphLayout, "crossingMatrix:direction"));
      const e = this.Vh(t), s = this.yi[t];
      (this.Bg === null || this.Bg.length < s * s) && (this.Bg = []);
      const n = this.Bg;
      for (let o = 0; o < s; o++) {
        let r = 0;
        const l = e[o], h = l.near;
        let a = 0;
        h !== null && h !== l && h.layer === l.layer && (r += Math.max(0, Math.abs(h.index - l.index) - 1));
        let f, c = 0, u, d = 0, m = 0, g = 0, p, y = 0, x, b = 0, k = 0, S = 0, M;
        if (i >= 0) {
          for (f = e[o].Mo, c = 0; c < f.length; c++)
            if (u = f[c], u.valid && u.fromVertex.layer !== t)
              for (d = u.fromVertex.index, m = u.portToPos, g = u.portFromPos, y = c + 1; y < f.length; y++)
                x = f[y], x.valid && x.fromVertex.layer !== t && (b = x.fromVertex.index, k = x.portToPos, S = x.portFromPos, m < k && (d > b || d === b && g > S) && r++, k < m && (b > d || b === d && S > g) && r++);
        }
        if (i <= 0) {
          for (f = e[o].hr, c = 0; c < f.length; c++)
            if (u = f[c], u.valid && u.toVertex.layer !== t)
              for (d = u.toVertex.index, m = u.portToPos, g = u.portFromPos, y = c + 1; y < f.length; y++)
                x = f[y], x.valid && x.toVertex.layer !== t && (b = x.toVertex.index, k = x.portToPos, S = x.portFromPos, g < S && (d > b || d === b && m > k) && r++, S < g && (b > d || b === d && k > m) && r++);
        }
        for (n[o * s + o] = r, a = o + 1; a < s; a++) {
          let A = 0, C = 0;
          if (i >= 0) {
            for (p = e[o].Mo, M = e[a].Mo, c = 0; c < p.length; c++)
              if (u = p[c], u.valid && u.fromVertex.layer !== t)
                for (d = u.fromVertex.index, m = u.portToPos, g = u.portFromPos, y = 0; y < M.length; y++)
                  x = M[y], x.valid && x.fromVertex.layer !== t && (b = x.fromVertex.index, k = x.portToPos, S = x.portFromPos, (d < b || d === b && g < S) && C++, (b < d || b === d && S < g) && A++);
          }
          if (i <= 0) {
            for (p = e[o].hr, M = e[a].hr, c = 0; c < p.length; c++)
              if (u = p[c], u.valid && u.toVertex.layer !== t)
                for (d = u.toVertex.index, m = u.portToPos, g = u.portFromPos, y = 0; y < M.length; y++)
                  x = M[y], x.valid && x.toVertex.layer !== t && (b = x.toVertex.index, k = x.portToPos, S = x.portFromPos, (d < b || d === b && m < k) && C++, (b < d || b === d && k < m) && A++);
          }
          n[o * s + a] = A, n[a * s + o] = C;
        }
      }
      return this.Bh(t, e), n;
    }
    countCrossings() {
      let t = 0;
      for (let i = 0; i <= this.Lt; i++) {
        const e = this._T(i, 1), s = this.yi[i];
        for (let n = 0; n < s; n++)
          for (let o = n; o < s; o++)
            t += e[n * s + o];
      }
      return t;
    }
    i3(t, i, e) {
      const s = this.Vh(t), n = this.yi[t];
      let o = 0;
      for (let r = 0; r < n; r++) {
        let l = null;
        i <= 0 && (l = s[r].Mo);
        let h = null;
        i >= 0 && (h = s[r].hr);
        let a, f = 0, c = 0;
        if (l !== null)
          for (let u = 0; u < l.length; u++)
            a = l[u], a.valid && a.fromVertex.layer !== t && (f = a.fromVertex.column + a.portFromColOffset, c = a.toVertex.column + a.portToColOffset, e ? o += Math.abs(f - c) * this.linkStraightenWeight(a) : o += Math.abs(f - c));
        if (h !== null)
          for (let u = 0; u < h.length; u++)
            a = h[u], a.valid && a.toVertex.layer !== t && (f = a.fromVertex.column + a.portFromColOffset, c = a.toVertex.column + a.portToColOffset, e ? o += (Math.abs(f - c) + 1) * this.linkStraightenWeight(a) : o += Math.abs(f - c));
      }
      return this.Bh(t, s), o;
    }
    nk(t) {
      let i = 0;
      for (let e = 0; e <= this.Lt; e++)
        i += this.i3(e, 1, t);
      return i;
    }
    jy() {
      let t = 1 / 0;
      this.Wt = -1;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        t = Math.min(t, e.column - this.nodeMinColumnSpace(e, true)), this.Wt = Math.max(this.Wt, e.column + this.nodeMinColumnSpace(e, false));
      }
      for (i.reset(); i.next(); ) {
        const e = i.value;
        e.column -= t;
      }
      this.Wt -= t;
    }
    Jy(t, i) {
      Debug && (Util.r(t, _LayeredDigraphLayout, "barycenters:unfixedLayer"), Util.r(i, _LayeredDigraphLayout, "barycenters:direction"));
      const e = this.Vh(t), s = this.yi[t], n = [];
      for (let o = 0; o < s; o++) {
        const r = e[o];
        let l = null;
        i <= 0 && (l = r.Mo);
        let h = null;
        i >= 0 && (h = r.hr);
        let a = 0, f = 0;
        const c = r.near;
        c !== null && c.layer === r.layer && (a += c.column - 1, f++);
        let u;
        if (l !== null)
          for (let d = 0; d < l.length; d++) {
            u = l[d];
            const m = u.fromVertex;
            u.valid && !u.rev && m.layer !== t && (a += m.column, f++);
          }
        if (h !== null)
          for (let d = 0; d < h.length; d++) {
            u = h[d];
            const m = u.toVertex;
            u.valid && !u.rev && m.layer !== t && (a += m.column, f++);
          }
        f === 0 ? n[o] = -1 : n[o] = a / f;
      }
      return this.Bh(t, e), n;
    }
    tD(t, i) {
      Debug && (Util.r(t, _LayeredDigraphLayout, "medians:unfixedLayer"), Util.r(i, _LayeredDigraphLayout, "medians:direction"));
      const e = this.Vh(t), s = this.yi[t], n = [];
      for (let o = 0; o < s; o++) {
        const r = e[o];
        let l = null;
        i <= 0 && (l = r.Mo);
        let h = null;
        i >= 0 && (h = r.hr);
        let a = 0;
        const f = [], c = r.near;
        c !== null && c.layer === r.layer && (f[a] = c.column - 1, a++);
        let u;
        if (l !== null)
          for (let d = 0; d < l.length; d++) {
            u = l[d];
            const m = u.fromVertex;
            u.valid && !u.rev && m.layer !== t && (f[a] = m.column + u.portFromColOffset, a++);
          }
        if (h !== null)
          for (let d = 0; d < h.length; d++) {
            u = h[d];
            const m = u.toVertex;
            u.valid && !u.rev && m.layer !== t && (f[a] = m.column + u.portToColOffset, a++);
          }
        if (a === 0)
          n[o] = -1;
        else {
          f.sort((m, g) => m - g);
          const d = a >> 1;
          a & 1 ? n[o] = f[d] : n[o] = f[d - 1] + f[d] >> 1;
        }
      }
      return this.Bh(t, e), n;
    }
    Zy(t, i, e, s, n) {
      if (t.component === e) {
        t.component = i;
        let o = 0, r = 0;
        if (s) {
          const l = t.destinationEdges;
          for (; l.next(); ) {
            const h = l.value, a = h.toVertex;
            o = t.layer - a.layer, r = this.linkMinLength(h), o === r && this.Zy(a, i, e, s, n);
          }
        }
        if (n) {
          const l = t.sourceEdges;
          for (; l.next(); ) {
            const h = l.value, a = h.fromVertex;
            o = a.layer - t.layer, r = this.linkMinLength(h), o === r && this.Zy(a, i, e, s, n);
          }
        }
      }
    }
    KN(t, i, e, s, n) {
      if (t.component === e) {
        if (t.component = i, s) {
          const o = t.destinationEdges;
          for (; o.next(); ) {
            const l = o.value.toVertex;
            this.KN(l, i, e, s, n);
          }
        }
        if (n) {
          const o = t.sourceEdges;
          for (; o.next(); ) {
            const l = o.value.fromVertex;
            this.KN(l, i, e, s, n);
          }
        }
      }
    }
    removeCycles() {
      const t = this.network.edges.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i.rev = false;
      }
      switch (this.Jc) {
        default:
        case 1:
          this.e3();
          break;
        case 0:
          this.s3();
          break;
        case 2:
          this.o3();
          break;
      }
    }
    o3() {
      const t = this.network, i = t.vertexes.iterator;
      let e = 1 / 0;
      for (; i.next(); ) {
        const s = i.value;
        e = Math.min(e, s.layer);
      }
      if (e < 1 / 0) {
        if (e < 0)
          for (i.reset(); i.next(); ) {
            const r = i.value;
            r.layer -= e;
          }
        const s = [];
        for (i.reset(); i.next(); ) {
          const r = i.value, l = s[r.layer];
          l === void 0 ? s[r.layer] = [r] : l.push(r);
        }
        let n = 0;
        for (let r = 0; r < s.length; r++) {
          const l = s[r];
          if (!l || l.length === 0)
            n++;
          else if (r > 0)
            for (let h = 0; h < l.length; h++) {
              const a = l[h];
              a.layer -= n;
            }
        }
        const o = t.edges.iterator;
        for (; o.next(); ) {
          const r = o.value, l = r.fromVertex, h = r.toVertex;
          l.layer < h.layer && (t.reverseEdge(r), r.rev = true);
        }
      }
    }
    e3() {
      const t = this.network;
      let i = 0, e = t.vertexes.count - 1;
      const s = [];
      s.length = e + 1;
      const n = t.vertexes.iterator;
      for (; n.next(); ) {
        const r = n.value;
        r.ee = true;
      }
      for (; this.r3(t) !== null; ) {
        let r;
        for (r = this.iD(t); r !== null; )
          s[e] = r, e--, r.ee = false, r = this.iD(t);
        for (r = this.eD(t); r !== null; )
          s[i] = r, i++, r.ee = false, r = this.eD(t);
        r = this.l3(t), r !== null && (s[i] = r, i++, r.ee = false);
      }
      for (let r = 0; r < t.vertexes.count; r++)
        s[r].index = r;
      const o = t.edges.iterator;
      for (; o.next(); ) {
        const r = o.value, l = r.fromVertex, h = r.toVertex;
        l.index > h.index && (t.reverseEdge(r), r.rev = true);
      }
    }
    r3(t) {
      const i = t.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        if (e.ee)
          return e;
      }
      return null;
    }
    iD(t) {
      const i = t.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        if (e.ee) {
          let s = true;
          const n = e.destinationEdges;
          for (; n.next(); )
            if (n.value.toVertex.ee) {
              s = false;
              break;
            }
          if (s)
            return e;
        }
      }
      return null;
    }
    eD(t) {
      const i = t.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        if (e.ee) {
          let s = true;
          const n = e.sourceEdges;
          for (; n.next(); )
            if (n.value.fromVertex.ee) {
              s = false;
              break;
            }
          if (s)
            return e;
        }
      }
      return null;
    }
    l3(t) {
      let i = null, e = 0;
      const s = this.network.vertexes.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (n.ee) {
          let o = 0;
          const r = n.destinationEdges;
          for (; r.next(); )
            r.value.toVertex.ee && o++;
          let l = 0;
          const h = n.sourceEdges;
          for (; h.next(); )
            h.value.fromVertex.ee && l++;
          (i === null || e < o - l) && (i = n, e = o - l);
        }
      }
      return i;
    }
    s3() {
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const e = t.value;
        e.iu = -1, e.Qn = -1;
      }
      const i = this.network.edges.iterator;
      for (; i.next(); ) {
        const e = i.value;
        e.forest = false;
      }
      for (this.Vg = 0, t.reset(); t.next(); ) {
        const e = t.value;
        e.sourceEdges.count === 0 && this.UN(e);
      }
      for (t.reset(); t.next(); ) {
        const e = t.value;
        e.iu === -1 && this.UN(e);
      }
      for (i.reset(); i.next(); ) {
        const e = i.value;
        if (!e.forest) {
          const s = e.fromVertex, n = s.iu, o = s.Qn, r = e.toVertex, l = r.iu, h = r.Qn;
          l < n && o < h && (this.network.reverseEdge(e), e.rev = true);
        }
      }
    }
    UN(t) {
      t.iu = this.Vg, this.Vg++;
      const i = t.destinationEdges;
      for (; i.next(); ) {
        const e = i.value, s = e.toVertex;
        s.iu === -1 && (e.forest = true, this.UN(s));
      }
      t.Qn = this.Vg, this.Vg++;
    }
    $O() {
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i.layer = -1;
      }
      for (this.Lt = -1, this.assignLayers(), t.reset(); t.next(); ) {
        const i = t.value;
        this.Lt = Math.max(this.Lt, i.layer);
      }
    }
    assignLayers() {
      switch (this.Zc) {
        case 11:
          this.sD();
          break;
        case 12:
          this.h3();
          break;
        default:
        case 10:
          this.a3();
          break;
      }
    }
    sD() {
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const i = t.value, e = this.nD(i);
        this.Lt = Math.max(e, this.Lt);
      }
    }
    nD(t) {
      let i = 0;
      if (t.layer === -1) {
        const e = t.destinationEdges;
        for (; e.next(); ) {
          const s = e.value, n = s.toVertex, o = this.linkMinLength(s);
          i = Math.max(i, this.nD(n) + o);
        }
        t.layer = i;
      } else
        i = t.layer;
      return i;
    }
    h3() {
      let t = 0;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        t = this.oD(e), this.Lt = Math.max(t, this.Lt);
      }
      for (i.reset(); i.next(); ) {
        const e = i.value;
        e.layer = this.Lt - e.layer;
      }
    }
    oD(t) {
      let i = 0;
      if (t.layer === -1) {
        const e = t.sourceEdges;
        for (; e.next(); ) {
          const s = e.value, n = s.fromVertex, o = this.linkMinLength(s);
          i = Math.max(i, this.oD(n) + o);
        }
        t.layer = i;
      } else
        i = t.layer;
      return i;
    }
    a3() {
      this.sD();
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const e = t.value;
        e.ee = false;
      }
      for (t.reset(); t.next(); ) {
        const e = t.value;
        e.sourceEdges.count === 0 && this.rD(e);
      }
      let i = 1 / 0;
      for (t.reset(); t.next(); ) {
        const e = t.value;
        i = Math.min(i, e.layer);
      }
      for (this.Lt = -1, t.reset(); t.next(); ) {
        const e = t.value;
        e.layer -= i, this.Lt = Math.max(this.Lt, e.layer);
      }
    }
    rD(t) {
      if (!t.ee) {
        t.ee = true;
        const i = t.destinationEdges;
        for (; i.next(); ) {
          const s = i.value.toVertex;
          this.rD(s);
        }
        this.f3(t), this.c3(t);
      }
    }
    f3(t) {
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const r = i.value;
        r.component = -1;
      }
      const e = 0, s = 1, n = t.Mo;
      let o = n.length;
      for (let r = 0; r < o; r++) {
        const l = n[r], h = l.fromVertex, a = l.toVertex, f = this.linkMinLength(l);
        h.layer - a.layer > f && this.Zy(h, e, -1, true, false);
      }
      for (this.Zy(t, s, -1, true, true); t.component !== e; ) {
        let r = 0, l = 1 / 0, h = 0, a = null;
        const f = this.network.vertexes.iterator;
        for (; f.next(); ) {
          const c = f.value;
          if (c.component === s) {
            let u = 0, d = false;
            const m = c.Mo;
            o = m.length;
            for (let p = 0; p < o; p++) {
              const y = m[p], x = y.fromVertex;
              if (u += this.linkLengthWeight(y), x.component !== s) {
                r += this.linkLengthWeight(y);
                const b = x.layer - c.layer, k = this.linkMinLength(y);
                l = Math.min(l, b - k);
              }
            }
            const g = c.hr;
            o = g.length;
            for (let p = 0; p < o; p++) {
              const y = g[p], x = y.toVertex;
              u -= this.linkLengthWeight(y), x.component !== s ? r -= this.linkLengthWeight(y) : d = true;
            }
            (a === null || u < h) && !d && (a = c, h = u);
          }
        }
        if (r > 0) {
          for (i.reset(); i.next(); ) {
            const c = i.value;
            c.component === s && (c.layer += l);
          }
          t.component = e;
        } else
          a.component = e;
      }
    }
    c3(t) {
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const n = i.value;
        n.component = -1;
      }
      const e = 0, s = 1;
      for (this.Zy(t, s, -1, true, false); t.component !== e; ) {
        let n = 0, o = 1 / 0, r = 0, l = null;
        const h = this.network.vertexes.iterator;
        for (; h.next(); ) {
          const a = h.value;
          if (a.component === s) {
            let f = 0, c = false;
            const u = a.Mo;
            let d = u.length;
            for (let g = 0; g < d; g++) {
              const p = u[g], y = p.fromVertex;
              f += this.linkLengthWeight(p), y.component !== s ? n += this.linkLengthWeight(p) : c = true;
            }
            const m = a.hr;
            d = m.length;
            for (let g = 0; g < d; g++) {
              const p = m[g], y = p.toVertex;
              if (f -= this.linkLengthWeight(p), y.component !== s) {
                n -= this.linkLengthWeight(p);
                const x = a.layer - y.layer, b = this.linkMinLength(p);
                o = Math.min(o, x - b);
              }
            }
            (l === null || f > r) && !c && (l = a, r = f);
          }
        }
        if (n < 0) {
          for (i.reset(); i.next(); ) {
            const a = i.value;
            a.component === s && (a.layer -= o);
          }
          t.component = e;
        } else
          l.component = e;
      }
    }
    QO() {
      const t = this.network, i = [], e = t.edges.iterator;
      for (; e.next(); ) {
        const s = e.value;
        s.valid = false, i.push(s);
      }
      for (let s = 0; s < i.length; s++) {
        const n = i[s];
        let o = n.fromVertex;
        const r = n.toVertex;
        if (n.valid || (o.node === null && o.data === null || r.node === null && r.data === null) && o.layer === r.layer)
          continue;
        let l = 0, h = 0, a = 0, f = 0;
        if (n.link !== null) {
          const S = n.link;
          if (S === null)
            continue;
          const M = o.node, A = r.node;
          if (M === null || A === null)
            continue;
          let C = S.fromNode, P = S.toNode, N = S.fromPort;
          for (; N !== null && !N.isVisibleObject(); )
            N = N.panel;
          let T = S.toPort;
          for (; T !== null && !T.isVisibleObject(); )
            T = T.panel;
          if (n.rev) {
            const B = C, K = N;
            C = P, N = T, P = B, T = K;
          }
          const L = o.focus, D = r.focus, F = n.rev ? r.bounds : o.bounds, R = Point2.a();
          M !== C ? F.isReal() && C.isVisible() ? C.actualBounds.isReal() ? (C.getRelativePoint(N, Spot2.Center, R), R.x += C.actualBounds.x - F.x, R.y += C.actualBounds.y - F.y) : (C.getRelativePoint(N, Spot2.Center, R), R.isReal() || R.c(L)) : R.c(L) : F.isReal() ? (C.getRelativePoint(N, Spot2.Center, R), R.isReal() || R.c(L)) : R.c(L);
          const I = n.rev ? o.bounds : r.bounds, O = Point2.a();
          A !== P ? I.isReal() && P.isVisible() ? P.actualBounds.isReal() ? (P.getRelativePoint(T, Spot2.Center, O), O.x += P.actualBounds.x - I.x, O.y += P.actualBounds.y - I.y) : (P.getRelativePoint(T, Spot2.Center, O), O.isReal() || O.c(D)) : O.c(D) : I.isReal() ? (P.getRelativePoint(T, Spot2.Center, O), O.isReal() || O.c(D)) : O.c(D), this.C === 90 || this.C === 270 ? (l = Math.round((R.x - L.x) / this.te), a = R.x, h = Math.round((O.x - D.x) / this.te), f = O.x) : (l = Math.round((R.y - L.y) / this.te), a = R.y, h = Math.round((O.y - D.y) / this.te), f = O.y), Point2.o(R), Point2.o(O), n.portFromColOffset = l, n.portFromPos = a, n.portToColOffset = h, n.portToPos = f;
        } else
          n.portFromColOffset = 0, n.portFromPos = 0, n.portToColOffset = 0, n.portToPos = 0;
        let c = o.layer;
        const u = r.layer, d = this.u3(n), m = d === 1 || d === 3, g = d === 2 || d === 3;
        let p, y, x = null, b;
        g && (x = this.d3(o, r), b = 1, y = t.createVertex(), y.node = null, y.ok = 1, y.layer = c, y.near = o, t.addVertex(y), p = t.linkVertexes(o, y, n.link), p.valid = false, p.rev = n.rev, p.portFromColOffset = l, p.portToColOffset = 0, p.portFromPos = a, p.portToPos = 0, o = y);
        let k = 1;
        if (m && k--, c - u > k && c > 0) {
          for (n.valid = false, y = t.createVertex(), y.node = null, y.ok = 2, y.layer = c - 1, x && b < x.length && y.layer === x[b].layer && (y.near = x[b++]), t.addVertex(y), p = t.linkVertexes(o, y, n.link), p.valid = true, p.rev = n.rev, p.portFromColOffset = g ? 0 : l, p.portToColOffset = 0, p.portFromPos = g ? 0 : a, p.portToPos = 0, o = y, c--; c - u > k && c > 0; )
            y = t.createVertex(), y.node = null, y.ok = 3, y.layer = c - 1, x && b < x.length && y.layer === x[b].layer && (y.near = x[b++]), t.addVertex(y), p = t.linkVertexes(o, y, n.link), p.valid = true, p.rev = n.rev, p.portFromColOffset = 0, p.portToColOffset = 0, p.portFromPos = 0, p.portToPos = 0, o = y, c--;
          p = t.linkVertexes(y, r, n.link), p.valid = !m, m && (y.near = r), p.rev = n.rev, p.portFromColOffset = 0, p.portToColOffset = h, p.portFromPos = 0, p.portToPos = f;
        } else
          n.valid = true;
      }
    }
    u3(t) {
      let i = 0;
      const e = t.link;
      if (e !== null) {
        const s = e.fromPort, n = e.toPort;
        if (s !== null && n !== null) {
          const o = e.fromNode, r = e.toNode;
          if (o !== null && r !== null) {
            const l = this.rk(true), h = this.rk(false), a = this.setsPortSpots ? l : e.computeSpot(true, s), f = this.setsPortSpots ? h : e.computeSpot(false, n), c = e.isOrthogonal;
            if (a.isSide() && a.includesSide(h) && f.isSide() && f.includesSide(l))
              return 0;
            const u = e.getLinkPoint(o, s, a, true, c, r, n, Point2.a()), d = e.getLinkDirection(o, s, u, a, true, c, r, n);
            Point2.o(u), (!a.isNone() && d === this.lD(t, true) || this.setsPortSpots && o !== null && o.ports.count === 1 && t.rev) && (i += 1);
            const m = e.getLinkPoint(r, n, f, false, c, o, s, Point2.a()), g = e.getLinkDirection(r, n, m, f, false, c, o, s);
            Point2.o(m), (!f.isNone() && g === this.lD(t, false) || this.setsPortSpots && r !== null && r.ports.count === 1 && t.rev) && (i += 2);
          }
        }
      }
      return i;
    }
    lD(t, i) {
      return this.C === 90 ? i && !t.rev || !i && t.rev ? 270 : 90 : this.C === 180 ? i && !t.rev || !i && t.rev ? 0 : 180 : this.C === 270 ? i && !t.rev || !i && t.rev ? 90 : 270 : i && !t.rev || !i && t.rev ? 180 : 0;
    }
    d3(t, i) {
      const e = [];
      return e.push(i), this.hD(t, e) ? e.reverse() : [];
    }
    hD(t, i) {
      const e = i[i.length - 1].sourceEdges.iterator;
      for (; e.next(); ) {
        const s = e.value;
        if (s.rev || !s.valid)
          continue;
        const n = s.fromVertex;
        if (i.push(n), n === t || this.hD(t, i))
          return true;
        i.pop();
      }
      return false;
    }
    _O() {
      const t = this.yi = [];
      for (let e = 0; e <= this.Lt; e++)
        t[e] = 0;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        e.index = -1;
      }
      this.initializeIndices(), this.Wy = -1, this.Eg = 0, this.Fs = 0;
      for (let e = 0; e <= this.Lt; e++)
        t[e] > t[this.Fs] && (this.Wy = t[e] - 1, this.Fs = e), t[e] < t[this.Eg] && (this.Eg = e);
      this.tu = [];
      for (let e = 0; e < t.length; e++)
        this.tu[e] = [];
      for (i.reset(); i.next(); ) {
        const e = i.value, s = e.layer, n = this.tu[s];
        n[e.index] = e;
      }
    }
    initializeIndices() {
      switch (this.$c) {
        default:
        case 22:
          this.g3();
          break;
        case 20:
          this.m3();
          break;
        case 21:
          this.p3();
          break;
      }
    }
    g3() {
      let t = null;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        if (e.near && (t === null && (t = /* @__PURE__ */ new Map()), e.layer === e.near.layer)) {
          const s = t.get(e.near) || [];
          s.push(e), t.set(e.near, s);
        }
      }
      for (i.reset(); i.next(); ) {
        const e = i.value;
        if (e.near)
          continue;
        const s = e.layer;
        if (e.index = this.yi[s], this.yi[s]++, !t)
          continue;
        const n = t.get(e);
        Array.isArray(n) && n.forEach((o) => {
          o.index = this.yi[s], this.yi[s]++;
        });
      }
    }
    m3() {
      let t = null;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        if (e.near && (t === null && (t = /* @__PURE__ */ new Map()), e.layer === e.near.layer)) {
          const s = t.get(e.near) || [];
          s.push(e), t.set(e.near, s);
        }
      }
      for (let e = this.Lt; e >= 0; e--)
        for (i.reset(); i.next(); ) {
          const s = i.value;
          s.layer === e && s.index === -1 && this.aD(s, t);
        }
    }
    aD(t, i) {
      if (t.near)
        return;
      const e = t.layer;
      if (t.index = this.yi[e], this.yi[e]++, i) {
        const o = i.get(t);
        Array.isArray(o) && o.forEach((r) => {
          r.index = this.yi[e], this.yi[e]++;
        });
      }
      const s = t.hr;
      let n = true;
      for (; n; ) {
        n = false;
        for (let o = 0; o < s.length - 1; o++) {
          const r = s[o], l = s[o + 1];
          r.portFromColOffset > l.portFromColOffset && (n = true, s[o] = l, s[o + 1] = r);
        }
      }
      for (let o = 0; o < s.length; o++) {
        const r = s[o];
        if (r.valid) {
          const l = r.toVertex;
          l.index === -1 && this.aD(l, i);
        }
      }
    }
    p3() {
      let t = null;
      const i = this.network.vertexes.iterator;
      for (; i.next(); ) {
        const e = i.value;
        if (e.near && (t === null && (t = /* @__PURE__ */ new Map()), e.layer === e.near.layer)) {
          const s = t.get(e.near) || [];
          s.push(e), t.set(e.near, s);
        }
      }
      for (let e = 0; e <= this.Lt; e++)
        for (i.reset(); i.next(); ) {
          const s = i.value;
          s.layer === e && s.index === -1 && this.fD(s, t);
        }
    }
    fD(t, i) {
      if (t.near)
        return;
      const e = t.layer;
      if (t.index = this.yi[e], this.yi[e]++, i) {
        const h = i.get(t);
        Array.isArray(h) && h.forEach((a) => {
          a.index = this.yi[e], this.yi[e]++;
        });
      }
      const s = t.Mo;
      let n = true, o = 0;
      for (; n; )
        for (n = false, o = 0; o < s.length - 1; o++) {
          const h = s[o], a = s[o + 1];
          h.portToColOffset > a.portToColOffset && (n = true, s[o] = a, s[o + 1] = h);
        }
      let r, l;
      for (o = 0; o < s.length; o++)
        l = s[o], l.valid && (r = l.fromVertex, r.index === -1 && this.fD(r, i));
    }
    t3() {
      this.Wt = -1;
      for (let t = 0; t <= this.Lt; t++) {
        const i = this.Vh(t);
        let e = 0;
        const s = this.yi[t];
        for (let n = 0; n < s; n++) {
          const o = i[n];
          e += this.nodeMinColumnSpace(o, true), o.column = e, e += 1, e += this.nodeMinColumnSpace(o, false);
        }
        this.Wt = Math.max(this.Wt, e - 1), this.Bh(t, i);
      }
    }
    reduceCrossings() {
      let t = this.countCrossings(), i = this.ie(), e = 0, s = 0, n = 0;
      for (e = 0; e < this.ef; e++) {
        for (s = 0; s <= this.Lt; s++)
          this.lk(s, 1), this.gs(s, 1, false, 1);
        for (n = this.countCrossings(), n < t && (t = n, i = this.ie()), s = this.Lt; s >= 0; s--)
          this.lk(s, -1), this.gs(s, -1, false, -1);
        n = this.countCrossings(), n < t && (t = n, i = this.ie());
      }
      for (this.ns(i), e = 0; e < this.ef; e++) {
        for (s = 0; s <= this.Lt; s++)
          this.lk(s, 0), this.gs(s, 0, false, 0);
        for (n = this.countCrossings(), n < t && (t = n, i = this.ie()), s = this.Lt; s >= 0; s--)
          this.lk(s, 0), this.gs(s, 0, false, 0);
        n = this.countCrossings(), n < t && (t = n, i = this.ie());
      }
      this.ns(i);
      let o = false, r = 0, l = 0, h = 0, a = 0;
      switch (this.Qc) {
        case 30:
          break;
        case 32:
          for (h = t + 1; (a = this.countCrossings()) < h; )
            for (h = a, r = this.Lt; r >= 0; r--)
              for (l = 0; l <= r; l++) {
                for (o = true; o; )
                  for (o = false, s = r; s >= l; s--)
                    o = this.gs(s, -1, false, -1) || o;
                for (n = this.countCrossings(), n >= t ? this.ns(i) : (t = n, i = this.ie()), o = true; o; )
                  for (o = false, s = r; s >= l; s--)
                    o = this.gs(s, 1, false, 1) || o;
                for (n = this.countCrossings(), n >= t ? this.ns(i) : (t = n, i = this.ie()), o = true; o; )
                  for (o = false, s = l; s <= r; s++)
                    o = this.gs(s, 1, false, 1) || o;
                for (n >= t ? this.ns(i) : (t = n, i = this.ie()), o = true; o; )
                  for (o = false, s = l; s <= r; s++)
                    o = this.gs(s, -1, false, -1) || o;
                for (n >= t ? this.ns(i) : (t = n, i = this.ie()), o = true; o; )
                  for (o = false, s = r; s >= l; s--)
                    o = this.gs(s, 0, false, 0) || o;
                for (n >= t ? this.ns(i) : (t = n, i = this.ie()), o = true; o; )
                  for (o = false, s = l; s <= r; s++)
                    o = this.gs(s, 0, false, 0) || o;
                n >= t ? this.ns(i) : (t = n, i = this.ie());
              }
          break;
        default:
        case 31:
          for (r = this.Lt, l = 0, h = t + 1; (a = this.countCrossings()) < h; ) {
            for (h = a, o = true; o; )
              for (o = false, s = r; s >= l; s--)
                o = this.gs(s, -1, false, -1) || o;
            for (n = this.countCrossings(), n >= t ? this.ns(i) : (t = n, i = this.ie()), o = true; o; )
              for (o = false, s = r; s >= l; s--)
                o = this.gs(s, 1, false, 1) || o;
            for (n = this.countCrossings(), n >= t ? this.ns(i) : (t = n, i = this.ie()), o = true; o; )
              for (o = false, s = l; s <= r; s++)
                o = this.gs(s, 1, false, 1) || o;
            for (n >= t ? this.ns(i) : (t = n, i = this.ie()), o = true; o; )
              for (o = false, s = l; s <= r; s++)
                o = this.gs(s, -1, false, -1) || o;
            for (n >= t ? this.ns(i) : (t = n, i = this.ie()), o = true; o; )
              for (o = false, s = r; s >= l; s--)
                o = this.gs(s, 0, false, 0) || o;
            for (n >= t ? this.ns(i) : (t = n, i = this.ie()), o = true; o; )
              for (o = false, s = l; s <= r; s++)
                o = this.gs(s, 0, false, 0) || o;
            n >= t ? this.ns(i) : (t = n, i = this.ie());
          }
          break;
      }
      this.ns(i);
    }
    lk(t, i) {
      Debug && (Util.r(t, _LayeredDigraphLayout, "medianBarycenterCrossingReduction:unfixedLayer"), Util.r(i, _LayeredDigraphLayout, "medianBarycenterCrossingReduction:direction"));
      let e = 0, s = false;
      const n = this.Vh(t), o = this.yi[t], r = this.tD(t, i), l = this.Jy(t, i);
      for (e = 0; e < o; e++)
        l[e] === -1 && (l[e] = n[e].column), r[e] === -1 && (r[e] = n[e].column);
      let h = true, a;
      for (; h; )
        for (h = false, e = 0; e < o - 1; e++)
          if (r[e + 1] < r[e] || r[e + 1] === r[e] && l[e + 1] < l[e]) {
            s = true, h = true;
            const c = r[e];
            r[e] = r[e + 1], r[e + 1] = c;
            const u = l[e];
            l[e] = l[e + 1], l[e + 1] = u, a = n[e], n[e] = n[e + 1], n[e + 1] = a;
          }
      let f = 0;
      for (e = 0; e < o; e++)
        a = n[e], a.index = e, f += this.nodeMinColumnSpace(a, true), a.column = f, f += 1, f += this.nodeMinColumnSpace(a, false);
      return this.Bh(t, n), s;
    }
    gs(t, i, e, s) {
      const n = this.Vh(t), o = this.yi[t], r = this._T(t, i);
      let l = 0, h;
      if (!e || s > 0)
        for (h = [], l = 0; l < o; l++)
          h[l] = -1;
      else
        h = this.Jy(t, -1);
      let a;
      if (!e || s < 0)
        for (a = [], l = 0; l < o; l++)
          a[l] = -1;
      else
        a = this.Jy(t, 1);
      let f = false, c = true;
      for (; c; )
        for (c = false, l = 0; l < o - 1; l++) {
          const u = r[n[l].index * o + n[l + 1].index], d = r[n[l + 1].index * o + n[l].index];
          let m = 0, g = 0;
          const p = n[l].column, y = n[l + 1].column, x = this.nodeMinColumnSpace(n[l], true), b = this.nodeMinColumnSpace(n[l], false), k = this.nodeMinColumnSpace(n[l + 1], true), S = this.nodeMinColumnSpace(n[l + 1], false), M = p - x + k, A = y - b + S;
          let C = 0, P = 0, N = 0, T = 0, L = 0, D = 0, F = 0, R, I = 0, O, B = 0;
          const K = n[l].sourceEdges.iterator;
          if (e && s <= 0)
            for (; K.next(); ) {
              const W = K.value;
              R = W.fromVertex, W.valid && R.layer !== t && (N = this.linkStraightenWeight(W), T = W.portFromColOffset, L = W.portToColOffset, D = R.column, C += (Math.abs(p + L - (D + T)) + 1) * N, P += (Math.abs(A + L - (D + T)) + 1) * N);
            }
          for (K.reset(); K.next(); ) {
            const W = K.value;
            if (R = W.fromVertex, W.valid && R.layer === t) {
              for (I = 0; I < n.length && n[I] !== R; )
                I++;
              I < l && (m += 2 * (l - I), g += 2 * (l + 1 - I)), I === l + 1 && (m += 1), I > l + 1 && (m += 4 * (I - l), g += 4 * (I - (l + 1)));
            }
          }
          const V = n[l].destinationEdges.iterator;
          if (e && s >= 0)
            for (; V.next(); ) {
              const W = V.value;
              O = W.toVertex, W.valid && O.layer !== t && (N = this.linkStraightenWeight(W), T = W.portFromColOffset, L = W.portToColOffset, F = O.column, C += (Math.abs(p + T - (F + L)) + 1) * N, P += (Math.abs(A + T - (F + L)) + 1) * N);
            }
          for (V.reset(); V.next(); ) {
            const W = V.value;
            if (O = W.toVertex, W.valid && O.layer === t) {
              for (B = 0; B < n.length && n[B] !== O; )
                B++;
              B === l + 1 && (g += 1);
            }
          }
          const X = n[l + 1].sourceEdges.iterator;
          if (e && s <= 0)
            for (; X.next(); ) {
              const W = X.value;
              R = W.fromVertex, W.valid && R.layer !== t && (N = this.linkStraightenWeight(W), T = W.portFromColOffset, L = W.portToColOffset, D = R.column, C += (Math.abs(y + L - (D + T)) + 1) * N, P += (Math.abs(M + L - (D + T)) + 1) * N);
            }
          for (X.reset(); X.next(); ) {
            const W = X.value;
            if (R = W.fromVertex, W.valid && R.layer === t) {
              for (I = 0; I < n.length && n[I] !== R; )
                I++;
              I < l && (m += 2 * (l + 1 - I), g += 2 * (l - I)), I === l && (g += 1), I > l + 1 && (m += 4 * (I - (l + 1)), g += 4 * (I - l));
            }
          }
          const z = n[l + 1].destinationEdges.iterator;
          if (e && s >= 0)
            for (; z.next(); ) {
              const W = z.value;
              O = W.toVertex, W.valid && O.layer !== t && (N = this.linkStraightenWeight(W), T = W.portFromColOffset, L = W.portToColOffset, F = O.column, C += (Math.abs(y + T - (F + L)) + 1) * N, P += (Math.abs(M + T - (F + L)) + 1) * N);
            }
          for (z.reset(); z.next(); ) {
            const W = z.value;
            if (O = W.toVertex, W.valid && O.layer === t) {
              for (B = 0; B < n.length && n[B] !== O; )
                B++;
              B === l && (m += 1);
            }
          }
          let G = 0, v = 0;
          const q = h[n[l].index], J = a[n[l].index], Y = h[n[l + 1].index], j = a[n[l + 1].index];
          if (q !== -1 && (G += Math.abs(q - p), v += Math.abs(q - A)), J !== -1 && (G += Math.abs(J - p), v += Math.abs(J - A)), Y !== -1 && (G += Math.abs(Y - y), v += Math.abs(Y - M)), j !== -1 && (G += Math.abs(j - y), v += Math.abs(j - M)), g < m - 0.5 || g === m && d < u - 0.5 || g === m && d === u && P < C - 0.5 || g === m && d === u && P === C && v < G - 0.5) {
            f = true, c = true, n[l].column = A, n[l + 1].column = M;
            const W = n[l];
            n[l] = n[l + 1], n[l + 1] = W;
          }
        }
      for (l = 0; l < o; l++)
        n[l].index = l;
      return this.Bh(t, n), f;
    }
    straightenAndPack() {
      if (this.Yn !== 0) {
        this.y3();
        return;
      }
      let t = 0, i = false, e = (this.cr & 1) !== 0;
      const s = (this.cr & 8) !== 0;
      if (this.network.edges.count > 1e3 && s && (e = false), e) {
        const n = [];
        let o = 0;
        for (o = 0; o <= this.Lt; o++)
          n[o] = 0;
        let r = 0;
        const l = this.network.vertexes.iterator;
        for (; l.next(); ) {
          const a = l.value;
          t = a.layer, r = a.column;
          const f = this.nodeMinColumnSpace(a, false);
          n[t] = Math.max(n[t], r + f);
        }
        const h = 8;
        for (l.reset(); l.next(); ) {
          const a = l.value;
          t = a.layer, r = a.column, a.column = ((this.Wt - n[t]) * h >> 1) + r * h;
        }
        this.Wt *= h;
      }
      if (this.cr & 2) {
        i = true;
        let n = 0;
        for (; i && n < this._c; ) {
          for (i = false, t = this.Fs + 1; t <= this.Lt; t++)
            i = this.zg(t, 1) || i;
          for (t = this.Fs - 1; t >= 0; t--)
            i = this.zg(t, -1) || i;
          i = this.zg(this.Fs, 0) || i, n++;
        }
      }
      if (this.cr & 4) {
        for (t = this.Fs + 1; t <= this.Lt; t++)
          this.GN(t, 1);
        for (t = this.Fs - 1; t >= 0; t--)
          this.GN(t, -1);
        this.GN(this.Fs, 0);
      }
      if (e && (this.cD(-1), this.cD(1)), this.cr & 2) {
        i = true;
        let n = 0;
        for (; i && n < this._c; ) {
          for (i = false, i = this.zg(this.Fs, 0) || i, t = this.Fs + 1; t <= this.Lt; t++)
            i = this.zg(t, 0) || i;
          for (t = this.Fs - 1; t >= 0; t--)
            i = this.zg(t, 0) || i;
          n++;
        }
      }
    }
    zg(t, i) {
      Debug && (Util.r(t, _LayeredDigraphLayout, "bendStraighten:unfixedLayer"), Util.r(i, _LayeredDigraphLayout, "bendStraighten:direction"));
      let e = false;
      for (; this.w3(t, i); )
        e = true;
      return e;
    }
    w3(t, i) {
      Debug && (Util.r(t, _LayeredDigraphLayout, "shiftbendStraighten:unfixedLayer"), Util.r(i, _LayeredDigraphLayout, "shiftbendStraighten:direction"));
      let e = 0;
      const s = this.Vh(t), n = this.yi[t], o = this.Jy(t, -1);
      if (i > 0)
        for (e = 0; e < n; e++)
          o[e] = -1;
      const r = this.Jy(t, 1);
      if (i < 0)
        for (e = 0; e < n; e++)
          r[e] = -1;
      let l = false, h = true;
      for (; h; )
        for (h = false, e = 0; e < n; e++) {
          const a = s[e].column, f = this.nodeMinColumnSpace(s[e], true), c = this.nodeMinColumnSpace(s[e], false);
          let u = 0;
          e - 1 < 0 || a - s[e - 1].column - 1 > f + this.nodeMinColumnSpace(s[e - 1], false) ? u = a - 1 : u = a;
          let d = 0;
          e + 1 >= n || s[e + 1].column - a - 1 > c + this.nodeMinColumnSpace(s[e + 1], true) ? d = a + 1 : d = a;
          let m = 0, g = 0, p = 0, y = 0, x = 0, b = 0;
          if (i <= 0) {
            const P = s[e].sourceEdges.iterator;
            for (; P.next(); ) {
              const N = P.value, T = N.fromVertex;
              if (N.valid && T.layer !== t) {
                y = this.linkStraightenWeight(N), x = N.portFromColOffset, b = N.portToColOffset;
                const L = T.column;
                m += (Math.abs(a + b - (L + x)) + 1) * y, g += (Math.abs(u + b - (L + x)) + 1) * y, p += (Math.abs(d + b - (L + x)) + 1) * y;
              }
            }
          }
          if (i >= 0) {
            const P = s[e].destinationEdges.iterator;
            for (; P.next(); ) {
              const N = P.value, T = N.toVertex;
              if (N.valid && T.layer !== t) {
                y = this.linkStraightenWeight(N), x = N.portFromColOffset, b = N.portToColOffset;
                const L = T.column;
                m += (Math.abs(a + x - (L + b)) + 1) * y, g += (Math.abs(u + x - (L + b)) + 1) * y, p += (Math.abs(d + x - (L + b)) + 1) * y;
              }
            }
          }
          let k = 0, S = 0, M = 0;
          const A = o[s[e].index], C = r[s[e].index];
          A !== -1 && (k += Math.abs(A - a), S += Math.abs(A - u), M += Math.abs(A - d)), C !== -1 && (k += Math.abs(C - a), S += Math.abs(C - u), M += Math.abs(C - d)), g < m || g === m && S < k ? (l = true, h = true, s[e].column = u) : (p < m || p === m && M < k) && (l = true, h = true, s[e].column = d);
        }
      return this.Bh(t, s), this.jy(), l;
    }
    GN(t, i) {
      Debug && (Util.r(t, _LayeredDigraphLayout, "medianStraighten:unfixedLayer"), Util.r(i, _LayeredDigraphLayout, "medianStraighten:direction"));
      let e = 0;
      const s = this.Vh(t), n = this.yi[t], o = this.tD(t, i), r = [];
      for (e = 0; e < n; e++)
        r[e] = o[e];
      let l = false, h = true;
      for (; h; )
        for (h = false, e = 0; e < n; e++) {
          const a = s[e].column, f = this.nodeMinColumnSpace(s[e], true), c = this.nodeMinColumnSpace(s[e], false);
          let u = 0, d = 0, m = 0, g = 0, p = 0;
          r[e] === -1 ? e === 0 && e === n - 1 ? u = a : e === 0 ? (d = s[e + 1].column, d - a === c + this.nodeMinColumnSpace(s[e + 1], true) ? u = a - 1 : u = a) : e === n - 1 ? (m = s[e - 1].column, a - m === f + this.nodeMinColumnSpace(s[e - 1], false) ? u = a + 1 : u = a) : (m = s[e - 1].column, p = m + this.nodeMinColumnSpace(s[e - 1], false) + f + 1, d = s[e + 1].column, g = d - this.nodeMinColumnSpace(s[e + 1], true) - c - 1, u = (p + g) / 2 | 0) : e === 0 && e === n - 1 ? u = r[e] : e === 0 ? (d = s[e + 1].column, g = d - this.nodeMinColumnSpace(s[e + 1], true) - c - 1, u = Math.min(r[e], g)) : e === n - 1 ? (m = s[e - 1].column, p = m + this.nodeMinColumnSpace(s[e - 1], false) + f + 1, u = Math.max(r[e], p)) : (m = s[e - 1].column, p = m + this.nodeMinColumnSpace(s[e - 1], false) + f + 1, d = s[e + 1].column, g = d - this.nodeMinColumnSpace(s[e + 1], true) - c - 1, p < r[e] && r[e] < g ? u = r[e] : p >= r[e] ? u = p : g <= r[e] && (u = g)), u !== a && (l = true, h = true, s[e].column = u);
        }
      return this.Bh(t, s), this.jy(), l;
    }
    x3() {
      for (let t = 0; t <= this.Wt; t++)
        for (; this.b3(t, 1); )
          ;
      this.jy();
    }
    b3(t, i) {
      Debug && (Util.r(t, _LayeredDigraphLayout, "packAux:column"), Util.r(i, _LayeredDigraphLayout, "packAux:direction"));
      let e = true;
      const s = this.network.vertexes.iterator;
      for (; s.next(); ) {
        const o = s.value, r = this.nodeMinColumnSpace(o, true), l = this.nodeMinColumnSpace(o, false);
        if (o.column - r <= t && o.column + l >= t) {
          e = false;
          break;
        }
      }
      let n = false;
      if (e) {
        if (i > 0)
          for (s.reset(); s.next(); ) {
            const o = s.value;
            o.column > t && (o.column -= 1, n = true);
          }
        if (i < 0)
          for (s.reset(); s.next(); ) {
            const o = s.value;
            o.column < t && (o.column += 1, n = true);
          }
      }
      return n;
    }
    k3() {
      this.x3();
      for (let t = 0; t < this.Wt; t++)
        for (; this.S3(t, 1); )
          ;
      this.jy();
    }
    S3(t, i) {
      Debug && (Util.r(t, _LayeredDigraphLayout, "tightPackAux:column"), Util.r(i, _LayeredDigraphLayout, "tightPackAux:direction"));
      let e = t;
      i > 0 && (e = t + 1), i < 0 && (e = t - 1);
      let s = 0;
      const n = [], o = [];
      for (s = 0; s <= this.Lt; s++)
        n[s] = false, o[s] = false;
      const r = this.network.vertexes.iterator;
      for (; r.next(); ) {
        const a = r.value, f = a.column - this.nodeMinColumnSpace(a, true), c = a.column + this.nodeMinColumnSpace(a, false);
        f <= t && c >= t && (n[a.layer] = true), f <= e && c >= e && (o[a.layer] = true);
      }
      let l = true, h = false;
      for (s = 0; s <= this.Lt; s++)
        l = l && !(n[s] && o[s]);
      if (l) {
        if (i > 0)
          for (r.reset(); r.next(); ) {
            const a = r.value;
            a.column > t && (a.column -= 1, h = true);
          }
        if (i < 0)
          for (r.reset(); r.next(); ) {
            const a = r.value;
            a.column < t && (a.column += 1, h = true);
          }
      }
      return h;
    }
    cD(t) {
      Debug && Util.r(t, _LayeredDigraphLayout, "componentPack:direction"), this.k3();
      let i = 0, e, s = 0, n = 0, o = 0;
      if (t > 0)
        for (i = 0; i <= this.Wt; i++)
          for (e = this.ie(), s = this.nk(true), n = s + 1; s < n; )
            n = s, this.uD(i, 1), o = this.nk(true), o > s ? this.ns(e) : o < s && (s = o, e = this.ie());
      if (t < 0)
        for (i = this.Wt; i >= 0; i--)
          for (e = this.ie(), s = this.nk(true), n = s + 1; s < n; )
            n = s, this.uD(i, -1), o = this.nk(true), o > s ? this.ns(e) : o < s && (s = o, e = this.ie());
      this.jy();
    }
    uD(t, i) {
      this.rn = 0;
      const e = this.network.vertexes.iterator;
      for (; e.next(); ) {
        const f = e.value;
        f.component = -1;
      }
      if (i > 0)
        for (e.reset(); e.next(); ) {
          const f = e.value;
          f.column - this.nodeMinColumnSpace(f, true) <= t && (f.component = this.rn);
        }
      if (i < 0)
        for (e.reset(); e.next(); ) {
          const f = e.value;
          f.column + this.nodeMinColumnSpace(f, false) >= t && (f.component = this.rn);
        }
      for (this.rn++, e.reset(); e.next(); ) {
        const f = e.value;
        f.component === -1 && (this.KN(f, this.rn, -1, true, true), this.rn++);
      }
      let s = 0;
      const n = [];
      for (s = 0; s < this.rn * this.rn; s++)
        n[s] = false;
      const o = [];
      for (s = 0; s < (this.Lt + 1) * (this.Wt + 1); s++)
        o[s] = -1;
      for (e.reset(); e.next(); ) {
        const f = e.value, c = f.layer, u = Math.max(0, f.column - this.nodeMinColumnSpace(f, true)), d = Math.min(this.Wt, f.column + this.nodeMinColumnSpace(f, false));
        for (let m = u; m <= d; m++)
          o[c * (this.Wt + 1) + m] = f.component;
      }
      for (let f = 0; f <= this.Lt; f++) {
        if (i > 0)
          for (let c = 0; c < this.Wt; c++)
            o[f * (this.Wt + 1) + c] !== -1 && o[f * (this.Wt + 1) + c + 1] !== -1 && o[f * (this.Wt + 1) + c] !== o[f * (this.Wt + 1) + c + 1] && (n[o[f * (this.Wt + 1) + c] * this.rn + o[f * (this.Wt + 1) + c + 1]] = true);
        if (i < 0)
          for (let c = this.Wt; c > 0; c--)
            o[f * (this.Wt + 1) + c] !== -1 && o[f * (this.Wt + 1) + c - 1] !== -1 && o[f * (this.Wt + 1) + c] !== o[f * (this.Wt + 1) + c - 1] && (n[o[f * (this.Wt + 1) + c] * this.rn + o[f * (this.Wt + 1) + c - 1]] = true);
      }
      const r = [];
      for (s = 0; s < this.rn; s++)
        r[s] = true;
      const l = [];
      l.push(0);
      let h = 0;
      for (; l.length !== 0; )
        if (h = l[l.length - 1], l.pop(), r[h])
          for (r[h] = false, s = 0; s < this.rn; s++)
            n[h * this.rn + s] && l.splice(0, 0, s);
      let a = false;
      if (i > 0)
        for (e.reset(); e.next(); ) {
          const f = e.value;
          r[f.component] && (f.column -= 1, a = true);
        }
      if (i < 0)
        for (e.reset(); e.next(); ) {
          const f = e.value;
          r[f.component] && (f.column += 1, a = true);
        }
      return a;
    }
    y3() {
      const t = Util.ct(), i = this.tu.length;
      for (let u = 0; u <= i; u++)
        t[u] = [];
      const e = this.network.vertexes.iterator;
      for (; e.next(); ) {
        const u = e.value, d = i - u.layer, m = t[d];
        m[u.index] = u;
      }
      const s = new GSet2();
      this.M3(t, s);
      let n = null, o = null, r = null, l = null;
      const h = (this.Yn & 1) !== 0, a = (this.Yn & 2) !== 0, f = (this.Yn & 4) !== 0, c = (this.Yn & 8) !== 0;
      h && (this.cl(t, s, true), n = this.hk(t, true, false)), t.reverse(), f && (this.cl(t, s, false), r = this.hk(t, false, false));
      for (const u of t)
        u.reverse();
      c && (this.cl(t, s, false), l = this.hk(t, false, true)), t.reverse(), a && (this.cl(t, s, true), o = this.hk(t, true, true)), Util.ot(t), this.P3(n, o, r, l), this.network.vertexes.each((u) => {
        const d = u, m = Util.ct();
        h && m.push(n.get(d)), a && m.push(o.get(d)), f && m.push(r.get(d)), c && m.push(l.get(d)), m.sort((b, k) => b - k);
        const g = m.length, p = Math.floor((g - 1) / 2), y = Math.ceil((g - 1) / 2), x = (m[p] + m[y]) / 2;
        Util.ot(m), d.pe = x;
      });
    }
    M3(t, i) {
      const e = t.length;
      for (let s = 1; s < e - 1; s++) {
        let n = 0, o = 0;
        const r = t[s], l = t[s + 1];
        for (let h = 0; o < l.length; h++) {
          const a = l[h], f = this.N3(a);
          if (h === l.length - 1 || f) {
            let c = r.length - 1;
            for (f && (c = a.getProperSourceVertexes()[0].index); o <= h; ) {
              const d = l[o].getProperSourceEdges();
              for (const m of d) {
                const p = m.fromVertex.index;
                (p < n || p > c) && i.add(m);
              }
              o++;
            }
            n = c;
          }
        }
      }
    }
    N3(t) {
      if (t.node === null) {
        const i = t.getProperSourceVertexes();
        if (i.length > 0)
          return i[0].node === null;
      }
      return false;
    }
    cl(t, i, e) {
      this.C3(t);
      for (const s of t) {
        let n = -1;
        for (const o of s) {
          const r = e ? o.getProperSourceVertexes() : o.getProperDestinationVertexes(), l = r.length;
          if (l > 0) {
            r.sort((a, f) => a.zh - f.zh);
            const h = (l - 1) / 2;
            for (let a = Math.floor(h), f = Math.ceil(h); a <= f; a++)
              if (o.Kn === o) {
                const c = r[a];
                let u;
                e ? u = c.getDestinationEdge(o) : u = o.getDestinationEdge(c), !i.contains(u) && n < c.zh && (c.Kn = o, o.nf = c.nf, o.Kn = c.nf, n = c.zh);
              }
          }
        }
      }
    }
    C3(t) {
      for (let i = 0; i < t.length; i++) {
        const e = t[i];
        for (let s = 0; s < e.length; s++) {
          const n = e[s];
          n.nf = n, n.Kn = n, n.dD = i, n.zh = s;
        }
      }
    }
    hk(t, i, e) {
      const s = this.C === 90 || this.C === 270;
      for (const o of t)
        for (const r of o)
          r.os = r, r.eu = 1 / 0, r.pe = NaN, r.Un = 0;
      this.A3(t, i, e);
      for (const o of t)
        for (const r of o)
          r.nf === r && this.gD(r, t);
      for (let o = 0; o < t.length; o++) {
        if (t[o].length <= 0)
          continue;
        const r = t[o][0];
        if (r.os === r) {
          r.os.eu === 1 / 0 && (r.os.eu = 0);
          let l = o, h = 0, a;
          do {
            for (a = t[l][h]; a.Kn !== a.nf; )
              if (a = a.Kn, l++, a.zh > 0) {
                const f = this.mD(a, t), c = s ? f.width : f.height, u = a.os.eu + a.pe + a.Un - (f.pe + f.Un + c + this.columnSpacing);
                f.os.eu = Math.min(f.os.eu, u);
              }
            h = a.zh + 1;
          } while (l < t.length && h < t[l].length && a.os === t[l][h].os);
        }
      }
      const n = new GMap2();
      for (const o of t)
        for (const r of o) {
          r.pe = r.pe + r.os.eu + r.Un;
          const l = s ? r.width : r.height;
          n.add(r, e ? -r.pe - l : r.pe);
        }
      return n;
    }
    A3(t, i, e) {
      const s = this.C === 90 || this.C === 270;
      for (const n of t)
        for (const o of n)
          if (o.nf === o) {
            let r = 0, l = o;
            for (; l.Kn !== o; ) {
              const h = l.Kn, a = s ? l.width : l.height, f = s ? h.width : h.height;
              let c, u, d, m;
              i ? (d = l.getDestinationEdge(h), c = d.portFromPos, u = d.portToPos, d.link !== null && (l.node && l.node !== d.link.fromNode && (c = s ? l.focusX : l.focusY), h.node && h.node !== d.link.toNode && (u = s ? h.focusX : h.focusY)), e ? m = l.Un + (a - c) - (f - u) : m = l.Un + c - u) : (d = h.getDestinationEdge(l), c = d.portToPos, u = d.portFromPos, d.link !== null && (l.node && l.node !== d.link.toNode && (c = s ? l.focusX : l.focusY), h.node && h.node !== d.link.fromNode && (u = s ? h.focusX : h.focusY)), e ? m = l.Un + (a - c) - (f - u) : m = l.Un + c - u), h.Un = m, r = Math.min(r, m), l = l.Kn;
            }
            l = o;
            do
              l.Un = l.Un - r, l = l.Kn;
            while (l !== o);
          }
    }
    gD(t, i) {
      if (!isNaN(t.pe))
        return;
      t.pe = 0;
      let e = t;
      do {
        if (e.zh > 0) {
          const s = this.mD(e, i), n = s.nf;
          this.gD(n, i), t.os === t && (t.os = n.os);
          const o = this.C === 90 || this.C === 270 ? s.width : s.height;
          if (t.os === n.os) {
            const r = n.pe + s.Un + o - e.Un + this.columnSpacing;
            t.pe = Math.max(t.pe, r);
          }
        }
        e = e.Kn;
      } while (e !== t);
      for (; e.Kn !== t; )
        e = e.Kn, e.pe = t.pe, e.os = t.os;
    }
    mD(t, i) {
      const e = t.dD, s = t.zh;
      return s < 1 && Util.n("Could not determine previous vertex in layer"), i[e][s - 1];
    }
    P3(...t) {
      let i = -1;
      const e = Util.ct(), s = Util.ct();
      let n = 1 / 0;
      for (let o = 0; o < 4; o++) {
        if (!t[o])
          continue;
        const r = this.L3(t[o], e, s, o);
        r < n && (i = o, n = r);
      }
      for (let o = 0; o < 4; o++) {
        const r = t[o];
        if (!r)
          continue;
        const l = o === 0 || o === 2 ? e[i] - e[o] : s[i] - s[o];
        l !== 0 && r.each((h) => {
          r.set(h.key, h.value + l);
        });
      }
      Util.ot(e), Util.ot(s);
    }
    L3(t, i, e, s) {
      if (!t || t.count === 0)
        return i[s] = 0, e[s] = 0, 1 / 0;
      let n = 1 / 0, o = -1 / 0;
      return t.each((r) => {
        const l = r.key, h = r.value, a = this.C === 90 || this.C === 270 ? l.width : l.height;
        h < n && (n = h), h + a > o && (o = h + a);
      }), i[s] = n, e[s] = o, o - n;
    }
    commitLayout() {
      this.qy(), this.commitNodes(), this.HN(), this.isRouting && this.commitLinks();
    }
    qy() {
      if (!this.setsPortSpots)
        return;
      const t = this.rk(true), i = this.rk(false), e = this.network.edges.iterator;
      for (; e.next(); ) {
        const n = e.value.link;
        n !== null && (n.fromSpot = t, n.toSpot = i);
      }
    }
    rk(t) {
      return this.C === 270 ? t ? Spot2.MiddleTop : Spot2.MiddleBottom : this.C === 90 ? t ? Spot2.MiddleBottom : Spot2.MiddleTop : this.C === 180 ? t ? Spot2.MiddleLeft : Spot2.MiddleRight : t ? Spot2.MiddleRight : Spot2.MiddleLeft;
    }
    commitNodes() {
      this.on = [], this.Rs = [], this.Is = [], this.Gt = [];
      for (let d = 0; d <= this.Lt; d++)
        this.on[d] = 0, this.Rs[d] = 0, this.Is[d] = 0, this.Gt[d] = 0;
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const d = t.value, m = d.layer;
        this.on[m] = Math.max(this.on[m], this.nodeMinLayerSpace(d, true)), this.Rs[m] = Math.max(this.Rs[m], this.nodeMinLayerSpace(d, false));
      }
      let i = 0;
      const e = this.Ds;
      for (let d = 0; d <= this.Lt; d++) {
        let m = e;
        this.on[d] + this.Rs[d] <= 0 && (m = 0), d > 0 && (i += m / 2), this.C === 90 || this.C === 0 ? (i += this.Rs[d], this.Is[d] = i, i += this.on[d]) : (i += this.on[d], this.Is[d] = i, i += this.Rs[d]), d < this.Lt && (i += m / 2), this.Gt[d] = i;
      }
      const s = i, n = this.arrangementOrigin;
      for (let d = 0; d <= this.Lt; d++)
        this.C === 270 ? this.Is[d] = n.y + this.Is[d] : this.C === 90 ? (this.Is[d] = n.y + s - this.Is[d], this.Gt[d] = s - this.Gt[d]) : this.C === 180 ? this.Is[d] = n.x + this.Is[d] : (this.Is[d] = n.x + s - this.Is[d], this.Gt[d] = s - this.Gt[d]);
      const o = this.Yn !== 0;
      t.reset();
      const r = this.C === 270 || this.C === 90;
      let l = 1 / 0, h = 1 / 0, a = 1 / 0, f = -1 / 0;
      for (; t.next(); ) {
        const d = t.value, m = d.layer, g = d.column | 0;
        let p = 0, y = 0;
        r ? (p = n.x + this.te * g, y = this.Is[m]) : (p = this.Is[m], y = n.y + this.te * g), d.centerX = p, d.centerY = y, o && isFinite(d.pe) && (r ? d.node ? d.x = n.x + d.pe : d.centerX = n.x + d.pe : d.node ? d.y = n.y + d.pe : d.centerY = n.y + d.pe), l = Math.min(d.x, l), h = Math.min(d.y, h), r ? (a = l, f = Math.max(f, d.bounds.right)) : (a = h, f = Math.max(f, d.bounds.bottom));
      }
      this.YN = f - a;
      const c = n.x - l, u = n.y - h;
      for (this.ur = new Point2(o && r ? 0 : c, o && !r ? 0 : u), t.reset(); t.next(); ) {
        const d = t.value;
        d.x += c, d.y += u, d.commit();
      }
    }
    HN() {
      let t = 0;
      const i = this.Ds;
      for (let n = 0; n <= this.Lt; n++)
        t += this.on[n], t += this.Rs[n];
      t += this.Lt * i;
      const e = [], s = this.Yn !== 0 ? this.YN : this.te * this.Wt;
      for (let n = this.maxLayer; n >= 0; n--)
        this.C === 270 ? n === 0 ? e.push(new Rect2(0, 0, s, Math.abs(this.Gt[0]))) : e.push(new Rect2(0, this.Gt[n - 1], s, Math.abs(this.Gt[n - 1] - this.Gt[n]))) : this.C === 90 ? n === 0 ? e.push(new Rect2(0, this.Gt[0], s, Math.abs(this.Gt[0] - t))) : e.push(new Rect2(0, this.Gt[n], s, Math.abs(this.Gt[n - 1] - this.Gt[n]))) : this.C === 180 ? n === 0 ? e.push(new Rect2(0, 0, Math.abs(this.Gt[0]), s)) : e.push(new Rect2(this.Gt[n - 1], 0, Math.abs(this.Gt[n - 1] - this.Gt[n]), s)) : n === 0 ? e.push(new Rect2(this.Gt[0], 0, Math.abs(this.Gt[0] - t), s)) : e.push(new Rect2(this.Gt[n], 0, Math.abs(this.Gt[n - 1] - this.Gt[n]), s));
      this.commitLayers(e, this.ur);
    }
    commitLayers(t, i) {
    }
    commitLinks() {
      const t = this.network.edges.iterator;
      let i;
      for (; t.next(); )
        i = t.value.link, i !== null && (i.startRoute(), i.clearPoints(), i.commitRoute());
      for (t.reset(); t.next(); )
        i = t.value.link, i !== null && i.updateRoute();
      for (t.reset(); t.next(); ) {
        const e = t.value;
        if (i = e.link, i === null || i.pointsCount === 0)
          continue;
        i.startRoute();
        const s = i;
        let n = s.fromNode, o = s.toNode, r = s.fromPort, l = s.toPort;
        if (n !== null) {
          const N = n.findVisibleNode();
          N !== null && N !== n && (n = N, r = N.port);
        }
        if (o !== null) {
          const N = o.findVisibleNode();
          N !== null && N !== o && (o = N, l = N.port);
        }
        const h = i.computeSpot(true, r), a = i.computeSpot(false, l);
        let f = e.fromVertex, c = e.toVertex;
        if (e.valid) {
          if (i.curve === 9 && i.pointsCount === 4)
            if (f.column === c.column && this.alignOption === 0) {
              const N = i.getLinkPoint(n, r, h, true, false, o, l), T = i.getLinkPoint(o, l, a, false, false, n, r);
              N.isReal() || N.set(n.actualBounds.center), T.isReal() || T.set(o.actualBounds.center), i.clearPoints(), i.addPointAt(N.x, N.y), i.addPointAt((2 * N.x + T.x) / 3, (2 * N.y + T.y) / 3), i.addPointAt((N.x + 2 * T.x) / 3, (N.y + 2 * T.y) / 3), i.addPointAt(T.x, T.y);
            } else {
              let N = false, T = false;
              if (r !== null && h === Spot2.None && (N = true), l !== null && a === Spot2.None && (T = true), N || T) {
                let L = null;
                N && (L = i.getLinkPointFromPoint(n, r, r.getDocumentPoint(Spot2.Center), i.getPoint(3), true), L.isReal() || L.set(n.actualBounds.center), i.setPointAt(0, L.x, L.y));
                let D = null;
                if (T && (D = i.getLinkPointFromPoint(o, l, l.getDocumentPoint(Spot2.Center), i.getPoint(0), false), D.isReal() || D.set(o.actualBounds.center), i.setPointAt(3, D.x, D.y)), L) {
                  const F = i.getPoint(2);
                  i.setPointAt(1, (L.x * 2 + F.x) / 3, (L.y * 2 + F.y) / 3);
                }
                if (D) {
                  const F = i.getPoint(1);
                  i.setPointAt(2, (D.x * 2 + F.x) / 3, (D.y * 2 + F.y) / 3);
                }
              }
            }
          i.commitRoute();
          continue;
        }
        if (f.layer === c.layer) {
          i.commitRoute();
          continue;
        }
        let u = false, d = false;
        const m = this.Ds;
        let g = 0, p = i.firstPickIndex + 1;
        if (i.isOrthogonal)
          d = true, g = i.pointsCount, g > 4 && i.points.removeRange(2, g - 3);
        else if (i.curve === 9)
          u = true, g = i.pointsCount, g > 4 && i.points.removeRange(2, g - 3), g === 4 && (p = 2);
        else {
          g = i.pointsCount;
          const N = h === Spot2.None, T = a === Spot2.None;
          g > 2 && N && T ? i.points.removeRange(1, g - 2) : g > 3 && N && !T ? i.points.removeRange(1, g - 3) : g > 3 && !N && T ? i.points.removeRange(2, g - 2) : g > 4 && !N && !T && i.points.removeRange(2, g - 3);
        }
        let y, x, b = 0, k = 0, S = 0, M = 0, A = 0, C = 0, P = 0;
        if (e.rev) {
          let N = 0;
          for (; c !== null && f !== c; ) {
            y = null, x = null;
            const T = c.sourceEdges.iterator;
            for (; T.next(); ) {
              const L = T.value;
              if (L.link === e.link && (y = L.fromVertex, x = L.toVertex, y.node === null))
                break;
            }
            if (y === null)
              break;
            if (y !== f)
              if (b = i.getPoint(p - 1).x, k = i.getPoint(p - 1).y, S = y.centerX, M = y.centerY, d)
                this.C === 180 || this.C === 0 ? p === i.firstPickIndex + 1 ? (i.insertPointAt(p++, b, k), i.insertPointAt(p++, b, M)) : (x !== null ? x.centerY : k) !== M && (A = this.Gt[y.layer - 1] + this.ur.x, i.insertPointAt(p++, A, k), i.insertPointAt(p++, A, M)) : p === i.firstPickIndex + 1 ? (i.insertPointAt(p++, b, k), i.insertPointAt(p++, S, k)) : (x !== null ? x.centerX : b) !== S && (A = this.Gt[y.layer - 1] + this.ur.y, i.insertPointAt(p++, b, A), i.insertPointAt(p++, S, A));
              else if (p === i.firstPickIndex + 1)
                if (C = Math.max(10, this.on[c.layer]), P = Math.max(10, this.Rs[c.layer]), u)
                  this.C === 180 ? S <= c.bounds.x ? (N = c.bounds.x, i.insertPointAt(p++, N - C, M), i.insertPointAt(p++, N, M), i.insertPointAt(p++, N + P, M)) : (i.insertPointAt(p++, S - C, M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S + P, M)) : this.C === 90 ? M >= c.bounds.bottom ? (N = c.bounds.y + c.bounds.height, i.insertPointAt(p++, S, N + P), i.insertPointAt(p++, S, N), i.insertPointAt(p++, S, N - C)) : (i.insertPointAt(p++, S, M + P), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, M - C)) : this.C === 270 ? M <= c.bounds.y ? (N = c.bounds.y, i.insertPointAt(p++, S, N - C), i.insertPointAt(p++, S, N), i.insertPointAt(p++, S, N + P)) : (i.insertPointAt(p++, S, M - C), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, M + P)) : this.C === 0 && (S >= c.bounds.right ? (N = c.bounds.x + c.bounds.width, i.insertPointAt(p++, N + P, M), i.insertPointAt(p++, N, M), i.insertPointAt(p++, N - C, M)) : (i.insertPointAt(p++, S + P, M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S - C, M)));
                else {
                  i.insertPointAt(p++, b, k);
                  let L = 0;
                  this.C === 180 || this.C === 0 ? ((this.C === 180 ? S >= c.bounds.right : S <= c.bounds.x) && (L = (this.C === 0 ? -C : P) / 2), i.insertPointAt(p++, b + L, M)) : ((this.C === 270 ? M >= c.bounds.bottom : M <= c.bounds.y) && (L = (this.C === 90 ? -C : P) / 2), i.insertPointAt(p++, S, k + L)), i.insertPointAt(p++, S, M);
                }
              else
                C = Math.max(10, this.on[y.layer]), P = Math.max(10, this.Rs[y.layer]), u ? this.C === 180 ? (i.insertPointAt(p++, S - C - m, M), i.insertPointAt(p++, Math.min(S - C + m / 2, S), M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, Math.max(S + P - m / 2, S), M), i.insertPointAt(p++, S + P + m, M)) : this.C === 90 ? (i.insertPointAt(p++, S, M + P + m), i.insertPointAt(p++, S, Math.max(M + P - m / 2, M)), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, Math.min(M - C + m / 2, M)), i.insertPointAt(p++, S, M - C - m)) : this.C === 270 ? (i.insertPointAt(p++, S, M - C - m), i.insertPointAt(p++, S, Math.min(M - C + m / 2, M)), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, Math.max(M + P - m / 2, M)), i.insertPointAt(p++, S, M + P + m)) : (i.insertPointAt(p++, S + P + m, M), i.insertPointAt(p++, Math.max(S + P - m / 2, S), M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, Math.min(S - C + m / 2, S), M), i.insertPointAt(p++, S - C - m, M)) : (this.C === 180 || this.C === 90 || this.C, i.insertPointAt(p++, S, M));
            c = y;
          }
          if (l === null || h !== Spot2.None || d)
            if (b = i.getPoint(p - 1).x, k = i.getPoint(p - 1).y, S = i.getPoint(p).x, M = i.getPoint(p).y, d) {
              const T = this.Rs[f.layer];
              let L = 0;
              this.C === 180 || this.C === 0 ? (L = k, L >= f.bounds.y && L <= f.bounds.bottom && (this.C === 180 ? S >= f.bounds.x : S <= f.bounds.right) && (N = f.centerX + (this.C === 180 ? -T : T), L < f.bounds.y + f.bounds.height / 2 ? L = f.bounds.y - this.te / 2 : L = f.bounds.bottom + this.te / 2, i.insertPointAt(p++, N, k), i.insertPointAt(p++, N, L)), i.insertPointAt(p++, S, L), i.insertPointAt(p++, S, M)) : (L = b, L >= f.bounds.x && L <= f.bounds.right && (this.C === 270 ? M >= f.bounds.y : M <= f.bounds.bottom) && (N = f.centerY + (this.C === 270 ? -T : T), L < f.bounds.x + f.bounds.width / 2 ? L = f.bounds.x - this.te / 2 : L = f.bounds.right + this.te / 2, i.insertPointAt(p++, b, N), i.insertPointAt(p++, L, N)), i.insertPointAt(p++, L, M), i.insertPointAt(p++, S, M));
            } else if (u)
              C = Math.max(10, this.on[f.layer]), P = Math.max(10, this.Rs[f.layer]), this.C === 180 && S >= f.bounds.x ? (N = f.bounds.x + f.bounds.width, i.setPointAt(p - 2, N, k), i.setPointAt(p - 1, N + P, k)) : this.C === 90 && M <= f.bounds.bottom ? (N = f.bounds.y, i.setPointAt(p - 2, b, N), i.setPointAt(p - 1, b, N - C)) : this.C === 270 && M >= f.bounds.y ? (N = f.bounds.y + f.bounds.height, i.setPointAt(p - 2, b, N), i.setPointAt(p - 1, b, N + P)) : this.C === 0 && S <= f.bounds.right && (N = f.bounds.x, i.setPointAt(p - 2, N, k), i.setPointAt(p - 1, N - C, k));
            else {
              C = Math.max(10, this.on[f.layer]), P = Math.max(10, this.Rs[f.layer]);
              let T = 0;
              this.C === 180 || this.C === 0 ? ((this.C === 180 ? S <= f.bounds.x : S >= f.bounds.right) && (T = (this.C === 0 ? P : -C) / 2), i.insertPointAt(p++, S + T, k)) : ((this.C === 270 ? M <= f.bounds.y : M >= f.bounds.bottom) && (T = (this.C === 90 ? P : -C) / 2), i.insertPointAt(p++, b, M + T)), i.insertPointAt(p++, S, M);
            }
        } else {
          for (; f !== null && f !== c; ) {
            y = null, x = null;
            const N = f.destinationEdges.iterator;
            for (; N.next(); ) {
              const T = N.value;
              if (T.link === e.link && (y = T.toVertex, x = T.fromVertex, x.node !== null && (x = null), y.node === null))
                break;
            }
            if (y === null)
              break;
            y !== c && (b = i.getPoint(p - 1).x, k = i.getPoint(p - 1).y, S = y.centerX, M = y.centerY, d ? this.C === 180 || this.C === 0 ? (x !== null ? x.centerY : k) !== M && (A = this.Gt[y.layer] + this.ur.x, p === i.firstPickIndex + 1 && (this.C === 0 ? A = Math.max(A, b) : A = Math.min(A, b)), i.insertPointAt(p++, A, k), i.insertPointAt(p++, A, M)) : (x !== null ? x.centerX : b) !== S && (A = this.Gt[y.layer] + this.ur.y, p === i.firstPickIndex + 1 && (this.C === 90 ? A = Math.max(A, k) : A = Math.min(A, k)), i.insertPointAt(p++, b, A), i.insertPointAt(p++, S, A)) : (C = Math.max(10, this.on[y.layer]), P = Math.max(10, this.Rs[y.layer]), u ? this.C === 180 ? (i.insertPointAt(p++, S + P + m, M), i.insertPointAt(p++, Math.max(S + P - m / 2, S), M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, Math.min(S - C + m / 2, S), M), i.insertPointAt(p++, S - C - m, M)) : this.C === 90 ? (i.insertPointAt(p++, S, M - C - m), i.insertPointAt(p++, S, Math.min(M - C + m / 2, M)), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, Math.max(M + P - m / 2, M)), i.insertPointAt(p++, S, M + P + m)) : this.C === 270 ? (i.insertPointAt(p++, S, M + P + m), i.insertPointAt(p++, S, Math.max(M + P - m / 2, M)), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, Math.min(M - C + m / 2, M)), i.insertPointAt(p++, S, M - C - m)) : (i.insertPointAt(p++, S - C - m, M), i.insertPointAt(p++, Math.min(S - C + m / 2, S), M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, S, M), i.insertPointAt(p++, Math.max(S + P - m / 2, S), M), i.insertPointAt(p++, S + P + m, M)) : this.C === 180 ? (i.insertPointAt(p++, S + P, M), i.insertPointAt(p++, S - C, M)) : this.C === 90 ? (i.insertPointAt(p++, S, M - C), i.insertPointAt(p++, S, M + P)) : this.C === 270 ? (i.insertPointAt(p++, S, M + P), i.insertPointAt(p++, S, M - C)) : (i.insertPointAt(p++, S - C, M), i.insertPointAt(p++, S + P, M)))), f = y;
          }
          d && (b = i.getPoint(p - 1).x, k = i.getPoint(p - 1).y, S = i.getPoint(p).x, M = i.getPoint(p).y, this.C === 180 || this.C === 0 ? k !== M && (this.C === 0 ? A = Math.min(Math.max((S + b) / 2, this.Gt[c.layer] + this.ur.x), S) : A = Math.max(Math.min((S + b) / 2, this.Gt[c.layer] + this.ur.x), S), i.insertPointAt(p++, A, k), i.insertPointAt(p++, A, M)) : b !== S && (this.C === 90 ? A = Math.min(Math.max((M + k) / 2, this.Gt[c.layer] + this.ur.y), M) : A = Math.max(Math.min((M + k) / 2, this.Gt[c.layer] + this.ur.y), M), i.insertPointAt(p++, b, A), i.insertPointAt(p++, S, A)));
        }
        if (s !== null && u && i.pointsCount >= 4) {
          if (r !== null) {
            const N = h === Spot2.None ? i.getLinkPointFromPoint(n, r, r.getDocumentPoint(Spot2.Center), i.getPoint(3), true) : i.getPoint(0);
            if (h === Spot2.None) {
              const T = i.getPoint(2), L = i.getPoint(3);
              this.direction === 90 || this.direction === 270 ? (i.setPointAt(1, (N.x + T.x) / 2, T.y), i.setPointAt(2, L.x, (T.y + L.y) / 2)) : (i.setPointAt(1, T.x, (N.y + T.y) / 2), i.setPointAt(2, (T.x + L.x) / 2, L.y));
            }
            N.isReal() || N.set(n.actualBounds.center), i.setPointAt(0, N.x, N.y);
          }
          if (l !== null) {
            const N = a === Spot2.None ? i.getLinkPointFromPoint(o, l, l.getDocumentPoint(Spot2.Center), i.getPoint(i.pointsCount - 4), false) : i.getPoint(i.pointsCount - 1);
            if (a === Spot2.None) {
              const T = i.getPoint(i.pointsCount - 3), L = i.getPoint(i.pointsCount - 4);
              this.direction === 90 || this.direction === 270 ? (i.setPointAt(i.pointsCount - 2, (N.x + T.x) / 2, T.y), i.setPointAt(i.pointsCount - 2, L.x, (T.y + L.y) / 2)) : (i.setPointAt(i.pointsCount - 2, T.x, (N.y + T.y) / 2), i.setPointAt(i.pointsCount - 3, (T.x + L.x) / 2, L.y));
            }
            N.isReal() || N.set(o.actualBounds.center), i.setPointAt(i.pointsCount - 1, N.x, N.y);
          }
        }
        i.commitRoute(), e.commit();
      }
    }
    ZO() {
      this.Wy = -1, this.Eg = 0, this.Fs = 0, this.sf = null, this.Bg = null, this.tu = null;
      for (let t = 0; t < this.Xn.length; t++)
        this.Xn[t] = null;
    }
    Vh(t) {
      let i;
      const e = this.yi[t];
      if (e >= this.Xn.length) {
        const n = [];
        for (let o = 0; o < this.Xn.length; o++)
          n[o] = this.Xn[o];
        this.Xn = n;
      }
      this.Xn[e] === void 0 || this.Xn[e] === null ? i = [] : (i = this.Xn[e], this.Xn[e] = null);
      const s = this.tu[t];
      for (let n = 0; n < s.length; n++) {
        const o = s[n];
        i[o.index] = o;
      }
      return i;
    }
    Bh(t, i) {
      this.Xn[this.yi[t]] = i;
    }
    get layerSpacing() {
      return this.Ds;
    }
    set layerSpacing(t) {
      this.Ds !== t && (Util.t(t, "number", _LayeredDigraphLayout, "layerSpacing"), t >= 0 && (this.Ds = t, this.invalidateLayout()));
    }
    get columnSpacing() {
      return this.te;
    }
    set columnSpacing(t) {
      this.te !== t && (Util.t(t, "number", _LayeredDigraphLayout, "columnSpacing"), t > 0 && (this.te = t, this.invalidateLayout()));
    }
    get direction() {
      return this.C;
    }
    set direction(t) {
      this.C !== t && (Util.t(t, "number", _LayeredDigraphLayout, "direction"), t === 0 || t === 90 || t === 180 || t === 270 ? (this.C = t, this.invalidateLayout()) : Util.n("LayeredDigraphLayout.direction must be 0, 90, 180, or 270"));
    }
    get cycleRemoveOption() {
      return this.Jc;
    }
    set cycleRemoveOption(t) {
      this.Jc !== t && (Util.it(t, LayeredDigraphCycleRemove2, "LayeredDigraphCycleRemove"), (t === 1 || t === 0 || t === 2) && (this.Jc = t, this.invalidateLayout()));
    }
    get layeringOption() {
      return this.Zc;
    }
    set layeringOption(t) {
      this.Zc !== t && (Util.it(t, LayeredDigraphLayering2, "LayeredDigraphLayering"), (t === 10 || t === 11 || t === 12) && (this.Zc = t, this.invalidateLayout()));
    }
    get initializeOption() {
      return this.$c;
    }
    set initializeOption(t) {
      this.$c !== t && (Util.it(t, LayeredDigraphInit2, "LayeredDigraphInit"), (t === 20 || t === 21 || t === 22) && (this.$c = t, this.invalidateLayout()));
    }
    get iterations() {
      return this.ef;
    }
    set iterations(t) {
      this.ef !== t && (Util.r(t, LayeredDigraphNetwork2, "iterations"), t >= 0 && (this.ef = t, this.invalidateLayout()));
    }
    get aggressiveOption() {
      return this.Qc;
    }
    set aggressiveOption(t) {
      this.Qc !== t && (Util.it(t, LayeredDigraphAggressive2, "LayeredDigraphAggressive"), (t === 30 || t === 31 || t === 32) && (this.Qc = t, this.invalidateLayout()));
    }
    get packOption() {
      return this.cr;
    }
    set packOption(t) {
      this.cr !== t && (Util.t(t, "number", _LayeredDigraphLayout, "packOption"), t >= 0 && t < 8 && (this.cr = t, this.invalidateLayout()));
    }
    get packIterations() {
      return this._c;
    }
    set packIterations(t) {
      this._c = t;
    }
    get alignOption() {
      return this.Yn;
    }
    set alignOption(t) {
      this.Yn !== t && (Util.t(t, "number", _LayeredDigraphLayout, "align"), t >= 0 && t < 16 && (this.Yn = t, this.invalidateLayout()));
    }
    get setsPortSpots() {
      return this.zn;
    }
    set setsPortSpots(t) {
      this.zn !== t && (Util.t(t, "boolean", _LayeredDigraphLayout, "setsPortSpots"), this.zn = t, this.invalidateLayout());
    }
    get maxLayer() {
      return this.Lt;
    }
    get maxIndex() {
      return this.Wy;
    }
    get maxColumn() {
      return this.Wt;
    }
    get minIndexLayer() {
      return this.Eg;
    }
    get maxIndexLayer() {
      return this.Fs;
    }
  };
  __publicField(_LayeredDigraphLayout, "CycleDepthFirst", 0);
  __publicField(_LayeredDigraphLayout, "CycleGreedy", 1);
  __publicField(_LayeredDigraphLayout, "CycleFromLayers", 2);
  __publicField(_LayeredDigraphLayout, "LayerOptimalLinkLength", 10);
  __publicField(_LayeredDigraphLayout, "LayerLongestPathSink", 11);
  __publicField(_LayeredDigraphLayout, "LayerLongestPathSource", 12);
  __publicField(_LayeredDigraphLayout, "InitDepthFirstOut", 20);
  __publicField(_LayeredDigraphLayout, "InitDepthFirstIn", 21);
  __publicField(_LayeredDigraphLayout, "InitNaive", 22);
  __publicField(_LayeredDigraphLayout, "AggressiveNone", 30);
  __publicField(_LayeredDigraphLayout, "AggressiveLess", 31);
  __publicField(_LayeredDigraphLayout, "AggressiveMore", 32);
  __publicField(_LayeredDigraphLayout, "PackNone", 0);
  __publicField(_LayeredDigraphLayout, "PackExpand", 1);
  __publicField(_LayeredDigraphLayout, "PackStraighten", 2);
  __publicField(_LayeredDigraphLayout, "PackMedian", 4);
  __publicField(_LayeredDigraphLayout, "PackAll", 15);
  __publicField(_LayeredDigraphLayout, "AlignNone", 0);
  __publicField(_LayeredDigraphLayout, "AlignUpperLeft", 1);
  __publicField(_LayeredDigraphLayout, "AlignUpperRight", 2);
  __publicField(_LayeredDigraphLayout, "AlignLowerLeft", 4);
  __publicField(_LayeredDigraphLayout, "AlignLowerRight", 8);
  __publicField(_LayeredDigraphLayout, "AlignAll", 15);
  let LayeredDigraphLayout2 = _LayeredDigraphLayout;
  class SegInfo {
    constructor() {
      __publicField(this, "ir");
      __publicField(this, "T3");
      __publicField(this, "b1");
      __publicField(this, "D3");
      __publicField(this, "F3");
      __publicField(this, "Vt");
      __publicField(this, "_e");
      __publicField(this, "R3");
      this.ir = 0, this.T3 = 0, this.b1 = 0, this.D3 = 0, this.F3 = 0, this.Vt = 0, this._e = null, this.R3 = 0;
    }
  }
  class LayeredDigraphNetwork2 extends LayoutNetwork2 {
    constructor(t) {
      super(t);
    }
    createVertex() {
      return new LayeredDigraphVertex2(this);
    }
    createEdge() {
      return new LayeredDigraphEdge2(this);
    }
  }
  class LayeredDigraphVertex2 extends LayoutVertex2 {
    constructor(t) {
      super(t);
      __publicField(this, "ir");
      __publicField(this, "vo");
      __publicField(this, "Vt");
      __publicField(this, "ak");
      __publicField(this, "fk");
      __publicField(this, "ee");
      __publicField(this, "iu");
      __publicField(this, "Qn");
      __publicField(this, "ok");
      __publicField(this, "ek");
      __publicField(this, "sk");
      __publicField(this, "nf");
      __publicField(this, "Kn");
      __publicField(this, "dD");
      __publicField(this, "zh");
      __publicField(this, "os");
      __publicField(this, "eu");
      __publicField(this, "pe");
      __publicField(this, "Un");
      __publicField(this, "$y", null);
      __publicField(this, "Qy", null);
      __publicField(this, "_y", null);
      __publicField(this, "tw", null);
      this.ir = -1, this.vo = -1, this.Vt = -1, this.ak = NaN, this.fk = null, this.ee = false, this.iu = NaN, this.Qn = NaN, this.ok = 0, this.ek = null, this.sk = null;
    }
    static pD(t, i) {
      return t.index - i.index;
    }
    getProperSourceEdges() {
      if (!this._y) {
        const t = [];
        for (const i of this.Mo) {
          const e = i;
          e.valid && t.push(e);
        }
        this._y = t;
      }
      return this._y;
    }
    getProperDestinationEdges() {
      if (!this.tw) {
        const t = [];
        for (const i of this.hr) {
          const e = i;
          e.valid && t.push(e);
        }
        this.tw = t;
      }
      return this.tw;
    }
    getDestinationEdge(t) {
      const i = this.getProperDestinationEdges();
      for (const e of i)
        if (e.toVertex === t)
          return e;
      Util.n("Unable to find destination edge to given vertex");
    }
    getProperSourceVertexes() {
      if (!this.$y) {
        const t = [];
        for (const i of this.Mo) {
          const e = i;
          !e.valid || e.fromVertex.layer <= e.toVertex.layer || t.push(e.fromVertex);
        }
        t.sort(LayeredDigraphVertex2.pD), this.$y = t;
      }
      return this.$y;
    }
    getProperDestinationVertexes() {
      if (!this.Qy) {
        const t = [];
        for (const i of this.hr) {
          const e = i;
          !e.valid || e.fromVertex.layer <= e.toVertex.layer || t.push(e.toVertex);
        }
        t.sort(LayeredDigraphVertex2.pD), this.Qy = t;
      }
      return this.Qy;
    }
    addSourceEdge(t) {
      super.addSourceEdge(t), this.$y = null, this._y = null;
    }
    deleteSourceEdge(t) {
      super.deleteSourceEdge(t), this.$y = null, this._y = null;
    }
    addDestinationEdge(t) {
      super.addDestinationEdge(t), this.Qy = null, this.tw = null;
    }
    deleteDestinationEdge(t) {
      super.deleteDestinationEdge(t), this.Qy = null, this.tw = null;
    }
    get layer() {
      return this.ir;
    }
    set layer(t) {
      this.ir !== t && (Util.t(t, "number", LayeredDigraphVertex2, "layer"), this.ir = t);
    }
    get column() {
      return this.vo;
    }
    set column(t) {
      this.vo !== t && (Util.t(t, "number", LayeredDigraphVertex2, "column"), this.vo = t);
    }
    get index() {
      return this.Vt;
    }
    set index(t) {
      this.Vt !== t && (Util.t(t, "number", LayeredDigraphVertex2, "index"), this.Vt = t);
    }
    get component() {
      return this.ak;
    }
    set component(t) {
      this.ak !== t && (Util.t(t, "number", LayeredDigraphVertex2, "component"), this.ak = t);
    }
    get near() {
      return this.fk;
    }
    set near(t) {
      this.fk !== t && (Debug && t !== null && Util.s(t, LayeredDigraphVertex2, LayeredDigraphVertex2, "near"), this.fk = t);
    }
  }
  class LayeredDigraphEdge2 extends LayoutEdge2 {
    constructor(t) {
      super(t);
      __publicField(this, "ee");
      __publicField(this, "ck");
      __publicField(this, "uk");
      __publicField(this, "dk");
      __publicField(this, "gk");
      __publicField(this, "mk");
      __publicField(this, "pk");
      this.ee = false, this.ck = false, this.uk = false, this.dk = NaN, this.gk = NaN, this.mk = 0, this.pk = 0;
    }
    get fromVertex() {
      return this.is;
    }
    set fromVertex(t) {
      this.is !== t && (Debug && t !== null && Util.s(t, LayeredDigraphVertex2, LayeredDigraphEdge2, "fromVertex"), this.is = t);
    }
    get toVertex() {
      return this.es;
    }
    set toVertex(t) {
      this.es !== t && (Debug && t !== null && Util.s(t, LayeredDigraphVertex2, LayeredDigraphEdge2, "toVertex"), this.es = t);
    }
    get valid() {
      return this.ee;
    }
    set valid(t) {
      this.ee !== t && (Util.t(t, "boolean", LayeredDigraphEdge2, "valid"), this.ee = t);
    }
    get rev() {
      return this.ck;
    }
    set rev(t) {
      this.ck !== t && (Util.t(t, "boolean", LayeredDigraphEdge2, "rev"), this.ck = t);
    }
    get forest() {
      return this.uk;
    }
    set forest(t) {
      this.uk !== t && (Util.t(t, "boolean", LayeredDigraphEdge2, "forest"), this.uk = t);
    }
    get portFromPos() {
      return this.dk;
    }
    set portFromPos(t) {
      this.dk !== t && (Util.t(t, "number", LayeredDigraphEdge2, "portFromPos"), this.dk = t);
    }
    get portToPos() {
      return this.gk;
    }
    set portToPos(t) {
      this.gk !== t && (Util.t(t, "number", LayeredDigraphEdge2, "portToPos"), this.gk = t);
    }
    get portFromColOffset() {
      return this.mk;
    }
    set portFromColOffset(t) {
      this.mk !== t && (Util.t(t, "number", LayeredDigraphEdge2, "portFromColOffset"), this.mk = t);
    }
    get portToColOffset() {
      return this.pk;
    }
    set portToColOffset(t) {
      this.pk !== t && (Util.t(t, "number", LayeredDigraphEdge2, "portToColOffset"), this.pk = t);
    }
  }
  var TreePath2 = ((w) => (w[w.Default = 0] = "Default", w[w.Destination = 1] = "Destination", w[w.Source = 2] = "Source", w))(TreePath2 || {}), TreeSorting2 = ((w) => (w[w.Forwards = 10] = "Forwards", w[w.Reverse = 11] = "Reverse", w[w.Ascending = 12] = "Ascending", w[w.Descending = 13] = "Descending", w))(TreeSorting2 || {}), TreeAlignment2 = ((w) => (w[w.CenterSubtrees = 20] = "CenterSubtrees", w[w.CenterChildren = 21] = "CenterChildren", w[w.Start = 22] = "Start", w[w.End = 23] = "End", w[w.Bus = 24] = "Bus", w[w.BusBranching = 25] = "BusBranching", w[w.TopLeftBus = 26] = "TopLeftBus", w[w.BottomRightBus = 27] = "BottomRightBus", w[w.Custom = 28] = "Custom", w))(TreeAlignment2 || {}), TreeCompaction2 = ((w) => (w[w.None = 30] = "None", w[w.Block = 31] = "Block", w))(TreeCompaction2 || {}), TreeStyle2 = ((w) => (w[w.Layered = 40] = "Layered", w[w.LastParents = 41] = "LastParents", w[w.Alternating = 42] = "Alternating", w[w.RootOnly = 43] = "RootOnly", w))(TreeStyle2 || {}), TreeArrangement2 = ((w) => (w[w.Vertical = 50] = "Vertical", w[w.Horizontal = 51] = "Horizontal", w[w.FixedRoots = 52] = "FixedRoots", w))(TreeArrangement2 || {}), TreeLayerStyle2 = ((w) => (w[w.Individual = 60] = "Individual", w[w.Siblings = 61] = "Siblings", w[w.Uniform = 62] = "Uniform", w))(TreeLayerStyle2 || {});
  const _TreeLayout = class _TreeLayout extends Layout2 {
    constructor(t) {
      super();
      __publicField(this, "Vi");
      __publicField(this, "Oi");
      __publicField(this, "su");
      __publicField(this, "Xg");
      __publicField(this, "vN");
      __publicField(this, "Ye");
      __publicField(this, "vi");
      __publicField(this, "Ts");
      __publicField(this, "K");
      __publicField(this, "U");
      __publicField(this, "yk");
      __publicField(this, "ms");
      this.Vi = new GSet2(), this.Oi = 0, this.ms = 1, this.su = 40, this.Xg = 60, this.vN = [], this.Ye = true, this.vi = 50, this.Ts = new Size2(10, 10).w();
      const i = new TreeNetwork2(this);
      this.K = new TreeVertex2(i), this.U = new TreeVertex2(i), this.yk = [], t && Object.assign(this, t);
    }
    cloneProtected(t) {
      super.cloneProtected(t), t.Oi = this.Oi, t.su = this.su, t.Xg = this.Xg, t.Ye = this.Ye, t.vi = this.vi, t.Ts.c(this.Ts), t.K.copyInheritedPropertiesFrom(this.K), t.U.copyInheritedPropertiesFrom(this.U);
    }
    ci(t) {
      t in TreeAlignment2 ? this.alignment = t : t in TreeArrangement2 ? this.arrangement = t : t in TreeCompaction2 ? this.compaction = t : t in TreePath2 ? this.path = t : t in TreeSorting2 ? this.sorting = t : t in TreeStyle2 ? this.treeStyle = t : super.ci(t);
    }
    createNetwork() {
      return new TreeNetwork2(this);
    }
    makeNetwork(t) {
      const i = this.createNetwork(), e = (s) => {
        if (s instanceof Node2)
          return !s.isLinkLabel && s.category !== "Comment";
        if (s instanceof Link2) {
          const n = s.fromNode;
          if (n === null || n.isLinkLabel || n.category === "Comment")
            return false;
          const o = s.toNode;
          return !(o === null || o.isLinkLabel || o.category === "Comment");
        }
        return false;
      };
      return t instanceof Diagram2 ? (i.addParts(t.nodes, true, e), i.addParts(t.links, true, e)) : t instanceof Group2 ? i.addParts(t.memberParts, false, e) : i.addParts(t.iterator, false, e), i;
    }
    doLayout(t) {
      Debug && t === null && Util.n("Layout.doLayout(collection) argument must not be null but a Diagram, a Group, or an Iterable of Parts"), this.network === null && (this.network = this.makeNetwork(t)), this.arrangement !== 52 && (this.arrangementOrigin = this.initialOrigin(this.arrangementOrigin));
      let i = this.diagram;
      i === null && t instanceof Diagram2 && (i = t), this.path === 0 && i !== null ? this.ms = i.isTreePathToChildren ? 1 : 2 : this.ms = this.path === 0 ? 1 : this.path, this.network.vertexes.count > 0 && (this.I3(), this.O3(), this.E3(), this.V3(), this.zN(), this.B3(), this.arrangeTrees(), this.updateParts()), this.network = null, this.Vi = new GSet2(), this.isValidLayout = true;
    }
    I3() {
      this.network.deleteSelfEdges();
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const n = t.value;
        n.initialized = false, n.level = 0, n.parent = null, n.children = [];
      }
      if (this.Vi.count > 0) {
        const n = new GSet2(), o = this.Vi.iterator;
        for (; o.next(); ) {
          const r = o.value;
          if (r instanceof Node2) {
            const l = this.network.findVertex(r);
            l !== null && n.add(l);
          } else
            r instanceof TreeVertex2 && n.add(r);
        }
        this.Vi = n;
      }
      this.Vi.count === 0 && this.findRoots();
      const i = this.Vi.copy().iterator;
      for (; i.next(); ) {
        const n = i.value;
        n.initialized || (n.initialized = true, this.qN(n));
      }
      let e = this.network.vertexes, s = null;
      for (; s = this.z3(e), s.count > 0; ) {
        const n = this.yD(s);
        n !== null && this.Vi.add(n), n.initialized = true, this.qN(n), e = s;
      }
    }
    z3(t) {
      const i = new GSet2(), e = t.iterator;
      for (; e.next(); ) {
        const s = e.value;
        s.initialized || i.add(s);
      }
      return i;
    }
    findRoots() {
      const t = this.network.vertexes, i = t.iterator;
      for (; i.next(); ) {
        const e = i.value;
        switch (this.ms) {
          case 1:
            e.sourceEdges.count === 0 && this.Vi.add(e);
            break;
          case 2:
            e.destinationEdges.count === 0 && this.Vi.add(e);
            break;
          default:
            Util.n("Unhandled path value " + this.ms.toString());
        }
      }
      if (this.Vi.count === 0) {
        const e = this.yD(t);
        e !== null && this.Vi.add(e);
      }
    }
    yD(t) {
      let i = 999999, e = null;
      const s = t.iterator;
      for (; s.next(); ) {
        const n = s.value;
        switch (this.ms) {
          case 1:
            n.sourceEdges.count < i && (i = n.sourceEdges.count, e = n);
            break;
          case 2:
            n.destinationEdges.count < i && (i = n.destinationEdges.count, e = n);
            break;
          default:
            Util.n("Unhandled path value " + this.ms.toString());
        }
      }
      return e;
    }
    qN(t) {
      if (t === null)
        return;
      switch (Debug && Util.s(t, TreeVertex2, _TreeLayout, "walkTree:v"), this.ms) {
        case 1:
          if (t.destinationEdges.count > 0) {
            const s = new List2(), n = t.destinationVertexes;
            for (; n.next(); ) {
              const o = n.value;
              this.wD(t, o) && s.add(o);
            }
            s.count > 0 && (t.children = s.toArray());
          }
          break;
        case 2:
          if (t.sourceEdges.count > 0) {
            const s = new List2(), n = t.sourceVertexes;
            for (; n.next(); ) {
              const o = n.value;
              this.wD(t, o) && s.add(o);
            }
            s.count > 0 && (t.children = s.toArray());
          }
          break;
        default:
          Util.n("Unhandled path value" + this.ms.toString());
      }
      const i = t.children, e = i.length;
      for (let s = 0; s < e; s++) {
        const n = i[s];
        n.initialized = true, n.level = t.level + 1, n.parent = t, this.Vi.remove(n);
      }
      for (let s = 0; s < e; s++) {
        const n = i[s];
        this.qN(n);
      }
    }
    wD(t, i) {
      return Debug && Util.s(t, TreeVertex2, _TreeLayout, "walkOK:v"), Debug && Util.s(i, TreeVertex2, _TreeLayout, "walkOK:c"), i.initialized ? this.X3(i, t) || i.level > t.level ? false : (this.Y3(i.parent, i), true) : true;
    }
    X3(t, i) {
      if (i === null)
        return false;
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "isAncestor:a"), Debug && Util.s(i, TreeVertex2, _TreeLayout, "isAncestor:b");
      let e = i.parent;
      for (; e !== null && e !== t; )
        e = e.parent;
      return e === t;
    }
    Y3(t, i) {
      if (t === null || i === null)
        return;
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "removeChild:p"), Debug && Util.s(i, TreeVertex2, _TreeLayout, "removeChild:c");
      const e = t.children;
      let s = 0;
      for (let n = 0; n < e.length; n++)
        e[n] === i && s++;
      if (s > 0) {
        const n = new Array(e.length - s);
        let o = 0;
        for (let r = 0; r < e.length; r++)
          e[r] !== i && (n[o++] = e[r]);
        t.children = n;
      }
    }
    O3() {
      const t = this.Vi.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i instanceof TreeVertex2 && this.xD(i);
      }
    }
    xD(t) {
      if (t === null)
        return;
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "initializeTree:v"), this.initializeTreeVertexValues(t), t.alignment === 25 && this.sortTreeVertexChildren(t);
      let i = 0, e = t.childrenCount, s = 0;
      const n = t.children, o = n.length;
      for (let r = 0; r < o; r++) {
        const l = n[r];
        this.xD(l), i += l.descendantCount + 1, e = Math.max(e, l.maxChildrenCount), s = Math.max(s, l.maxGenerationCount);
      }
      t.descendantCount = i, t.maxChildrenCount = e, t.maxGenerationCount = e > 0 ? s + 1 : 0;
    }
    K3(t) {
      switch (Debug && Util.s(t, TreeVertex2, _TreeLayout, "mom:v"), this.su) {
        default:
        case 40:
          return t.parent !== null ? t.parent : this.K;
        case 43:
          return t.parent === null ? this.K : t.parent.parent === null ? this.U : t.parent;
        case 42:
          return t.parent !== null ? t.parent.parent !== null ? t.parent.parent : this.U : this.K;
        case 41: {
          let i = true;
          if (t.childrenCount === 0)
            i = false;
          else {
            const e = t.children, s = e.length;
            for (let n = 0; n < s; n++)
              if (e[n].childrenCount > 0) {
                i = false;
                break;
              }
          }
          return i && t.parent !== null ? this.U : t.parent !== null ? t.parent : this.K;
        }
      }
    }
    initializeTreeVertexValues(t) {
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "initializeTreeVertexValues:v");
      const i = this.K3(t);
      if (t.copyInheritedPropertiesFrom(i), t.parent !== null && t.parent.alignment === 25) {
        let e = t.angle;
        const s = t.parent.children;
        let n = 0;
        for (; n < s.length && t !== s[n]; )
          n++;
        n % 2 === 0 ? n !== s.length - 1 && (e === 90 ? e = 180 : e === 180 ? e = 270 : e === 270 ? e = 180 : e = 270) : e === 90 ? e = 0 : e === 180 ? e = 90 : e === 270 ? e = 0 : e = 90, t.angle = e;
      }
      t.initialized = true;
    }
    E3() {
      const t = this.Vi.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i instanceof TreeVertex2 && this.bD(i);
      }
    }
    bD(t) {
      if (t === null)
        return;
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "assignTree:v"), this.assignTreeVertexValues(t);
      const i = t.children, e = i.length;
      for (let s = 0; s < e; s++) {
        const n = i[s];
        this.bD(n);
      }
    }
    assignTreeVertexValues(t) {
    }
    V3() {
      const t = this.Vi.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i instanceof TreeVertex2 && this.kD(i);
      }
    }
    kD(t) {
      if (t === null)
        return;
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "sortTree:v"), t.alignment !== 25 && this.sortTreeVertexChildren(t);
      const i = t.children, e = i.length;
      for (let s = 0; s < e; s++) {
        const n = i[s];
        this.kD(n);
      }
    }
    sortTreeVertexChildren(t) {
      switch (Debug && Util.s(t, TreeVertex2, _TreeLayout, "sortTreeVertexChildren:v"), t.sorting) {
        default:
        case 10:
          break;
        case 11:
          t.children.reverse();
          break;
        case 12:
          t.children.sort(t.comparer);
          break;
        case 13:
          t.children.sort(t.comparer), t.children.reverse();
          break;
      }
    }
    zN() {
      if (!this.comments)
        return;
      const t = this.network.vertexes.iterator;
      for (; t.next(); ) {
        const i = t.value;
        this.addComments(i);
      }
    }
    addComments(t) {
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "addComments:v");
      const i = t.angle, e = t.parent;
      let s = 0, n = 21, o = false;
      e !== null && (s = e.angle, n = e.alignment, o = this.isBusAlignment(n));
      const r = i === 90 || i === 270, l = s === 90 || s === 270, h = t.childrenCount === 0;
      let a = 0, f = 0, c = 0;
      const u = t.commentSpacing;
      if (t.node !== null) {
        const d = t.node.findNodesConnected();
        for (; d.next(); ) {
          const m = d.value;
          if (m.category !== "Comment" || !m.canLayout())
            continue;
          t.comments === null && (t.comments = []), t.comments.push(m), m.ensureBounds();
          const g = m.measuredBounds;
          r && !h || !o && !l && h || o && l && h ? (a = Math.max(a, g.width), f += g.height + Math.abs(c)) : (a += g.width + Math.abs(c), f = Math.max(f, g.height)), c = u;
        }
      }
      if (t.comments !== null) {
        r && !h || !o && !l && h || o && l && h ? (a += Math.abs(t.commentMargin), f = Math.max(0, f - t.height)) : (f += Math.abs(t.commentMargin), a = Math.max(0, a - t.width));
        const d = Rect2.H(0, 0, t.bounds.width + a, t.bounds.height + f);
        t.bounds = d, Rect2.o(d);
      }
    }
    isBusAlignment(t) {
      return t === 24 || t === 25 || t === 26 || t === 27;
    }
    iw(t) {
      return t === 24 || t === 25;
    }
    WN(t) {
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "isLeftSideBus:v");
      const i = t.parent;
      if (i !== null) {
        const e = i.alignment;
        if (this.isBusAlignment(e))
          if (this.iw(e)) {
            const s = i.children;
            let n = 0;
            for (; n < s.length && t !== s[n]; )
              n++;
            return n % 2 === 0;
          } else
            return e === 26;
      }
      return false;
    }
    layoutComments(t) {
      if (Debug && Util.s(t, TreeVertex2, _TreeLayout, "layoutComments:v"), t.comments !== null) {
        const e = t.node.measuredBounds, s = t.parent, n = t.angle;
        let o = 0, r = 21, l = false;
        s !== null && (o = s.angle, r = s.alignment, l = this.isBusAlignment(r));
        const h = n === 90 || n === 270, a = o === 90 || o === 270, f = t.childrenCount === 0, c = this.WN(t);
        let u = 0;
        const d = t.comments, m = d.length, g = Point2.a();
        for (let y = 0; y < m; y++) {
          const x = d[y], b = x.measuredBounds;
          if (h && !f || !l && !a && f || l && a && f) {
            if (o > 135 && !l || a && c)
              if (t.commentMargin >= 0) {
                g.e(t.bounds.x - t.commentMargin - b.width, t.bounds.y + u), x.move(g);
                const k = x.findLinksInto();
                for (; k.next(); ) {
                  const S = k.value;
                  S.fromSpot = Spot2.MiddleLeft, S.toSpot = Spot2.MiddleRight;
                }
              } else {
                g.e(t.bounds.x + t.focus.x * 2 - t.commentMargin, t.bounds.y + u), x.move(g);
                const k = x.findLinksInto();
                for (; k.next(); ) {
                  const S = k.value;
                  S.fromSpot = Spot2.MiddleRight, S.toSpot = Spot2.MiddleLeft;
                }
              }
            else if (t.commentMargin >= 0) {
              g.e(t.bounds.x + t.focus.x * 2 + t.commentMargin, t.bounds.y + u), x.move(g);
              const k = x.findLinksInto();
              for (; k.next(); ) {
                const S = k.value;
                S.fromSpot = Spot2.MiddleRight, S.toSpot = Spot2.MiddleLeft;
              }
            } else {
              g.e(t.bounds.x + t.commentMargin - b.width, t.bounds.y + u), x.move(g);
              const k = x.findLinksInto();
              for (; k.next(); ) {
                const S = k.value;
                S.fromSpot = Spot2.MiddleLeft, S.toSpot = Spot2.MiddleRight;
              }
            }
            t.commentSpacing >= 0 ? u += b.height + t.commentSpacing : u += t.commentSpacing - b.height;
          } else {
            if (o > 135 && !l || !a && c)
              if (t.commentMargin >= 0) {
                g.e(t.bounds.x + u, t.bounds.y - t.commentMargin - b.height), x.move(g);
                const k = x.findLinksInto();
                for (; k.next(); ) {
                  const S = k.value;
                  S.fromSpot = Spot2.MiddleTop, S.toSpot = Spot2.MiddleBottom;
                }
              } else {
                g.e(t.bounds.x + u, t.bounds.y + t.focus.y * 2 - t.commentMargin), x.move(g);
                const k = x.findLinksInto();
                for (; k.next(); ) {
                  const S = k.value;
                  S.fromSpot = Spot2.MiddleBottom, S.toSpot = Spot2.MiddleTop;
                }
              }
            else if (t.commentMargin >= 0) {
              g.e(t.bounds.x + u, t.bounds.y + t.focus.y * 2 + t.commentMargin), x.move(g);
              const k = x.findLinksInto();
              for (; k.next(); ) {
                const S = k.value;
                S.fromSpot = Spot2.MiddleBottom, S.toSpot = Spot2.MiddleTop;
              }
            } else {
              g.e(t.bounds.x + u, t.bounds.y + t.commentMargin - b.height), x.move(g);
              const k = x.findLinksInto();
              for (; k.next(); ) {
                const S = k.value;
                S.fromSpot = Spot2.MiddleTop, S.toSpot = Spot2.MiddleBottom;
              }
            }
            t.commentSpacing >= 0 ? u += b.width + t.commentSpacing : u += t.commentSpacing - b.width;
          }
        }
        Point2.o(g);
        const p = u - t.commentSpacing - (h ? e.height : e.width);
        if (this.ms === 1) {
          const y = t.destinationEdges;
          for (; y.next(); ) {
            const b = y.value.link;
            b !== null && !b.isAvoiding && (b.fromEndSegmentLength = p > 0 ? p : NaN);
          }
        } else {
          const y = t.sourceEdges;
          for (; y.next(); ) {
            const b = y.value.link;
            b !== null && !b.isAvoiding && (b.toEndSegmentLength = p > 0 ? p : NaN);
          }
        }
      }
    }
    B3() {
      if (this.layerStyle === 62) {
        const i = [];
        let e = this.network.vertexes.iterator;
        for (; e.next(); ) {
          const s = e.value;
          let n = s.parent;
          n === null && (n = s);
          const o = n.angle === 0 || n.angle === 180;
          let r = i[s.level];
          r === void 0 && (r = 0), i[s.level] = Math.max(r, o ? s.width : s.height);
        }
        for (let s = 0; s < i.length; s++)
          i[s] === void 0 && (i[s] = 0);
        for (this.vN = i, e = this.network.vertexes.iterator; e.next(); ) {
          const s = e.value;
          let n = s.parent;
          n === null && (n = s), n.angle === 0 || n.angle === 180 ? (n.angle === 180 && (s.focusX += i[s.level] - s.width), s.width = i[s.level]) : (n.angle === 270 && (s.focusY += i[s.level] - s.height), s.height = i[s.level]);
        }
      } else if (this.layerStyle === 61) {
        const i = this.network.vertexes.iterator;
        for (; i.next(); ) {
          const e = i.value, s = e.angle === 0 || e.angle === 180;
          let n = -1;
          for (let o = 0; o < e.children.length; o++) {
            const r = e.children[o];
            n = Math.max(n, s ? r.width : r.height);
          }
          if (n >= 0)
            for (let o = 0; o < e.children.length; o++) {
              const r = e.children[o];
              s ? (e.angle === 180 && (r.focusX += n - r.width), r.width = n) : (e.angle === 270 && (r.focusY += n - r.height), r.height = n);
            }
        }
      }
      const t = this.Vi.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i instanceof TreeVertex2 && this.layoutTree(i);
      }
    }
    layoutTree(t) {
      if (t === null)
        return;
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "layoutTree:v");
      const i = t.children, e = i.length;
      for (let s = 0; s < e; s++) {
        const n = i[s];
        this.layoutTree(n);
      }
      switch (t.compaction) {
        case 30:
          this.SD(t);
          break;
        default:
        case 31:
          t.alignment === 25 ? this.SD(t) : this.U3(t);
          break;
      }
    }
    SD(t) {
      if (Debug && Util.s(t, TreeVertex2, _TreeLayout, "layoutTreeNone:v"), t.childrenCount === 0) {
        let R = false, I = 0, O = 21;
        t.parent !== null && (I = t.parent.angle, O = t.parent.alignment, R = this.isBusAlignment(O));
        const B = this.WN(t);
        t.X.e(0, 0), t.kt.e(t.width, t.height), t.parent !== null && t.comments !== null && ((I === 180 || I === 270) && !R || B) ? I === 180 && !R || (I === 90 || I === 270) && B ? t.ht.e(t.width - t.focus.x * 2, 0) : t.ht.e(0, t.height - t.focus.y * 2) : t.ht.e(0, 0);
        return;
      }
      const i = this.orthoAngle(t), e = i === 90 || i === 270;
      let s = 0;
      const n = t.children, o = n.length;
      for (let R = 0; R < o; R++) {
        const I = n[R];
        s = Math.max(s, e ? I.kt.width : I.kt.height);
      }
      const r = t.alignment, l = r === 22, h = r === 23, a = this.isBusAlignment(r), f = Math.max(0, t.breadthLimit), c = this.computeLayerSpacing(t), u = t.nodeSpacing, d = this.computeNodeIndent(t), m = l || h ? 0 : d / 2, g = t.rowSpacing;
      let p = 0;
      (l || h || t.nu || t.ou && t.maxGenerationCount === 1) && (p = Math.max(0, t.rowIndent));
      const y = t.width, x = t.height;
      let b = 0, k = 0, S = 0, M = 0, A = 0, C = 0, P = 0, N = 0, T = 0, L = 0;
      if (a && !this.iw(r) && i > 135 && n.reverse(), this.iw(r))
        if (o > 1)
          for (let R = 0; R < o; R++) {
            const I = n[R], O = I.kt;
            R % 2 === 0 && R !== o - 1 ? T = Math.max(T, (e ? O.width : O.height) + this.computeBusNodeSpacing(I) - u) : R % 2 !== 0 && (L = Math.max(L, (e ? O.width : O.height) + this.computeBusNodeSpacing(I) - u));
          }
        else
          o === 1 && (T = e ? n[0].kt.width : n[0].kt.height);
      if (a)
        switch (r) {
          case 24:
          case 25:
            let R;
            i < 135 ? R = this.MD(t, n, T, L, b, k) : R = this.PD(t, n, T, L, b, k), T = R.x, b = R.width, k = R.height;
            break;
          case 26:
            for (let I = 0; I < o; I++) {
              const O = n[I], B = O.kt, K = P === 0 ? 0 : g;
              e ? (O.X.e(s - B.width, A + K), b = Math.max(b, B.width), k = Math.max(k, A + K + B.height), A += K + B.height) : (O.X.e(M + K, s - B.height), b = Math.max(b, M + K + B.width), k = Math.max(k, B.height), M += K + B.width), P++;
            }
            break;
          case 27:
            for (let I = 0; I < o; I++) {
              const O = n[I], B = O.kt, K = P === 0 ? 0 : g;
              e ? (O.X.e(u / 2 + t.focus.x, A + K), b = Math.max(b, B.width), k = Math.max(k, A + K + B.height), A += K + B.height) : (O.X.e(M + K, u / 2 + t.focus.y), b = Math.max(b, M + K + B.width), k = Math.max(k, B.height), M += K + B.width), P++;
            }
            break;
        }
      else
        for (let R = 0; R < o; R++) {
          const I = n[R], O = I.kt;
          if (e) {
            f > 0 && P > 0 && M + u + O.width > f && (M < s && this.of(t, r, s - M, 0, N, R - 1), C++, P = 0, N = R, S = k, M = 0, A = i > 135 ? -k - g : k + g);
            const B = P === 0 ? m : u;
            this.wk(I, 0, A), I.X.e(M + B, A), b = Math.max(b, M + B + O.width), k = Math.max(k, S + (C === 0 ? 0 : g) + O.height), M += B + O.width;
          } else {
            f > 0 && P > 0 && A + u + O.height > f && (A < s && this.of(t, r, 0, s - A, N, R - 1), C++, P = 0, N = R, S = b, A = 0, M = i > 135 ? -b - g : b + g);
            const B = P === 0 ? m : u;
            this.wk(I, M, 0), I.X.e(M, A + B), k = Math.max(k, A + B + O.height), b = Math.max(b, S + (C === 0 ? 0 : g) + O.width), A += B + O.height;
          }
          P++;
        }
      C > 0 && (e ? (k += Math.max(0, c), M < b && this.of(t, r, b - M, 0, N, o - 1), p > 0 && (h || this.ru(t, p, 0, 0, o - 1), b += p)) : (b += Math.max(0, c), A < k && this.of(t, r, 0, k - A, N, o - 1), p > 0 && (h || this.ru(t, 0, p, 0, o - 1), k += p)));
      let D = 0, F = 0;
      switch (r) {
        case 20:
          e ? D += b / 2 - t.focus.x - d / 2 : F += k / 2 - t.focus.y - d / 2;
          break;
        default:
        case 21:
          if (C > 0)
            e ? D += b / 2 - t.focus.x - d / 2 : F += k / 2 - t.focus.y - d / 2;
          else {
            const I = o;
            if (e) {
              const O = n[0].X.x + n[0].ht.x, B = n[I - 1].X.x + n[I - 1].ht.x + n[I - 1].focus.x * 2;
              D += O + (B - O) / 2 - t.focus.x - d / 2;
            } else {
              const O = n[0].X.y + n[0].ht.y, B = n[I - 1].X.y + n[I - 1].ht.y + n[I - 1].focus.y * 2;
              F += O + (B - O) / 2 - t.focus.y - d / 2;
            }
          }
          break;
        case 22:
          e ? (D -= d, b += d) : (F -= d, k += d);
          break;
        case 23:
          e ? (D += b - t.width + d, b += d) : (F += k - t.height + d, k += d);
          break;
        case 24:
        case 25:
          e ? o > 1 ? D += T + u / 2 - t.focus.x : D += n[0].focus.x - t.focus.x + n[0].ht.x : o > 1 ? F += T + u / 2 - t.focus.y : F += n[0].focus.y - t.focus.y + n[0].ht.y;
          break;
        case 26:
          e ? D += b + u / 2 - t.focus.x : F += k + u / 2 - t.focus.y;
          break;
        case 27:
          break;
        case 28:
          const R = this.customAlignment(t, D, F, b, k);
          D = R[0], F = R[1], b = R[2], k = R[3];
          break;
      }
      for (let R = 0; R < o; R++) {
        const I = n[R];
        e ? I.X.e(I.X.x + I.ht.x - D, I.X.y + (i > 135 ? (a ? -k : -I.kt.height) + I.ht.y - c : x + c + I.ht.y)) : I.X.e(I.X.x + (i > 135 ? (a ? -b : -I.kt.width) + I.ht.x - c : y + c + I.ht.x), I.X.y + I.ht.y - F);
      }
      e ? (b = this.jN(t, b, D), D < 0 && (D = 0), i > 135 && (F += k + c), k = Math.max(Math.max(k, x), k + x + c)) : (i > 135 && (D += b + c), b = Math.max(Math.max(b, y), b + y + c), k = this.JN(t, k, F), F < 0 && (F = 0)), t.ht.e(D, F), t.kt.e(b, k);
    }
    customAlignment(t, i, e, s, n) {
      return [i, e, s, n];
    }
    MD(t, i, e, s, n, o) {
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "layoutBusChildrenPosDir:v");
      const r = i.length;
      if (r === 0)
        return new Rect2(e, 0, n, o);
      if (r === 1) {
        const p = i[0];
        return n = p.kt.width, o = p.kt.height, new Rect2(e, 0, n, o);
      }
      const l = t.nodeSpacing, h = t.rowSpacing, f = this.orthoAngle(t) === 90;
      let c = 0, u = 0, d = 0;
      for (let p = 0; p < r; p++) {
        if (p % 2 !== 0 || r > 1 && p === r - 1)
          continue;
        const y = i[p], x = y.kt, b = c === 0 ? 0 : h;
        if (f) {
          const k = this.computeBusNodeSpacing(y) - l;
          y.X.e(e - (x.width + k), d + b), n = Math.max(n, x.width + k), o = Math.max(o, d + b + x.height), d += b + x.height;
        } else {
          const k = this.computeBusNodeSpacing(y) - l;
          y.X.e(u + b, e - (x.height + k)), o = Math.max(o, x.height + k), n = Math.max(n, u + b + x.width), u += b + x.width;
        }
        c++;
      }
      c = 0;
      const m = u, g = d;
      f ? (u = e + l, d = 0) : (u = 0, d = e + l);
      for (let p = 0; p < r; p++) {
        if (p % 2 === 0)
          continue;
        const y = i[p], x = y.kt, b = c === 0 ? 0 : h;
        if (f) {
          const k = this.computeBusNodeSpacing(y) - l;
          y.X.e(u + k, d + b), n = Math.max(n, u + x.width + k), o = Math.max(o, d + b + x.height), d += b + x.height;
        } else {
          const k = this.computeBusNodeSpacing(y) - l;
          y.X.e(u + b, d + k), n = Math.max(n, u + b + x.width), o = Math.max(o, d + x.height + k), u += b + x.width;
        }
        c++;
      }
      if (r > 1 && r % 2 === 1) {
        const p = i[r - 1], y = p.kt, x = this.computeBusLastRowSpacing(p, f ? Math.max(Math.abs(g), Math.abs(d)) : Math.max(Math.abs(m), Math.abs(u)));
        if (f) {
          p.X.e(e + l / 2 - p.focus.x - p.ht.x, o + x);
          const b = e + l / 2 - p.focus.x - p.ht.x;
          n = Math.max(n, b + y.width), b < 0 && (n -= b), o = Math.max(o, Math.max(g, d) + x + y.height), p.X.x < 0 && (e = this.xk(t, p.X.x, false, e, l));
        } else {
          p.X.e(n + x, e + l / 2 - p.focus.y - p.ht.y), n = Math.max(n, Math.max(m, u) + x + y.width);
          const b = e + l / 2 - p.focus.y - p.ht.y;
          o = Math.max(o, b + y.height), b < 0 && (o -= b), p.X.y < 0 && (e = this.xk(t, p.X.y, true, e, l));
        }
      }
      return new Rect2(e, 0, n, o);
    }
    PD(t, i, e, s, n, o) {
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "layoutBusChildrenNegDir:v");
      const r = i.length;
      if (r === 0)
        return new Rect2(e, 0, n, o);
      if (r === 1) {
        const p = i[0];
        return n = p.kt.width, o = p.kt.height, new Rect2(e, 0, n, o);
      }
      const l = t.nodeSpacing, h = t.rowSpacing, f = this.orthoAngle(t) === 270;
      let c = 0, u = 0, d = 0;
      for (let p = 0; p < r; p++) {
        if (p % 2 !== 0 || r > 1 && p === r - 1)
          continue;
        const y = i[p], x = y.kt, b = c === 0 ? 0 : h;
        if (f) {
          const k = this.computeBusNodeSpacing(y) - l;
          d -= b + x.height, y.X.e(e - (x.width + k), d), n = Math.max(n, x.width + k), o = Math.max(o, Math.abs(d));
        } else {
          const k = this.computeBusNodeSpacing(y) - l;
          u -= b + x.width, y.X.e(u, e - (x.height + k)), o = Math.max(o, x.height + k), n = Math.max(n, Math.abs(u));
        }
        c++;
      }
      c = 0;
      const m = u, g = d;
      f ? (u = e + l, d = 0) : (u = 0, d = e + l);
      for (let p = 0; p < r; p++) {
        if (p % 2 === 0)
          continue;
        const y = i[p], x = y.kt, b = c === 0 ? 0 : h;
        if (f) {
          const k = this.computeBusNodeSpacing(y) - l;
          d -= b + x.height, y.X.e(u + k, d), n = Math.max(n, u + x.width + k), o = Math.max(o, Math.abs(d));
        } else {
          const k = this.computeBusNodeSpacing(y) - l;
          u -= b + x.width, y.X.e(u, d + k), o = Math.max(o, d + x.height + k), n = Math.max(n, Math.abs(u));
        }
        c++;
      }
      if (r > 1 && r % 2 === 1) {
        const p = i[r - 1], y = p.kt, x = this.computeBusLastRowSpacing(p, f ? Math.max(Math.abs(g), Math.abs(d)) : Math.max(Math.abs(m), Math.abs(u)));
        if (f) {
          p.X.e(e + l / 2 - p.focus.x - p.ht.x, -o - y.height - x);
          const b = e + l / 2 - p.focus.x - p.ht.x;
          n = Math.max(n, b + y.width), b < 0 && (n -= b), o = Math.max(o, Math.abs(Math.min(g, d)) + x + y.height), p.X.x < 0 && (e = this.xk(t, p.X.x, false, e, l));
        } else {
          p.X.e(-n - y.width - x, e + l / 2 - p.focus.y - p.ht.y), n = Math.max(n, Math.abs(Math.min(m, u)) + x + y.width);
          const b = e + l / 2 - p.focus.y - p.ht.y;
          o = Math.max(o, b + y.height), b < 0 && (o -= b), p.X.y < 0 && (e = this.xk(t, p.X.y, true, e, l));
        }
      }
      for (let p = 0; p < r; p++) {
        const y = i[p];
        f ? y.X.e(y.X.x, y.X.y + o) : y.X.e(y.X.x + n, y.X.y);
      }
      return new Rect2(e, 0, n, o);
    }
    computeBusNodeSpacing(t) {
      return Debug && Util.s(t, TreeVertex2, _TreeLayout, "fixRelativePostions:child"), t.parent === null ? 0 : t.parent.nodeSpacing;
    }
    computeBusLastRowSpacing(t, i) {
      return Debug && Util.s(t, TreeVertex2, _TreeLayout, "fixRelativePostions:lastchild"), t.parent === null ? 0 : t.parent.rowSpacing;
    }
    xk(t, i, e, s, n) {
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "fixRelativePostions:v");
      const o = t.children, r = o.length;
      for (let h = 0; h < r; h++)
        e ? o[h].X.e(o[h].X.x, o[h].X.y - i) : o[h].X.e(o[h].X.x - i, o[h].X.y);
      const l = o[r - 1];
      return Math.max(s, e ? l.ht.y + l.focus.y - n / 2 : l.ht.x + l.focus.x - n / 2);
    }
    jN(t, i, e) {
      switch (Debug && Util.s(t, TreeVertex2, _TreeLayout, "calculateSubwidth:v"), t.alignment) {
        case 21:
        case 20:
          let s = i;
          return e + t.width > s && (s = e + t.width), e < 0 && (s -= e), s;
        case 22:
          return t.width > i ? t.width : i;
        case 23:
          return t.focus.x * 2 > i ? t.width : i + t.width - t.focus.x * 2;
        case 24:
        case 25:
          const n = Math.min(0, e), o = Math.max(i, e + t.width);
          return Math.max(t.width, o - n);
        case 26:
          return t.width - t.focus.x + t.nodeSpacing / 2 + i;
        case 27:
          return Math.max(t.width, t.focus.x + t.nodeSpacing / 2 + i);
        default:
          return i;
      }
    }
    JN(t, i, e) {
      switch (Debug && Util.s(t, TreeVertex2, _TreeLayout, "calculateSubheight:v"), t.alignment) {
        case 21:
        case 20:
          let s = i;
          return e + t.height > s && (s = e + t.height), e < 0 && (s -= e), s;
        case 22:
          return t.height > i ? t.height : i;
        case 23:
          return t.focus.y * 2 > i ? t.height : i + t.height - t.focus.y * 2;
        case 24:
        case 25:
          const n = Math.min(0, e), o = Math.max(i, e + t.height);
          return Math.max(t.height, o - n);
        case 26:
          return t.height - t.focus.y + t.nodeSpacing / 2 + i;
        case 27:
          return Math.max(t.height, t.focus.y + t.nodeSpacing / 2 + i);
        default:
          return i;
      }
    }
    ZN(t, i, e) {
      switch (Debug && Util.it(t, TreeAlignment2, "TreeAlignment"), t) {
        case 20:
          i /= 2, e /= 2;
          break;
        case 21:
          i /= 2, e /= 2;
          break;
        case 22:
          i = 0, e = 0;
          break;
        case 23:
          break;
        default:
          Util.n("Unhandled alignment value " + t.toString());
      }
      return new Point2(i, e);
    }
    of(t, i, e, s, n, o) {
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "shiftRelPosAlign:v"), Debug && Util.it(i, TreeAlignment2, "TreeAlignment");
      const r = this.ZN(i, e, s);
      this.ru(t, r.x, r.y, n, o);
    }
    ru(t, i, e, s, n) {
      if (Debug && Util.s(t, TreeVertex2, _TreeLayout, "shiftRelPos:v"), i === 0 && e === 0)
        return;
      const o = t.children;
      for (let r = s; r <= n; r++) {
        const h = o[r].X;
        h.x += i, h.y += e;
      }
    }
    wk(t, i, e) {
      Debug && (Util.s(t, TreeVertex2, _TreeLayout, "recordMidPoints:v"), Util.t(i, "number", _TreeLayout, "recordMidPoints:x"), Util.t(e, "number", _TreeLayout, "recordMidPoints:y"));
      const s = t.parent;
      switch (this.ms) {
        case 1: {
          const n = t.sourceEdges;
          for (; n.next(); ) {
            const o = n.value;
            o.fromVertex === s && o.relativePoint.e(i, e);
          }
          break;
        }
        case 2: {
          const n = t.destinationEdges;
          for (; n.next(); ) {
            const o = n.value;
            o.toVertex === s && o.relativePoint.e(i, e);
          }
          break;
        }
        default:
          Util.n("Unhandled path value " + this.ms.toString());
      }
    }
    U3(t) {
      if (Debug && Util.s(t, TreeVertex2, _TreeLayout, "layoutTreeBlock:v"), t.childrenCount === 0) {
        const z = t.parent;
        let G = false, v = 0, q = 21;
        z !== null && (v = z.angle, q = z.alignment, G = this.isBusAlignment(q));
        const J = this.WN(t);
        t.X.e(0, 0), t.kt.e(t.width, t.height), t.parent !== null && t.comments !== null && ((v === 180 || v === 270) && !G || J) ? v === 180 && !G || (v === 90 || v === 270) && J ? t.ht.e(t.width - t.focus.x * 2, 0) : t.ht.e(0, t.height - t.focus.y * 2) : t.ht.e(0, 0), t.Yg = null, t.Kg = null;
        return;
      }
      const i = this.orthoAngle(t), e = i === 90 || i === 270;
      let s = 0;
      const n = t.children, o = n.length;
      for (let z = 0; z < o; z++) {
        const G = n[z];
        s = Math.max(s, e ? G.kt.width : G.kt.height);
      }
      const r = t.alignment, l = r === 22, h = r === 23, a = this.isBusAlignment(r), f = Math.max(0, t.breadthLimit), c = this.computeLayerSpacing(t), u = t.nodeSpacing, d = this.computeNodeIndent(t), m = t.rowSpacing;
      let g = 0;
      (l || h || t.nu || t.ou && t.maxGenerationCount === 1) && (g = Math.max(0, t.rowIndent));
      const p = t.width, y = t.height;
      let x = 0, b = 0, k = 0, S = null, M = null, A = 0, C = 0, P = 0, N = 0, T = 0, L = 0, D = 0, F = 0, R = 0;
      if (a && !this.iw(r) && i > 135 && n.reverse(), this.iw(r))
        if (o > 1)
          for (let z = 0; z < o; z++)
            z % 2 === 0 && z !== o - 1 ? F = Math.max(F, e ? n[z].kt.width : n[z].kt.height) : z % 2 !== 0 && (R = Math.max(R, e ? n[z].kt.width : n[z].kt.height));
        else
          o === 1 && (F = e ? n[0].kt.width : n[0].kt.height);
      if (a) {
        switch (r) {
          case 24:
            let z;
            i < 135 ? z = this.MD(t, n, F, R, x, b) : z = this.PD(t, n, F, R, x, b), F = z.x, x = z.width, b = z.height;
            break;
          case 26:
            for (let G = 0; G < o; G++) {
              const v = n[G], q = v.kt, J = L === 0 ? 0 : m;
              e ? (v.X.e(s - q.width, N + J), x = Math.max(x, q.width), b = Math.max(b, N + J + q.height), N += J + q.height) : (v.X.e(P + J, s - q.height), x = Math.max(x, P + J + q.width), b = Math.max(b, q.height), P += J + q.width), L++;
            }
            break;
          case 27:
            for (let G = 0; G < o; G++) {
              const v = n[G], q = v.kt, J = L === 0 ? 0 : m;
              e ? (v.X.e(u / 2 + t.focus.x, N + J), x = Math.max(x, q.width), b = Math.max(b, N + J + q.height), N += J + q.height) : (v.X.e(P + J, u / 2 + t.focus.y), x = Math.max(x, P + J + q.width), b = Math.max(b, q.height), P += J + q.width), L++;
            }
            break;
        }
        S = this.ye(2), M = this.ye(2), e ? (S[0].e(0, 0), S[1].e(0, b), M[0].e(x, 0), M[1].e(x, b)) : (S[0].e(0, 0), S[1].e(x, 0), M[0].e(0, b), M[1].e(x, b));
      } else
        for (let z = 0; z < o; z++) {
          const G = n[z], v = G.kt;
          if (e) {
            f > 0 && L > 0 && P + u + v.width > f && (P < s && this.of(t, r, s - P, 0, D, z - 1), T++, L = 0, D = z, k = b, P = 0, N = i > 135 ? -b - m : b + m), this.wk(G, 0, N);
            let q = 0;
            if (L === 0)
              S = G.Yg, M = G.Kg, A = v.width, C = v.height, (S === null || M === null || i !== this.orthoAngle(G)) && (S = this.ye(2), M = this.ye(2), S[0].e(0, 0), S[1].e(0, C), M[0].e(A, 0), M[1].e(A, C));
            else {
              const J = Util.ct(), Y = this.ND(t, G, S, M, A, C, J);
              q = Y.x, S = J[0], M = J[1], A = Y.width, C = Y.height, Util.ot(J), P < v.width && q < 0 && (this.ru(t, -q, 0, D, z - 1), this.bk(S, -q, 0), this.bk(M, -q, 0), q = 0);
            }
            G.X.e(q, N), x = Math.max(x, A), b = Math.max(b, k + (T === 0 ? 0 : m) + v.height), P = A;
          } else {
            f > 0 && L > 0 && N + u + v.height > f && (N < s && this.of(t, r, 0, s - N, D, z - 1), T++, L = 0, D = z, k = x, N = 0, P = i > 135 ? -x - m : x + m), this.wk(G, P, 0);
            let q = 0;
            if (L === 0)
              S = G.Yg, M = G.Kg, A = v.width, C = v.height, (S === null || M === null || i !== this.orthoAngle(G)) && (S = this.ye(2), M = this.ye(2), S[0].e(0, 0), S[1].e(A, 0), M[0].e(0, C), M[1].e(A, C));
            else {
              const J = Util.ct(), Y = this.ND(t, G, S, M, A, C, J);
              q = Y.x, S = J[0], M = J[1], A = Y.width, C = Y.height, Util.ot(J), N < v.height && q < 0 && (this.ru(t, 0, -q, D, z - 1), this.bk(S, 0, -q), this.bk(M, 0, -q), q = 0);
            }
            G.X.e(P, q), b = Math.max(b, C), x = Math.max(x, k + (T === 0 ? 0 : m) + v.width), N = C;
          }
          L++;
        }
      T > 0 && (e ? (b += Math.max(0, c), P < x && this.of(t, r, x - P, 0, D, o - 1), g > 0 && (h || this.ru(t, g, 0, 0, o - 1), x += g)) : (x += Math.max(0, c), N < b && this.of(t, r, 0, b - N, D, o - 1), g > 0 && (h || this.ru(t, 0, g, 0, o - 1), b += g)));
      let I = 0, O = 0;
      switch (r) {
        case 20:
          e ? I += x / 2 - t.focus.x - d / 2 : O += b / 2 - t.focus.y - d / 2;
          break;
        default:
        case 21:
          if (T > 0)
            e ? I += x / 2 - t.focus.x - d / 2 : O += b / 2 - t.focus.y - d / 2;
          else {
            const G = o;
            if (e) {
              const v = n[0].X.x + n[0].ht.x, q = n[G - 1].X.x + n[G - 1].ht.x + n[G - 1].focus.x * 2;
              I += v + (q - v) / 2 - t.focus.x - d / 2;
            } else {
              const v = n[0].X.y + n[0].ht.y, q = n[G - 1].X.y + n[G - 1].ht.y + n[G - 1].focus.y * 2;
              O += v + (q - v) / 2 - t.focus.y - d / 2;
            }
          }
          break;
        case 22:
          e ? (I -= d, x += d) : (O -= d, b += d);
          break;
        case 23:
          e ? (I += x - t.width + d, x += d) : (O += b - t.height + d, b += d);
          break;
        case 24:
          e ? o > 1 ? I += F + u / 2 - t.focus.x : I += n[0].focus.x - t.focus.x + n[0].ht.x : o > 1 ? O += F + u / 2 - t.focus.y : O += n[0].focus.y - t.focus.y + n[0].ht.y;
          break;
        case 26:
          e ? I += x + u / 2 - t.focus.x : O += b + u / 2 - t.focus.y;
          break;
        case 27:
          break;
        case 28:
          const z = this.customAlignment(t, I, O, x, b);
          I = z[0], O = z[1], x = z[2], b = z[3];
          break;
      }
      for (let z = 0; z < o; z++) {
        const G = n[z];
        e ? G.X.e(G.X.x + G.ht.x - I, G.X.y + (i > 135 ? (a ? -b : -G.kt.height) + G.ht.y - c : y + c + G.ht.y)) : G.X.e(G.X.x + (i > 135 ? (a ? -x : -G.kt.width) + G.ht.x - c : p + c + G.ht.x), G.X.y + G.ht.y - O);
      }
      let B = 0, K = 0;
      if (a)
        e ? (x = this.jN(t, x, I), I < 0 && (I = 0), i > 135 && (O += b + c), b += y + c, r === 27 && (B += u / 2 + t.focus.x), K += y + c) : (i > 135 && (I += x + c), x += p + c, b = this.JN(t, b, O), O < 0 && (O = 0), r === 27 && (K += u / 2 + t.focus.y), B += p + c);
      else if (e) {
        if (t.comments === null) {
          if (p > x) {
            const z = this.ZN(r, p - x, 0);
            B = z.x, K = z.y, x = p, I = 0;
          }
        } else
          x = this.jN(t, x, I);
        I < 0 && (B -= I, I = 0), i > 135 && (O += b + c), b = Math.max(Math.max(b, y), b + y + c), K += y + c;
      } else {
        if (i > 135 && (I += x + c), x = Math.max(Math.max(x, p), x + p + c), t.comments === null) {
          if (y > b) {
            const z = this.ZN(r, 0, y - b);
            B = z.x, K = z.y, b = y, O = 0;
          }
        } else
          b = this.JN(t, b, O);
        O < 0 && (K -= O, O = 0), B += p + c;
      }
      let V, X;
      if (T > 0)
        V = this.ye(4), X = this.ye(4), e ? (V[2].e(0, y + c), V[3].e(V[2].x, b), X[2].e(x, V[2].y), X[3].e(X[2].x, V[3].y)) : (V[2].e(p + c, 0), V[3].e(x, V[2].y), X[2].e(V[2].x, b), X[3].e(V[3].x, X[2].y));
      else {
        V = this.ye(S.length + 2), X = this.ye(M.length + 2);
        for (let z = 0; z < S.length; z++) {
          const G = S[z];
          V[z + 2].e(G.x + B, G.y + K);
        }
        for (let z = 0; z < M.length; z++) {
          const G = M[z];
          X[z + 2].e(G.x + B, G.y + K);
        }
      }
      e ? (V[0].e(I, 0), V[1].e(V[0].x, y), V[2].y < V[1].y && (V[2].x > V[0].x ? V[2].c(V[1]) : V[1].c(V[2])), V[3].y < V[2].y && (V[3].x > V[0].x ? V[3].c(V[2]) : V[2].c(V[3])), X[0].e(I + p, 0), X[1].e(X[0].x, y), X[2].y < X[1].y && (X[2].x < X[0].x ? X[2].c(X[1]) : X[1].c(X[2])), X[3].y < X[2].y && (X[3].x < X[0].x ? X[3].c(X[2]) : X[2].c(X[3])), V[2].y -= c / 2, X[2].y -= c / 2) : (V[0].e(0, O), V[1].e(p, V[0].y), V[2].x < V[1].x && (V[2].y > V[0].y ? V[2].c(V[1]) : V[1].c(V[2])), V[3].x < V[2].x && (V[3].y > V[0].y ? V[3].c(V[2]) : V[2].c(V[3])), X[0].e(0, O + y), X[1].e(p, X[0].y), X[2].x < X[1].x && (X[2].y < X[0].y ? X[2].c(X[1]) : X[1].c(X[2])), X[3].x < X[2].x && (X[3].y < X[0].y ? X[3].c(X[2]) : X[2].c(X[3])), V[2].x -= c / 2, X[2].x -= c / 2), this.ln(S), this.ln(M), t.Yg = V, t.Kg = X, t.ht.e(I, O), t.kt.e(x, b);
    }
    bk(t, i, e) {
      for (let s = 0; s < t.length; s++) {
        const n = t[s];
        n.x += i, n.y += e;
      }
    }
    ND(t, i, e, s, n, o, r) {
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "mergeFringes:parent"), Debug && Util.s(i, TreeVertex2, _TreeLayout, "mergeFringes:child");
      const l = this.orthoAngle(t), h = l === 90 || l === 270, a = t.nodeSpacing, f = e, c = s, u = n, d = o;
      let m = i.Yg, g = i.Kg;
      const p = i.kt, y = h ? Math.max(d, p.height) : Math.max(u, p.width);
      if ((m === null || l !== this.orthoAngle(i)) && (m = this.ye(2), g = this.ye(2), h ? (m[0].e(0, 0), m[1].e(0, p.height), g[0].e(p.width, 0), g[1].e(g[0].x, m[1].y)) : (m[0].e(0, 0), m[1].e(p.width, 0), g[0].e(0, p.height), g[1].e(m[1].x, g[0].y))), h) {
        const x = u;
        let b = x - this.G3(c, m, x);
        return b += a, e = this.H3(f, m, b), s = this.v3(c, g, b), n = Math.max(0, b) + p.width, o = y, this.ln(f), this.ln(m), this.ln(c), this.ln(g), r[0] = e, r[1] = s, new Rect2(b, 0, n, o);
      } else {
        const x = d;
        let b = x - this.q3(c, m, x);
        return b += a, e = this.W3(f, m, b), s = this.j3(c, g, b), n = y, o = Math.max(0, b) + p.height, this.ln(f), this.ln(m), this.ln(c), this.ln(g), r[0] = e, r[1] = s, new Rect2(b, 0, n, o);
      }
    }
    W3(t, i, e) {
      if (t === null || t.length < 2 || i === null || i.length < 2)
        return null;
      const s = this.ye(t.length + i.length);
      let n = 0, o = 0, r = 0;
      for (; o < i.length && i[o].x < t[0].x; ) {
        const a = i[o++];
        s[r++].e(a.x, a.y + e);
      }
      for (; n < t.length; ) {
        const a = t[n++];
        s[r++].e(a.x, a.y);
      }
      const l = t[t.length - 1].x;
      for (; o < i.length && i[o].x <= l; )
        o++;
      for (; o < i.length && i[o].x > l; ) {
        const a = i[o++];
        s[r++].e(a.x, a.y + e);
      }
      const h = this.ye(r);
      for (n = 0; n < r; n++)
        h[n].c(s[n]);
      return this.ln(s), h;
    }
    H3(t, i, e) {
      if (t === null || t.length < 2 || i === null || i.length < 2)
        return null;
      const s = this.ye(t.length + i.length);
      let n = 0, o = 0, r = 0;
      for (; o < i.length && i[o].y < t[0].y; ) {
        const a = i[o++];
        s[r++].e(a.x + e, a.y);
      }
      for (; n < t.length; ) {
        const a = t[n++];
        s[r++].e(a.x, a.y);
      }
      const l = t[t.length - 1].y;
      for (; o < i.length && i[o].y <= l; )
        o++;
      for (; o < i.length && i[o].y > l; ) {
        const a = i[o++];
        s[r++].e(a.x + e, a.y);
      }
      const h = this.ye(r);
      for (n = 0; n < r; n++)
        h[n].c(s[n]);
      return this.ln(s), h;
    }
    j3(t, i, e) {
      if (t === null || t.length < 2 || i === null || i.length < 2)
        return null;
      const s = this.ye(t.length + i.length);
      let n = 0, o = 0, r = 0;
      for (; n < t.length && t[n].x < i[0].x; ) {
        const a = t[n++];
        s[r++].e(a.x, a.y);
      }
      for (; o < i.length; ) {
        const a = i[o++];
        s[r++].e(a.x, a.y + e);
      }
      const l = i[i.length - 1].x;
      for (; n < t.length && t[n].x <= l; )
        n++;
      for (; n < t.length && t[n].x > l; ) {
        const a = t[n++];
        s[r++].e(a.x, a.y);
      }
      const h = this.ye(r);
      for (n = 0; n < r; n++)
        h[n].c(s[n]);
      return this.ln(s), h;
    }
    v3(t, i, e) {
      if (t === null || t.length < 2 || i === null || i.length < 2)
        return null;
      const s = this.ye(t.length + i.length);
      let n = 0, o = 0, r = 0;
      for (; n < t.length && t[n].y < i[0].y; ) {
        const a = t[n++];
        s[r++].e(a.x, a.y);
      }
      for (; o < i.length; ) {
        const a = i[o++];
        s[r++].e(a.x + e, a.y);
      }
      const l = i[i.length - 1].y;
      for (; n < t.length && t[n].y <= l; )
        n++;
      for (; n < t.length && t[n].y > l; ) {
        const a = t[n++];
        s[r++].e(a.x, a.y);
      }
      const h = this.ye(r);
      for (n = 0; n < r; n++)
        h[n].c(s[n]);
      return this.ln(s), h;
    }
    q3(t, i, e) {
      let s = 9999999;
      if (t === null || t.length < 2 || i === null || i.length < 2)
        return s;
      let n = 0, o = 0;
      for (; n < t.length && o < i.length; ) {
        const r = t[n], l = i[o], h = l.x;
        let a = l.y;
        a += e;
        let f = r;
        n + 1 < t.length && (f = t[n + 1]);
        let c = l, u = c.x, d = c.y;
        o + 1 < i.length && (c = i[o + 1], u = c.x, d = c.y, d += e);
        let m = s;
        r.x === h ? m = a - r.y : r.x > h && r.x < u ? m = a + (r.x - h) / (u - h) * (d - a) - r.y : h > r.x && h < f.x && (m = a - (r.y + (h - r.x) / (f.x - r.x) * (f.y - r.y))), m < s && (s = m), f.x <= r.x ? n++ : u <= h ? o++ : (f.x <= u && n++, u <= f.x && o++);
      }
      return s;
    }
    G3(t, i, e) {
      let s = 9999999;
      if (t === null || t.length < 2 || i === null || i.length < 2)
        return s;
      let n = 0, o = 0;
      for (; n < t.length && o < i.length; ) {
        const r = t[n], l = i[o];
        let h = l.x;
        const a = l.y;
        h += e;
        let f = r;
        n + 1 < t.length && (f = t[n + 1]);
        let c = l, u = c.x, d = c.y;
        o + 1 < i.length && (c = i[o + 1], u = c.x, d = c.y, u += e);
        let m = s;
        r.y === a ? m = h - r.x : r.y > a && r.y < d ? m = h + (r.y - a) / (d - a) * (u - h) - r.x : a > r.y && a < f.y && (m = h - (r.x + (a - r.y) / (f.y - r.y) * (f.x - r.x))), m < s && (s = m), f.y <= r.y ? n++ : d <= a ? o++ : (f.y <= d && n++, d <= f.y && o++);
      }
      return s;
    }
    ye(t) {
      const i = this.yk[t];
      if (i !== void 0) {
        const s = i.pop();
        if (s !== void 0)
          return s;
      }
      const e = [];
      for (let s = 0; s < t; s++)
        e[s] = new Point2();
      return e;
    }
    ln(t) {
      const i = t.length;
      let e = this.yk[i];
      e === void 0 && (e = [], this.yk[i] = e), e.push(t);
    }
    arrangeTrees() {
      if (this.vi === 52) {
        const t = this.Vi.iterator;
        for (; t.next(); ) {
          const i = t.value;
          if (!(i instanceof TreeVertex2))
            continue;
          const e = i.node;
          if (e === null)
            continue;
          const s = e.position;
          let n = s.x, o = s.y;
          isFinite(n) || (n = 0), isFinite(o) || (o = 0), this.$N(i, n, o);
        }
      } else {
        const t = [], i = this.Vi.iterator;
        for (; i.next(); ) {
          const o = i.value;
          o instanceof TreeVertex2 && t.push(o);
        }
        switch (this.sorting) {
          default:
          case 10:
            break;
          case 11:
            t.reverse();
            break;
          case 12:
            t.sort(this.comparer);
            break;
          case 13:
            t.sort(this.comparer), t.reverse();
            break;
        }
        const e = this.arrangementOrigin;
        let s = e.x, n = e.y;
        for (let o = 0; o < t.length; o++) {
          const r = t[o];
          switch (this.$N(r, s + r.ht.x, n + r.ht.y), this.vi) {
            case 50:
              n += r.kt.height + this.Ts.height;
              break;
            default:
            case 51:
              s += r.kt.width + this.Ts.width;
              break;
          }
        }
      }
    }
    $N(t, i, e) {
      if (t === null)
        return;
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "assignAbsolutePositions:v"), t.x = i, t.y = e;
      const s = t.children, n = s.length;
      for (let o = 0; o < n; o++) {
        const r = s[o];
        this.$N(r, i + r.X.x, e + r.X.y);
      }
    }
    commitLayout() {
      this.qy(), this.commitNodes(), this.HN(), this.isRouting && this.commitLinks();
    }
    commitNodes() {
      const t = this.network.vertexes.iterator;
      for (; t.next(); )
        t.value.commit();
      for (t.reset(); t.next(); ) {
        const i = t.value;
        this.layoutComments(i);
      }
    }
    HN() {
      if (this.layerStyle !== 62)
        return;
      const t = this.vN, i = [];
      let e = null;
      const s = this.network.vertexes.iterator;
      for (; s.next(); ) {
        const h = s.value;
        e === null ? e = h.bounds.copy() : e.unionRect(h.bounds);
        let a = i[h.level];
        a === void 0 ? a = this.computeLayerSpacing(h) : a = Math.max(a, this.computeLayerSpacing(h)), i[h.level] = a;
      }
      for (let h = 0; h < i.length; h++)
        i[h] === void 0 && (i[h] = 0);
      let n;
      this.angle === 90 || this.angle === 270 ? (e.inflate(this.nodeSpacing / 2, this.layerSpacing), n = new Point2(-this.nodeSpacing / 2, -this.layerSpacing / 2)) : (e.inflate(this.layerSpacing, this.nodeSpacing / 2), n = new Point2(-this.layerSpacing / 2, -this.nodeSpacing / 2));
      const o = [], r = this.angle === 90 || this.angle === 270 ? e.width : e.height;
      let l = 0;
      if (this.angle === 180 || this.angle === 270)
        for (let h = 0; h < t.length; h++)
          l += t[h] + i[h];
      for (let h = 0; h < t.length; h++) {
        const a = t[h] + i[h];
        this.angle === 270 ? (l -= a, o.push(new Rect2(0, l, r, a))) : this.angle === 90 ? (o.push(new Rect2(0, l, r, a)), l += a) : this.angle === 180 ? (l -= a, o.push(new Rect2(l, 0, a, r))) : (o.push(new Rect2(l, 0, a, r)), l += a);
      }
      this.commitLayers(o, n);
    }
    commitLayers(t, i) {
    }
    commitLinks() {
      const t = this.network.edges.iterator;
      for (; t.next(); )
        t.value.commit();
    }
    qy() {
      const t = this.Vi.iterator;
      for (; t.next(); ) {
        const i = t.value;
        i instanceof TreeVertex2 && this.CD(i);
      }
    }
    CD(t) {
      if (t === null)
        return;
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "setPortSpotsTree:v"), this.setPortSpots(t);
      const i = t.children, e = i.length;
      for (let s = 0; s < e; s++) {
        const n = i[s];
        this.CD(n);
      }
    }
    setPortSpots(t) {
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "setPortSpots:v");
      const i = t.alignment;
      if (this.isBusAlignment(i))
        this.J3(t, i);
      else {
        const e = this.orthoAngle(t);
        if (this.ms === 1) {
          const s = t.destinationEdges;
          for (; s.next(); ) {
            const o = s.value.link;
            if (o !== null) {
              if (t.setsPortSpot)
                if (t.portSpot.isDefault())
                  switch (e) {
                    case 0:
                      o.fromSpot = Spot2.MiddleRight;
                      break;
                    case 90:
                      o.fromSpot = Spot2.MiddleBottom;
                      break;
                    case 180:
                      o.fromSpot = Spot2.MiddleLeft;
                      break;
                    default:
                      o.fromSpot = Spot2.MiddleTop;
                      break;
                  }
                else
                  o.fromSpot = t.portSpot;
              if (t.setsChildPortSpot)
                if (t.childPortSpot.isDefault())
                  switch (e) {
                    case 0:
                      o.toSpot = Spot2.MiddleLeft;
                      break;
                    case 90:
                      o.toSpot = Spot2.MiddleTop;
                      break;
                    case 180:
                      o.toSpot = Spot2.MiddleRight;
                      break;
                    default:
                      o.toSpot = Spot2.MiddleBottom;
                      break;
                  }
                else
                  o.toSpot = t.childPortSpot;
            }
          }
        } else {
          const s = t.sourceEdges;
          for (; s.next(); ) {
            const o = s.value.link;
            if (o !== null) {
              if (t.setsPortSpot)
                if (t.portSpot.isDefault())
                  switch (e) {
                    case 0:
                      o.toSpot = Spot2.MiddleRight;
                      break;
                    case 90:
                      o.toSpot = Spot2.MiddleBottom;
                      break;
                    case 180:
                      o.toSpot = Spot2.MiddleLeft;
                      break;
                    default:
                      o.toSpot = Spot2.MiddleTop;
                      break;
                  }
                else
                  o.toSpot = t.portSpot;
              if (t.setsChildPortSpot)
                if (t.childPortSpot.isDefault())
                  switch (e) {
                    case 0:
                      o.fromSpot = Spot2.MiddleLeft;
                      break;
                    case 90:
                      o.fromSpot = Spot2.MiddleTop;
                      break;
                    case 180:
                      o.fromSpot = Spot2.MiddleRight;
                      break;
                    default:
                      o.fromSpot = Spot2.MiddleBottom;
                      break;
                  }
                else
                  o.fromSpot = t.childPortSpot;
            }
          }
        }
      }
    }
    J3(t, i) {
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "setPortSpotsBus:v"), Debug && Util.it(i, TreeAlignment2, "TreeAlignment");
      const e = this.ms === 1, s = this.orthoAngle(t);
      let n;
      switch (s) {
        case 0:
          n = Spot2.MiddleRight;
          break;
        case 90:
          n = Spot2.MiddleBottom;
          break;
        case 180:
          n = Spot2.MiddleLeft;
          break;
        default:
          n = Spot2.MiddleTop;
          break;
      }
      const o = t.children, r = o.length;
      switch (i) {
        case 24:
        case 25: {
          for (let l = 0; l < r; l++) {
            const h = o[l], a = (e ? h.sourceEdges : h.destinationEdges).first();
            if (a === null)
              continue;
            const f = a.link;
            if (f !== null) {
              let c = s === 90 || s === 270 ? Spot2.MiddleLeft : Spot2.MiddleTop;
              if (r === 1 || l === r - 1 && r % 2 === 1)
                switch (s) {
                  case 0:
                    c = Spot2.MiddleLeft;
                    break;
                  case 90:
                    c = Spot2.MiddleTop;
                    break;
                  case 180:
                    c = Spot2.MiddleRight;
                    break;
                  default:
                    c = Spot2.MiddleBottom;
                    break;
                }
              else
                l % 2 === 0 && (c = s === 90 || s === 270 ? Spot2.MiddleRight : Spot2.MiddleBottom);
              e ? (t.setsPortSpot && (f.fromSpot = n), t.setsChildPortSpot && (f.toSpot = c)) : (t.setsPortSpot && (f.fromSpot = c), t.setsChildPortSpot && (f.toSpot = n));
            }
          }
          break;
        }
        case 26: {
          const l = s === 90 || s === 270 ? Spot2.MiddleRight : Spot2.MiddleBottom, h = e ? t.destinationEdges : t.sourceEdges;
          for (; h.next(); ) {
            const f = h.value.link;
            f !== null && (e ? (t.setsPortSpot && (f.fromSpot = n), t.setsChildPortSpot && (f.toSpot = l)) : (t.setsPortSpot && (f.fromSpot = l), t.setsChildPortSpot && (f.toSpot = n)));
          }
          break;
        }
        case 27: {
          const l = s === 90 || s === 270 ? Spot2.MiddleLeft : Spot2.MiddleTop, h = e ? t.destinationEdges : t.sourceEdges;
          for (; h.next(); ) {
            const f = h.value.link;
            f !== null && (e ? (t.setsPortSpot && (f.fromSpot = n), t.setsChildPortSpot && (f.toSpot = l)) : (t.setsPortSpot && (f.fromSpot = l), t.setsChildPortSpot && (f.toSpot = n)));
          }
          break;
        }
      }
    }
    orthoAngle(t) {
      const i = t.angle;
      return i <= 45 ? 0 : i <= 135 ? 90 : i <= 225 ? 180 : i <= 315 ? 270 : 0;
    }
    computeLayerSpacing(t) {
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "computeLayerSpacing:v");
      const i = this.orthoAngle(t), e = i === 90 || i === 270;
      let s = t.layerSpacing;
      if (t.layerSpacingParentOverlap > 0) {
        const n = Math.min(1, t.layerSpacingParentOverlap);
        s -= e ? t.height * n : t.width * n;
      }
      return s < (e ? -t.height : -t.width) && (s = e ? -t.height : -t.width), s;
    }
    computeNodeIndent(t) {
      Debug && Util.s(t, TreeVertex2, _TreeLayout, "computeNodeIndent:v");
      const i = this.orthoAngle(t), e = i === 90 || i === 270;
      let s = t.nodeIndent;
      if (t.nodeIndentPastParent > 0) {
        const n = Math.min(1, t.nodeIndentPastParent);
        s += e ? t.width * n : t.height * n;
      }
      return s = Math.max(0, s), s;
    }
    get roots() {
      return this.Vi;
    }
    set roots(t) {
      this.Vi !== t && (Util.s(t, GSet2, _TreeLayout, "roots"), this.Vi = t, this.invalidateLayout());
    }
    get path() {
      return this.Oi;
    }
    set path(t) {
      this.Oi !== t && (Util.it(t, TreePath2, "TreePath"), this.Oi = t, this.invalidateLayout());
    }
    get treeStyle() {
      return this.su;
    }
    set treeStyle(t) {
      this.su !== t && (Util.it(t, TreeStyle2, "TreeStyle"), (t === 40 || t === 42 || t === 41 || t === 43) && (this.su = t, this.invalidateLayout()));
    }
    get layerStyle() {
      return this.Xg;
    }
    set layerStyle(t) {
      this.Xg !== t && (Util.it(t, TreeLayerStyle2, "TreeLayerStyle"), (t === 60 || t === 61 || t === 62) && (this.Xg = t, this.invalidateLayout()));
    }
    get comments() {
      return this.Ye;
    }
    set comments(t) {
      this.Ye !== t && (Util.t(t, "boolean", _TreeLayout, "comments"), this.Ye = t, this.invalidateLayout());
    }
    get arrangement() {
      return this.vi;
    }
    set arrangement(t) {
      this.vi !== t && (Util.it(t, TreeArrangement2, "TreeArrangement"), (t === 50 || t === 51 || t === 52) && (this.vi = t, this.invalidateLayout()));
    }
    get arrangementSpacing() {
      return this.Ts;
    }
    set arrangementSpacing(t) {
      Util.s(t, Size2, _TreeLayout, "arrangementSpacing"), this.Ts.equals(t) || (this.Ts.c(t), this.invalidateLayout());
    }
    get rootDefaults() {
      return this.K;
    }
    set rootDefaults(t) {
      this.K !== t && (Util.s(t, TreeVertex2, _TreeLayout, "rootDefaults"), this.K = t, this.invalidateLayout());
    }
    get alternateDefaults() {
      return this.U;
    }
    set alternateDefaults(t) {
      this.U !== t && (Util.s(t, TreeVertex2, _TreeLayout, "alternateDefaults"), this.U = t, this.invalidateLayout());
    }
    get sorting() {
      return this.K.sorting;
    }
    set sorting(t) {
      this.K.sorting !== t && (Util.it(t, TreeSorting2, "TreeSorting"), this.K.sorting = t, this.invalidateLayout());
    }
    get comparer() {
      return this.K.comparer;
    }
    set comparer(t) {
      this.K.comparer !== t && (Util.t(t, "function", _TreeLayout, "comparer"), this.K.comparer = t, this.invalidateLayout());
    }
    get angle() {
      return this.K.angle;
    }
    set angle(t) {
      this.K.angle !== t && (Util.t(t, "number", _TreeLayout, "angle"), t === 0 || t === 90 || t === 180 || t === 270 ? (this.K.angle = t, this.invalidateLayout()) : Util.n("TreeLayout.angle must be 0, 90, 180, or 270"));
    }
    get alignment() {
      return this.K.alignment;
    }
    set alignment(t) {
      this.K.alignment !== t && (Util.it(t, TreeAlignment2, "TreeAlignment"), this.K.alignment = t, this.invalidateLayout());
    }
    get nodeIndent() {
      return this.K.nodeIndent;
    }
    set nodeIndent(t) {
      this.K.nodeIndent !== t && (Util.t(t, "number", _TreeLayout, "nodeIndent"), t >= 0 && (this.K.nodeIndent = t, this.invalidateLayout()));
    }
    get nodeIndentPastParent() {
      return this.K.nodeIndentPastParent;
    }
    set nodeIndentPastParent(t) {
      this.K.nodeIndentPastParent !== t && (Util.t(t, "number", _TreeLayout, "nodeIndentPastParent"), t >= 0 && t <= 1 && (this.K.nodeIndentPastParent = t, this.invalidateLayout()));
    }
    get nodeSpacing() {
      return this.K.nodeSpacing;
    }
    set nodeSpacing(t) {
      this.K.nodeSpacing !== t && (Util.t(t, "number", _TreeLayout, "nodeSpacing"), this.K.nodeSpacing = t, this.invalidateLayout());
    }
    get layerSpacing() {
      return this.K.layerSpacing;
    }
    set layerSpacing(t) {
      this.K.layerSpacing !== t && (Util.t(t, "number", _TreeLayout, "layerSpacing"), this.K.layerSpacing = t, this.invalidateLayout());
    }
    get layerSpacingParentOverlap() {
      return this.K.layerSpacingParentOverlap;
    }
    set layerSpacingParentOverlap(t) {
      this.K.layerSpacingParentOverlap !== t && (Util.t(t, "number", _TreeLayout, "layerSpacingParentOverlap"), t >= 0 && t <= 1 && (this.K.layerSpacingParentOverlap = t, this.invalidateLayout()));
    }
    get compaction() {
      return this.K.compaction;
    }
    set compaction(t) {
      this.K.compaction !== t && (Util.it(t, TreeCompaction2, "TreeCompaction"), (t === 30 || t === 31) && (this.K.compaction = t, this.invalidateLayout()));
    }
    get breadthLimit() {
      return this.K.breadthLimit;
    }
    set breadthLimit(t) {
      this.K.breadthLimit !== t && (Util.t(t, "number", _TreeLayout, "breadthLimit"), t >= 0 && (this.K.breadthLimit = t, this.invalidateLayout()));
    }
    get rowSpacing() {
      return this.K.rowSpacing;
    }
    set rowSpacing(t) {
      this.K.rowSpacing !== t && (Util.t(t, "number", _TreeLayout, "rowSpacing"), this.K.rowSpacing = t, this.invalidateLayout());
    }
    get rowIndent() {
      return this.K.rowIndent;
    }
    set rowIndent(t) {
      this.K.rowIndent !== t && (Util.t(t, "number", _TreeLayout, "rowIndent"), t >= 0 && (this.K.rowIndent = t, this.invalidateLayout()));
    }
    get commentSpacing() {
      return this.K.commentSpacing;
    }
    set commentSpacing(t) {
      this.K.commentSpacing !== t && (Util.t(t, "number", _TreeLayout, "commentSpacing"), this.K.commentSpacing = t, this.invalidateLayout());
    }
    get commentMargin() {
      return this.K.commentMargin;
    }
    set commentMargin(t) {
      this.K.commentMargin !== t && (Util.t(t, "number", _TreeLayout, "commentMargin"), this.K.commentMargin = t, this.invalidateLayout());
    }
    get setsPortSpot() {
      return this.K.setsPortSpot;
    }
    set setsPortSpot(t) {
      this.K.setsPortSpot !== t && (Util.t(t, "boolean", _TreeLayout, "setsPortSpot"), this.K.setsPortSpot = t, this.invalidateLayout());
    }
    get portSpot() {
      return this.K.portSpot;
    }
    set portSpot(t) {
      Util.s(t, Spot2, _TreeLayout, "portSpot"), this.K.portSpot.equals(t) || (this.K.portSpot = t, this.invalidateLayout());
    }
    get setsChildPortSpot() {
      return this.K.setsChildPortSpot;
    }
    set setsChildPortSpot(t) {
      this.K.setsChildPortSpot !== t && (Util.t(t, "boolean", _TreeLayout, "setsChildPortSpot"), this.K.setsChildPortSpot = t, this.invalidateLayout());
    }
    get childPortSpot() {
      return this.K.childPortSpot;
    }
    set childPortSpot(t) {
      Util.s(t, Spot2, _TreeLayout, "childPortSpot"), this.K.childPortSpot.equals(t) || (this.K.childPortSpot = t, this.invalidateLayout());
    }
    get alternateSorting() {
      return this.U.sorting;
    }
    set alternateSorting(t) {
      this.U.sorting !== t && (Util.it(t, TreeSorting2, "TreeSorting"), this.U.sorting = t, this.invalidateLayout());
    }
    get alternateComparer() {
      return this.U.comparer;
    }
    set alternateComparer(t) {
      this.U.comparer !== t && (Util.t(t, "function", _TreeLayout, "alternateComparer"), this.U.comparer = t, this.invalidateLayout());
    }
    get alternateAngle() {
      return this.U.angle;
    }
    set alternateAngle(t) {
      this.U.angle !== t && (Util.t(t, "number", _TreeLayout, "alternateAngle"), (t === 0 || t === 90 || t === 180 || t === 270) && (this.U.angle = t, this.invalidateLayout()));
    }
    get alternateAlignment() {
      return this.U.alignment;
    }
    set alternateAlignment(t) {
      this.U.alignment !== t && (Util.it(t, TreeAlignment2, "TreeAlignment"), this.U.alignment = t, this.invalidateLayout());
    }
    get alternateNodeIndent() {
      return this.U.nodeIndent;
    }
    set alternateNodeIndent(t) {
      this.U.nodeIndent !== t && (Util.t(t, "number", _TreeLayout, "alternateNodeIndent"), t >= 0 && (this.U.nodeIndent = t, this.invalidateLayout()));
    }
    get alternateNodeIndentPastParent() {
      return this.U.nodeIndentPastParent;
    }
    set alternateNodeIndentPastParent(t) {
      this.U.nodeIndentPastParent !== t && (Util.t(t, "number", _TreeLayout, "alternateNodeIndentPastParent"), t >= 0 && t <= 1 && (this.U.nodeIndentPastParent = t, this.invalidateLayout()));
    }
    get alternateNodeSpacing() {
      return this.U.nodeSpacing;
    }
    set alternateNodeSpacing(t) {
      this.U.nodeSpacing !== t && (Util.t(t, "number", _TreeLayout, "alternateNodeSpacing"), this.U.nodeSpacing = t, this.invalidateLayout());
    }
    get alternateLayerSpacing() {
      return this.U.layerSpacing;
    }
    set alternateLayerSpacing(t) {
      this.U.layerSpacing !== t && (Util.t(t, "number", _TreeLayout, "alternateLayerSpacing"), this.U.layerSpacing = t, this.invalidateLayout());
    }
    get alternateLayerSpacingParentOverlap() {
      return this.U.layerSpacingParentOverlap;
    }
    set alternateLayerSpacingParentOverlap(t) {
      this.U.layerSpacingParentOverlap !== t && (Util.t(t, "number", _TreeLayout, "alternateLayerSpacingParentOverlap"), t >= 0 && t <= 1 && (this.U.layerSpacingParentOverlap = t, this.invalidateLayout()));
    }
    get alternateCompaction() {
      return this.U.compaction;
    }
    set alternateCompaction(t) {
      this.U.compaction !== t && (Util.it(t, TreeCompaction2, "TreeCompaction"), (t === 30 || t === 31) && (this.U.compaction = t, this.invalidateLayout()));
    }
    get alternateBreadthLimit() {
      return this.U.breadthLimit;
    }
    set alternateBreadthLimit(t) {
      this.U.breadthLimit !== t && (Util.t(t, "number", _TreeLayout, "alternateBreadthLimit"), t >= 0 && (this.U.breadthLimit = t, this.invalidateLayout()));
    }
    get alternateRowSpacing() {
      return this.U.rowSpacing;
    }
    set alternateRowSpacing(t) {
      this.U.rowSpacing !== t && (Util.t(t, "number", _TreeLayout, "alternateRowSpacing"), this.U.rowSpacing = t, this.invalidateLayout());
    }
    get alternateRowIndent() {
      return this.U.rowIndent;
    }
    set alternateRowIndent(t) {
      this.U.rowIndent !== t && (Util.t(t, "number", _TreeLayout, "alternateRowIndent"), t >= 0 && (this.U.rowIndent = t, this.invalidateLayout()));
    }
    get alternateCommentSpacing() {
      return this.U.commentSpacing;
    }
    set alternateCommentSpacing(t) {
      this.U.commentSpacing !== t && (Util.t(t, "number", _TreeLayout, "alternateCommentSpacing"), this.U.commentSpacing = t, this.invalidateLayout());
    }
    get alternateCommentMargin() {
      return this.U.commentMargin;
    }
    set alternateCommentMargin(t) {
      this.U.commentMargin !== t && (Util.t(t, "number", _TreeLayout, "alternateCommentMargin"), this.U.commentMargin = t, this.invalidateLayout());
    }
    get alternateSetsPortSpot() {
      return this.U.setsPortSpot;
    }
    set alternateSetsPortSpot(t) {
      this.U.setsPortSpot !== t && (Util.t(t, "boolean", _TreeLayout, "alternateSetsPortSpot"), this.U.setsPortSpot = t, this.invalidateLayout());
    }
    get alternatePortSpot() {
      return this.U.portSpot;
    }
    set alternatePortSpot(t) {
      Util.s(t, Spot2, _TreeLayout, "alternatePortSpot"), this.U.portSpot.equals(t) || (this.U.portSpot = t, this.invalidateLayout());
    }
    get alternateSetsChildPortSpot() {
      return this.U.setsChildPortSpot;
    }
    set alternateSetsChildPortSpot(t) {
      this.U.setsChildPortSpot !== t && (Util.t(t, "boolean", _TreeLayout, "alternateSetsChildPortSpot"), this.U.setsChildPortSpot = t, this.invalidateLayout());
    }
    get alternateChildPortSpot() {
      return this.U.childPortSpot;
    }
    set alternateChildPortSpot(t) {
      Util.s(t, Spot2, _TreeLayout, "alternateChildPortSpot"), this.U.childPortSpot.equals(t) || (this.U.childPortSpot = t, this.invalidateLayout());
    }
  };
  __publicField(_TreeLayout, "PathDefault", 0);
  __publicField(_TreeLayout, "PathDestination", 1);
  __publicField(_TreeLayout, "PathSource", 2);
  __publicField(_TreeLayout, "SortingForwards", 10);
  __publicField(_TreeLayout, "SortingReverse", 11);
  __publicField(_TreeLayout, "SortingAscending", 12);
  __publicField(_TreeLayout, "SortingDescending", 13);
  __publicField(_TreeLayout, "AlignmentCenterSubtrees", 20);
  __publicField(_TreeLayout, "AlignmentCenterChildren", 21);
  __publicField(_TreeLayout, "AlignmentStart", 22);
  __publicField(_TreeLayout, "AlignmentEnd", 23);
  __publicField(_TreeLayout, "AlignmentBus", 24);
  __publicField(_TreeLayout, "AlignmentBusBranching", 25);
  __publicField(_TreeLayout, "AlignmentTopLeftBus", 26);
  __publicField(_TreeLayout, "AlignmentBottomRightBus", 27);
  __publicField(_TreeLayout, "CompactionNone", 30);
  __publicField(_TreeLayout, "CompactionBlock", 31);
  __publicField(_TreeLayout, "StyleLayered", 40);
  __publicField(_TreeLayout, "StyleLastParents", 41);
  __publicField(_TreeLayout, "StyleAlternating", 42);
  __publicField(_TreeLayout, "StyleRootOnly", 43);
  __publicField(_TreeLayout, "ArrangementVertical", 50);
  __publicField(_TreeLayout, "ArrangementHorizontal", 51);
  __publicField(_TreeLayout, "ArrangementFixedRoots", 52);
  __publicField(_TreeLayout, "LayerIndividual", 60);
  __publicField(_TreeLayout, "LayerSiblings", 61);
  __publicField(_TreeLayout, "LayerUniform", 62);
  let TreeLayout2 = _TreeLayout;
  class TreeNetwork2 extends LayoutNetwork2 {
    constructor(t) {
      super(t);
    }
    createVertex() {
      return new TreeVertex2(this);
    }
    createEdge() {
      return new TreeEdge2(this);
    }
  }
  class TreeVertex2 extends LayoutVertex2 {
    constructor(t) {
      super(t);
      __publicField(this, "X");
      __publicField(this, "kt");
      __publicField(this, "ht");
      __publicField(this, "kk");
      __publicField(this, "Sk");
      __publicField(this, "Mk");
      __publicField(this, "Pk");
      __publicField(this, "Nk");
      __publicField(this, "Ck");
      __publicField(this, "Ak");
      __publicField(this, "Ye");
      __publicField(this, "AD");
      __publicField(this, "nu");
      __publicField(this, "ou");
      __publicField(this, "Yg");
      __publicField(this, "Kg");
      __publicField(this, "Pe");
      __publicField(this, "Ne");
      __publicField(this, "qt");
      __publicField(this, "fi");
      __publicField(this, "ew");
      __publicField(this, "sw");
      __publicField(this, "nw");
      __publicField(this, "Ds");
      __publicField(this, "ow");
      __publicField(this, "rw");
      __publicField(this, "lw");
      __publicField(this, "hw");
      __publicField(this, "aw");
      __publicField(this, "fw");
      __publicField(this, "cw");
      __publicField(this, "uw");
      __publicField(this, "dw");
      __publicField(this, "gw");
      __publicField(this, "mw");
      this.kk = false, this.Sk = null, this.Mk = [], this.Pk = 0, this.Nk = 0, this.Ck = 0, this.Ak = 0, this.Ye = null, this.X = new Point2(0, 0), this.kt = new Size2(0, 0), this.ht = new Point2(0, 0), this.AD = false, this.nu = false, this.ou = false, this.Yg = null, this.Kg = null, this.Pe = 10, this.Ne = LayoutVertex2.standardComparer, this.qt = 0, this.fi = 21, this.ew = 0, this.sw = 0, this.nw = 20, this.Ds = 50, this.ow = 0, this.rw = 31, this.lw = 0, this.hw = 25, this.aw = 10, this.fw = 10, this.cw = 20, this.uw = true, this.dw = Spot2.Default, this.gw = true, this.mw = Spot2.Default;
    }
    copyInheritedPropertiesFrom(t) {
      t !== null && (this.Pe = t.sorting, this.Ne = t.comparer, this.qt = t.angle, this.fi = t.alignment, this.ew = t.nodeIndent, this.sw = t.nodeIndentPastParent, this.nw = t.nodeSpacing, this.Ds = t.layerSpacing, this.ow = t.layerSpacingParentOverlap, this.rw = t.compaction, this.lw = t.breadthLimit, this.hw = t.rowSpacing, this.aw = t.rowIndent, this.fw = t.commentSpacing, this.cw = t.commentMargin, this.uw = t.setsPortSpot, this.dw = t.portSpot, this.gw = t.setsChildPortSpot, this.mw = t.childPortSpot);
    }
    get initialized() {
      return this.kk;
    }
    set initialized(t) {
      this.kk !== t && (Util.t(t, "boolean", TreeVertex2, "initialized"), this.kk = t);
    }
    get parent() {
      return this.Sk;
    }
    set parent(t) {
      this.Sk !== t && (Debug && t !== null && Util.s(t, TreeVertex2, TreeVertex2, "parent"), this.Sk = t);
    }
    get children() {
      return this.Mk;
    }
    set children(t) {
      if (this.Mk !== t) {
        if (t !== null && !Array.isArray(t) && Util.Bi(t, "Array", TreeVertex2, "children:value"), t !== null) {
          const i = t.length;
          for (let e = 0; e < i; e++) {
            const s = t[e];
            Debug && Util.s(s, TreeVertex2, TreeVertex2, "children");
          }
        }
        this.Mk = t;
      }
    }
    get level() {
      return this.Pk;
    }
    set level(t) {
      this.Pk !== t && (Util.t(t, "number", TreeVertex2, "level"), this.Pk = t);
    }
    get descendantCount() {
      return this.Nk;
    }
    set descendantCount(t) {
      this.Nk !== t && (Util.t(t, "number", TreeVertex2, "descendantCount"), this.Nk = t);
    }
    get maxChildrenCount() {
      return this.Ck;
    }
    set maxChildrenCount(t) {
      this.Ck !== t && (Util.t(t, "number", TreeVertex2, "maxChildrenCount"), this.Ck = t);
    }
    get maxGenerationCount() {
      return this.Ak;
    }
    set maxGenerationCount(t) {
      this.Ak !== t && (Util.t(t, "number", TreeVertex2, "maxGenerationCount"), this.Ak = t);
    }
    get comments() {
      return this.Ye;
    }
    set comments(t) {
      if (this.Ye !== t) {
        if (t !== null && !Array.isArray(t) && Util.Bi(t, "Array", TreeVertex2, "comments:value"), t !== null) {
          const i = t.length;
          for (let e = 0; e < i; e++) {
            const s = t[e];
            Debug && Util.s(s, Node2, TreeVertex2, "comments");
          }
        }
        this.Ye = t;
      }
    }
    get sorting() {
      return this.Pe;
    }
    set sorting(t) {
      this.Pe !== t && (Util.it(t, TreeSorting2, "TreeSorting"), this.Pe = t);
    }
    get comparer() {
      return this.Ne;
    }
    set comparer(t) {
      this.Ne !== t && (Util.t(t, "function", TreeVertex2, "comparer"), this.Ne = t);
    }
    get angle() {
      return this.qt;
    }
    set angle(t) {
      this.qt !== t && (Util.t(t, "number", TreeVertex2, "angle"), this.qt = t);
    }
    get alignment() {
      return this.fi;
    }
    set alignment(t) {
      this.fi !== t && (Util.it(t, TreeAlignment2, "TreeAlignment"), this.fi = t);
    }
    get nodeIndent() {
      return this.ew;
    }
    set nodeIndent(t) {
      this.ew !== t && (Util.t(t, "number", TreeVertex2, "nodeIndent"), this.ew = t);
    }
    get nodeIndentPastParent() {
      return this.sw;
    }
    set nodeIndentPastParent(t) {
      this.sw !== t && (Util.t(t, "number", TreeVertex2, "nodeIndentPastParent"), this.sw = t);
    }
    get nodeSpacing() {
      return this.nw;
    }
    set nodeSpacing(t) {
      this.nw !== t && (Util.t(t, "number", TreeVertex2, "nodeSpacing"), this.nw = t);
    }
    get layerSpacing() {
      return this.Ds;
    }
    set layerSpacing(t) {
      this.Ds !== t && (Util.t(t, "number", TreeVertex2, "layerSpacing"), this.Ds = t);
    }
    get layerSpacingParentOverlap() {
      return this.ow;
    }
    set layerSpacingParentOverlap(t) {
      this.ow !== t && (Util.t(t, "number", TreeVertex2, "layerSpacingParentOverlap"), this.ow = t);
    }
    get compaction() {
      return this.rw;
    }
    set compaction(t) {
      this.rw !== t && (Util.it(t, TreeCompaction2, "TreeCompaction"), this.rw = t);
    }
    get breadthLimit() {
      return this.lw;
    }
    set breadthLimit(t) {
      this.lw !== t && (Util.t(t, "number", TreeVertex2, "breadthLimit"), this.lw = t);
    }
    get rowSpacing() {
      return this.hw;
    }
    set rowSpacing(t) {
      this.hw !== t && (Util.t(t, "number", TreeVertex2, "rowSpacing"), this.hw = t);
    }
    get rowIndent() {
      return this.aw;
    }
    set rowIndent(t) {
      this.aw !== t && (Util.t(t, "number", TreeVertex2, "rowIndent"), this.aw = t);
    }
    get commentSpacing() {
      return this.fw;
    }
    set commentSpacing(t) {
      this.fw !== t && (Util.t(t, "number", TreeVertex2, "commentSpacing"), this.fw = t);
    }
    get commentMargin() {
      return this.cw;
    }
    set commentMargin(t) {
      this.cw !== t && (Util.t(t, "number", TreeVertex2, "commentMargin"), this.cw = t);
    }
    get setsPortSpot() {
      return this.uw;
    }
    set setsPortSpot(t) {
      this.uw !== t && (Util.t(t, "boolean", TreeVertex2, "setsPortSpot"), this.uw = t);
    }
    get portSpot() {
      return this.dw;
    }
    set portSpot(t) {
      Util.s(t, Spot2, TreeVertex2, "portSpot"), this.dw.equals(t) || (this.dw = t);
    }
    get setsChildPortSpot() {
      return this.gw;
    }
    set setsChildPortSpot(t) {
      this.gw !== t && (Util.t(t, "boolean", TreeVertex2, "setsChildPortSpot"), this.gw = t);
    }
    get childPortSpot() {
      return this.mw;
    }
    set childPortSpot(t) {
      Util.s(t, Spot2, TreeVertex2, "childPortSpot"), this.mw.equals(t) || (this.mw = t);
    }
    get childrenCount() {
      return this.children.length;
    }
    get relativePosition() {
      return this.X;
    }
    set relativePosition(t) {
      this.X.set(t);
    }
    get subtreeSize() {
      return this.kt;
    }
    set subtreeSize(t) {
      this.kt.set(t);
    }
    get subtreeOffset() {
      return this.ht;
    }
    set subtreeOffset(t) {
      this.ht.set(t);
    }
  }
  class TreeEdge2 extends LayoutEdge2 {
    constructor(t) {
      super(t);
      __publicField(this, "Lk");
      this.Lk = new Point2(0, 0);
    }
    commit() {
      const t = this.link;
      if (t === null || t.isAvoiding)
        return;
      const i = this.network.layout;
      let e = null, s = null;
      switch (i.ms) {
        case 1:
          e = this.fromVertex, s = this.toVertex;
          break;
        case 2:
          e = this.toVertex, s = this.fromVertex;
          break;
        default:
          Util.n("Unhandled path value " + i.ms.toString());
      }
      if (e === null || s === null)
        return;
      const n = this.Lk;
      if (n.x === 0 && n.y === 0 && !e.AD) {
        this.Z3(e, s);
        return;
      }
      const o = e.bounds, r = i.orthoAngle(e), l = i.computeLayerSpacing(e), h = e.rowSpacing;
      t.updateRoute();
      const a = t.curve === 9, f = t.isOrthogonal;
      let c = 0, u, d;
      if (t.startRoute(), f || a) {
        for (c = 2; t.pointsCount > 4; )
          t.removePoint(2);
        u = t.getPoint(1), d = t.getPoint(2);
      } else {
        for (c = 1; t.pointsCount > 3; )
          t.removePoint(1);
        u = t.getPoint(0), d = t.getPoint(t.pointsCount - 1);
      }
      const m = t.getPoint(t.pointsCount - 1);
      let g = 0;
      r === 0 ? (e.alignment === 23 ? (g = o.bottom + n.y, n.y === 0 && u.y > m.y + e.rowIndent && (g = Math.min(g, Math.max(u.y, g - i.computeNodeIndent(e))))) : e.alignment === 22 ? (g = o.top + n.y, n.y === 0 && u.y < m.y - e.rowIndent && (g = Math.max(g, Math.min(u.y, g + i.computeNodeIndent(e))))) : e.nu || e.ou && e.maxGenerationCount === 1 ? g = o.top - e.ht.y + n.y : g = o.y + o.height / 2 + n.y, a ? (t.insertPointAt(c, u.x, g), c++, t.insertPointAt(c, o.right + l, g), c++, t.insertPointAt(c, o.right + l + (n.x - h) / 3, g), c++, t.insertPointAt(c, o.right + l + (n.x - h) * 2 / 3, g), c++, t.insertPointAt(c, o.right + l + (n.x - h), g), c++, t.insertPointAt(c, d.x, g), c++) : (f && (t.insertPointAt(c, o.right + l / 2, u.y), c++), t.insertPointAt(c, o.right + l / 2, g), c++, t.insertPointAt(c, o.right + l + n.x - (f ? h / 2 : h), g), c++, f && (t.insertPointAt(c, t.getPoint(c - 1).x, d.y), c++))) : r === 90 ? (e.alignment === 23 ? (g = o.right + n.x, n.x === 0 && u.x > m.x + e.rowIndent && (g = Math.min(g, Math.max(u.x, g - i.computeNodeIndent(e))))) : e.alignment === 22 ? (g = o.left + n.x, n.x === 0 && u.x < m.x - e.rowIndent && (g = Math.max(g, Math.min(u.x, g + i.computeNodeIndent(e))))) : e.nu || e.ou && e.maxGenerationCount === 1 ? g = o.left - e.ht.x + n.x : g = o.x + o.width / 2 + n.x, a ? (t.insertPointAt(c, g, u.y), c++, t.insertPointAt(c, g, o.bottom + l), c++, t.insertPointAt(c, g, o.bottom + l + (n.y - h) / 3), c++, t.insertPointAt(c, g, o.bottom + l + (n.y - h) * 2 / 3), c++, t.insertPointAt(c, g, o.bottom + l + (n.y - h)), c++, t.insertPointAt(c, g, d.y), c++) : (f && (t.insertPointAt(c, u.x, o.bottom + l / 2), c++), t.insertPointAt(c, g, o.bottom + l / 2), c++, t.insertPointAt(c, g, o.bottom + l + n.y - (f ? h / 2 : h)), c++, f && (t.insertPointAt(c, d.x, t.getPoint(c - 1).y), c++))) : r === 180 ? (e.alignment === 23 ? (g = o.bottom + n.y, n.y === 0 && u.y > m.y + e.rowIndent && (g = Math.min(g, Math.max(u.y, g - i.computeNodeIndent(e))))) : e.alignment === 22 ? (g = o.top + n.y, n.y === 0 && u.y < m.y - e.rowIndent && (g = Math.max(g, Math.min(u.y, g + i.computeNodeIndent(e))))) : e.nu || e.ou && e.maxGenerationCount === 1 ? g = o.top - e.ht.y + n.y : g = o.y + o.height / 2 + n.y, a ? (t.insertPointAt(c, u.x, g), c++, t.insertPointAt(c, o.left - l, g), c++, t.insertPointAt(c, o.left - l + (n.x + h) / 3, g), c++, t.insertPointAt(c, o.left - l + (n.x + h) * 2 / 3, g), c++, t.insertPointAt(c, o.left - l + (n.x + h), g), c++, t.insertPointAt(c, d.x, g), c++) : (f && (t.insertPointAt(c, o.left - l / 2, u.y), c++), t.insertPointAt(c, o.left - l / 2, g), c++, t.insertPointAt(c, o.left - l + n.x + (f ? h / 2 : h), g), c++, f && (t.insertPointAt(c, t.getPoint(c - 1).x, d.y), c++))) : r === 270 ? (e.alignment === 23 ? (g = o.right + n.x, n.x === 0 && u.x > m.x + e.rowIndent && (g = Math.min(g, Math.max(u.x, g - i.computeNodeIndent(e))))) : e.alignment === 22 ? (g = o.left + n.x, n.x === 0 && u.x < m.x - e.rowIndent && (g = Math.max(g, Math.min(u.x, g + i.computeNodeIndent(e))))) : e.nu || e.ou && e.maxGenerationCount === 1 ? g = o.left - e.ht.x + n.x : g = o.x + o.width / 2 + n.x, a ? (t.insertPointAt(c, g, u.y), c++, t.insertPointAt(c, g, o.top - l), c++, t.insertPointAt(c, g, o.top - l + (n.y + h) / 3), c++, t.insertPointAt(c, g, o.top - l + (n.y + h) * 2 / 3), c++, t.insertPointAt(c, g, o.top - l + (n.y + h)), c++, t.insertPointAt(c, g, d.y), c++) : (f && (t.insertPointAt(c, u.x, o.top - l / 2), c++), t.insertPointAt(c, g, o.top - l / 2), c++, t.insertPointAt(c, g, o.top - l + n.y + (f ? h / 2 : h)), c++, f && (t.insertPointAt(c, d.x, t.getPoint(c - 1).y), c++))) : Util.n("Invalid angle " + r), t.commitRoute();
    }
    Z3(t, i) {
      Debug && Util.s(t, TreeVertex2, TreeEdge2, "adjustRouteForAngleChange:parent"), Debug && Util.s(i, TreeVertex2, TreeEdge2, "adjustRouteForAngleChange:child");
      const e = this.link, s = this.network.layout, n = s.orthoAngle(t), o = s.orthoAngle(i);
      if (n === o)
        return;
      const r = s.computeLayerSpacing(t), l = t.bounds, h = i.bounds;
      if (n === 0 && h.left - l.right < r + 1 || n === 90 && h.top - l.bottom < r + 1 || n === 180 && l.left - h.right < r + 1 || n === 270 && l.top - h.bottom < r + 1)
        return;
      e.updateRoute();
      const a = e.curve === 9, f = e.isOrthogonal, c = this.fromVertex, u = s.isBusAlignment(c.alignment);
      if (e.startRoute(), n === 0) {
        const d = l.right + r / 2;
        if (a) {
          if (e.pointsCount === 4) {
            const m = e.getPoint(3).y;
            e.setPointAt(1, d - 20, e.getPoint(1).y), e.insertPointAt(2, d - 20, m), e.insertPointAt(3, d, m), e.insertPointAt(4, d + 20, m), e.setPointAt(5, e.getPoint(5).x, m);
          }
        } else
          f ? u ? e.setPointAt(3, e.getPoint(2).x, e.getPoint(4).y) : e.pointsCount === 6 && (e.setPointAt(2, d, e.getPoint(2).y), e.setPointAt(3, d, e.getPoint(3).y)) : e.pointsCount === 4 ? e.insertPointAt(2, d, e.getPoint(2).y) : e.pointsCount === 3 ? e.setPointAt(1, d, e.getPoint(2).y) : e.pointsCount === 2 && e.insertPointAt(1, d, e.getPoint(1).y);
      } else if (n === 90) {
        const d = l.bottom + r / 2;
        if (a) {
          if (e.pointsCount === 4) {
            const m = e.getPoint(3).x;
            e.setPointAt(1, e.getPoint(1).x, d - 20), e.insertPointAt(2, m, d - 20), e.insertPointAt(3, m, d), e.insertPointAt(4, m, d + 20), e.setPointAt(5, m, e.getPoint(5).y);
          }
        } else
          f ? u ? e.setPointAt(3, e.getPoint(2).x, e.getPoint(4).y) : e.pointsCount === 6 && (e.setPointAt(2, e.getPoint(2).x, d), e.setPointAt(3, e.getPoint(3).x, d)) : e.pointsCount === 4 ? e.insertPointAt(2, e.getPoint(2).x, d) : e.pointsCount === 3 ? e.setPointAt(1, e.getPoint(2).x, d) : e.pointsCount === 2 && e.insertPointAt(1, e.getPoint(1).x, d);
      } else if (n === 180) {
        const d = l.left - r / 2;
        if (a) {
          if (e.pointsCount === 4) {
            const m = e.getPoint(3).y;
            e.setPointAt(1, d + 20, e.getPoint(1).y), e.insertPointAt(2, d + 20, m), e.insertPointAt(3, d, m), e.insertPointAt(4, d - 20, m), e.setPointAt(5, e.getPoint(5).x, m);
          }
        } else
          f ? u ? e.setPointAt(3, e.getPoint(2).x, e.getPoint(4).y) : e.pointsCount === 6 && (e.setPointAt(2, d, e.getPoint(2).y), e.setPointAt(3, d, e.getPoint(3).y)) : e.pointsCount === 4 ? e.insertPointAt(2, d, e.getPoint(2).y) : e.pointsCount === 3 ? e.setPointAt(1, d, e.getPoint(2).y) : e.pointsCount === 2 && e.insertPointAt(1, d, e.getPoint(1).y);
      } else if (n === 270) {
        const d = l.top - r / 2;
        if (a) {
          if (e.pointsCount === 4) {
            const m = e.getPoint(3).x;
            e.setPointAt(1, e.getPoint(1).x, d + 20), e.insertPointAt(2, m, d + 20), e.insertPointAt(3, m, d), e.insertPointAt(4, m, d - 20), e.setPointAt(5, m, e.getPoint(5).y);
          }
        } else
          f ? u ? e.setPointAt(3, e.getPoint(2).x, e.getPoint(4).y) : e.pointsCount === 6 && (e.setPointAt(2, e.getPoint(2).x, d), e.setPointAt(3, e.getPoint(3).x, d)) : e.pointsCount === 4 ? e.insertPointAt(2, e.getPoint(2).x, d) : e.pointsCount === 3 ? e.setPointAt(1, e.getPoint(2).x, d) : e.pointsCount === 2 && e.insertPointAt(1, e.getPoint(1).x, d);
      }
      e.commitRoute();
    }
    get fromVertex() {
      return this.is;
    }
    set fromVertex(t) {
      this.is !== t && (Debug && t !== null && Util.s(t, TreeVertex2, TreeEdge2, "fromVertex"), this.is = t);
    }
    get toVertex() {
      return this.es;
    }
    set toVertex(t) {
      this.es !== t && (Debug && t !== null && Util.s(t, TreeVertex2, TreeEdge2, "toVertex"), this.es = t);
    }
    get relativePoint() {
      return this.Lk;
    }
    set relativePoint(t) {
      this.Lk.set(t);
    }
  }
  class Themes2 {
    constructor() {
    }
  }
  __publicField(Themes2, "Light", { colors: { text: "#0a0a0a", comment: "#ca8a04", link: "#0a0a0a", group: "#a3a3a344", outline: "#a3a3a3", selection: "#0ea5e9", div: "#fff", gridMinor: "#e5e5e5", gridMajor: "#a3a3a3", overviewBox: "#c026d3", tempLink: "#2563eb", tempPort: "#c026d3", adornmentFill: "#0ea5e9", adornmentStroke: "#1e40af", dragSelect: "#c026d3" }, fonts: { normal: "10pt sans-serif", bold: "bold 12pt sans-serif" }, numbers: { group: 1, selection: 3 }, margins: { group: new Margin2(5) }, arrowheads: { toArrow: "Standard" } });
  __publicField(Themes2, "Dark", { colors: { text: "#f5f5f5", comment: "#facc15", link: "#f5f5f5", group: "#a3a3a388", outline: "#a3a3a3", selection: "#38bdf8", div: "#171717", gridMinor: "#262626", gridMajor: "#404040", overviewBox: "#e879f9", tempLink: "#60a5fa", tempPort: "#e879f9", adornmentFill: "#38bdf8", adornmentStroke: "#2563eb", dragSelect: "#e879f9" }, fonts: { normal: "10pt sans-serif", bold: "bold 12pt sans-serif" }, numbers: { group: 1, selection: 3 }, margins: { group: new Margin2(5) }, arrowheads: { toArrow: "Standard" } });
  const _ThemeManager = class _ThemeManager {
    constructor(t) {
      __publicField(this, "as", /* @__PURE__ */ new Set());
      __publicField(this, "lu", new GMap2());
      __publicField(this, "Tk", "light");
      __publicField(this, "Dk", "light");
      __publicField(this, "Fk", false);
      __publicField(this, "Ug", "light");
      __publicField(this, "LD", (t) => {
        const i = t.matches ? "dark" : "light";
        i !== this.Ug && (this.Ug = i, this.Dk === "system" && this.pw());
      });
      t && Object.assign(this, t), (t == null ? void 0 : t.themeMap) || (this.lu.set("light", { colors: { ...Themes2.Light.colors }, fonts: { ...Themes2.Light.fonts }, numbers: { ...Themes2.Light.numbers }, margins: { ...Themes2.Light.margins }, arrowheads: { ...Themes2.Light.arrowheads } }), this.lu.set("dark", { colors: { ...Themes2.Dark.colors }, fonts: { ...Themes2.Dark.fonts }, numbers: { ...Themes2.Dark.numbers }, margins: { ...Themes2.Dark.margins }, arrowheads: { ...Themes2.Dark.arrowheads } })), root.matchMedia && (this.Ug = root.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light");
    }
    get themeMap() {
      return this.lu;
    }
    set themeMap(t) {
      this.lu !== t && (this.lu = t, this.pw());
    }
    get defaultTheme() {
      return this.Tk;
    }
    set defaultTheme(t) {
      this.Tk !== t && (Util.t(t, "string", _ThemeManager, "defaultTheme"), this.Tk = t, this.pw());
    }
    get currentTheme() {
      return this.Dk;
    }
    set currentTheme(t) {
      this.Dk !== t && (Util.t(t, "string", _ThemeManager, "currentTheme"), this.Dk = t, this.pw());
    }
    get changesDivBackground() {
      return this.Fk;
    }
    set changesDivBackground(t) {
      if (this.Fk !== t && (this.Fk = t, t))
        for (const e of this.as)
          e.setDivBackground(this.findValue("div", "", "fill")), e.V("ThemeChanged", this);
    }
    get preferredColorScheme() {
      return this.Ug;
    }
    addDiagram(t) {
      return this.as.add(t), this.QN(t), this;
    }
    removeDiagram(t) {
      return this.as.delete(t), this.QN(t), this;
    }
    qF() {
      var _a;
      this.as.size === 0 && root.matchMedia && ((_a = root.matchMedia("(prefers-color-scheme: dark)")) == null ? void 0 : _a.addEventListener("change", this.LD));
    }
    WF() {
      var _a;
      this.as.size === 0 && root.matchMedia && ((_a = root.matchMedia("(prefers-color-scheme: dark)")) == null ? void 0 : _a.removeEventListener("change", this.LD));
    }
    set(t, i) {
      t === "" && (t = this.Tk), t === "system" && (t = this.Ug);
      let e = this.lu.get(t);
      return e ? e = this.TD(e, i) : e = i, this.lu.set(t, e), this.pw(), this;
    }
    findValue(t, i, e) {
      return this.getValue(this.findTheme(this.currentTheme), t, i, e) || this.getValue(this.findTheme(this.defaultTheme), t, i, e);
    }
    getValue(t, i, e, s) {
      var _a;
      if (!t)
        return;
      e == null && (e = "");
      let n = t;
      const o = (l) => {
        if (n === void 0 || l === "")
          return;
        if (typeof l == "number" || !(Array.isArray(l) || l.includes(".")))
          return n[l];
        const h = Array.isArray(l) ? l : l.split(".");
        for (let a = 0; a < h.length; a++) {
          const f = h[a];
          if (f !== "" && (n = n[f], n === void 0))
            return;
        }
        return n;
      }, r = () => {
        if (!(e !== "" && (n = o(e), n === void 0)))
          return Array.isArray(n) && typeof i == "number" ? n = n[i % n.length] : n = o(i), n;
      };
      if (n = r(), n === void 0 && typeof s == "string" && s.length > 0) {
        let l = (_a = t.targetPropertyMap) == null ? void 0 : _a.get(s);
        if (l ? n = t[l] : (l = _ThemeManager.$3.get(s), n = l ? t[l] : t.colors), n = r(), n !== void 0)
          return n;
      }
      return n;
    }
    findTheme(t) {
      return this.themeMap.get(t === "system" ? this.Ug : t);
    }
    QN(t) {
      const i = t.skipsUndoManager;
      t.skipsUndoManager = true, t.updateAllThemeBindings(), this.Fk && t.setDivBackground(this.findValue("div", "", "fill")), t.skipsUndoManager = i, t.V("ThemeChanged", this);
    }
    pw() {
      for (const t of this.as)
        this.QN(t);
    }
    TD(t, i) {
      for (const e in i)
        if (Util.yw(i, e))
          try {
            i[e].constructor === Object ? t[e] = this.TD(t[e] ?? {}, i[e]) : t[e] = i[e];
          } catch {
            delete t[e];
          }
      return t;
    }
  };
  __publicField(_ThemeManager, "$3", /* @__PURE__ */ new Map([["background", "colors"], ["defaultColumnSeparatorStroke", "colors"], ["defaultRowSeparatorStroke", "colors"], ["shadowColor", "colors"], ["fill", "colors"], ["stroke", "colors"], ["font", "fonts"], ["angle", "numbers"], ["fromEndSegmentLength", "numbers"], ["fromShortLength", "numbers"], ["height", "numbers"], ["opacity", "numbers"], ["scale", "numbers"], ["toEndSegmentLength", "numbers"], ["toShortLength", "numbers"], ["width", "numbers"], ["defaultColumnSeparatorStrokeWidth", "numbers"], ["defaultRowSeparatorStrokeWidth", "numbers"], ["shadowBlur", "numbers"], ["corner", "numbers"], ["curviness", "numbers"], ["smoothness", "numbers"], ["parameter1", "numbers"], ["parameter2", "numbers"], ["strokeWidth", "numbers"], ["strokeDashOffset", "numbers"], ["maxLines", "numbers"], ["spacingAbove", "numbers"], ["spacingBelow", "numbers"], ["position", "points"], ["shadowOffset", "points"], ["desiredSize", "sizes"], ["maxSize", "sizes"], ["minSize", "sizes"], ["margin", "margins"], ["defaultSeparatorPadding", "margins"], ["padding", "margins"], ["alignment", "spots"], ["alignmentFocus", "spots"], ["fromSpot", "spots"], ["toSpot", "spots"], ["defaultAlignment", "spots"], ["spot1", "spots"], ["spot2", "spots"], ["verticalAlignment", "spots"], ["imageAlignment", "spots"], ["fromArrow", "arrowheads"], ["toArrow", "arrowheads"]]));
  let ThemeManager2 = _ThemeManager;
  class Router2 {
    constructor() {
      __publicField(this, "Tt");
      __publicField(this, "b");
      __publicField(this, "Xi");
      __publicField(this, "xl");
      this.b = Diagram2.Pm(), this.Tt = "", this.Xi = true, this.xl = true;
    }
    get name() {
      return this.Tt;
    }
    set name(t) {
      this.Tt = t;
    }
    get isEnabled() {
      return this.Xi;
    }
    set isEnabled(t) {
      this.Xi = t;
    }
    get isRealtime() {
      return this.xl;
    }
    set isRealtime(t) {
      this.xl = t;
    }
    get diagram() {
      return this.b;
    }
    set diagram(t) {
      this.b !== t && (this.b = t, t.Al = true, t.requestUpdate());
    }
    invalidateRouter() {
      this.b !== null && (this.b.Al = true, this.b.requestUpdate());
    }
    canRoute(t) {
      if (!this.isEnabled)
        return false;
      const i = this.diagram;
      return !(i && (!this.isRealtime && i.Mu || i.animationManager.isTicking));
    }
    routeLinks(t, i) {
    }
    toString() {
      return this.name !== "" ? this.name + " Router" : Util.an(this.constructor);
    }
  }
  class AvoidsNodesRouter extends Router2 {
    constructor(t) {
      super(), this.name = "AvoidsNodes", t && Object.assign(this, t);
    }
    routeLinks(t, i) {
      const e = i instanceof Diagram2 ? null : i, s = t.iterator;
      for (; s.next(); ) {
        const n = s.value;
        if (!n.isAvoiding || i && n.containingGroup !== e || n.toNode === null || n.fromNode === null || n.pointsCount < 4)
          continue;
        n.startRoute();
        const o = n.pointsCount, r = n.getPoint(1), l = n.getPoint(o - 2), h = n.fromNode.actualBounds.copy();
        h.inflate(Link2.Xa, Link2.Xa), h.unionPoint(n.getPoint(0));
        const a = n.toNode.actualBounds.copy();
        a.inflate(Link2.Xa, Link2.Xa), a.unionPoint(n.getPoint(o - 1));
        const f = n.diagram.getPositions(true, n.containingGroup, null);
        this.Q3(n, h, a, f) && this._3(n, r, n.lN, l, n.hN, h, a), n.commitRoute();
      }
    }
    Q3(t, i, e, s) {
      const n = t.diagram, o = t.pointsCount;
      if (n === null || t.fromNode === t.toNode || t.layer.isTemporary || i.containsPoint(t.getPoint(o - 1)) && !t.toNode.isMemberOf(t.fromNode) || e.containsPoint(t.getPoint(0)) && !t.fromNode.isMemberOf(t.toNode) || !t.isOrthogonal)
        return false;
      if (t.segmentIndex === 17)
        return true;
      const r = t.getPoint(1), l = t.getPoint(o - 2), h = t.getPoint(2);
      if (!s.isUnoccupied(Math.min(r.x, h.x), Math.min(r.y, h.y), Math.abs(r.x - h.x), Math.abs(r.y - h.y)))
        return true;
      for (let f = 2; f < o - 3; f++) {
        const c = t.getPoint(f), u = t.getPoint(f + 1);
        if (!s.isUnoccupied(Math.min(c.x, u.x), Math.min(c.y, u.y), Math.abs(c.x - u.x), Math.abs(c.y - u.y)))
          return true;
      }
      const a = t.getPoint(o - 3);
      return !s.isUnoccupied(Math.min(a.x, l.x), Math.min(a.y, l.y), Math.abs(a.x - l.x), Math.abs(a.y - l.y));
    }
    _3(t, i, e, s, n, o, r) {
      const l = t.diagram, h = l.getPositions(true, t.containingGroup, null), a = i, f = s;
      let c = null, u = null;
      if (l.isVirtualized) {
        const g = h.bounds.copy(), p = t.getPoint(2), y = t.getPoint(t.pointsCount - 3);
        g.inflate(-h.cellWidth, -h.cellHeight);
        const x = Point2.a();
        h.Wd(i.x, i.y) || (Geo.Ml(g.x, g.y, g.x + g.width, g.y + g.height, i.x, i.y, p.x, p.y, x) ? (c = i = x.copy(), e = x.directionPoint(p)) : Geo.Ml(g.x, g.y, g.x + g.width, g.y + g.height, p.x, p.y, y.x, y.y, x) ? (c = i = x.copy(), e = x.directionPoint(y)) : Geo.Ml(g.x, g.y, g.x + g.width, g.y + g.height, y.x, y.y, s.x, s.y, x) && (c = i = x.copy(), e = x.directionPoint(s))), h.Wd(s.x, s.y) || (Geo.Ml(g.x, g.y, g.x + g.width, g.y + g.height, s.x, s.y, y.x, y.y, x) ? (u = s = x.copy(), n = y.directionPoint(x)) : Geo.Ml(g.x, g.y, g.x + g.width, g.y + g.height, y.x, y.y, p.x, p.y, x) ? (u = s = x.copy(), n = p.directionPoint(x)) : Geo.Ml(g.x, g.y, g.x + g.width, g.y + g.height, p.x, p.y, i.x, i.y, x) && (u = s = x.copy(), n = i.directionPoint(x))), Point2.o(x);
      }
      const d = o.copy().unionRect(r);
      d.inflate(h.cellWidth * h.Jf, h.cellHeight * h.Jf), h.fT(i, e, s, n, d, true);
      let m = h._i(s.x, s.y);
      if (!h.Cy && m >= PositionArray.qd && (h.GA(), d.inflate(h.cellWidth * h.zP, h.cellHeight * h.XP), h.fT(i, e, s, n, d, false), m = h._i(s.x, s.y)), !h.Cy && m < PositionArray.qd && !h.pO(s.x, s.y)) {
        t.points.removeRange(2, t.pointsCount - 3), this.vd(t, h, s.x, s.y, n, true);
        const g = 0, p = 90, y = 180, x = 270, b = t.getPoint(2);
        if (t.pointsCount < 4)
          e === g || e === y ? (b.x = i.x, b.y = s.y) : (b.x = s.x, b.y = i.y), t.setPointAt(2, b.x, b.y), t.insertPointAt(3, b.x, b.y);
        else {
          const k = t.getPoint(3);
          if (e === g || e === y)
            if (Geo.p(b.x, k.x)) {
              const S = e === g ? Math.max(b.x, i.x) : Math.min(b.x, i.x);
              t.setPointAt(2, S, i.y), t.setPointAt(3, S, k.y);
            } else
              Geo.p(b.y, k.y) ? (Math.abs(i.y - b.y) <= h.cellHeight / 2 && (t.setPointAt(2, b.x, i.y), t.setPointAt(3, k.x, i.y)), t.insertPointAt(2, b.x, i.y)) : t.setPointAt(2, i.x, b.y);
          else if (e === p || e === x)
            if (Geo.p(b.y, k.y)) {
              const S = e === p ? Math.max(b.y, i.y) : Math.min(b.y, i.y);
              t.setPointAt(2, i.x, S), t.setPointAt(3, k.x, S);
            } else
              Geo.p(b.x, k.x) ? (Math.abs(i.x - b.x) <= h.cellWidth / 2 && (t.setPointAt(2, i.x, b.y), t.setPointAt(3, i.x, k.y)), t.insertPointAt(2, i.x, b.y)) : t.setPointAt(2, b.x, i.y);
        }
        if (c !== null) {
          const k = t.getPoint(1), S = t.getPoint(2);
          k.x !== S.x && k.y !== S.y ? e === g || e === y ? t.insertPointAt(2, k.x, S.y) : t.insertPointAt(2, S.x, k.y) : e === g || e === y ? t.insertPointAt(2, a.x, c.y) : t.insertPointAt(2, c.x, a.y);
        }
        u !== null && (n === g || n === y ? t.insertPointAt(t.pointsCount - 2, f.x, u.y) : t.insertPointAt(t.pointsCount - 2, u.x, f.y));
      }
    }
    vd(t, i, e, s, n, o) {
      const f = i.cellWidth, c = i.cellHeight;
      let u = i._i(e, s), d = e, m = s, g = d, p = m;
      for (n === 0 ? g += f : n === 90 ? p += c : n === 180 ? g -= f : p -= c, t.cN && u > PositionArray.xo && i._i(g, p) !== u - 1 && (i._i(d - f, m) === u - 1 ? (n = 180, g = d - f, p = m) : i._i(d + f, m) === u - 1 ? (n = 0, g = d + f, p = m) : i._i(d, m - c) === u - 1 ? (n = 270, g = d, p = m - c) : i._i(d, m + c) === u - 1 && (n = 90, g = d, p = m + c)); u > PositionArray.xo && i._i(g, p) === u - 1; )
        d = g, m = p, n === 0 ? g += f : n === 90 ? p += c : n === 180 ? g -= f : p -= c, u -= 1;
      if (o ? u > PositionArray.xo && (n === 180 || n === 0 ? d = Math.floor(d / f) * f + f / 2 : (n === 90 || n === 270) && (m = Math.floor(m / c) * c + c / 2)) : (d = Math.floor(d / f) * f + f / 2, m = Math.floor(m / c) * c + c / 2), u > PositionArray.xo) {
        let y = n, x = d, b = m;
        if (n === 0 ? (y = 90, b += c) : n === 90 ? (y = 180, x -= f) : n === 180 ? (y = 270, b -= c) : n === 270 && (y = 0, x += f), i._i(x, b) === u - 1)
          this.vd(t, i, x, b, y, false);
        else {
          let S = d, M = m;
          n === 0 ? (y = 270, M -= c) : n === 90 ? (y = 0, S += f) : n === 180 ? (y = 90, M += c) : n === 270 && (y = 180, S -= f), i._i(S, M) === u - 1 && this.vd(t, i, S, M, y, false);
        }
      }
      t.insertPointAt(t.pointsCount - 2, d, m);
    }
  }
  ToolManager2.prototype.initializeStandardTools = function() {
    this.ii("Action", new ActionTool2(), this.mouseDownTools), this.ii("Relinking", new RelinkingTool2(), this.mouseDownTools), this.ii("LinkReshaping", new LinkReshapingTool2(), this.mouseDownTools), this.ii("Rotating", new RotatingTool2(), this.mouseDownTools), this.ii("Resizing", new ResizingTool2(), this.mouseDownTools), this.ii("Linking", new LinkingTool2(), this.mouseMoveTools), this.ii("Dragging", new DraggingTool2(), this.mouseMoveTools), this.ii("DragSelecting", new DragSelectingTool2(), this.mouseMoveTools), this.ii("Panning", new PanningTool2(), this.mouseMoveTools), this.ii("ContextMenu", new ContextMenuTool2(), this.mouseUpTools), this.ii("TextEditing", new TextEditingTool2(), this.mouseUpTools), this.ii("ClickCreating", new ClickCreatingTool2(), this.mouseUpTools), this.ii("ClickSelecting", new ClickSelectingTool2(), this.mouseUpTools);
  }, Diagram2.xP("GraphLinksModel", GraphLinksPartManager), Diagram2.xP("TreeModel", TreePartManager);
  const oldGo = root.go, go2 = { get version() {
    return Diagram2.version;
  }, Group: Group2, List: List2, Set: GSet2, Map: GMap2, Point: Point2, Size: Size2, Rect: Rect2, Margin: Margin2, Spot: Spot2, Geometry: Geometry2, PathFigure: PathFigure2, PathSegment: PathSegment2, InputEvent: InputEvent2, DiagramEvent: DiagramEvent2, ChangedEvent: ChangedEvent2, Model: Model2, GraphLinksModel: GraphLinksModel2, TreeModel: TreeModel2, Binding: Binding2, ThemeBinding: ThemeBinding2, Transaction: Transaction2, UndoManager: UndoManager2, CommandHandler: CommandHandler2, Tool: Tool2, DraggingTool: DraggingTool2, DraggingInfo: DraggingInfo2, DraggingOptions: DraggingOptions2, LinkingBaseTool: LinkingBaseTool2, LinkingTool: LinkingTool2, RelinkingTool: RelinkingTool2, LinkReshapingTool: LinkReshapingTool2, ResizingTool: ResizingTool2, RotatingTool: RotatingTool2, ClickSelectingTool: ClickSelectingTool2, ActionTool: ActionTool2, ClickCreatingTool: ClickCreatingTool2, HTMLInfo: HTMLInfo2, ContextMenuTool: ContextMenuTool2, DragSelectingTool: DragSelectingTool2, PanningTool: PanningTool2, TextEditingTool: TextEditingTool2, ToolManager: ToolManager2, Animation: Animation2, AnimationManager: AnimationManager2, AnimationTrigger: AnimationTrigger2, Layer: Layer2, Diagram: Diagram2, Palette: Palette2, Overview: Overview2, Brush: Brush2, GraphObject: GraphObject2, Panel: Panel2, RowColumnDefinition: RowColumnDefinition2, Shape: Shape2, TextBlock: TextBlock2, Picture: Picture2, Part: Part2, Adornment: Adornment2, Node: Node2, Link: Link2, Placeholder: Placeholder2, Layout: Layout2, LayoutNetwork: LayoutNetwork2, LayoutVertex: LayoutVertex2, LayoutEdge: LayoutEdge2, GridLayout: GridLayout2, PanelLayout: PanelLayout2, CircularLayout: CircularLayout2, CircularNetwork: CircularNetwork2, CircularVertex: CircularVertex2, CircularEdge: CircularEdge2, ForceDirectedLayout: ForceDirectedLayout2, ForceDirectedNetwork: ForceDirectedNetwork2, ForceDirectedVertex: ForceDirectedVertex2, ForceDirectedEdge: ForceDirectedEdge2, LayeredDigraphLayout: LayeredDigraphLayout2, LayeredDigraphNetwork: LayeredDigraphNetwork2, LayeredDigraphVertex: LayeredDigraphVertex2, LayeredDigraphEdge: LayeredDigraphEdge2, TreeLayout: TreeLayout2, TreeNetwork: TreeNetwork2, TreeVertex: TreeVertex2, TreeEdge: TreeEdge2, Themes: Themes2, ThemeManager: ThemeManager2, Router: Router2, AnimationStyle: AnimationStyle2, AutoScale: AutoScale2, CycleMode: CycleMode2, Flip: Flip2, TextFormat: TextFormat2, ImageStretch: ImageStretch2, LayoutConditions: LayoutConditions2, LinkAdjusting: LinkAdjusting2, Curve: Curve2, Routing: Routing2, Orientation: Orientation2, TextOverflow: TextOverflow2, PortSpreading: PortSpreading2, ScrollMode: ScrollMode2, CollapsePolicy: CollapsePolicy2, Sizing: Sizing2, TriggerStart: TriggerStart2, Stretch: Stretch2, ViewboxStretch: ViewboxStretch2, Wrap: Wrap2, BrushType: BrushType2, ColorSpace: ColorSpace2, GeometryStretch: GeometryStretch2, GeometryType: GeometryType2, SegmentType: SegmentType2, BindingMode: BindingMode2, ChangeType: ChangeType2, CircularArrangement: CircularArrangement2, CircularDirection: CircularDirection2, CircularNodeDiameterFormula: CircularNodeDiameterFormula2, CircularSorting: CircularSorting2, GridAlignment: GridAlignment2, GridArrangement: GridArrangement2, GridSorting: GridSorting2, LayeredDigraphAggressive: LayeredDigraphAggressive2, LayeredDigraphAlign: LayeredDigraphAlign2, LayeredDigraphCycleRemove: LayeredDigraphCycleRemove2, LayeredDigraphInit: LayeredDigraphInit2, LayeredDigraphLayering: LayeredDigraphLayering2, LayeredDigraphPack: LayeredDigraphPack2, TreeAlignment: TreeAlignment2, TreeArrangement: TreeArrangement2, TreeCompaction: TreeCompaction2, TreeLayerStyle: TreeLayerStyle2, TreePath: TreePath2, TreeSorting: TreeSorting2, TreeStyle: TreeStyle2, GestureMode: GestureMode2, LinkingDirection: LinkingDirection2, ReshapingBehavior: ReshapingBehavior2, TextEditingAccept: TextEditingAccept2, TextEditingStarting: TextEditingStarting2, TextEditingState: TextEditingState2, WheelMode: WheelMode2 };
  typeof oldGo == "object" && oldGo.version && Util.ft("WARNING: a `go` object on the root object is already defined.  " + ("Debug" in oldGo ? "debug " : "") + "version: " + oldGo.version + ", replaced with version: " + go2.version), Diagram2.prototype.go = go2, root.go = go2, go2.Debug = Debug, Debug.attachReadonlyWarnings(go2);
})();
var go_debug_default = typeof global !== "undefined" ? global.go : self.go;
var go = typeof global !== "undefined" ? global.go : self.go;
var Group = go.Group;
var List = go.List;
var GSet = go.Set;
var GMap = go.Map;
var Point = go.Point;
var Size = go.Size;
var Rect = go.Rect;
var Margin = go.Margin;
var Spot = go.Spot;
var Geometry = go.Geometry;
var PathFigure = go.PathFigure;
var PathSegment = go.PathSegment;
var InputEvent = go.InputEvent;
var DiagramEvent = go.DiagramEvent;
var ChangedEvent = go.ChangedEvent;
var Model = go.Model;
var GraphLinksModel = go.GraphLinksModel;
var TreeModel = go.TreeModel;
var Binding = go.Binding;
var ThemeBinding = go.ThemeBinding;
var Transaction = go.Transaction;
var UndoManager = go.UndoManager;
var CommandHandler = go.CommandHandler;
var Tool = go.Tool;
var DraggingTool = go.DraggingTool;
var DraggingInfo = go.DraggingInfo;
var DraggingOptions = go.DraggingOptions;
var LinkingBaseTool = go.LinkingBaseTool;
var LinkingTool = go.LinkingTool;
var RelinkingTool = go.RelinkingTool;
var LinkReshapingTool = go.LinkReshapingTool;
var ResizingTool = go.ResizingTool;
var RotatingTool = go.RotatingTool;
var ClickSelectingTool = go.ClickSelectingTool;
var ActionTool = go.ActionTool;
var ClickCreatingTool = go.ClickCreatingTool;
var HTMLInfo = go.HTMLInfo;
var ContextMenuTool = go.ContextMenuTool;
var DragSelectingTool = go.DragSelectingTool;
var PanningTool = go.PanningTool;
var TextEditingTool = go.TextEditingTool;
var ToolManager = go.ToolManager;
var Animation = go.Animation;
var AnimationManager = go.AnimationManager;
var AnimationTrigger = go.AnimationTrigger;
var Layer = go.Layer;
var Diagram = go.Diagram;
var Palette = go.Palette;
var Overview = go.Overview;
var Brush = go.Brush;
var GraphObject = go.GraphObject;
var Panel = go.Panel;
var RowColumnDefinition = go.RowColumnDefinition;
var Shape = go.Shape;
var TextBlock = go.TextBlock;
var Picture = go.Picture;
var Part = go.Part;
var Adornment = go.Adornment;
var Node = go.Node;
var Link = go.Link;
var Placeholder = go.Placeholder;
var Layout = go.Layout;
var LayoutNetwork = go.LayoutNetwork;
var LayoutVertex = go.LayoutVertex;
var LayoutEdge = go.LayoutEdge;
var GridLayout = go.GridLayout;
var PanelLayout = go.PanelLayout;
var CircularLayout = go.CircularLayout;
var CircularNetwork = go.CircularNetwork;
var CircularVertex = go.CircularVertex;
var CircularEdge = go.CircularEdge;
var ForceDirectedLayout = go.ForceDirectedLayout;
var ForceDirectedNetwork = go.ForceDirectedNetwork;
var ForceDirectedVertex = go.ForceDirectedVertex;
var ForceDirectedEdge = go.ForceDirectedEdge;
var LayeredDigraphLayout = go.LayeredDigraphLayout;
var LayeredDigraphNetwork = go.LayeredDigraphNetwork;
var LayeredDigraphVertex = go.LayeredDigraphVertex;
var LayeredDigraphEdge = go.LayeredDigraphEdge;
var TreeLayout = go.TreeLayout;
var TreeNetwork = go.TreeNetwork;
var TreeVertex = go.TreeVertex;
var TreeEdge = go.TreeEdge;
var Themes = go.Themes;
var ThemeManager = go.ThemeManager;
var Router = go.Router;
var version = go.version;
var AnimationStyle = go.AnimationStyle;
var AutoScale = go.AutoScale;
var Curve = go.Curve;
var CycleMode = go.CycleMode;
var Flip = go.Flip;
var ImageStretch = go.ImageStretch;
var LayoutConditions = go.LayoutConditions;
var LinkAdjusting = go.LinkAdjusting;
var Orientation = go.Orientation;
var PortSpreading = go.PortSpreading;
var Routing = go.Routing;
var ScrollMode = go.ScrollMode;
var CollapsePolicy = go.CollapsePolicy;
var Sizing = go.Sizing;
var TriggerStart = go.TriggerStart;
var Stretch = go.Stretch;
var TextFormat = go.TextFormat;
var TextOverflow = go.TextOverflow;
var ViewboxStretch = go.ViewboxStretch;
var Wrap = go.Wrap;
var BrushType = go.BrushType;
var ColorSpace = go.ColorSpace;
var GeometryStretch = go.GeometryStretch;
var GeometryType = go.GeometryType;
var SegmentType = go.SegmentType;
var BindingMode = go.BindingMode;
var ChangeType = go.ChangeType;
var CircularArrangement = go.CircularArrangement;
var CircularDirection = go.CircularDirection;
var CircularNodeDiameterFormula = go.CircularNodeDiameterFormula;
var CircularSorting = go.CircularSorting;
var GridAlignment = go.GridAlignment;
var GridArrangement = go.GridArrangement;
var GridSorting = go.GridSorting;
var LayeredDigraphAggressive = go.LayeredDigraphAggressive;
var LayeredDigraphAlign = go.LayeredDigraphAlign;
var LayeredDigraphCycleRemove = go.LayeredDigraphCycleRemove;
var LayeredDigraphInit = go.LayeredDigraphInit;
var LayeredDigraphLayering = go.LayeredDigraphLayering;
var LayeredDigraphPack = go.LayeredDigraphPack;
var TreeAlignment = go.TreeAlignment;
var TreeArrangement = go.TreeArrangement;
var TreeCompaction = go.TreeCompaction;
var TreeLayerStyle = go.TreeLayerStyle;
var TreePath = go.TreePath;
var TreeSorting = go.TreeSorting;
var TreeStyle = go.TreeStyle;
var GestureMode = go.GestureMode;
var LinkingDirection = go.LinkingDirection;
var ReshapingBehavior = go.ReshapingBehavior;
var TextEditingAccept = go.TextEditingAccept;
var TextEditingStarting = go.TextEditingStarting;
var TextEditingState = go.TextEditingState;
var WheelMode = go.WheelMode;
export {
  ActionTool,
  Adornment,
  Animation,
  AnimationManager,
  AnimationStyle,
  AnimationTrigger,
  AutoScale,
  Binding,
  BindingMode,
  Brush,
  BrushType,
  ChangeType,
  ChangedEvent,
  CircularArrangement,
  CircularDirection,
  CircularEdge,
  CircularLayout,
  CircularNetwork,
  CircularNodeDiameterFormula,
  CircularSorting,
  CircularVertex,
  ClickCreatingTool,
  ClickSelectingTool,
  CollapsePolicy,
  ColorSpace,
  CommandHandler,
  ContextMenuTool,
  Curve,
  CycleMode,
  Diagram,
  DiagramEvent,
  DragSelectingTool,
  DraggingInfo,
  DraggingOptions,
  DraggingTool,
  Flip,
  ForceDirectedEdge,
  ForceDirectedLayout,
  ForceDirectedNetwork,
  ForceDirectedVertex,
  Geometry,
  GeometryStretch,
  GeometryType,
  GestureMode,
  GraphLinksModel,
  GraphObject,
  GridAlignment,
  GridArrangement,
  GridLayout,
  GridSorting,
  Group,
  HTMLInfo,
  ImageStretch,
  InputEvent,
  Layer,
  LayeredDigraphAggressive,
  LayeredDigraphAlign,
  LayeredDigraphCycleRemove,
  LayeredDigraphEdge,
  LayeredDigraphInit,
  LayeredDigraphLayering,
  LayeredDigraphLayout,
  LayeredDigraphNetwork,
  LayeredDigraphPack,
  LayeredDigraphVertex,
  Layout,
  LayoutConditions,
  LayoutEdge,
  LayoutNetwork,
  LayoutVertex,
  Link,
  LinkAdjusting,
  LinkReshapingTool,
  LinkingBaseTool,
  LinkingDirection,
  LinkingTool,
  List,
  GMap as Map,
  Margin,
  Model,
  Node,
  Orientation,
  Overview,
  Palette,
  Panel,
  PanelLayout,
  PanningTool,
  Part,
  PathFigure,
  PathSegment,
  Picture,
  Placeholder,
  Point,
  PortSpreading,
  Rect,
  RelinkingTool,
  ReshapingBehavior,
  ResizingTool,
  RotatingTool,
  Router,
  Routing,
  RowColumnDefinition,
  ScrollMode,
  SegmentType,
  GSet as Set,
  Shape,
  Size,
  Sizing,
  Spot,
  Stretch,
  TextBlock,
  TextEditingAccept,
  TextEditingStarting,
  TextEditingState,
  TextEditingTool,
  TextFormat,
  TextOverflow,
  ThemeBinding,
  ThemeManager,
  Themes,
  Tool,
  ToolManager,
  Transaction,
  TreeAlignment,
  TreeArrangement,
  TreeCompaction,
  TreeEdge,
  TreeLayerStyle,
  TreeLayout,
  TreeModel,
  TreeNetwork,
  TreePath,
  TreeSorting,
  TreeStyle,
  TreeVertex,
  TriggerStart,
  UndoManager,
  ViewboxStretch,
  WheelMode,
  Wrap,
  go_debug_default as default,
  go,
  version
};
//# sourceMappingURL=gojs.js.map
